// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: proto/clarifai/api/service.proto
#ifndef GRPC_proto_2fclarifai_2fapi_2fservice_2eproto__INCLUDED
#define GRPC_proto_2fclarifai_2fapi_2fservice_2eproto__INCLUDED

#include "proto/clarifai/api/service.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace clarifai {
namespace api {

//
// Note: this is based on the google api format defined here. Please
// read this before contributing to this file and other *.proto files
// for the API.
// https://cloud.google.com/service-management/reference/rpc/google.api#google.api.HttpRule
//
class V2 final {
 public:
  static constexpr char const* service_full_name() {
    return "clarifai.api.V2";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // //////////////////////////////////////
    // Concept Relationships
    // //////////////////////////////////////
    //
    // List concept relations between concepts in the platform.
    // MUST be above ListConcepts so that if concept_id is empty this will still match
    // /concepts/relations to list all the concept relations in the app.
    virtual ::grpc::Status ListConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::ListConceptRelationsRequest& request, ::clarifai::api::MultiConceptRelationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptRelationResponse>> AsyncListConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::ListConceptRelationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptRelationResponse>>(AsyncListConceptRelationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptRelationResponse>> PrepareAsyncListConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::ListConceptRelationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptRelationResponse>>(PrepareAsyncListConceptRelationsRaw(context, request, cq));
    }
    // Post concept relations to create relations between concepts in the platform.
    virtual ::grpc::Status PostConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::PostConceptRelationsRequest& request, ::clarifai::api::MultiConceptRelationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptRelationResponse>> AsyncPostConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::PostConceptRelationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptRelationResponse>>(AsyncPostConceptRelationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptRelationResponse>> PrepareAsyncPostConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::PostConceptRelationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptRelationResponse>>(PrepareAsyncPostConceptRelationsRaw(context, request, cq));
    }
    // Post concept relations to create relations between concepts in the platform.
    virtual ::grpc::Status DeleteConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::DeleteConceptRelationsRequest& request, ::clarifai::api::status::BaseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> AsyncDeleteConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::DeleteConceptRelationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(AsyncDeleteConceptRelationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::DeleteConceptRelationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteConceptRelationsRaw(context, request, cq));
    }
    // //////////////////////////////////////
    // Concepts
    // //////////////////////////////////////
    //
    // List all the concepts with their positive and negative counts
    virtual ::grpc::Status GetConceptCounts(::grpc::ClientContext* context, const ::clarifai::api::GetConceptCountsRequest& request, ::clarifai::api::MultiConceptCountResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptCountResponse>> AsyncGetConceptCounts(::grpc::ClientContext* context, const ::clarifai::api::GetConceptCountsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptCountResponse>>(AsyncGetConceptCountsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptCountResponse>> PrepareAsyncGetConceptCounts(::grpc::ClientContext* context, const ::clarifai::api::GetConceptCountsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptCountResponse>>(PrepareAsyncGetConceptCountsRaw(context, request, cq));
    }
    // Get a specific concept from an app.
    virtual ::grpc::Status GetConcept(::grpc::ClientContext* context, const ::clarifai::api::GetConceptRequest& request, ::clarifai::api::SingleConceptResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleConceptResponse>> AsyncGetConcept(::grpc::ClientContext* context, const ::clarifai::api::GetConceptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleConceptResponse>>(AsyncGetConceptRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleConceptResponse>> PrepareAsyncGetConcept(::grpc::ClientContext* context, const ::clarifai::api::GetConceptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleConceptResponse>>(PrepareAsyncGetConceptRaw(context, request, cq));
    }
    // List all the concepts.
    virtual ::grpc::Status ListConcepts(::grpc::ClientContext* context, const ::clarifai::api::ListConceptsRequest& request, ::clarifai::api::MultiConceptResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptResponse>> AsyncListConcepts(::grpc::ClientContext* context, const ::clarifai::api::ListConceptsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptResponse>>(AsyncListConceptsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptResponse>> PrepareAsyncListConcepts(::grpc::ClientContext* context, const ::clarifai::api::ListConceptsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptResponse>>(PrepareAsyncListConceptsRaw(context, request, cq));
    }
    // Search over the concepts to find one or more you're looking for.
    // This leverage the "body" parameter because we also have page and
    // per_page as url query param variables in this request.
    virtual ::grpc::Status PostConceptsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsSearchesRequest& request, ::clarifai::api::MultiConceptResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptResponse>> AsyncPostConceptsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsSearchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptResponse>>(AsyncPostConceptsSearchesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptResponse>> PrepareAsyncPostConceptsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsSearchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptResponse>>(PrepareAsyncPostConceptsSearchesRaw(context, request, cq));
    }
    // Add a concept to an app.
    virtual ::grpc::Status PostConcepts(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsRequest& request, ::clarifai::api::MultiConceptResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptResponse>> AsyncPostConcepts(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptResponse>>(AsyncPostConceptsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptResponse>> PrepareAsyncPostConcepts(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptResponse>>(PrepareAsyncPostConceptsRaw(context, request, cq));
    }
    // Patch one or more concepts.
    virtual ::grpc::Status PatchConcepts(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptsRequest& request, ::clarifai::api::MultiConceptResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptResponse>> AsyncPatchConcepts(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptResponse>>(AsyncPatchConceptsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptResponse>> PrepareAsyncPatchConcepts(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptResponse>>(PrepareAsyncPatchConceptsRaw(context, request, cq));
    }
    // //////////////////////////////////////
    //
    // //////////////////////////////////////
    // Concept Languages
    // //////////////////////////////////////
    //
    // Get a specific concept from an app.
    virtual ::grpc::Status GetConceptLanguage(::grpc::ClientContext* context, const ::clarifai::api::GetConceptLanguageRequest& request, ::clarifai::api::SingleConceptLanguageResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleConceptLanguageResponse>> AsyncGetConceptLanguage(::grpc::ClientContext* context, const ::clarifai::api::GetConceptLanguageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleConceptLanguageResponse>>(AsyncGetConceptLanguageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleConceptLanguageResponse>> PrepareAsyncGetConceptLanguage(::grpc::ClientContext* context, const ::clarifai::api::GetConceptLanguageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleConceptLanguageResponse>>(PrepareAsyncGetConceptLanguageRaw(context, request, cq));
    }
    // List the concept in all the translated languages.
    virtual ::grpc::Status ListConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::ListConceptLanguagesRequest& request, ::clarifai::api::MultiConceptLanguageResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptLanguageResponse>> AsyncListConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::ListConceptLanguagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptLanguageResponse>>(AsyncListConceptLanguagesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptLanguageResponse>> PrepareAsyncListConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::ListConceptLanguagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptLanguageResponse>>(PrepareAsyncListConceptLanguagesRaw(context, request, cq));
    }
    // Add a new tranlsation for this concept.
    virtual ::grpc::Status PostConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::PostConceptLanguagesRequest& request, ::clarifai::api::MultiConceptLanguageResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptLanguageResponse>> AsyncPostConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::PostConceptLanguagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptLanguageResponse>>(AsyncPostConceptLanguagesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptLanguageResponse>> PrepareAsyncPostConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::PostConceptLanguagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptLanguageResponse>>(PrepareAsyncPostConceptLanguagesRaw(context, request, cq));
    }
    // Patch the name for a given language names by passing in a list of concepts with the new names
    // for the languages.
    virtual ::grpc::Status PatchConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptLanguagesRequest& request, ::clarifai::api::MultiConceptLanguageResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptLanguageResponse>> AsyncPatchConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptLanguagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptLanguageResponse>>(AsyncPatchConceptLanguagesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptLanguageResponse>> PrepareAsyncPatchConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptLanguagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptLanguageResponse>>(PrepareAsyncPatchConceptLanguagesRaw(context, request, cq));
    }
    // //////////////////////////////////////
    // Knowledge Graph
    // //////////////////////////////////////
    //
    // List all domain graphs.
    virtual ::grpc::Status ListKnowledgeGraphs(::grpc::ClientContext* context, const ::clarifai::api::ListKnowledgeGraphsRequest& request, ::clarifai::api::MultiKnowledgeGraphResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKnowledgeGraphResponse>> AsyncListKnowledgeGraphs(::grpc::ClientContext* context, const ::clarifai::api::ListKnowledgeGraphsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKnowledgeGraphResponse>>(AsyncListKnowledgeGraphsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKnowledgeGraphResponse>> PrepareAsyncListKnowledgeGraphs(::grpc::ClientContext* context, const ::clarifai::api::ListKnowledgeGraphsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKnowledgeGraphResponse>>(PrepareAsyncListKnowledgeGraphsRaw(context, request, cq));
    }
    // Post domain graphs.
    virtual ::grpc::Status PostKnowledgeGraphs(::grpc::ClientContext* context, const ::clarifai::api::PostKnowledgeGraphsRequest& request, ::clarifai::api::MultiKnowledgeGraphResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKnowledgeGraphResponse>> AsyncPostKnowledgeGraphs(::grpc::ClientContext* context, const ::clarifai::api::PostKnowledgeGraphsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKnowledgeGraphResponse>>(AsyncPostKnowledgeGraphsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKnowledgeGraphResponse>> PrepareAsyncPostKnowledgeGraphs(::grpc::ClientContext* context, const ::clarifai::api::PostKnowledgeGraphsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKnowledgeGraphResponse>>(PrepareAsyncPostKnowledgeGraphsRaw(context, request, cq));
    }
    // Start concept mapping jobs.
    virtual ::grpc::Status PostConceptMappingJobs(::grpc::ClientContext* context, const ::clarifai::api::PostConceptMappingJobsRequest& request, ::clarifai::api::MultiConceptMappingJobResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptMappingJobResponse>> AsyncPostConceptMappingJobs(::grpc::ClientContext* context, const ::clarifai::api::PostConceptMappingJobsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptMappingJobResponse>>(AsyncPostConceptMappingJobsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptMappingJobResponse>> PrepareAsyncPostConceptMappingJobs(::grpc::ClientContext* context, const ::clarifai::api::PostConceptMappingJobsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptMappingJobResponse>>(PrepareAsyncPostConceptMappingJobsRaw(context, request, cq));
    }
    // //////////////////////////////////////
    // annotations
    // //////////////////////////////////////
    //
    // Get a specific annotation from an app.
    virtual ::grpc::Status GetAnnotation(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationRequest& request, ::clarifai::api::SingleAnnotationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleAnnotationResponse>> AsyncGetAnnotation(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleAnnotationResponse>>(AsyncGetAnnotationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleAnnotationResponse>> PrepareAsyncGetAnnotation(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleAnnotationResponse>>(PrepareAsyncGetAnnotationRaw(context, request, cq));
    }
    // List all the annotation.
    virtual ::grpc::Status ListAnnotations(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationsRequest& request, ::clarifai::api::MultiAnnotationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationResponse>> AsyncListAnnotations(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationResponse>>(AsyncListAnnotationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationResponse>> PrepareAsyncListAnnotations(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationResponse>>(PrepareAsyncListAnnotationsRaw(context, request, cq));
    }
    // Post annotations.
    virtual ::grpc::Status PostAnnotations(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsRequest& request, ::clarifai::api::MultiAnnotationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationResponse>> AsyncPostAnnotations(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationResponse>>(AsyncPostAnnotationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationResponse>> PrepareAsyncPostAnnotations(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationResponse>>(PrepareAsyncPostAnnotationsRaw(context, request, cq));
    }
    // Patch one or more annotations.
    virtual ::grpc::Status PatchAnnotations(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsRequest& request, ::clarifai::api::MultiAnnotationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationResponse>> AsyncPatchAnnotations(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationResponse>>(AsyncPatchAnnotationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationResponse>> PrepareAsyncPatchAnnotations(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationResponse>>(PrepareAsyncPatchAnnotationsRaw(context, request, cq));
    }
    // Patch annotations status by worker id and task id.
    virtual ::grpc::Status PatchAnnotationsStatus(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsStatusRequest& request, ::clarifai::api::PatchAnnotationsStatusResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::PatchAnnotationsStatusResponse>> AsyncPatchAnnotationsStatus(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::PatchAnnotationsStatusResponse>>(AsyncPatchAnnotationsStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::PatchAnnotationsStatusResponse>> PrepareAsyncPatchAnnotationsStatus(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::PatchAnnotationsStatusResponse>>(PrepareAsyncPatchAnnotationsStatusRaw(context, request, cq));
    }
    // Delete a single annotation.
    virtual ::grpc::Status DeleteAnnotation(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationRequest& request, ::clarifai::api::status::BaseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> AsyncDeleteAnnotation(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(AsyncDeleteAnnotationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteAnnotation(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteAnnotationRaw(context, request, cq));
    }
    // Delete multiple annotations in one request.
    virtual ::grpc::Status DeleteAnnotations(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationsRequest& request, ::clarifai::api::status::BaseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> AsyncDeleteAnnotations(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(AsyncDeleteAnnotationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteAnnotations(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteAnnotationsRaw(context, request, cq));
    }
    // Execute a search over annotation
    virtual ::grpc::Status PostAnnotationsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsSearchesRequest& request, ::clarifai::api::MultiSearchResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>> AsyncPostAnnotationsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsSearchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>>(AsyncPostAnnotationsSearchesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>> PrepareAsyncPostAnnotationsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsSearchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>>(PrepareAsyncPostAnnotationsSearchesRaw(context, request, cq));
    }
    // //////////////////////////////////////
    // Inputs
    // //////////////////////////////////////
    //
    // Get input count per status.
    virtual ::grpc::Status GetInputCount(::grpc::ClientContext* context, const ::clarifai::api::GetInputCountRequest& request, ::clarifai::api::SingleInputCountResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleInputCountResponse>> AsyncGetInputCount(::grpc::ClientContext* context, const ::clarifai::api::GetInputCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleInputCountResponse>>(AsyncGetInputCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleInputCountResponse>> PrepareAsyncGetInputCount(::grpc::ClientContext* context, const ::clarifai::api::GetInputCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleInputCountResponse>>(PrepareAsyncGetInputCountRaw(context, request, cq));
    }
    // Streams all the inputs starting from oldest assets.
    virtual ::grpc::Status StreamInputs(::grpc::ClientContext* context, const ::clarifai::api::StreamInputsRequest& request, ::clarifai::api::MultiInputResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>> AsyncStreamInputs(::grpc::ClientContext* context, const ::clarifai::api::StreamInputsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>>(AsyncStreamInputsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>> PrepareAsyncStreamInputs(::grpc::ClientContext* context, const ::clarifai::api::StreamInputsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>>(PrepareAsyncStreamInputsRaw(context, request, cq));
    }
    // Get a specific input from an app.
    virtual ::grpc::Status GetInputSamples(::grpc::ClientContext* context, const ::clarifai::api::GetInputSamplesRequest& request, ::clarifai::api::MultiInputAnnotationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputAnnotationResponse>> AsyncGetInputSamples(::grpc::ClientContext* context, const ::clarifai::api::GetInputSamplesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputAnnotationResponse>>(AsyncGetInputSamplesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputAnnotationResponse>> PrepareAsyncGetInputSamples(::grpc::ClientContext* context, const ::clarifai::api::GetInputSamplesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputAnnotationResponse>>(PrepareAsyncGetInputSamplesRaw(context, request, cq));
    }
    // Get a specific input from an app.
    virtual ::grpc::Status GetInput(::grpc::ClientContext* context, const ::clarifai::api::GetInputRequest& request, ::clarifai::api::SingleInputResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleInputResponse>> AsyncGetInput(::grpc::ClientContext* context, const ::clarifai::api::GetInputRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleInputResponse>>(AsyncGetInputRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleInputResponse>> PrepareAsyncGetInput(::grpc::ClientContext* context, const ::clarifai::api::GetInputRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleInputResponse>>(PrepareAsyncGetInputRaw(context, request, cq));
    }
    // List all the inputs.
    virtual ::grpc::Status ListInputs(::grpc::ClientContext* context, const ::clarifai::api::ListInputsRequest& request, ::clarifai::api::MultiInputResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>> AsyncListInputs(::grpc::ClientContext* context, const ::clarifai::api::ListInputsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>>(AsyncListInputsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>> PrepareAsyncListInputs(::grpc::ClientContext* context, const ::clarifai::api::ListInputsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>>(PrepareAsyncListInputsRaw(context, request, cq));
    }
    // Add an input (or set of inputs) to an app.
    // This call is synchronous if the PostInputsRequest contains exactly one image input. Otherwise,
    // it is asynchronous.
    virtual ::grpc::Status PostInputs(::grpc::ClientContext* context, const ::clarifai::api::PostInputsRequest& request, ::clarifai::api::MultiInputResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>> AsyncPostInputs(::grpc::ClientContext* context, const ::clarifai::api::PostInputsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>>(AsyncPostInputsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>> PrepareAsyncPostInputs(::grpc::ClientContext* context, const ::clarifai::api::PostInputsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>>(PrepareAsyncPostInputsRaw(context, request, cq));
    }
    // Patch one or more inputs.
    virtual ::grpc::Status PatchInputs(::grpc::ClientContext* context, const ::clarifai::api::PatchInputsRequest& request, ::clarifai::api::MultiInputResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>> AsyncPatchInputs(::grpc::ClientContext* context, const ::clarifai::api::PatchInputsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>>(AsyncPatchInputsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>> PrepareAsyncPatchInputs(::grpc::ClientContext* context, const ::clarifai::api::PatchInputsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>>(PrepareAsyncPatchInputsRaw(context, request, cq));
    }
    // Delete a single input.  This call is synchronous.
    virtual ::grpc::Status DeleteInput(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputRequest& request, ::clarifai::api::status::BaseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> AsyncDeleteInput(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(AsyncDeleteInputRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteInput(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteInputRaw(context, request, cq));
    }
    // Delete multiple inputs in one request.
    // This call is asynchronous. Use DeleteInput if you want a synchronous version.
    virtual ::grpc::Status DeleteInputs(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputsRequest& request, ::clarifai::api::status::BaseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> AsyncDeleteInputs(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(AsyncDeleteInputsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteInputs(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteInputsRaw(context, request, cq));
    }
    // Execute a search over input
    virtual ::grpc::Status PostInputsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostInputsSearchesRequest& request, ::clarifai::api::MultiSearchResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>> AsyncPostInputsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostInputsSearchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>>(AsyncPostInputsSearchesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>> PrepareAsyncPostInputsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostInputsSearchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>>(PrepareAsyncPostInputsSearchesRaw(context, request, cq));
    }
    // Get predicted outputs from the model.
    virtual ::grpc::Status PostModelOutputs(::grpc::ClientContext* context, const ::clarifai::api::PostModelOutputsRequest& request, ::clarifai::api::MultiOutputResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiOutputResponse>> AsyncPostModelOutputs(::grpc::ClientContext* context, const ::clarifai::api::PostModelOutputsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiOutputResponse>>(AsyncPostModelOutputsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiOutputResponse>> PrepareAsyncPostModelOutputs(::grpc::ClientContext* context, const ::clarifai::api::PostModelOutputsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiOutputResponse>>(PrepareAsyncPostModelOutputsRaw(context, request, cq));
    }
    // //////////////////////////////////////
    //
    // //////////////////////////////////////
    // Models
    // //////////////////////////////////////
    //
    // Get a specific model type.
    virtual ::grpc::Status GetModelType(::grpc::ClientContext* context, const ::clarifai::api::GetModelTypeRequest& request, ::clarifai::api::SingleModelTypeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelTypeResponse>> AsyncGetModelType(::grpc::ClientContext* context, const ::clarifai::api::GetModelTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelTypeResponse>>(AsyncGetModelTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelTypeResponse>> PrepareAsyncGetModelType(::grpc::ClientContext* context, const ::clarifai::api::GetModelTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelTypeResponse>>(PrepareAsyncGetModelTypeRaw(context, request, cq));
    }
    // List all the model types available in the platform.
    // This MUST be above ListModels so that the /models/types endpoint takes precedence.
    virtual ::grpc::Status ListModelTypes(::grpc::ClientContext* context, const ::clarifai::api::ListModelTypesRequest& request, ::clarifai::api::MultiModelTypeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelTypeResponse>> AsyncListModelTypes(::grpc::ClientContext* context, const ::clarifai::api::ListModelTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelTypeResponse>>(AsyncListModelTypesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelTypeResponse>> PrepareAsyncListModelTypes(::grpc::ClientContext* context, const ::clarifai::api::ListModelTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelTypeResponse>>(PrepareAsyncListModelTypesRaw(context, request, cq));
    }
    // Get a specific model from an app.
    virtual ::grpc::Status GetModel(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest& request, ::clarifai::api::SingleModelResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelResponse>> AsyncGetModel(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelResponse>>(AsyncGetModelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelResponse>> PrepareAsyncGetModel(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelResponse>>(PrepareAsyncGetModelRaw(context, request, cq));
    }
    // Get a the output info for a given model_id or model_id/version_id
    // combo.
    virtual ::grpc::Status GetModelOutputInfo(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest& request, ::clarifai::api::SingleModelResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelResponse>> AsyncGetModelOutputInfo(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelResponse>>(AsyncGetModelOutputInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelResponse>> PrepareAsyncGetModelOutputInfo(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelResponse>>(PrepareAsyncGetModelOutputInfoRaw(context, request, cq));
    }
    // List all the models.
    virtual ::grpc::Status ListModels(::grpc::ClientContext* context, const ::clarifai::api::ListModelsRequest& request, ::clarifai::api::MultiModelResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelResponse>> AsyncListModels(::grpc::ClientContext* context, const ::clarifai::api::ListModelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelResponse>>(AsyncListModelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelResponse>> PrepareAsyncListModels(::grpc::ClientContext* context, const ::clarifai::api::ListModelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelResponse>>(PrepareAsyncListModelsRaw(context, request, cq));
    }
    // Search over the models to find one or more you're looking for.
    // This leverage the "body" parameter because we also have page and
    // per_page as url query param variables in this request.
    virtual ::grpc::Status PostModelsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostModelsSearchesRequest& request, ::clarifai::api::MultiModelResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelResponse>> AsyncPostModelsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostModelsSearchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelResponse>>(AsyncPostModelsSearchesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelResponse>> PrepareAsyncPostModelsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostModelsSearchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelResponse>>(PrepareAsyncPostModelsSearchesRaw(context, request, cq));
    }
    // Add a models to an app.
    // FIXME(zeiler): this should have been a plural response.
    virtual ::grpc::Status PostModels(::grpc::ClientContext* context, const ::clarifai::api::PostModelsRequest& request, ::clarifai::api::SingleModelResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelResponse>> AsyncPostModels(::grpc::ClientContext* context, const ::clarifai::api::PostModelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelResponse>>(AsyncPostModelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelResponse>> PrepareAsyncPostModels(::grpc::ClientContext* context, const ::clarifai::api::PostModelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelResponse>>(PrepareAsyncPostModelsRaw(context, request, cq));
    }
    // Patch one or more models.
    virtual ::grpc::Status PatchModels(::grpc::ClientContext* context, const ::clarifai::api::PatchModelsRequest& request, ::clarifai::api::MultiModelResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelResponse>> AsyncPatchModels(::grpc::ClientContext* context, const ::clarifai::api::PatchModelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelResponse>>(AsyncPatchModelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelResponse>> PrepareAsyncPatchModels(::grpc::ClientContext* context, const ::clarifai::api::PatchModelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelResponse>>(PrepareAsyncPatchModelsRaw(context, request, cq));
    }
    // Delete a single model.
    virtual ::grpc::Status DeleteModel(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelRequest& request, ::clarifai::api::status::BaseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> AsyncDeleteModel(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(AsyncDeleteModelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteModel(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteModelRaw(context, request, cq));
    }
    // Delete multiple models in one request.
    virtual ::grpc::Status DeleteModels(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelsRequest& request, ::clarifai::api::status::BaseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> AsyncDeleteModels(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(AsyncDeleteModelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteModels(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteModelsRaw(context, request, cq));
    }
    // List all the inputs.
    virtual ::grpc::Status ListModelInputs(::grpc::ClientContext* context, const ::clarifai::api::ListModelInputsRequest& request, ::clarifai::api::MultiInputResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>> AsyncListModelInputs(::grpc::ClientContext* context, const ::clarifai::api::ListModelInputsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>>(AsyncListModelInputsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>> PrepareAsyncListModelInputs(::grpc::ClientContext* context, const ::clarifai::api::ListModelInputsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>>(PrepareAsyncListModelInputsRaw(context, request, cq));
    }
    // //////////////////////////////////////
    //
    // //////////////////////////////////////
    // Model versions
    // //////////////////////////////////////
    //
    // Get a specific model from an app.
    virtual ::grpc::Status GetModelVersion(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionRequest& request, ::clarifai::api::SingleModelVersionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelVersionResponse>> AsyncGetModelVersion(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelVersionResponse>>(AsyncGetModelVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelVersionResponse>> PrepareAsyncGetModelVersion(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelVersionResponse>>(PrepareAsyncGetModelVersionRaw(context, request, cq));
    }
    // List all the models.
    virtual ::grpc::Status ListModelVersions(::grpc::ClientContext* context, const ::clarifai::api::ListModelVersionsRequest& request, ::clarifai::api::MultiModelVersionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelVersionResponse>> AsyncListModelVersions(::grpc::ClientContext* context, const ::clarifai::api::ListModelVersionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelVersionResponse>>(AsyncListModelVersionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelVersionResponse>> PrepareAsyncListModelVersions(::grpc::ClientContext* context, const ::clarifai::api::ListModelVersionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelVersionResponse>>(PrepareAsyncListModelVersionsRaw(context, request, cq));
    }
    // NOTE: inconsistency: do we want this to return a SingleModelResponse?
    //
    // Create a new model version to trigger training of the model.
    // FIXME(zeiler): this should have been a plural response.
    virtual ::grpc::Status PostModelVersions(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionsRequest& request, ::clarifai::api::SingleModelResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelResponse>> AsyncPostModelVersions(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelResponse>>(AsyncPostModelVersionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelResponse>> PrepareAsyncPostModelVersions(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelResponse>>(PrepareAsyncPostModelVersionsRaw(context, request, cq));
    }
    // Delete a single model.
    virtual ::grpc::Status DeleteModelVersion(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelVersionRequest& request, ::clarifai::api::status::BaseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> AsyncDeleteModelVersion(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(AsyncDeleteModelVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteModelVersion(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteModelVersionRaw(context, request, cq));
    }
    // Get the evaluation metrics for a model version.
    virtual ::grpc::Status GetModelVersionMetrics(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionMetricsRequest& request, ::clarifai::api::SingleModelVersionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelVersionResponse>> AsyncGetModelVersionMetrics(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelVersionResponse>>(AsyncGetModelVersionMetricsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelVersionResponse>> PrepareAsyncGetModelVersionMetrics(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelVersionResponse>>(PrepareAsyncGetModelVersionMetricsRaw(context, request, cq));
    }
    // Run the evaluation metrics for a model version.
    virtual ::grpc::Status PostModelVersionMetrics(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionMetricsRequest& request, ::clarifai::api::SingleModelVersionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelVersionResponse>> AsyncPostModelVersionMetrics(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelVersionResponse>>(AsyncPostModelVersionMetricsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelVersionResponse>> PrepareAsyncPostModelVersionMetrics(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelVersionResponse>>(PrepareAsyncPostModelVersionMetricsRaw(context, request, cq));
    }
    // //////////////////////////////////////
    //
    // //////////////////////////////////////
    // Workflows
    // //////////////////////////////////////
    //
    // Get a specific workflow from an app.
    virtual ::grpc::Status GetWorkflow(::grpc::ClientContext* context, const ::clarifai::api::GetWorkflowRequest& request, ::clarifai::api::SingleWorkflowResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleWorkflowResponse>> AsyncGetWorkflow(::grpc::ClientContext* context, const ::clarifai::api::GetWorkflowRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleWorkflowResponse>>(AsyncGetWorkflowRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleWorkflowResponse>> PrepareAsyncGetWorkflow(::grpc::ClientContext* context, const ::clarifai::api::GetWorkflowRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleWorkflowResponse>>(PrepareAsyncGetWorkflowRaw(context, request, cq));
    }
    // List all the workflows.
    virtual ::grpc::Status ListWorkflows(::grpc::ClientContext* context, const ::clarifai::api::ListWorkflowsRequest& request, ::clarifai::api::MultiWorkflowResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiWorkflowResponse>> AsyncListWorkflows(::grpc::ClientContext* context, const ::clarifai::api::ListWorkflowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiWorkflowResponse>>(AsyncListWorkflowsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiWorkflowResponse>> PrepareAsyncListWorkflows(::grpc::ClientContext* context, const ::clarifai::api::ListWorkflowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiWorkflowResponse>>(PrepareAsyncListWorkflowsRaw(context, request, cq));
    }
    // Add a workflow to an app.
    virtual ::grpc::Status PostWorkflows(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowsRequest& request, ::clarifai::api::MultiWorkflowResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiWorkflowResponse>> AsyncPostWorkflows(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiWorkflowResponse>>(AsyncPostWorkflowsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiWorkflowResponse>> PrepareAsyncPostWorkflows(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiWorkflowResponse>>(PrepareAsyncPostWorkflowsRaw(context, request, cq));
    }
    // Patch one or more workflows.
    virtual ::grpc::Status PatchWorkflows(::grpc::ClientContext* context, const ::clarifai::api::PatchWorkflowsRequest& request, ::clarifai::api::MultiWorkflowResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiWorkflowResponse>> AsyncPatchWorkflows(::grpc::ClientContext* context, const ::clarifai::api::PatchWorkflowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiWorkflowResponse>>(AsyncPatchWorkflowsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiWorkflowResponse>> PrepareAsyncPatchWorkflows(::grpc::ClientContext* context, const ::clarifai::api::PatchWorkflowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiWorkflowResponse>>(PrepareAsyncPatchWorkflowsRaw(context, request, cq));
    }
    // Delete a single workflow.
    virtual ::grpc::Status DeleteWorkflow(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowRequest& request, ::clarifai::api::status::BaseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> AsyncDeleteWorkflow(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(AsyncDeleteWorkflowRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteWorkflow(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteWorkflowRaw(context, request, cq));
    }
    // Delete multiple workflows in one request.
    virtual ::grpc::Status DeleteWorkflows(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowsRequest& request, ::clarifai::api::status::BaseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> AsyncDeleteWorkflows(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(AsyncDeleteWorkflowsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteWorkflows(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteWorkflowsRaw(context, request, cq));
    }
    // Predict using a workflow.
    virtual ::grpc::Status PostWorkflowResults(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsRequest& request, ::clarifai::api::PostWorkflowResultsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::PostWorkflowResultsResponse>> AsyncPostWorkflowResults(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::PostWorkflowResultsResponse>>(AsyncPostWorkflowResultsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::PostWorkflowResultsResponse>> PrepareAsyncPostWorkflowResults(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::PostWorkflowResultsResponse>>(PrepareAsyncPostWorkflowResultsRaw(context, request, cq));
    }
    // Compare embeddings distances using a workflow
    //
    virtual ::grpc::Status PostWorkflowResultsSimilarity(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsSimilarityRequest& request, ::clarifai::api::PostWorkflowResultsSimilarityResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::PostWorkflowResultsSimilarityResponse>> AsyncPostWorkflowResultsSimilarity(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsSimilarityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::PostWorkflowResultsSimilarityResponse>>(AsyncPostWorkflowResultsSimilarityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::PostWorkflowResultsSimilarityResponse>> PrepareAsyncPostWorkflowResultsSimilarity(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsSimilarityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::PostWorkflowResultsSimilarityResponse>>(PrepareAsyncPostWorkflowResultsSimilarityRaw(context, request, cq));
    }
    // //////////////////////////////////////
    // API Keys
    // //////////////////////////////////////
    //
    // Get a specific key from an app.
    virtual ::grpc::Status GetKey(::grpc::ClientContext* context, const ::clarifai::api::GetKeyRequest& request, ::clarifai::api::SingleKeyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleKeyResponse>> AsyncGetKey(::grpc::ClientContext* context, const ::clarifai::api::GetKeyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleKeyResponse>>(AsyncGetKeyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleKeyResponse>> PrepareAsyncGetKey(::grpc::ClientContext* context, const ::clarifai::api::GetKeyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleKeyResponse>>(PrepareAsyncGetKeyRaw(context, request, cq));
    }
    // List all the keys.
    virtual ::grpc::Status ListKeys(::grpc::ClientContext* context, const ::clarifai::api::ListKeysRequest& request, ::clarifai::api::MultiKeyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKeyResponse>> AsyncListKeys(::grpc::ClientContext* context, const ::clarifai::api::ListKeysRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKeyResponse>>(AsyncListKeysRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKeyResponse>> PrepareAsyncListKeys(::grpc::ClientContext* context, const ::clarifai::api::ListKeysRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKeyResponse>>(PrepareAsyncListKeysRaw(context, request, cq));
    }
    // List keys by app_id
    virtual ::grpc::Status ListAppKeys(::grpc::ClientContext* context, const ::clarifai::api::ListAppKeysRequest& request, ::clarifai::api::MultiKeyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKeyResponse>> AsyncListAppKeys(::grpc::ClientContext* context, const ::clarifai::api::ListAppKeysRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKeyResponse>>(AsyncListAppKeysRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKeyResponse>> PrepareAsyncListAppKeys(::grpc::ClientContext* context, const ::clarifai::api::ListAppKeysRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKeyResponse>>(PrepareAsyncListAppKeysRaw(context, request, cq));
    }
    // Search over the keys to find one or more you're looking for.
    // This leverage the "body" parameter because we also have page and
    // per_page as url query param variables in this request.
    virtual ::grpc::Status DeleteKey(::grpc::ClientContext* context, const ::clarifai::api::DeleteKeyRequest& request, ::clarifai::api::status::BaseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> AsyncDeleteKey(::grpc::ClientContext* context, const ::clarifai::api::DeleteKeyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(AsyncDeleteKeyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteKey(::grpc::ClientContext* context, const ::clarifai::api::DeleteKeyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteKeyRaw(context, request, cq));
    }
    // Add a key to an app.
    virtual ::grpc::Status PostKeys(::grpc::ClientContext* context, const ::clarifai::api::PostKeysRequest& request, ::clarifai::api::MultiKeyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKeyResponse>> AsyncPostKeys(::grpc::ClientContext* context, const ::clarifai::api::PostKeysRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKeyResponse>>(AsyncPostKeysRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKeyResponse>> PrepareAsyncPostKeys(::grpc::ClientContext* context, const ::clarifai::api::PostKeysRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKeyResponse>>(PrepareAsyncPostKeysRaw(context, request, cq));
    }
    // Patch one or more keys.
    virtual ::grpc::Status PatchKeys(::grpc::ClientContext* context, const ::clarifai::api::PatchKeysRequest& request, ::clarifai::api::MultiKeyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKeyResponse>> AsyncPatchKeys(::grpc::ClientContext* context, const ::clarifai::api::PatchKeysRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKeyResponse>>(AsyncPatchKeysRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKeyResponse>> PrepareAsyncPatchKeys(::grpc::ClientContext* context, const ::clarifai::api::PatchKeysRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKeyResponse>>(PrepareAsyncPatchKeysRaw(context, request, cq));
    }
    // API Keys in the public API -- request is itself Key authorized, and will tell
    // the user the scopes/access of the key/credential they're providing, as computed by
    // our authorizer:
    virtual ::grpc::Status MyScopes(::grpc::ClientContext* context, const ::clarifai::api::MyScopesRequest& request, ::clarifai::api::MultiScopeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiScopeResponse>> AsyncMyScopes(::grpc::ClientContext* context, const ::clarifai::api::MyScopesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiScopeResponse>>(AsyncMyScopesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiScopeResponse>> PrepareAsyncMyScopes(::grpc::ClientContext* context, const ::clarifai::api::MyScopesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiScopeResponse>>(PrepareAsyncMyScopesRaw(context, request, cq));
    }
    // List all auth scopes available.
    virtual ::grpc::Status ListScopes(::grpc::ClientContext* context, const ::clarifai::api::ListScopesRequest& request, ::clarifai::api::MultiScopeDepsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiScopeDepsResponse>> AsyncListScopes(::grpc::ClientContext* context, const ::clarifai::api::ListScopesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiScopeDepsResponse>>(AsyncListScopesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiScopeDepsResponse>> PrepareAsyncListScopes(::grpc::ClientContext* context, const ::clarifai::api::ListScopesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiScopeDepsResponse>>(PrepareAsyncListScopesRaw(context, request, cq));
    }
    // //////////////////////////////////////
    // Apps
    // //////////////////////////////////////
    //
    // Get a specific app from an app.
    virtual ::grpc::Status GetApp(::grpc::ClientContext* context, const ::clarifai::api::GetAppRequest& request, ::clarifai::api::SingleAppResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleAppResponse>> AsyncGetApp(::grpc::ClientContext* context, const ::clarifai::api::GetAppRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleAppResponse>>(AsyncGetAppRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleAppResponse>> PrepareAsyncGetApp(::grpc::ClientContext* context, const ::clarifai::api::GetAppRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleAppResponse>>(PrepareAsyncGetAppRaw(context, request, cq));
    }
    // List all the apps.
    virtual ::grpc::Status ListApps(::grpc::ClientContext* context, const ::clarifai::api::ListAppsRequest& request, ::clarifai::api::MultiAppResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppResponse>> AsyncListApps(::grpc::ClientContext* context, const ::clarifai::api::ListAppsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppResponse>>(AsyncListAppsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppResponse>> PrepareAsyncListApps(::grpc::ClientContext* context, const ::clarifai::api::ListAppsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppResponse>>(PrepareAsyncListAppsRaw(context, request, cq));
    }
    // Search over the apps to find one or more you're looking for.
    // This leverage the "body" parameter because we also have page and
    // per_page as url query param variables in this request.
    virtual ::grpc::Status DeleteApp(::grpc::ClientContext* context, const ::clarifai::api::DeleteAppRequest& request, ::clarifai::api::status::BaseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> AsyncDeleteApp(::grpc::ClientContext* context, const ::clarifai::api::DeleteAppRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(AsyncDeleteAppRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteApp(::grpc::ClientContext* context, const ::clarifai::api::DeleteAppRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteAppRaw(context, request, cq));
    }
    // Add a app to an app.
    // This needs to load the default workflow to make a copy, validating all the models in it, and
    // then writing the new workflow back to this new app.
    virtual ::grpc::Status PostApps(::grpc::ClientContext* context, const ::clarifai::api::PostAppsRequest& request, ::clarifai::api::MultiAppResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppResponse>> AsyncPostApps(::grpc::ClientContext* context, const ::clarifai::api::PostAppsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppResponse>>(AsyncPostAppsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppResponse>> PrepareAsyncPostApps(::grpc::ClientContext* context, const ::clarifai::api::PostAppsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppResponse>>(PrepareAsyncPostAppsRaw(context, request, cq));
    }
    // Patch one or more apps.
    virtual ::grpc::Status PatchApps(::grpc::ClientContext* context, const ::clarifai::api::PatchAppsRequest& request, ::clarifai::api::MultiAppResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppResponse>> AsyncPatchApps(::grpc::ClientContext* context, const ::clarifai::api::PatchAppsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppResponse>>(AsyncPatchAppsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppResponse>> PrepareAsyncPatchApps(::grpc::ClientContext* context, const ::clarifai::api::PatchAppsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppResponse>>(PrepareAsyncPatchAppsRaw(context, request, cq));
    }
    // Search over the applications to find one or more you're looking for.
    virtual ::grpc::Status PostAppsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostAppsSearchesRequest& request, ::clarifai::api::MultiAppResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppResponse>> AsyncPostAppsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostAppsSearchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppResponse>>(AsyncPostAppsSearchesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppResponse>> PrepareAsyncPostAppsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostAppsSearchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppResponse>>(PrepareAsyncPostAppsSearchesRaw(context, request, cq));
    }
    // //////////////////////////////////////
    //
    // //////////////////////////////////////
    // Password
    // //////////////////////////////////////
    //
    // Validate new password in real-time for a user
    virtual ::grpc::Status PostValidatePassword(::grpc::ClientContext* context, const ::clarifai::api::PostValidatePasswordRequest& request, ::clarifai::api::SinglePasswordValidationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SinglePasswordValidationResponse>> AsyncPostValidatePassword(::grpc::ClientContext* context, const ::clarifai::api::PostValidatePasswordRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SinglePasswordValidationResponse>>(AsyncPostValidatePasswordRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SinglePasswordValidationResponse>> PrepareAsyncPostValidatePassword(::grpc::ClientContext* context, const ::clarifai::api::PostValidatePasswordRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SinglePasswordValidationResponse>>(PrepareAsyncPostValidatePasswordRaw(context, request, cq));
    }
    // //////////////////////////////////////
    // Searches
    // //////////////////////////////////////
    //
    // Get a saved search.
    virtual ::grpc::Status GetSearch(::grpc::ClientContext* context, const ::clarifai::api::GetSearchRequest& request, ::clarifai::api::SingleSearchResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleSearchResponse>> AsyncGetSearch(::grpc::ClientContext* context, const ::clarifai::api::GetSearchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleSearchResponse>>(AsyncGetSearchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleSearchResponse>> PrepareAsyncGetSearch(::grpc::ClientContext* context, const ::clarifai::api::GetSearchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleSearchResponse>>(PrepareAsyncGetSearchRaw(context, request, cq));
    }
    // List all saved searches.
    virtual ::grpc::Status ListSearches(::grpc::ClientContext* context, const ::clarifai::api::ListSearchesRequest& request, ::clarifai::api::MultiSearchResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>> AsyncListSearches(::grpc::ClientContext* context, const ::clarifai::api::ListSearchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>>(AsyncListSearchesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>> PrepareAsyncListSearches(::grpc::ClientContext* context, const ::clarifai::api::ListSearchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>>(PrepareAsyncListSearchesRaw(context, request, cq));
    }
    // Execute a new search and optionally save it.
    virtual ::grpc::Status PostSearches(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesRequest& request, ::clarifai::api::MultiSearchResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>> AsyncPostSearches(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>>(AsyncPostSearchesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>> PrepareAsyncPostSearches(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>>(PrepareAsyncPostSearchesRaw(context, request, cq));
    }
    // Execute a previously saved search.
    virtual ::grpc::Status PostSearchesByID(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesByIDRequest& request, ::clarifai::api::MultiSearchResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>> AsyncPostSearchesByID(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>>(AsyncPostSearchesByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>> PrepareAsyncPostSearchesByID(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>>(PrepareAsyncPostSearchesByIDRaw(context, request, cq));
    }
    // Evaluate the results of two search requests
    virtual ::grpc::Status PostAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationSearchMetricsRequest& request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationSearchMetricsResponse>> AsyncPostAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationSearchMetricsResponse>>(AsyncPostAnnotationSearchMetricsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationSearchMetricsResponse>> PrepareAsyncPostAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationSearchMetricsResponse>>(PrepareAsyncPostAnnotationSearchMetricsRaw(context, request, cq));
    }
    // Get the evaluation results between two search requests
    virtual ::grpc::Status GetAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationSearchMetricsRequest& request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationSearchMetricsResponse>> AsyncGetAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationSearchMetricsResponse>>(AsyncGetAnnotationSearchMetricsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationSearchMetricsResponse>> PrepareAsyncGetAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationSearchMetricsResponse>>(PrepareAsyncGetAnnotationSearchMetricsRaw(context, request, cq));
    }
    // List the evaluation results between two search requests
    virtual ::grpc::Status ListAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationSearchMetricsRequest& request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationSearchMetricsResponse>> AsyncListAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationSearchMetricsResponse>>(AsyncListAnnotationSearchMetricsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationSearchMetricsResponse>> PrepareAsyncListAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationSearchMetricsResponse>>(PrepareAsyncListAnnotationSearchMetricsRaw(context, request, cq));
    }
    virtual ::grpc::Status DeleteAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationSearchMetricsRequest& request, ::clarifai::api::status::BaseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> AsyncDeleteAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(AsyncDeleteAnnotationSearchMetricsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteAnnotationSearchMetricsRaw(context, request, cq));
    }
    // Delete a saved search.
    virtual ::grpc::Status DeleteSearch(::grpc::ClientContext* context, const ::clarifai::api::DeleteSearchRequest& request, ::clarifai::api::status::BaseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> AsyncDeleteSearch(::grpc::ClientContext* context, const ::clarifai::api::DeleteSearchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(AsyncDeleteSearchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteSearch(::grpc::ClientContext* context, const ::clarifai::api::DeleteSearchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteSearchRaw(context, request, cq));
    }
    // //////////////////////////////////////
    //
    // //////////////////////////////////////
    // Status Codes
    // //////////////////////////////////////
    //
    // List all status codes.
    virtual ::grpc::Status ListStatusCodes(::grpc::ClientContext* context, const ::clarifai::api::ListStatusCodesRequest& request, ::clarifai::api::MultiStatusCodeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiStatusCodeResponse>> AsyncListStatusCodes(::grpc::ClientContext* context, const ::clarifai::api::ListStatusCodesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiStatusCodeResponse>>(AsyncListStatusCodesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiStatusCodeResponse>> PrepareAsyncListStatusCodes(::grpc::ClientContext* context, const ::clarifai::api::ListStatusCodesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiStatusCodeResponse>>(PrepareAsyncListStatusCodesRaw(context, request, cq));
    }
    // Get more details for a status code.
    virtual ::grpc::Status GetStatusCode(::grpc::ClientContext* context, const ::clarifai::api::GetStatusCodeRequest& request, ::clarifai::api::SingleStatusCodeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleStatusCodeResponse>> AsyncGetStatusCode(::grpc::ClientContext* context, const ::clarifai::api::GetStatusCodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleStatusCodeResponse>>(AsyncGetStatusCodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleStatusCodeResponse>> PrepareAsyncGetStatusCode(::grpc::ClientContext* context, const ::clarifai::api::GetStatusCodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleStatusCodeResponse>>(PrepareAsyncGetStatusCodeRaw(context, request, cq));
    }
    // //////////////////////////////////////
    // App Sharing
    // //////////////////////////////////////
    //
    // owner list users who the app is shared with
    virtual ::grpc::Status ListCollaborators(::grpc::ClientContext* context, const ::clarifai::api::ListCollaboratorsRequest& request, ::clarifai::api::MultiCollaboratorsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollaboratorsResponse>> AsyncListCollaborators(::grpc::ClientContext* context, const ::clarifai::api::ListCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollaboratorsResponse>>(AsyncListCollaboratorsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollaboratorsResponse>> PrepareAsyncListCollaborators(::grpc::ClientContext* context, const ::clarifai::api::ListCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollaboratorsResponse>>(PrepareAsyncListCollaboratorsRaw(context, request, cq));
    }
    // add collaborators to an app.
    virtual ::grpc::Status PostCollaborators(::grpc::ClientContext* context, const ::clarifai::api::PostCollaboratorsRequest& request, ::clarifai::api::MultiCollaboratorsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollaboratorsResponse>> AsyncPostCollaborators(::grpc::ClientContext* context, const ::clarifai::api::PostCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollaboratorsResponse>>(AsyncPostCollaboratorsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollaboratorsResponse>> PrepareAsyncPostCollaborators(::grpc::ClientContext* context, const ::clarifai::api::PostCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollaboratorsResponse>>(PrepareAsyncPostCollaboratorsRaw(context, request, cq));
    }
    // Patch existing collaborators.
    virtual ::grpc::Status PatchCollaborators(::grpc::ClientContext* context, const ::clarifai::api::PatchCollaboratorsRequest& request, ::clarifai::api::MultiCollaboratorsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollaboratorsResponse>> AsyncPatchCollaborators(::grpc::ClientContext* context, const ::clarifai::api::PatchCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollaboratorsResponse>>(AsyncPatchCollaboratorsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollaboratorsResponse>> PrepareAsyncPatchCollaborators(::grpc::ClientContext* context, const ::clarifai::api::PatchCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollaboratorsResponse>>(PrepareAsyncPatchCollaboratorsRaw(context, request, cq));
    }
    // Delete existing collaborators.
    virtual ::grpc::Status DeleteCollaborators(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollaboratorsRequest& request, ::clarifai::api::status::BaseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> AsyncDeleteCollaborators(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(AsyncDeleteCollaboratorsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteCollaborators(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteCollaboratorsRaw(context, request, cq));
    }
    // Collaboration includes the app user are invitied to work on
    virtual ::grpc::Status ListCollaborations(::grpc::ClientContext* context, const ::clarifai::api::ListCollaborationsRequest& request, ::clarifai::api::MultiCollaborationsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollaborationsResponse>> AsyncListCollaborations(::grpc::ClientContext* context, const ::clarifai::api::ListCollaborationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollaborationsResponse>>(AsyncListCollaborationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollaborationsResponse>> PrepareAsyncListCollaborations(::grpc::ClientContext* context, const ::clarifai::api::ListCollaborationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollaborationsResponse>>(PrepareAsyncListCollaborationsRaw(context, request, cq));
    }
    // //////////////////////////////////////
    // App duplication
    // //////////////////////////////////////
    //
    // start to duplicate an app which copies all the inputs, annotations, models, concepts etc. to a new app.
    // this is an async process, you should use ListAppDuplications or GetAppDuplication to check the status.
    virtual ::grpc::Status PostAppDuplications(::grpc::ClientContext* context, const ::clarifai::api::PostAppDuplicationsRequest& request, ::clarifai::api::MultiAppDuplicationsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppDuplicationsResponse>> AsyncPostAppDuplications(::grpc::ClientContext* context, const ::clarifai::api::PostAppDuplicationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppDuplicationsResponse>>(AsyncPostAppDuplicationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppDuplicationsResponse>> PrepareAsyncPostAppDuplications(::grpc::ClientContext* context, const ::clarifai::api::PostAppDuplicationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppDuplicationsResponse>>(PrepareAsyncPostAppDuplicationsRaw(context, request, cq));
    }
    // list all the app duplications user triggers
    virtual ::grpc::Status ListAppDuplications(::grpc::ClientContext* context, const ::clarifai::api::ListAppDuplicationsRequest& request, ::clarifai::api::MultiAppDuplicationsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppDuplicationsResponse>> AsyncListAppDuplications(::grpc::ClientContext* context, const ::clarifai::api::ListAppDuplicationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppDuplicationsResponse>>(AsyncListAppDuplicationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppDuplicationsResponse>> PrepareAsyncListAppDuplications(::grpc::ClientContext* context, const ::clarifai::api::ListAppDuplicationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppDuplicationsResponse>>(PrepareAsyncListAppDuplicationsRaw(context, request, cq));
    }
    // get the app duplication status
    virtual ::grpc::Status GetAppDuplication(::grpc::ClientContext* context, const ::clarifai::api::GetAppDuplicationRequest& request, ::clarifai::api::SingleAppDuplicationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleAppDuplicationResponse>> AsyncGetAppDuplication(::grpc::ClientContext* context, const ::clarifai::api::GetAppDuplicationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleAppDuplicationResponse>>(AsyncGetAppDuplicationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleAppDuplicationResponse>> PrepareAsyncGetAppDuplication(::grpc::ClientContext* context, const ::clarifai::api::GetAppDuplicationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleAppDuplicationResponse>>(PrepareAsyncGetAppDuplicationRaw(context, request, cq));
    }
    // //////////////////////////////////////
    // Tasks
    // //////////////////////////////////////
    //
    // Add tasks to an app.
    virtual ::grpc::Status PostTasks(::grpc::ClientContext* context, const ::clarifai::api::PostTasksRequest& request, ::clarifai::api::MultiTaskResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiTaskResponse>> AsyncPostTasks(::grpc::ClientContext* context, const ::clarifai::api::PostTasksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiTaskResponse>>(AsyncPostTasksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiTaskResponse>> PrepareAsyncPostTasks(::grpc::ClientContext* context, const ::clarifai::api::PostTasksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiTaskResponse>>(PrepareAsyncPostTasksRaw(context, request, cq));
    }
    // Task annotation count
    virtual ::grpc::Status GetTaskAnnotationCount(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest& request, ::clarifai::api::SingleTaskCountResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleTaskCountResponse>> AsyncGetTaskAnnotationCount(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleTaskCountResponse>>(AsyncGetTaskAnnotationCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleTaskCountResponse>> PrepareAsyncGetTaskAnnotationCount(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleTaskCountResponse>>(PrepareAsyncGetTaskAnnotationCountRaw(context, request, cq));
    }
    // Task Input count
    virtual ::grpc::Status GetTaskInputCount(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest& request, ::clarifai::api::SingleTaskCountResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleTaskCountResponse>> AsyncGetTaskInputCount(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleTaskCountResponse>>(AsyncGetTaskInputCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleTaskCountResponse>> PrepareAsyncGetTaskInputCount(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleTaskCountResponse>>(PrepareAsyncGetTaskInputCountRaw(context, request, cq));
    }
    // Get a specific task from an app.
    virtual ::grpc::Status GetTask(::grpc::ClientContext* context, const ::clarifai::api::GetTaskRequest& request, ::clarifai::api::SingleTaskResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleTaskResponse>> AsyncGetTask(::grpc::ClientContext* context, const ::clarifai::api::GetTaskRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleTaskResponse>>(AsyncGetTaskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleTaskResponse>> PrepareAsyncGetTask(::grpc::ClientContext* context, const ::clarifai::api::GetTaskRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleTaskResponse>>(PrepareAsyncGetTaskRaw(context, request, cq));
    }
    // List tasks from an app.
    virtual ::grpc::Status ListTasks(::grpc::ClientContext* context, const ::clarifai::api::ListTasksRequest& request, ::clarifai::api::MultiTaskResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiTaskResponse>> AsyncListTasks(::grpc::ClientContext* context, const ::clarifai::api::ListTasksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiTaskResponse>>(AsyncListTasksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiTaskResponse>> PrepareAsyncListTasks(::grpc::ClientContext* context, const ::clarifai::api::ListTasksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiTaskResponse>>(PrepareAsyncListTasksRaw(context, request, cq));
    }
    // Patch one or more tasks.
    virtual ::grpc::Status PatchTasks(::grpc::ClientContext* context, const ::clarifai::api::PatchTasksRequest& request, ::clarifai::api::MultiTaskResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiTaskResponse>> AsyncPatchTasks(::grpc::ClientContext* context, const ::clarifai::api::PatchTasksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiTaskResponse>>(AsyncPatchTasksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiTaskResponse>> PrepareAsyncPatchTasks(::grpc::ClientContext* context, const ::clarifai::api::PatchTasksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiTaskResponse>>(PrepareAsyncPatchTasksRaw(context, request, cq));
    }
    // Delete multiple tasks in one request.
    virtual ::grpc::Status DeleteTasks(::grpc::ClientContext* context, const ::clarifai::api::DeleteTasksRequest& request, ::clarifai::api::status::BaseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> AsyncDeleteTasks(::grpc::ClientContext* context, const ::clarifai::api::DeleteTasksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(AsyncDeleteTasksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteTasks(::grpc::ClientContext* context, const ::clarifai::api::DeleteTasksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteTasksRaw(context, request, cq));
    }
    // //////////////////////////////////////
    // Collectors
    // //////////////////////////////////////
    //
    // Add a list of Collectors to an app.
    // In the handler of this endpoint we also check for all the scopes of the  POST /inputs
    // endpoint.
    // Those current scopes are listed here as a hard requirement.
    // They are needed when adding the collectors just so we now that you have permission with
    // that key at least to do the writing to this app with POST /inputs.
    virtual ::grpc::Status PostCollectors(::grpc::ClientContext* context, const ::clarifai::api::PostCollectorsRequest& request, ::clarifai::api::MultiCollectorResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollectorResponse>> AsyncPostCollectors(::grpc::ClientContext* context, const ::clarifai::api::PostCollectorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollectorResponse>>(AsyncPostCollectorsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollectorResponse>> PrepareAsyncPostCollectors(::grpc::ClientContext* context, const ::clarifai::api::PostCollectorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollectorResponse>>(PrepareAsyncPostCollectorsRaw(context, request, cq));
    }
    // Get a specific collector from an app.
    virtual ::grpc::Status GetCollector(::grpc::ClientContext* context, const ::clarifai::api::GetCollectorRequest& request, ::clarifai::api::SingleCollectorResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleCollectorResponse>> AsyncGetCollector(::grpc::ClientContext* context, const ::clarifai::api::GetCollectorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleCollectorResponse>>(AsyncGetCollectorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleCollectorResponse>> PrepareAsyncGetCollector(::grpc::ClientContext* context, const ::clarifai::api::GetCollectorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleCollectorResponse>>(PrepareAsyncGetCollectorRaw(context, request, cq));
    }
    // List all the collectors.
    virtual ::grpc::Status ListCollectors(::grpc::ClientContext* context, const ::clarifai::api::ListCollectorsRequest& request, ::clarifai::api::MultiCollectorResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollectorResponse>> AsyncListCollectors(::grpc::ClientContext* context, const ::clarifai::api::ListCollectorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollectorResponse>>(AsyncListCollectorsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollectorResponse>> PrepareAsyncListCollectors(::grpc::ClientContext* context, const ::clarifai::api::ListCollectorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollectorResponse>>(PrepareAsyncListCollectorsRaw(context, request, cq));
    }
    // Patch one or more collectors.
    virtual ::grpc::Status PatchCollectors(::grpc::ClientContext* context, const ::clarifai::api::PatchCollectorsRequest& request, ::clarifai::api::MultiCollectorResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollectorResponse>> AsyncPatchCollectors(::grpc::ClientContext* context, const ::clarifai::api::PatchCollectorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollectorResponse>>(AsyncPatchCollectorsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollectorResponse>> PrepareAsyncPatchCollectors(::grpc::ClientContext* context, const ::clarifai::api::PatchCollectorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollectorResponse>>(PrepareAsyncPatchCollectorsRaw(context, request, cq));
    }
    // Delete multiple collectors in one request.
    // This call is asynchronous. Use DeleteCollector if you want a synchronous version.
    virtual ::grpc::Status DeleteCollectors(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollectorsRequest& request, ::clarifai::api::status::BaseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> AsyncDeleteCollectors(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollectorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(AsyncDeleteCollectorsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteCollectors(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollectorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteCollectorsRaw(context, request, cq));
    }
    // //////////////////////////////////////////////////////////////////////////////
    // Stats Collection Endpoints.
    // //////////////////////////////////////////////////////////////////////////////
    //
    virtual ::grpc::Status PostStatValues(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesRequest& request, ::clarifai::api::MultiStatValueResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiStatValueResponse>> AsyncPostStatValues(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiStatValueResponse>>(AsyncPostStatValuesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiStatValueResponse>> PrepareAsyncPostStatValues(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiStatValueResponse>>(PrepareAsyncPostStatValuesRaw(context, request, cq));
    }
    virtual ::grpc::Status PostStatValuesAggregate(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesAggregateRequest& request, ::clarifai::api::MultiStatValueAggregateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiStatValueAggregateResponse>> AsyncPostStatValuesAggregate(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesAggregateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiStatValueAggregateResponse>>(AsyncPostStatValuesAggregateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiStatValueAggregateResponse>> PrepareAsyncPostStatValuesAggregate(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesAggregateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiStatValueAggregateResponse>>(PrepareAsyncPostStatValuesAggregateRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // //////////////////////////////////////
      // Concept Relationships
      // //////////////////////////////////////
      //
      // List concept relations between concepts in the platform.
      // MUST be above ListConcepts so that if concept_id is empty this will still match
      // /concepts/relations to list all the concept relations in the app.
      virtual void ListConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::ListConceptRelationsRequest* request, ::clarifai::api::MultiConceptRelationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListConceptRelations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptRelationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::ListConceptRelationsRequest* request, ::clarifai::api::MultiConceptRelationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::ListConceptRelationsRequest* request, ::clarifai::api::MultiConceptRelationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListConceptRelations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptRelationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListConceptRelations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptRelationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Post concept relations to create relations between concepts in the platform.
      virtual void PostConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::PostConceptRelationsRequest* request, ::clarifai::api::MultiConceptRelationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostConceptRelations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptRelationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::PostConceptRelationsRequest* request, ::clarifai::api::MultiConceptRelationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::PostConceptRelationsRequest* request, ::clarifai::api::MultiConceptRelationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostConceptRelations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptRelationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostConceptRelations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptRelationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Post concept relations to create relations between concepts in the platform.
      virtual void DeleteConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::DeleteConceptRelationsRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteConceptRelations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::DeleteConceptRelationsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::DeleteConceptRelationsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteConceptRelations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteConceptRelations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // //////////////////////////////////////
      // Concepts
      // //////////////////////////////////////
      //
      // List all the concepts with their positive and negative counts
      virtual void GetConceptCounts(::grpc::ClientContext* context, const ::clarifai::api::GetConceptCountsRequest* request, ::clarifai::api::MultiConceptCountResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetConceptCounts(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptCountResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetConceptCounts(::grpc::ClientContext* context, const ::clarifai::api::GetConceptCountsRequest* request, ::clarifai::api::MultiConceptCountResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetConceptCounts(::grpc::ClientContext* context, const ::clarifai::api::GetConceptCountsRequest* request, ::clarifai::api::MultiConceptCountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetConceptCounts(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptCountResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetConceptCounts(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptCountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get a specific concept from an app.
      virtual void GetConcept(::grpc::ClientContext* context, const ::clarifai::api::GetConceptRequest* request, ::clarifai::api::SingleConceptResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetConcept(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleConceptResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetConcept(::grpc::ClientContext* context, const ::clarifai::api::GetConceptRequest* request, ::clarifai::api::SingleConceptResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetConcept(::grpc::ClientContext* context, const ::clarifai::api::GetConceptRequest* request, ::clarifai::api::SingleConceptResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetConcept(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleConceptResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetConcept(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleConceptResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // List all the concepts.
      virtual void ListConcepts(::grpc::ClientContext* context, const ::clarifai::api::ListConceptsRequest* request, ::clarifai::api::MultiConceptResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListConcepts(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListConcepts(::grpc::ClientContext* context, const ::clarifai::api::ListConceptsRequest* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListConcepts(::grpc::ClientContext* context, const ::clarifai::api::ListConceptsRequest* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListConcepts(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListConcepts(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Search over the concepts to find one or more you're looking for.
      // This leverage the "body" parameter because we also have page and
      // per_page as url query param variables in this request.
      virtual void PostConceptsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsSearchesRequest* request, ::clarifai::api::MultiConceptResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostConceptsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostConceptsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsSearchesRequest* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostConceptsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsSearchesRequest* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostConceptsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostConceptsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Add a concept to an app.
      virtual void PostConcepts(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsRequest* request, ::clarifai::api::MultiConceptResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostConcepts(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostConcepts(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsRequest* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostConcepts(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsRequest* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostConcepts(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostConcepts(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Patch one or more concepts.
      virtual void PatchConcepts(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptsRequest* request, ::clarifai::api::MultiConceptResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PatchConcepts(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PatchConcepts(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptsRequest* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PatchConcepts(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptsRequest* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PatchConcepts(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PatchConcepts(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // //////////////////////////////////////
      //
      // //////////////////////////////////////
      // Concept Languages
      // //////////////////////////////////////
      //
      // Get a specific concept from an app.
      virtual void GetConceptLanguage(::grpc::ClientContext* context, const ::clarifai::api::GetConceptLanguageRequest* request, ::clarifai::api::SingleConceptLanguageResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetConceptLanguage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleConceptLanguageResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetConceptLanguage(::grpc::ClientContext* context, const ::clarifai::api::GetConceptLanguageRequest* request, ::clarifai::api::SingleConceptLanguageResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetConceptLanguage(::grpc::ClientContext* context, const ::clarifai::api::GetConceptLanguageRequest* request, ::clarifai::api::SingleConceptLanguageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetConceptLanguage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleConceptLanguageResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetConceptLanguage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleConceptLanguageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // List the concept in all the translated languages.
      virtual void ListConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::ListConceptLanguagesRequest* request, ::clarifai::api::MultiConceptLanguageResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListConceptLanguages(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptLanguageResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::ListConceptLanguagesRequest* request, ::clarifai::api::MultiConceptLanguageResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::ListConceptLanguagesRequest* request, ::clarifai::api::MultiConceptLanguageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListConceptLanguages(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptLanguageResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListConceptLanguages(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptLanguageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Add a new tranlsation for this concept.
      virtual void PostConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::PostConceptLanguagesRequest* request, ::clarifai::api::MultiConceptLanguageResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostConceptLanguages(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptLanguageResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::PostConceptLanguagesRequest* request, ::clarifai::api::MultiConceptLanguageResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::PostConceptLanguagesRequest* request, ::clarifai::api::MultiConceptLanguageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostConceptLanguages(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptLanguageResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostConceptLanguages(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptLanguageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Patch the name for a given language names by passing in a list of concepts with the new names
      // for the languages.
      virtual void PatchConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptLanguagesRequest* request, ::clarifai::api::MultiConceptLanguageResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PatchConceptLanguages(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptLanguageResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PatchConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptLanguagesRequest* request, ::clarifai::api::MultiConceptLanguageResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PatchConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptLanguagesRequest* request, ::clarifai::api::MultiConceptLanguageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PatchConceptLanguages(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptLanguageResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PatchConceptLanguages(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptLanguageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // //////////////////////////////////////
      // Knowledge Graph
      // //////////////////////////////////////
      //
      // List all domain graphs.
      virtual void ListKnowledgeGraphs(::grpc::ClientContext* context, const ::clarifai::api::ListKnowledgeGraphsRequest* request, ::clarifai::api::MultiKnowledgeGraphResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListKnowledgeGraphs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKnowledgeGraphResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListKnowledgeGraphs(::grpc::ClientContext* context, const ::clarifai::api::ListKnowledgeGraphsRequest* request, ::clarifai::api::MultiKnowledgeGraphResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListKnowledgeGraphs(::grpc::ClientContext* context, const ::clarifai::api::ListKnowledgeGraphsRequest* request, ::clarifai::api::MultiKnowledgeGraphResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListKnowledgeGraphs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKnowledgeGraphResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListKnowledgeGraphs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKnowledgeGraphResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Post domain graphs.
      virtual void PostKnowledgeGraphs(::grpc::ClientContext* context, const ::clarifai::api::PostKnowledgeGraphsRequest* request, ::clarifai::api::MultiKnowledgeGraphResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostKnowledgeGraphs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKnowledgeGraphResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostKnowledgeGraphs(::grpc::ClientContext* context, const ::clarifai::api::PostKnowledgeGraphsRequest* request, ::clarifai::api::MultiKnowledgeGraphResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostKnowledgeGraphs(::grpc::ClientContext* context, const ::clarifai::api::PostKnowledgeGraphsRequest* request, ::clarifai::api::MultiKnowledgeGraphResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostKnowledgeGraphs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKnowledgeGraphResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostKnowledgeGraphs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKnowledgeGraphResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Start concept mapping jobs.
      virtual void PostConceptMappingJobs(::grpc::ClientContext* context, const ::clarifai::api::PostConceptMappingJobsRequest* request, ::clarifai::api::MultiConceptMappingJobResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostConceptMappingJobs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptMappingJobResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostConceptMappingJobs(::grpc::ClientContext* context, const ::clarifai::api::PostConceptMappingJobsRequest* request, ::clarifai::api::MultiConceptMappingJobResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostConceptMappingJobs(::grpc::ClientContext* context, const ::clarifai::api::PostConceptMappingJobsRequest* request, ::clarifai::api::MultiConceptMappingJobResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostConceptMappingJobs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptMappingJobResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostConceptMappingJobs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptMappingJobResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // //////////////////////////////////////
      // annotations
      // //////////////////////////////////////
      //
      // Get a specific annotation from an app.
      virtual void GetAnnotation(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationRequest* request, ::clarifai::api::SingleAnnotationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAnnotation(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleAnnotationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetAnnotation(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationRequest* request, ::clarifai::api::SingleAnnotationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetAnnotation(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationRequest* request, ::clarifai::api::SingleAnnotationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetAnnotation(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleAnnotationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetAnnotation(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleAnnotationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // List all the annotation.
      virtual void ListAnnotations(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationsRequest* request, ::clarifai::api::MultiAnnotationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListAnnotations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListAnnotations(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationsRequest* request, ::clarifai::api::MultiAnnotationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListAnnotations(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationsRequest* request, ::clarifai::api::MultiAnnotationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListAnnotations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListAnnotations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Post annotations.
      virtual void PostAnnotations(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsRequest* request, ::clarifai::api::MultiAnnotationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostAnnotations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostAnnotations(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsRequest* request, ::clarifai::api::MultiAnnotationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostAnnotations(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsRequest* request, ::clarifai::api::MultiAnnotationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostAnnotations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostAnnotations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Patch one or more annotations.
      virtual void PatchAnnotations(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsRequest* request, ::clarifai::api::MultiAnnotationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PatchAnnotations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PatchAnnotations(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsRequest* request, ::clarifai::api::MultiAnnotationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PatchAnnotations(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsRequest* request, ::clarifai::api::MultiAnnotationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PatchAnnotations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PatchAnnotations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Patch annotations status by worker id and task id.
      virtual void PatchAnnotationsStatus(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsStatusRequest* request, ::clarifai::api::PatchAnnotationsStatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PatchAnnotationsStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::PatchAnnotationsStatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PatchAnnotationsStatus(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsStatusRequest* request, ::clarifai::api::PatchAnnotationsStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PatchAnnotationsStatus(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsStatusRequest* request, ::clarifai::api::PatchAnnotationsStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PatchAnnotationsStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::PatchAnnotationsStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PatchAnnotationsStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::PatchAnnotationsStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Delete a single annotation.
      virtual void DeleteAnnotation(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteAnnotation(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteAnnotation(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteAnnotation(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteAnnotation(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteAnnotation(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Delete multiple annotations in one request.
      virtual void DeleteAnnotations(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationsRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteAnnotations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteAnnotations(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteAnnotations(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteAnnotations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteAnnotations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Execute a search over annotation
      virtual void PostAnnotationsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostAnnotationsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostAnnotationsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostAnnotationsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostAnnotationsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostAnnotationsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // //////////////////////////////////////
      // Inputs
      // //////////////////////////////////////
      //
      // Get input count per status.
      virtual void GetInputCount(::grpc::ClientContext* context, const ::clarifai::api::GetInputCountRequest* request, ::clarifai::api::SingleInputCountResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetInputCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleInputCountResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetInputCount(::grpc::ClientContext* context, const ::clarifai::api::GetInputCountRequest* request, ::clarifai::api::SingleInputCountResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetInputCount(::grpc::ClientContext* context, const ::clarifai::api::GetInputCountRequest* request, ::clarifai::api::SingleInputCountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetInputCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleInputCountResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetInputCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleInputCountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Streams all the inputs starting from oldest assets.
      virtual void StreamInputs(::grpc::ClientContext* context, const ::clarifai::api::StreamInputsRequest* request, ::clarifai::api::MultiInputResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StreamInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void StreamInputs(::grpc::ClientContext* context, const ::clarifai::api::StreamInputsRequest* request, ::clarifai::api::MultiInputResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void StreamInputs(::grpc::ClientContext* context, const ::clarifai::api::StreamInputsRequest* request, ::clarifai::api::MultiInputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void StreamInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void StreamInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get a specific input from an app.
      virtual void GetInputSamples(::grpc::ClientContext* context, const ::clarifai::api::GetInputSamplesRequest* request, ::clarifai::api::MultiInputAnnotationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetInputSamples(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputAnnotationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetInputSamples(::grpc::ClientContext* context, const ::clarifai::api::GetInputSamplesRequest* request, ::clarifai::api::MultiInputAnnotationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetInputSamples(::grpc::ClientContext* context, const ::clarifai::api::GetInputSamplesRequest* request, ::clarifai::api::MultiInputAnnotationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetInputSamples(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputAnnotationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetInputSamples(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputAnnotationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get a specific input from an app.
      virtual void GetInput(::grpc::ClientContext* context, const ::clarifai::api::GetInputRequest* request, ::clarifai::api::SingleInputResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetInput(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleInputResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetInput(::grpc::ClientContext* context, const ::clarifai::api::GetInputRequest* request, ::clarifai::api::SingleInputResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetInput(::grpc::ClientContext* context, const ::clarifai::api::GetInputRequest* request, ::clarifai::api::SingleInputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetInput(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleInputResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetInput(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleInputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // List all the inputs.
      virtual void ListInputs(::grpc::ClientContext* context, const ::clarifai::api::ListInputsRequest* request, ::clarifai::api::MultiInputResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListInputs(::grpc::ClientContext* context, const ::clarifai::api::ListInputsRequest* request, ::clarifai::api::MultiInputResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListInputs(::grpc::ClientContext* context, const ::clarifai::api::ListInputsRequest* request, ::clarifai::api::MultiInputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Add an input (or set of inputs) to an app.
      // This call is synchronous if the PostInputsRequest contains exactly one image input. Otherwise,
      // it is asynchronous.
      virtual void PostInputs(::grpc::ClientContext* context, const ::clarifai::api::PostInputsRequest* request, ::clarifai::api::MultiInputResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostInputs(::grpc::ClientContext* context, const ::clarifai::api::PostInputsRequest* request, ::clarifai::api::MultiInputResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostInputs(::grpc::ClientContext* context, const ::clarifai::api::PostInputsRequest* request, ::clarifai::api::MultiInputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Patch one or more inputs.
      virtual void PatchInputs(::grpc::ClientContext* context, const ::clarifai::api::PatchInputsRequest* request, ::clarifai::api::MultiInputResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PatchInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PatchInputs(::grpc::ClientContext* context, const ::clarifai::api::PatchInputsRequest* request, ::clarifai::api::MultiInputResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PatchInputs(::grpc::ClientContext* context, const ::clarifai::api::PatchInputsRequest* request, ::clarifai::api::MultiInputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PatchInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PatchInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Delete a single input.  This call is synchronous.
      virtual void DeleteInput(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteInput(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteInput(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteInput(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteInput(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteInput(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Delete multiple inputs in one request.
      // This call is asynchronous. Use DeleteInput if you want a synchronous version.
      virtual void DeleteInputs(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputsRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteInputs(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteInputs(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Execute a search over input
      virtual void PostInputsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostInputsSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostInputsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostInputsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostInputsSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostInputsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostInputsSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostInputsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostInputsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get predicted outputs from the model.
      virtual void PostModelOutputs(::grpc::ClientContext* context, const ::clarifai::api::PostModelOutputsRequest* request, ::clarifai::api::MultiOutputResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostModelOutputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiOutputResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostModelOutputs(::grpc::ClientContext* context, const ::clarifai::api::PostModelOutputsRequest* request, ::clarifai::api::MultiOutputResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostModelOutputs(::grpc::ClientContext* context, const ::clarifai::api::PostModelOutputsRequest* request, ::clarifai::api::MultiOutputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostModelOutputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiOutputResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostModelOutputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiOutputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // //////////////////////////////////////
      //
      // //////////////////////////////////////
      // Models
      // //////////////////////////////////////
      //
      // Get a specific model type.
      virtual void GetModelType(::grpc::ClientContext* context, const ::clarifai::api::GetModelTypeRequest* request, ::clarifai::api::SingleModelTypeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetModelType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelTypeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetModelType(::grpc::ClientContext* context, const ::clarifai::api::GetModelTypeRequest* request, ::clarifai::api::SingleModelTypeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetModelType(::grpc::ClientContext* context, const ::clarifai::api::GetModelTypeRequest* request, ::clarifai::api::SingleModelTypeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetModelType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelTypeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetModelType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelTypeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // List all the model types available in the platform.
      // This MUST be above ListModels so that the /models/types endpoint takes precedence.
      virtual void ListModelTypes(::grpc::ClientContext* context, const ::clarifai::api::ListModelTypesRequest* request, ::clarifai::api::MultiModelTypeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListModelTypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelTypeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListModelTypes(::grpc::ClientContext* context, const ::clarifai::api::ListModelTypesRequest* request, ::clarifai::api::MultiModelTypeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListModelTypes(::grpc::ClientContext* context, const ::clarifai::api::ListModelTypesRequest* request, ::clarifai::api::MultiModelTypeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListModelTypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelTypeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListModelTypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelTypeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get a specific model from an app.
      virtual void GetModel(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest* request, ::clarifai::api::SingleModelResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetModel(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest* request, ::clarifai::api::SingleModelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetModel(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest* request, ::clarifai::api::SingleModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get a the output info for a given model_id or model_id/version_id
      // combo.
      virtual void GetModelOutputInfo(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest* request, ::clarifai::api::SingleModelResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetModelOutputInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetModelOutputInfo(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest* request, ::clarifai::api::SingleModelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetModelOutputInfo(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest* request, ::clarifai::api::SingleModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetModelOutputInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetModelOutputInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // List all the models.
      virtual void ListModels(::grpc::ClientContext* context, const ::clarifai::api::ListModelsRequest* request, ::clarifai::api::MultiModelResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListModels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListModels(::grpc::ClientContext* context, const ::clarifai::api::ListModelsRequest* request, ::clarifai::api::MultiModelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListModels(::grpc::ClientContext* context, const ::clarifai::api::ListModelsRequest* request, ::clarifai::api::MultiModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListModels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListModels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Search over the models to find one or more you're looking for.
      // This leverage the "body" parameter because we also have page and
      // per_page as url query param variables in this request.
      virtual void PostModelsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostModelsSearchesRequest* request, ::clarifai::api::MultiModelResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostModelsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostModelsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostModelsSearchesRequest* request, ::clarifai::api::MultiModelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostModelsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostModelsSearchesRequest* request, ::clarifai::api::MultiModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostModelsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostModelsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Add a models to an app.
      // FIXME(zeiler): this should have been a plural response.
      virtual void PostModels(::grpc::ClientContext* context, const ::clarifai::api::PostModelsRequest* request, ::clarifai::api::SingleModelResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostModels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostModels(::grpc::ClientContext* context, const ::clarifai::api::PostModelsRequest* request, ::clarifai::api::SingleModelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostModels(::grpc::ClientContext* context, const ::clarifai::api::PostModelsRequest* request, ::clarifai::api::SingleModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostModels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostModels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Patch one or more models.
      virtual void PatchModels(::grpc::ClientContext* context, const ::clarifai::api::PatchModelsRequest* request, ::clarifai::api::MultiModelResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PatchModels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PatchModels(::grpc::ClientContext* context, const ::clarifai::api::PatchModelsRequest* request, ::clarifai::api::MultiModelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PatchModels(::grpc::ClientContext* context, const ::clarifai::api::PatchModelsRequest* request, ::clarifai::api::MultiModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PatchModels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PatchModels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Delete a single model.
      virtual void DeleteModel(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteModel(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteModel(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Delete multiple models in one request.
      virtual void DeleteModels(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelsRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteModels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteModels(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteModels(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteModels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteModels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // List all the inputs.
      virtual void ListModelInputs(::grpc::ClientContext* context, const ::clarifai::api::ListModelInputsRequest* request, ::clarifai::api::MultiInputResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListModelInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListModelInputs(::grpc::ClientContext* context, const ::clarifai::api::ListModelInputsRequest* request, ::clarifai::api::MultiInputResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListModelInputs(::grpc::ClientContext* context, const ::clarifai::api::ListModelInputsRequest* request, ::clarifai::api::MultiInputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListModelInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListModelInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // //////////////////////////////////////
      //
      // //////////////////////////////////////
      // Model versions
      // //////////////////////////////////////
      //
      // Get a specific model from an app.
      virtual void GetModelVersion(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionRequest* request, ::clarifai::api::SingleModelVersionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetModelVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelVersionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetModelVersion(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionRequest* request, ::clarifai::api::SingleModelVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetModelVersion(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionRequest* request, ::clarifai::api::SingleModelVersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetModelVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetModelVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelVersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // List all the models.
      virtual void ListModelVersions(::grpc::ClientContext* context, const ::clarifai::api::ListModelVersionsRequest* request, ::clarifai::api::MultiModelVersionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListModelVersions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelVersionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListModelVersions(::grpc::ClientContext* context, const ::clarifai::api::ListModelVersionsRequest* request, ::clarifai::api::MultiModelVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListModelVersions(::grpc::ClientContext* context, const ::clarifai::api::ListModelVersionsRequest* request, ::clarifai::api::MultiModelVersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListModelVersions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListModelVersions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelVersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // NOTE: inconsistency: do we want this to return a SingleModelResponse?
      //
      // Create a new model version to trigger training of the model.
      // FIXME(zeiler): this should have been a plural response.
      virtual void PostModelVersions(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionsRequest* request, ::clarifai::api::SingleModelResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostModelVersions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostModelVersions(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionsRequest* request, ::clarifai::api::SingleModelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostModelVersions(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionsRequest* request, ::clarifai::api::SingleModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostModelVersions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostModelVersions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Delete a single model.
      virtual void DeleteModelVersion(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelVersionRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteModelVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteModelVersion(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelVersionRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteModelVersion(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelVersionRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteModelVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteModelVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get the evaluation metrics for a model version.
      virtual void GetModelVersionMetrics(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionMetricsRequest* request, ::clarifai::api::SingleModelVersionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetModelVersionMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelVersionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetModelVersionMetrics(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionMetricsRequest* request, ::clarifai::api::SingleModelVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetModelVersionMetrics(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionMetricsRequest* request, ::clarifai::api::SingleModelVersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetModelVersionMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetModelVersionMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelVersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Run the evaluation metrics for a model version.
      virtual void PostModelVersionMetrics(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionMetricsRequest* request, ::clarifai::api::SingleModelVersionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostModelVersionMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelVersionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostModelVersionMetrics(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionMetricsRequest* request, ::clarifai::api::SingleModelVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostModelVersionMetrics(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionMetricsRequest* request, ::clarifai::api::SingleModelVersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostModelVersionMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostModelVersionMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelVersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // //////////////////////////////////////
      //
      // //////////////////////////////////////
      // Workflows
      // //////////////////////////////////////
      //
      // Get a specific workflow from an app.
      virtual void GetWorkflow(::grpc::ClientContext* context, const ::clarifai::api::GetWorkflowRequest* request, ::clarifai::api::SingleWorkflowResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetWorkflow(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleWorkflowResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetWorkflow(::grpc::ClientContext* context, const ::clarifai::api::GetWorkflowRequest* request, ::clarifai::api::SingleWorkflowResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetWorkflow(::grpc::ClientContext* context, const ::clarifai::api::GetWorkflowRequest* request, ::clarifai::api::SingleWorkflowResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetWorkflow(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleWorkflowResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetWorkflow(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleWorkflowResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // List all the workflows.
      virtual void ListWorkflows(::grpc::ClientContext* context, const ::clarifai::api::ListWorkflowsRequest* request, ::clarifai::api::MultiWorkflowResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListWorkflows(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiWorkflowResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListWorkflows(::grpc::ClientContext* context, const ::clarifai::api::ListWorkflowsRequest* request, ::clarifai::api::MultiWorkflowResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListWorkflows(::grpc::ClientContext* context, const ::clarifai::api::ListWorkflowsRequest* request, ::clarifai::api::MultiWorkflowResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListWorkflows(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiWorkflowResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListWorkflows(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiWorkflowResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Add a workflow to an app.
      virtual void PostWorkflows(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowsRequest* request, ::clarifai::api::MultiWorkflowResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostWorkflows(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiWorkflowResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostWorkflows(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowsRequest* request, ::clarifai::api::MultiWorkflowResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostWorkflows(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowsRequest* request, ::clarifai::api::MultiWorkflowResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostWorkflows(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiWorkflowResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostWorkflows(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiWorkflowResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Patch one or more workflows.
      virtual void PatchWorkflows(::grpc::ClientContext* context, const ::clarifai::api::PatchWorkflowsRequest* request, ::clarifai::api::MultiWorkflowResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PatchWorkflows(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiWorkflowResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PatchWorkflows(::grpc::ClientContext* context, const ::clarifai::api::PatchWorkflowsRequest* request, ::clarifai::api::MultiWorkflowResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PatchWorkflows(::grpc::ClientContext* context, const ::clarifai::api::PatchWorkflowsRequest* request, ::clarifai::api::MultiWorkflowResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PatchWorkflows(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiWorkflowResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PatchWorkflows(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiWorkflowResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Delete a single workflow.
      virtual void DeleteWorkflow(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteWorkflow(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteWorkflow(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteWorkflow(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteWorkflow(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteWorkflow(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Delete multiple workflows in one request.
      virtual void DeleteWorkflows(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowsRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteWorkflows(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteWorkflows(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteWorkflows(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteWorkflows(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteWorkflows(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Predict using a workflow.
      virtual void PostWorkflowResults(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsRequest* request, ::clarifai::api::PostWorkflowResultsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostWorkflowResults(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::PostWorkflowResultsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostWorkflowResults(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsRequest* request, ::clarifai::api::PostWorkflowResultsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostWorkflowResults(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsRequest* request, ::clarifai::api::PostWorkflowResultsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostWorkflowResults(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::PostWorkflowResultsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostWorkflowResults(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::PostWorkflowResultsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Compare embeddings distances using a workflow
      //
      virtual void PostWorkflowResultsSimilarity(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsSimilarityRequest* request, ::clarifai::api::PostWorkflowResultsSimilarityResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostWorkflowResultsSimilarity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::PostWorkflowResultsSimilarityResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostWorkflowResultsSimilarity(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsSimilarityRequest* request, ::clarifai::api::PostWorkflowResultsSimilarityResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostWorkflowResultsSimilarity(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsSimilarityRequest* request, ::clarifai::api::PostWorkflowResultsSimilarityResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostWorkflowResultsSimilarity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::PostWorkflowResultsSimilarityResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostWorkflowResultsSimilarity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::PostWorkflowResultsSimilarityResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // //////////////////////////////////////
      // API Keys
      // //////////////////////////////////////
      //
      // Get a specific key from an app.
      virtual void GetKey(::grpc::ClientContext* context, const ::clarifai::api::GetKeyRequest* request, ::clarifai::api::SingleKeyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetKey(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleKeyResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetKey(::grpc::ClientContext* context, const ::clarifai::api::GetKeyRequest* request, ::clarifai::api::SingleKeyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetKey(::grpc::ClientContext* context, const ::clarifai::api::GetKeyRequest* request, ::clarifai::api::SingleKeyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetKey(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleKeyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetKey(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleKeyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // List all the keys.
      virtual void ListKeys(::grpc::ClientContext* context, const ::clarifai::api::ListKeysRequest* request, ::clarifai::api::MultiKeyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListKeys(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKeyResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListKeys(::grpc::ClientContext* context, const ::clarifai::api::ListKeysRequest* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListKeys(::grpc::ClientContext* context, const ::clarifai::api::ListKeysRequest* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListKeys(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListKeys(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // List keys by app_id
      virtual void ListAppKeys(::grpc::ClientContext* context, const ::clarifai::api::ListAppKeysRequest* request, ::clarifai::api::MultiKeyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListAppKeys(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKeyResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListAppKeys(::grpc::ClientContext* context, const ::clarifai::api::ListAppKeysRequest* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListAppKeys(::grpc::ClientContext* context, const ::clarifai::api::ListAppKeysRequest* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListAppKeys(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListAppKeys(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Search over the keys to find one or more you're looking for.
      // This leverage the "body" parameter because we also have page and
      // per_page as url query param variables in this request.
      virtual void DeleteKey(::grpc::ClientContext* context, const ::clarifai::api::DeleteKeyRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteKey(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteKey(::grpc::ClientContext* context, const ::clarifai::api::DeleteKeyRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteKey(::grpc::ClientContext* context, const ::clarifai::api::DeleteKeyRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteKey(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteKey(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Add a key to an app.
      virtual void PostKeys(::grpc::ClientContext* context, const ::clarifai::api::PostKeysRequest* request, ::clarifai::api::MultiKeyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostKeys(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKeyResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostKeys(::grpc::ClientContext* context, const ::clarifai::api::PostKeysRequest* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostKeys(::grpc::ClientContext* context, const ::clarifai::api::PostKeysRequest* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostKeys(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostKeys(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Patch one or more keys.
      virtual void PatchKeys(::grpc::ClientContext* context, const ::clarifai::api::PatchKeysRequest* request, ::clarifai::api::MultiKeyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PatchKeys(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKeyResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PatchKeys(::grpc::ClientContext* context, const ::clarifai::api::PatchKeysRequest* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PatchKeys(::grpc::ClientContext* context, const ::clarifai::api::PatchKeysRequest* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PatchKeys(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PatchKeys(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // API Keys in the public API -- request is itself Key authorized, and will tell
      // the user the scopes/access of the key/credential they're providing, as computed by
      // our authorizer:
      virtual void MyScopes(::grpc::ClientContext* context, const ::clarifai::api::MyScopesRequest* request, ::clarifai::api::MultiScopeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MyScopes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiScopeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MyScopes(::grpc::ClientContext* context, const ::clarifai::api::MyScopesRequest* request, ::clarifai::api::MultiScopeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MyScopes(::grpc::ClientContext* context, const ::clarifai::api::MyScopesRequest* request, ::clarifai::api::MultiScopeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MyScopes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiScopeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MyScopes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiScopeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // List all auth scopes available.
      virtual void ListScopes(::grpc::ClientContext* context, const ::clarifai::api::ListScopesRequest* request, ::clarifai::api::MultiScopeDepsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListScopes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiScopeDepsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListScopes(::grpc::ClientContext* context, const ::clarifai::api::ListScopesRequest* request, ::clarifai::api::MultiScopeDepsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListScopes(::grpc::ClientContext* context, const ::clarifai::api::ListScopesRequest* request, ::clarifai::api::MultiScopeDepsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListScopes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiScopeDepsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListScopes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiScopeDepsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // //////////////////////////////////////
      // Apps
      // //////////////////////////////////////
      //
      // Get a specific app from an app.
      virtual void GetApp(::grpc::ClientContext* context, const ::clarifai::api::GetAppRequest* request, ::clarifai::api::SingleAppResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetApp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleAppResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetApp(::grpc::ClientContext* context, const ::clarifai::api::GetAppRequest* request, ::clarifai::api::SingleAppResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetApp(::grpc::ClientContext* context, const ::clarifai::api::GetAppRequest* request, ::clarifai::api::SingleAppResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetApp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleAppResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetApp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleAppResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // List all the apps.
      virtual void ListApps(::grpc::ClientContext* context, const ::clarifai::api::ListAppsRequest* request, ::clarifai::api::MultiAppResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListApps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListApps(::grpc::ClientContext* context, const ::clarifai::api::ListAppsRequest* request, ::clarifai::api::MultiAppResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListApps(::grpc::ClientContext* context, const ::clarifai::api::ListAppsRequest* request, ::clarifai::api::MultiAppResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListApps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListApps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Search over the apps to find one or more you're looking for.
      // This leverage the "body" parameter because we also have page and
      // per_page as url query param variables in this request.
      virtual void DeleteApp(::grpc::ClientContext* context, const ::clarifai::api::DeleteAppRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteApp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteApp(::grpc::ClientContext* context, const ::clarifai::api::DeleteAppRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteApp(::grpc::ClientContext* context, const ::clarifai::api::DeleteAppRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteApp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteApp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Add a app to an app.
      // This needs to load the default workflow to make a copy, validating all the models in it, and
      // then writing the new workflow back to this new app.
      virtual void PostApps(::grpc::ClientContext* context, const ::clarifai::api::PostAppsRequest* request, ::clarifai::api::MultiAppResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostApps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostApps(::grpc::ClientContext* context, const ::clarifai::api::PostAppsRequest* request, ::clarifai::api::MultiAppResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostApps(::grpc::ClientContext* context, const ::clarifai::api::PostAppsRequest* request, ::clarifai::api::MultiAppResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostApps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostApps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Patch one or more apps.
      virtual void PatchApps(::grpc::ClientContext* context, const ::clarifai::api::PatchAppsRequest* request, ::clarifai::api::MultiAppResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PatchApps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PatchApps(::grpc::ClientContext* context, const ::clarifai::api::PatchAppsRequest* request, ::clarifai::api::MultiAppResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PatchApps(::grpc::ClientContext* context, const ::clarifai::api::PatchAppsRequest* request, ::clarifai::api::MultiAppResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PatchApps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PatchApps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Search over the applications to find one or more you're looking for.
      virtual void PostAppsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostAppsSearchesRequest* request, ::clarifai::api::MultiAppResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostAppsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostAppsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostAppsSearchesRequest* request, ::clarifai::api::MultiAppResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostAppsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostAppsSearchesRequest* request, ::clarifai::api::MultiAppResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostAppsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostAppsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // //////////////////////////////////////
      //
      // //////////////////////////////////////
      // Password
      // //////////////////////////////////////
      //
      // Validate new password in real-time for a user
      virtual void PostValidatePassword(::grpc::ClientContext* context, const ::clarifai::api::PostValidatePasswordRequest* request, ::clarifai::api::SinglePasswordValidationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostValidatePassword(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SinglePasswordValidationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostValidatePassword(::grpc::ClientContext* context, const ::clarifai::api::PostValidatePasswordRequest* request, ::clarifai::api::SinglePasswordValidationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostValidatePassword(::grpc::ClientContext* context, const ::clarifai::api::PostValidatePasswordRequest* request, ::clarifai::api::SinglePasswordValidationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostValidatePassword(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SinglePasswordValidationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostValidatePassword(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SinglePasswordValidationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // //////////////////////////////////////
      // Searches
      // //////////////////////////////////////
      //
      // Get a saved search.
      virtual void GetSearch(::grpc::ClientContext* context, const ::clarifai::api::GetSearchRequest* request, ::clarifai::api::SingleSearchResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleSearchResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetSearch(::grpc::ClientContext* context, const ::clarifai::api::GetSearchRequest* request, ::clarifai::api::SingleSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetSearch(::grpc::ClientContext* context, const ::clarifai::api::GetSearchRequest* request, ::clarifai::api::SingleSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // List all saved searches.
      virtual void ListSearches(::grpc::ClientContext* context, const ::clarifai::api::ListSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListSearches(::grpc::ClientContext* context, const ::clarifai::api::ListSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListSearches(::grpc::ClientContext* context, const ::clarifai::api::ListSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Execute a new search and optionally save it.
      virtual void PostSearches(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostSearches(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostSearches(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Execute a previously saved search.
      virtual void PostSearchesByID(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesByIDRequest* request, ::clarifai::api::MultiSearchResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostSearchesByID(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostSearchesByID(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesByIDRequest* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostSearchesByID(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesByIDRequest* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostSearchesByID(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostSearchesByID(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Evaluate the results of two search requests
      virtual void PostAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationSearchMetricsRequest* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostAnnotationSearchMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationSearchMetricsRequest* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationSearchMetricsRequest* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostAnnotationSearchMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostAnnotationSearchMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get the evaluation results between two search requests
      virtual void GetAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationSearchMetricsRequest* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAnnotationSearchMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationSearchMetricsRequest* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationSearchMetricsRequest* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetAnnotationSearchMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetAnnotationSearchMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // List the evaluation results between two search requests
      virtual void ListAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationSearchMetricsRequest* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListAnnotationSearchMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationSearchMetricsRequest* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationSearchMetricsRequest* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListAnnotationSearchMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListAnnotationSearchMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void DeleteAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationSearchMetricsRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteAnnotationSearchMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationSearchMetricsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationSearchMetricsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteAnnotationSearchMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteAnnotationSearchMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Delete a saved search.
      virtual void DeleteSearch(::grpc::ClientContext* context, const ::clarifai::api::DeleteSearchRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteSearch(::grpc::ClientContext* context, const ::clarifai::api::DeleteSearchRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteSearch(::grpc::ClientContext* context, const ::clarifai::api::DeleteSearchRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // //////////////////////////////////////
      //
      // //////////////////////////////////////
      // Status Codes
      // //////////////////////////////////////
      //
      // List all status codes.
      virtual void ListStatusCodes(::grpc::ClientContext* context, const ::clarifai::api::ListStatusCodesRequest* request, ::clarifai::api::MultiStatusCodeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListStatusCodes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiStatusCodeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListStatusCodes(::grpc::ClientContext* context, const ::clarifai::api::ListStatusCodesRequest* request, ::clarifai::api::MultiStatusCodeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListStatusCodes(::grpc::ClientContext* context, const ::clarifai::api::ListStatusCodesRequest* request, ::clarifai::api::MultiStatusCodeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListStatusCodes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiStatusCodeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListStatusCodes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiStatusCodeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get more details for a status code.
      virtual void GetStatusCode(::grpc::ClientContext* context, const ::clarifai::api::GetStatusCodeRequest* request, ::clarifai::api::SingleStatusCodeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetStatusCode(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleStatusCodeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetStatusCode(::grpc::ClientContext* context, const ::clarifai::api::GetStatusCodeRequest* request, ::clarifai::api::SingleStatusCodeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetStatusCode(::grpc::ClientContext* context, const ::clarifai::api::GetStatusCodeRequest* request, ::clarifai::api::SingleStatusCodeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetStatusCode(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleStatusCodeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetStatusCode(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleStatusCodeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // //////////////////////////////////////
      // App Sharing
      // //////////////////////////////////////
      //
      // owner list users who the app is shared with
      virtual void ListCollaborators(::grpc::ClientContext* context, const ::clarifai::api::ListCollaboratorsRequest* request, ::clarifai::api::MultiCollaboratorsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListCollaborators(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollaboratorsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListCollaborators(::grpc::ClientContext* context, const ::clarifai::api::ListCollaboratorsRequest* request, ::clarifai::api::MultiCollaboratorsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListCollaborators(::grpc::ClientContext* context, const ::clarifai::api::ListCollaboratorsRequest* request, ::clarifai::api::MultiCollaboratorsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListCollaborators(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollaboratorsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListCollaborators(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollaboratorsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // add collaborators to an app.
      virtual void PostCollaborators(::grpc::ClientContext* context, const ::clarifai::api::PostCollaboratorsRequest* request, ::clarifai::api::MultiCollaboratorsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostCollaborators(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollaboratorsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostCollaborators(::grpc::ClientContext* context, const ::clarifai::api::PostCollaboratorsRequest* request, ::clarifai::api::MultiCollaboratorsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostCollaborators(::grpc::ClientContext* context, const ::clarifai::api::PostCollaboratorsRequest* request, ::clarifai::api::MultiCollaboratorsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostCollaborators(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollaboratorsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostCollaborators(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollaboratorsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Patch existing collaborators.
      virtual void PatchCollaborators(::grpc::ClientContext* context, const ::clarifai::api::PatchCollaboratorsRequest* request, ::clarifai::api::MultiCollaboratorsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PatchCollaborators(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollaboratorsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PatchCollaborators(::grpc::ClientContext* context, const ::clarifai::api::PatchCollaboratorsRequest* request, ::clarifai::api::MultiCollaboratorsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PatchCollaborators(::grpc::ClientContext* context, const ::clarifai::api::PatchCollaboratorsRequest* request, ::clarifai::api::MultiCollaboratorsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PatchCollaborators(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollaboratorsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PatchCollaborators(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollaboratorsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Delete existing collaborators.
      virtual void DeleteCollaborators(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollaboratorsRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteCollaborators(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteCollaborators(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollaboratorsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteCollaborators(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollaboratorsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteCollaborators(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteCollaborators(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Collaboration includes the app user are invitied to work on
      virtual void ListCollaborations(::grpc::ClientContext* context, const ::clarifai::api::ListCollaborationsRequest* request, ::clarifai::api::MultiCollaborationsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListCollaborations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollaborationsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListCollaborations(::grpc::ClientContext* context, const ::clarifai::api::ListCollaborationsRequest* request, ::clarifai::api::MultiCollaborationsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListCollaborations(::grpc::ClientContext* context, const ::clarifai::api::ListCollaborationsRequest* request, ::clarifai::api::MultiCollaborationsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListCollaborations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollaborationsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListCollaborations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollaborationsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // //////////////////////////////////////
      // App duplication
      // //////////////////////////////////////
      //
      // start to duplicate an app which copies all the inputs, annotations, models, concepts etc. to a new app.
      // this is an async process, you should use ListAppDuplications or GetAppDuplication to check the status.
      virtual void PostAppDuplications(::grpc::ClientContext* context, const ::clarifai::api::PostAppDuplicationsRequest* request, ::clarifai::api::MultiAppDuplicationsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostAppDuplications(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppDuplicationsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostAppDuplications(::grpc::ClientContext* context, const ::clarifai::api::PostAppDuplicationsRequest* request, ::clarifai::api::MultiAppDuplicationsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostAppDuplications(::grpc::ClientContext* context, const ::clarifai::api::PostAppDuplicationsRequest* request, ::clarifai::api::MultiAppDuplicationsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostAppDuplications(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppDuplicationsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostAppDuplications(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppDuplicationsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // list all the app duplications user triggers
      virtual void ListAppDuplications(::grpc::ClientContext* context, const ::clarifai::api::ListAppDuplicationsRequest* request, ::clarifai::api::MultiAppDuplicationsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListAppDuplications(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppDuplicationsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListAppDuplications(::grpc::ClientContext* context, const ::clarifai::api::ListAppDuplicationsRequest* request, ::clarifai::api::MultiAppDuplicationsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListAppDuplications(::grpc::ClientContext* context, const ::clarifai::api::ListAppDuplicationsRequest* request, ::clarifai::api::MultiAppDuplicationsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListAppDuplications(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppDuplicationsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListAppDuplications(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppDuplicationsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // get the app duplication status
      virtual void GetAppDuplication(::grpc::ClientContext* context, const ::clarifai::api::GetAppDuplicationRequest* request, ::clarifai::api::SingleAppDuplicationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAppDuplication(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleAppDuplicationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetAppDuplication(::grpc::ClientContext* context, const ::clarifai::api::GetAppDuplicationRequest* request, ::clarifai::api::SingleAppDuplicationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetAppDuplication(::grpc::ClientContext* context, const ::clarifai::api::GetAppDuplicationRequest* request, ::clarifai::api::SingleAppDuplicationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetAppDuplication(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleAppDuplicationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetAppDuplication(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleAppDuplicationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // //////////////////////////////////////
      // Tasks
      // //////////////////////////////////////
      //
      // Add tasks to an app.
      virtual void PostTasks(::grpc::ClientContext* context, const ::clarifai::api::PostTasksRequest* request, ::clarifai::api::MultiTaskResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostTasks(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiTaskResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostTasks(::grpc::ClientContext* context, const ::clarifai::api::PostTasksRequest* request, ::clarifai::api::MultiTaskResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostTasks(::grpc::ClientContext* context, const ::clarifai::api::PostTasksRequest* request, ::clarifai::api::MultiTaskResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostTasks(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiTaskResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostTasks(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiTaskResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Task annotation count
      virtual void GetTaskAnnotationCount(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest* request, ::clarifai::api::SingleTaskCountResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTaskAnnotationCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleTaskCountResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetTaskAnnotationCount(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest* request, ::clarifai::api::SingleTaskCountResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetTaskAnnotationCount(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest* request, ::clarifai::api::SingleTaskCountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetTaskAnnotationCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleTaskCountResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetTaskAnnotationCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleTaskCountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Task Input count
      virtual void GetTaskInputCount(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest* request, ::clarifai::api::SingleTaskCountResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTaskInputCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleTaskCountResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetTaskInputCount(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest* request, ::clarifai::api::SingleTaskCountResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetTaskInputCount(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest* request, ::clarifai::api::SingleTaskCountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetTaskInputCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleTaskCountResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetTaskInputCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleTaskCountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get a specific task from an app.
      virtual void GetTask(::grpc::ClientContext* context, const ::clarifai::api::GetTaskRequest* request, ::clarifai::api::SingleTaskResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTask(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleTaskResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetTask(::grpc::ClientContext* context, const ::clarifai::api::GetTaskRequest* request, ::clarifai::api::SingleTaskResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetTask(::grpc::ClientContext* context, const ::clarifai::api::GetTaskRequest* request, ::clarifai::api::SingleTaskResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetTask(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleTaskResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetTask(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleTaskResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // List tasks from an app.
      virtual void ListTasks(::grpc::ClientContext* context, const ::clarifai::api::ListTasksRequest* request, ::clarifai::api::MultiTaskResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListTasks(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiTaskResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListTasks(::grpc::ClientContext* context, const ::clarifai::api::ListTasksRequest* request, ::clarifai::api::MultiTaskResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListTasks(::grpc::ClientContext* context, const ::clarifai::api::ListTasksRequest* request, ::clarifai::api::MultiTaskResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListTasks(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiTaskResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListTasks(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiTaskResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Patch one or more tasks.
      virtual void PatchTasks(::grpc::ClientContext* context, const ::clarifai::api::PatchTasksRequest* request, ::clarifai::api::MultiTaskResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PatchTasks(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiTaskResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PatchTasks(::grpc::ClientContext* context, const ::clarifai::api::PatchTasksRequest* request, ::clarifai::api::MultiTaskResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PatchTasks(::grpc::ClientContext* context, const ::clarifai::api::PatchTasksRequest* request, ::clarifai::api::MultiTaskResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PatchTasks(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiTaskResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PatchTasks(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiTaskResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Delete multiple tasks in one request.
      virtual void DeleteTasks(::grpc::ClientContext* context, const ::clarifai::api::DeleteTasksRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteTasks(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteTasks(::grpc::ClientContext* context, const ::clarifai::api::DeleteTasksRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteTasks(::grpc::ClientContext* context, const ::clarifai::api::DeleteTasksRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteTasks(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteTasks(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // //////////////////////////////////////
      // Collectors
      // //////////////////////////////////////
      //
      // Add a list of Collectors to an app.
      // In the handler of this endpoint we also check for all the scopes of the  POST /inputs
      // endpoint.
      // Those current scopes are listed here as a hard requirement.
      // They are needed when adding the collectors just so we now that you have permission with
      // that key at least to do the writing to this app with POST /inputs.
      virtual void PostCollectors(::grpc::ClientContext* context, const ::clarifai::api::PostCollectorsRequest* request, ::clarifai::api::MultiCollectorResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostCollectors(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollectorResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostCollectors(::grpc::ClientContext* context, const ::clarifai::api::PostCollectorsRequest* request, ::clarifai::api::MultiCollectorResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostCollectors(::grpc::ClientContext* context, const ::clarifai::api::PostCollectorsRequest* request, ::clarifai::api::MultiCollectorResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostCollectors(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollectorResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostCollectors(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollectorResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get a specific collector from an app.
      virtual void GetCollector(::grpc::ClientContext* context, const ::clarifai::api::GetCollectorRequest* request, ::clarifai::api::SingleCollectorResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCollector(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleCollectorResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetCollector(::grpc::ClientContext* context, const ::clarifai::api::GetCollectorRequest* request, ::clarifai::api::SingleCollectorResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetCollector(::grpc::ClientContext* context, const ::clarifai::api::GetCollectorRequest* request, ::clarifai::api::SingleCollectorResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetCollector(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleCollectorResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetCollector(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleCollectorResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // List all the collectors.
      virtual void ListCollectors(::grpc::ClientContext* context, const ::clarifai::api::ListCollectorsRequest* request, ::clarifai::api::MultiCollectorResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListCollectors(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollectorResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListCollectors(::grpc::ClientContext* context, const ::clarifai::api::ListCollectorsRequest* request, ::clarifai::api::MultiCollectorResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListCollectors(::grpc::ClientContext* context, const ::clarifai::api::ListCollectorsRequest* request, ::clarifai::api::MultiCollectorResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListCollectors(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollectorResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListCollectors(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollectorResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Patch one or more collectors.
      virtual void PatchCollectors(::grpc::ClientContext* context, const ::clarifai::api::PatchCollectorsRequest* request, ::clarifai::api::MultiCollectorResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PatchCollectors(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollectorResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PatchCollectors(::grpc::ClientContext* context, const ::clarifai::api::PatchCollectorsRequest* request, ::clarifai::api::MultiCollectorResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PatchCollectors(::grpc::ClientContext* context, const ::clarifai::api::PatchCollectorsRequest* request, ::clarifai::api::MultiCollectorResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PatchCollectors(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollectorResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PatchCollectors(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollectorResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Delete multiple collectors in one request.
      // This call is asynchronous. Use DeleteCollector if you want a synchronous version.
      virtual void DeleteCollectors(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollectorsRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteCollectors(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteCollectors(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollectorsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteCollectors(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollectorsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteCollectors(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteCollectors(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // //////////////////////////////////////////////////////////////////////////////
      // Stats Collection Endpoints.
      // //////////////////////////////////////////////////////////////////////////////
      //
      virtual void PostStatValues(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesRequest* request, ::clarifai::api::MultiStatValueResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostStatValues(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiStatValueResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostStatValues(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesRequest* request, ::clarifai::api::MultiStatValueResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostStatValues(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesRequest* request, ::clarifai::api::MultiStatValueResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostStatValues(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiStatValueResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostStatValues(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiStatValueResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void PostStatValuesAggregate(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesAggregateRequest* request, ::clarifai::api::MultiStatValueAggregateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostStatValuesAggregate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiStatValueAggregateResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostStatValuesAggregate(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesAggregateRequest* request, ::clarifai::api::MultiStatValueAggregateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostStatValuesAggregate(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesAggregateRequest* request, ::clarifai::api::MultiStatValueAggregateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PostStatValuesAggregate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiStatValueAggregateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PostStatValuesAggregate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiStatValueAggregateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptRelationResponse>* AsyncListConceptRelationsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListConceptRelationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptRelationResponse>* PrepareAsyncListConceptRelationsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListConceptRelationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptRelationResponse>* AsyncPostConceptRelationsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostConceptRelationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptRelationResponse>* PrepareAsyncPostConceptRelationsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostConceptRelationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* AsyncDeleteConceptRelationsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteConceptRelationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteConceptRelationsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteConceptRelationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptCountResponse>* AsyncGetConceptCountsRaw(::grpc::ClientContext* context, const ::clarifai::api::GetConceptCountsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptCountResponse>* PrepareAsyncGetConceptCountsRaw(::grpc::ClientContext* context, const ::clarifai::api::GetConceptCountsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleConceptResponse>* AsyncGetConceptRaw(::grpc::ClientContext* context, const ::clarifai::api::GetConceptRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleConceptResponse>* PrepareAsyncGetConceptRaw(::grpc::ClientContext* context, const ::clarifai::api::GetConceptRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptResponse>* AsyncListConceptsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListConceptsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptResponse>* PrepareAsyncListConceptsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListConceptsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptResponse>* AsyncPostConceptsSearchesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsSearchesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptResponse>* PrepareAsyncPostConceptsSearchesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsSearchesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptResponse>* AsyncPostConceptsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptResponse>* PrepareAsyncPostConceptsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptResponse>* AsyncPatchConceptsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptResponse>* PrepareAsyncPatchConceptsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleConceptLanguageResponse>* AsyncGetConceptLanguageRaw(::grpc::ClientContext* context, const ::clarifai::api::GetConceptLanguageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleConceptLanguageResponse>* PrepareAsyncGetConceptLanguageRaw(::grpc::ClientContext* context, const ::clarifai::api::GetConceptLanguageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptLanguageResponse>* AsyncListConceptLanguagesRaw(::grpc::ClientContext* context, const ::clarifai::api::ListConceptLanguagesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptLanguageResponse>* PrepareAsyncListConceptLanguagesRaw(::grpc::ClientContext* context, const ::clarifai::api::ListConceptLanguagesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptLanguageResponse>* AsyncPostConceptLanguagesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostConceptLanguagesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptLanguageResponse>* PrepareAsyncPostConceptLanguagesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostConceptLanguagesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptLanguageResponse>* AsyncPatchConceptLanguagesRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptLanguagesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptLanguageResponse>* PrepareAsyncPatchConceptLanguagesRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptLanguagesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKnowledgeGraphResponse>* AsyncListKnowledgeGraphsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListKnowledgeGraphsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKnowledgeGraphResponse>* PrepareAsyncListKnowledgeGraphsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListKnowledgeGraphsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKnowledgeGraphResponse>* AsyncPostKnowledgeGraphsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostKnowledgeGraphsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKnowledgeGraphResponse>* PrepareAsyncPostKnowledgeGraphsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostKnowledgeGraphsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptMappingJobResponse>* AsyncPostConceptMappingJobsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostConceptMappingJobsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiConceptMappingJobResponse>* PrepareAsyncPostConceptMappingJobsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostConceptMappingJobsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleAnnotationResponse>* AsyncGetAnnotationRaw(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleAnnotationResponse>* PrepareAsyncGetAnnotationRaw(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationResponse>* AsyncListAnnotationsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationResponse>* PrepareAsyncListAnnotationsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationResponse>* AsyncPostAnnotationsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationResponse>* PrepareAsyncPostAnnotationsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationResponse>* AsyncPatchAnnotationsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationResponse>* PrepareAsyncPatchAnnotationsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::PatchAnnotationsStatusResponse>* AsyncPatchAnnotationsStatusRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::PatchAnnotationsStatusResponse>* PrepareAsyncPatchAnnotationsStatusRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* AsyncDeleteAnnotationRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteAnnotationRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* AsyncDeleteAnnotationsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteAnnotationsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>* AsyncPostAnnotationsSearchesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsSearchesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>* PrepareAsyncPostAnnotationsSearchesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsSearchesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleInputCountResponse>* AsyncGetInputCountRaw(::grpc::ClientContext* context, const ::clarifai::api::GetInputCountRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleInputCountResponse>* PrepareAsyncGetInputCountRaw(::grpc::ClientContext* context, const ::clarifai::api::GetInputCountRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>* AsyncStreamInputsRaw(::grpc::ClientContext* context, const ::clarifai::api::StreamInputsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>* PrepareAsyncStreamInputsRaw(::grpc::ClientContext* context, const ::clarifai::api::StreamInputsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputAnnotationResponse>* AsyncGetInputSamplesRaw(::grpc::ClientContext* context, const ::clarifai::api::GetInputSamplesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputAnnotationResponse>* PrepareAsyncGetInputSamplesRaw(::grpc::ClientContext* context, const ::clarifai::api::GetInputSamplesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleInputResponse>* AsyncGetInputRaw(::grpc::ClientContext* context, const ::clarifai::api::GetInputRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleInputResponse>* PrepareAsyncGetInputRaw(::grpc::ClientContext* context, const ::clarifai::api::GetInputRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>* AsyncListInputsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListInputsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>* PrepareAsyncListInputsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListInputsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>* AsyncPostInputsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostInputsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>* PrepareAsyncPostInputsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostInputsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>* AsyncPatchInputsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchInputsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>* PrepareAsyncPatchInputsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchInputsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* AsyncDeleteInputRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteInputRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* AsyncDeleteInputsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteInputsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>* AsyncPostInputsSearchesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostInputsSearchesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>* PrepareAsyncPostInputsSearchesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostInputsSearchesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiOutputResponse>* AsyncPostModelOutputsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostModelOutputsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiOutputResponse>* PrepareAsyncPostModelOutputsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostModelOutputsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelTypeResponse>* AsyncGetModelTypeRaw(::grpc::ClientContext* context, const ::clarifai::api::GetModelTypeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelTypeResponse>* PrepareAsyncGetModelTypeRaw(::grpc::ClientContext* context, const ::clarifai::api::GetModelTypeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelTypeResponse>* AsyncListModelTypesRaw(::grpc::ClientContext* context, const ::clarifai::api::ListModelTypesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelTypeResponse>* PrepareAsyncListModelTypesRaw(::grpc::ClientContext* context, const ::clarifai::api::ListModelTypesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelResponse>* AsyncGetModelRaw(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelResponse>* PrepareAsyncGetModelRaw(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelResponse>* AsyncGetModelOutputInfoRaw(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelResponse>* PrepareAsyncGetModelOutputInfoRaw(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelResponse>* AsyncListModelsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListModelsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelResponse>* PrepareAsyncListModelsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListModelsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelResponse>* AsyncPostModelsSearchesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostModelsSearchesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelResponse>* PrepareAsyncPostModelsSearchesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostModelsSearchesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelResponse>* AsyncPostModelsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostModelsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelResponse>* PrepareAsyncPostModelsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostModelsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelResponse>* AsyncPatchModelsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchModelsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelResponse>* PrepareAsyncPatchModelsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchModelsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* AsyncDeleteModelRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteModelRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* AsyncDeleteModelsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteModelsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>* AsyncListModelInputsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListModelInputsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiInputResponse>* PrepareAsyncListModelInputsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListModelInputsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelVersionResponse>* AsyncGetModelVersionRaw(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelVersionResponse>* PrepareAsyncGetModelVersionRaw(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelVersionResponse>* AsyncListModelVersionsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListModelVersionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiModelVersionResponse>* PrepareAsyncListModelVersionsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListModelVersionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelResponse>* AsyncPostModelVersionsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelResponse>* PrepareAsyncPostModelVersionsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* AsyncDeleteModelVersionRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelVersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteModelVersionRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelVersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelVersionResponse>* AsyncGetModelVersionMetricsRaw(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionMetricsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelVersionResponse>* PrepareAsyncGetModelVersionMetricsRaw(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionMetricsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelVersionResponse>* AsyncPostModelVersionMetricsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionMetricsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleModelVersionResponse>* PrepareAsyncPostModelVersionMetricsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionMetricsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleWorkflowResponse>* AsyncGetWorkflowRaw(::grpc::ClientContext* context, const ::clarifai::api::GetWorkflowRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleWorkflowResponse>* PrepareAsyncGetWorkflowRaw(::grpc::ClientContext* context, const ::clarifai::api::GetWorkflowRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiWorkflowResponse>* AsyncListWorkflowsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListWorkflowsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiWorkflowResponse>* PrepareAsyncListWorkflowsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListWorkflowsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiWorkflowResponse>* AsyncPostWorkflowsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiWorkflowResponse>* PrepareAsyncPostWorkflowsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiWorkflowResponse>* AsyncPatchWorkflowsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchWorkflowsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiWorkflowResponse>* PrepareAsyncPatchWorkflowsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchWorkflowsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* AsyncDeleteWorkflowRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteWorkflowRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* AsyncDeleteWorkflowsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteWorkflowsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::PostWorkflowResultsResponse>* AsyncPostWorkflowResultsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::PostWorkflowResultsResponse>* PrepareAsyncPostWorkflowResultsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::PostWorkflowResultsSimilarityResponse>* AsyncPostWorkflowResultsSimilarityRaw(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsSimilarityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::PostWorkflowResultsSimilarityResponse>* PrepareAsyncPostWorkflowResultsSimilarityRaw(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsSimilarityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleKeyResponse>* AsyncGetKeyRaw(::grpc::ClientContext* context, const ::clarifai::api::GetKeyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleKeyResponse>* PrepareAsyncGetKeyRaw(::grpc::ClientContext* context, const ::clarifai::api::GetKeyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKeyResponse>* AsyncListKeysRaw(::grpc::ClientContext* context, const ::clarifai::api::ListKeysRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKeyResponse>* PrepareAsyncListKeysRaw(::grpc::ClientContext* context, const ::clarifai::api::ListKeysRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKeyResponse>* AsyncListAppKeysRaw(::grpc::ClientContext* context, const ::clarifai::api::ListAppKeysRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKeyResponse>* PrepareAsyncListAppKeysRaw(::grpc::ClientContext* context, const ::clarifai::api::ListAppKeysRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* AsyncDeleteKeyRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteKeyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteKeyRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteKeyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKeyResponse>* AsyncPostKeysRaw(::grpc::ClientContext* context, const ::clarifai::api::PostKeysRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKeyResponse>* PrepareAsyncPostKeysRaw(::grpc::ClientContext* context, const ::clarifai::api::PostKeysRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKeyResponse>* AsyncPatchKeysRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchKeysRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiKeyResponse>* PrepareAsyncPatchKeysRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchKeysRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiScopeResponse>* AsyncMyScopesRaw(::grpc::ClientContext* context, const ::clarifai::api::MyScopesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiScopeResponse>* PrepareAsyncMyScopesRaw(::grpc::ClientContext* context, const ::clarifai::api::MyScopesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiScopeDepsResponse>* AsyncListScopesRaw(::grpc::ClientContext* context, const ::clarifai::api::ListScopesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiScopeDepsResponse>* PrepareAsyncListScopesRaw(::grpc::ClientContext* context, const ::clarifai::api::ListScopesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleAppResponse>* AsyncGetAppRaw(::grpc::ClientContext* context, const ::clarifai::api::GetAppRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleAppResponse>* PrepareAsyncGetAppRaw(::grpc::ClientContext* context, const ::clarifai::api::GetAppRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppResponse>* AsyncListAppsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListAppsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppResponse>* PrepareAsyncListAppsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListAppsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* AsyncDeleteAppRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteAppRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteAppRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteAppRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppResponse>* AsyncPostAppsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostAppsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppResponse>* PrepareAsyncPostAppsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostAppsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppResponse>* AsyncPatchAppsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchAppsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppResponse>* PrepareAsyncPatchAppsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchAppsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppResponse>* AsyncPostAppsSearchesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostAppsSearchesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppResponse>* PrepareAsyncPostAppsSearchesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostAppsSearchesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SinglePasswordValidationResponse>* AsyncPostValidatePasswordRaw(::grpc::ClientContext* context, const ::clarifai::api::PostValidatePasswordRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SinglePasswordValidationResponse>* PrepareAsyncPostValidatePasswordRaw(::grpc::ClientContext* context, const ::clarifai::api::PostValidatePasswordRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleSearchResponse>* AsyncGetSearchRaw(::grpc::ClientContext* context, const ::clarifai::api::GetSearchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleSearchResponse>* PrepareAsyncGetSearchRaw(::grpc::ClientContext* context, const ::clarifai::api::GetSearchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>* AsyncListSearchesRaw(::grpc::ClientContext* context, const ::clarifai::api::ListSearchesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>* PrepareAsyncListSearchesRaw(::grpc::ClientContext* context, const ::clarifai::api::ListSearchesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>* AsyncPostSearchesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>* PrepareAsyncPostSearchesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>* AsyncPostSearchesByIDRaw(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesByIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiSearchResponse>* PrepareAsyncPostSearchesByIDRaw(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesByIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationSearchMetricsResponse>* AsyncPostAnnotationSearchMetricsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationSearchMetricsResponse>* PrepareAsyncPostAnnotationSearchMetricsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationSearchMetricsResponse>* AsyncGetAnnotationSearchMetricsRaw(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationSearchMetricsResponse>* PrepareAsyncGetAnnotationSearchMetricsRaw(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationSearchMetricsResponse>* AsyncListAnnotationSearchMetricsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAnnotationSearchMetricsResponse>* PrepareAsyncListAnnotationSearchMetricsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* AsyncDeleteAnnotationSearchMetricsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteAnnotationSearchMetricsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* AsyncDeleteSearchRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteSearchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteSearchRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteSearchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiStatusCodeResponse>* AsyncListStatusCodesRaw(::grpc::ClientContext* context, const ::clarifai::api::ListStatusCodesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiStatusCodeResponse>* PrepareAsyncListStatusCodesRaw(::grpc::ClientContext* context, const ::clarifai::api::ListStatusCodesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleStatusCodeResponse>* AsyncGetStatusCodeRaw(::grpc::ClientContext* context, const ::clarifai::api::GetStatusCodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleStatusCodeResponse>* PrepareAsyncGetStatusCodeRaw(::grpc::ClientContext* context, const ::clarifai::api::GetStatusCodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollaboratorsResponse>* AsyncListCollaboratorsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollaboratorsResponse>* PrepareAsyncListCollaboratorsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollaboratorsResponse>* AsyncPostCollaboratorsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollaboratorsResponse>* PrepareAsyncPostCollaboratorsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollaboratorsResponse>* AsyncPatchCollaboratorsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollaboratorsResponse>* PrepareAsyncPatchCollaboratorsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* AsyncDeleteCollaboratorsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteCollaboratorsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollaborationsResponse>* AsyncListCollaborationsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListCollaborationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollaborationsResponse>* PrepareAsyncListCollaborationsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListCollaborationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppDuplicationsResponse>* AsyncPostAppDuplicationsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostAppDuplicationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppDuplicationsResponse>* PrepareAsyncPostAppDuplicationsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostAppDuplicationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppDuplicationsResponse>* AsyncListAppDuplicationsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListAppDuplicationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiAppDuplicationsResponse>* PrepareAsyncListAppDuplicationsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListAppDuplicationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleAppDuplicationResponse>* AsyncGetAppDuplicationRaw(::grpc::ClientContext* context, const ::clarifai::api::GetAppDuplicationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleAppDuplicationResponse>* PrepareAsyncGetAppDuplicationRaw(::grpc::ClientContext* context, const ::clarifai::api::GetAppDuplicationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiTaskResponse>* AsyncPostTasksRaw(::grpc::ClientContext* context, const ::clarifai::api::PostTasksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiTaskResponse>* PrepareAsyncPostTasksRaw(::grpc::ClientContext* context, const ::clarifai::api::PostTasksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleTaskCountResponse>* AsyncGetTaskAnnotationCountRaw(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleTaskCountResponse>* PrepareAsyncGetTaskAnnotationCountRaw(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleTaskCountResponse>* AsyncGetTaskInputCountRaw(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleTaskCountResponse>* PrepareAsyncGetTaskInputCountRaw(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleTaskResponse>* AsyncGetTaskRaw(::grpc::ClientContext* context, const ::clarifai::api::GetTaskRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleTaskResponse>* PrepareAsyncGetTaskRaw(::grpc::ClientContext* context, const ::clarifai::api::GetTaskRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiTaskResponse>* AsyncListTasksRaw(::grpc::ClientContext* context, const ::clarifai::api::ListTasksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiTaskResponse>* PrepareAsyncListTasksRaw(::grpc::ClientContext* context, const ::clarifai::api::ListTasksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiTaskResponse>* AsyncPatchTasksRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchTasksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiTaskResponse>* PrepareAsyncPatchTasksRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchTasksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* AsyncDeleteTasksRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteTasksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteTasksRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteTasksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollectorResponse>* AsyncPostCollectorsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostCollectorsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollectorResponse>* PrepareAsyncPostCollectorsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostCollectorsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleCollectorResponse>* AsyncGetCollectorRaw(::grpc::ClientContext* context, const ::clarifai::api::GetCollectorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::SingleCollectorResponse>* PrepareAsyncGetCollectorRaw(::grpc::ClientContext* context, const ::clarifai::api::GetCollectorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollectorResponse>* AsyncListCollectorsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListCollectorsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollectorResponse>* PrepareAsyncListCollectorsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListCollectorsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollectorResponse>* AsyncPatchCollectorsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchCollectorsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiCollectorResponse>* PrepareAsyncPatchCollectorsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchCollectorsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* AsyncDeleteCollectorsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollectorsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteCollectorsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollectorsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiStatValueResponse>* AsyncPostStatValuesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiStatValueResponse>* PrepareAsyncPostStatValuesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiStatValueAggregateResponse>* AsyncPostStatValuesAggregateRaw(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesAggregateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::clarifai::api::MultiStatValueAggregateResponse>* PrepareAsyncPostStatValuesAggregateRaw(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesAggregateRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status ListConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::ListConceptRelationsRequest& request, ::clarifai::api::MultiConceptRelationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptRelationResponse>> AsyncListConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::ListConceptRelationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptRelationResponse>>(AsyncListConceptRelationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptRelationResponse>> PrepareAsyncListConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::ListConceptRelationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptRelationResponse>>(PrepareAsyncListConceptRelationsRaw(context, request, cq));
    }
    ::grpc::Status PostConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::PostConceptRelationsRequest& request, ::clarifai::api::MultiConceptRelationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptRelationResponse>> AsyncPostConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::PostConceptRelationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptRelationResponse>>(AsyncPostConceptRelationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptRelationResponse>> PrepareAsyncPostConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::PostConceptRelationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptRelationResponse>>(PrepareAsyncPostConceptRelationsRaw(context, request, cq));
    }
    ::grpc::Status DeleteConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::DeleteConceptRelationsRequest& request, ::clarifai::api::status::BaseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> AsyncDeleteConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::DeleteConceptRelationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(AsyncDeleteConceptRelationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::DeleteConceptRelationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteConceptRelationsRaw(context, request, cq));
    }
    ::grpc::Status GetConceptCounts(::grpc::ClientContext* context, const ::clarifai::api::GetConceptCountsRequest& request, ::clarifai::api::MultiConceptCountResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptCountResponse>> AsyncGetConceptCounts(::grpc::ClientContext* context, const ::clarifai::api::GetConceptCountsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptCountResponse>>(AsyncGetConceptCountsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptCountResponse>> PrepareAsyncGetConceptCounts(::grpc::ClientContext* context, const ::clarifai::api::GetConceptCountsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptCountResponse>>(PrepareAsyncGetConceptCountsRaw(context, request, cq));
    }
    ::grpc::Status GetConcept(::grpc::ClientContext* context, const ::clarifai::api::GetConceptRequest& request, ::clarifai::api::SingleConceptResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleConceptResponse>> AsyncGetConcept(::grpc::ClientContext* context, const ::clarifai::api::GetConceptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleConceptResponse>>(AsyncGetConceptRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleConceptResponse>> PrepareAsyncGetConcept(::grpc::ClientContext* context, const ::clarifai::api::GetConceptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleConceptResponse>>(PrepareAsyncGetConceptRaw(context, request, cq));
    }
    ::grpc::Status ListConcepts(::grpc::ClientContext* context, const ::clarifai::api::ListConceptsRequest& request, ::clarifai::api::MultiConceptResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptResponse>> AsyncListConcepts(::grpc::ClientContext* context, const ::clarifai::api::ListConceptsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptResponse>>(AsyncListConceptsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptResponse>> PrepareAsyncListConcepts(::grpc::ClientContext* context, const ::clarifai::api::ListConceptsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptResponse>>(PrepareAsyncListConceptsRaw(context, request, cq));
    }
    ::grpc::Status PostConceptsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsSearchesRequest& request, ::clarifai::api::MultiConceptResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptResponse>> AsyncPostConceptsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsSearchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptResponse>>(AsyncPostConceptsSearchesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptResponse>> PrepareAsyncPostConceptsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsSearchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptResponse>>(PrepareAsyncPostConceptsSearchesRaw(context, request, cq));
    }
    ::grpc::Status PostConcepts(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsRequest& request, ::clarifai::api::MultiConceptResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptResponse>> AsyncPostConcepts(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptResponse>>(AsyncPostConceptsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptResponse>> PrepareAsyncPostConcepts(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptResponse>>(PrepareAsyncPostConceptsRaw(context, request, cq));
    }
    ::grpc::Status PatchConcepts(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptsRequest& request, ::clarifai::api::MultiConceptResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptResponse>> AsyncPatchConcepts(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptResponse>>(AsyncPatchConceptsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptResponse>> PrepareAsyncPatchConcepts(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptResponse>>(PrepareAsyncPatchConceptsRaw(context, request, cq));
    }
    ::grpc::Status GetConceptLanguage(::grpc::ClientContext* context, const ::clarifai::api::GetConceptLanguageRequest& request, ::clarifai::api::SingleConceptLanguageResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleConceptLanguageResponse>> AsyncGetConceptLanguage(::grpc::ClientContext* context, const ::clarifai::api::GetConceptLanguageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleConceptLanguageResponse>>(AsyncGetConceptLanguageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleConceptLanguageResponse>> PrepareAsyncGetConceptLanguage(::grpc::ClientContext* context, const ::clarifai::api::GetConceptLanguageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleConceptLanguageResponse>>(PrepareAsyncGetConceptLanguageRaw(context, request, cq));
    }
    ::grpc::Status ListConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::ListConceptLanguagesRequest& request, ::clarifai::api::MultiConceptLanguageResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptLanguageResponse>> AsyncListConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::ListConceptLanguagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptLanguageResponse>>(AsyncListConceptLanguagesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptLanguageResponse>> PrepareAsyncListConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::ListConceptLanguagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptLanguageResponse>>(PrepareAsyncListConceptLanguagesRaw(context, request, cq));
    }
    ::grpc::Status PostConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::PostConceptLanguagesRequest& request, ::clarifai::api::MultiConceptLanguageResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptLanguageResponse>> AsyncPostConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::PostConceptLanguagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptLanguageResponse>>(AsyncPostConceptLanguagesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptLanguageResponse>> PrepareAsyncPostConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::PostConceptLanguagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptLanguageResponse>>(PrepareAsyncPostConceptLanguagesRaw(context, request, cq));
    }
    ::grpc::Status PatchConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptLanguagesRequest& request, ::clarifai::api::MultiConceptLanguageResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptLanguageResponse>> AsyncPatchConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptLanguagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptLanguageResponse>>(AsyncPatchConceptLanguagesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptLanguageResponse>> PrepareAsyncPatchConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptLanguagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptLanguageResponse>>(PrepareAsyncPatchConceptLanguagesRaw(context, request, cq));
    }
    ::grpc::Status ListKnowledgeGraphs(::grpc::ClientContext* context, const ::clarifai::api::ListKnowledgeGraphsRequest& request, ::clarifai::api::MultiKnowledgeGraphResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKnowledgeGraphResponse>> AsyncListKnowledgeGraphs(::grpc::ClientContext* context, const ::clarifai::api::ListKnowledgeGraphsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKnowledgeGraphResponse>>(AsyncListKnowledgeGraphsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKnowledgeGraphResponse>> PrepareAsyncListKnowledgeGraphs(::grpc::ClientContext* context, const ::clarifai::api::ListKnowledgeGraphsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKnowledgeGraphResponse>>(PrepareAsyncListKnowledgeGraphsRaw(context, request, cq));
    }
    ::grpc::Status PostKnowledgeGraphs(::grpc::ClientContext* context, const ::clarifai::api::PostKnowledgeGraphsRequest& request, ::clarifai::api::MultiKnowledgeGraphResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKnowledgeGraphResponse>> AsyncPostKnowledgeGraphs(::grpc::ClientContext* context, const ::clarifai::api::PostKnowledgeGraphsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKnowledgeGraphResponse>>(AsyncPostKnowledgeGraphsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKnowledgeGraphResponse>> PrepareAsyncPostKnowledgeGraphs(::grpc::ClientContext* context, const ::clarifai::api::PostKnowledgeGraphsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKnowledgeGraphResponse>>(PrepareAsyncPostKnowledgeGraphsRaw(context, request, cq));
    }
    ::grpc::Status PostConceptMappingJobs(::grpc::ClientContext* context, const ::clarifai::api::PostConceptMappingJobsRequest& request, ::clarifai::api::MultiConceptMappingJobResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptMappingJobResponse>> AsyncPostConceptMappingJobs(::grpc::ClientContext* context, const ::clarifai::api::PostConceptMappingJobsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptMappingJobResponse>>(AsyncPostConceptMappingJobsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptMappingJobResponse>> PrepareAsyncPostConceptMappingJobs(::grpc::ClientContext* context, const ::clarifai::api::PostConceptMappingJobsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptMappingJobResponse>>(PrepareAsyncPostConceptMappingJobsRaw(context, request, cq));
    }
    ::grpc::Status GetAnnotation(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationRequest& request, ::clarifai::api::SingleAnnotationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleAnnotationResponse>> AsyncGetAnnotation(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleAnnotationResponse>>(AsyncGetAnnotationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleAnnotationResponse>> PrepareAsyncGetAnnotation(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleAnnotationResponse>>(PrepareAsyncGetAnnotationRaw(context, request, cq));
    }
    ::grpc::Status ListAnnotations(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationsRequest& request, ::clarifai::api::MultiAnnotationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationResponse>> AsyncListAnnotations(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationResponse>>(AsyncListAnnotationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationResponse>> PrepareAsyncListAnnotations(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationResponse>>(PrepareAsyncListAnnotationsRaw(context, request, cq));
    }
    ::grpc::Status PostAnnotations(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsRequest& request, ::clarifai::api::MultiAnnotationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationResponse>> AsyncPostAnnotations(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationResponse>>(AsyncPostAnnotationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationResponse>> PrepareAsyncPostAnnotations(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationResponse>>(PrepareAsyncPostAnnotationsRaw(context, request, cq));
    }
    ::grpc::Status PatchAnnotations(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsRequest& request, ::clarifai::api::MultiAnnotationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationResponse>> AsyncPatchAnnotations(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationResponse>>(AsyncPatchAnnotationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationResponse>> PrepareAsyncPatchAnnotations(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationResponse>>(PrepareAsyncPatchAnnotationsRaw(context, request, cq));
    }
    ::grpc::Status PatchAnnotationsStatus(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsStatusRequest& request, ::clarifai::api::PatchAnnotationsStatusResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::PatchAnnotationsStatusResponse>> AsyncPatchAnnotationsStatus(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::PatchAnnotationsStatusResponse>>(AsyncPatchAnnotationsStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::PatchAnnotationsStatusResponse>> PrepareAsyncPatchAnnotationsStatus(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::PatchAnnotationsStatusResponse>>(PrepareAsyncPatchAnnotationsStatusRaw(context, request, cq));
    }
    ::grpc::Status DeleteAnnotation(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationRequest& request, ::clarifai::api::status::BaseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> AsyncDeleteAnnotation(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(AsyncDeleteAnnotationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteAnnotation(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteAnnotationRaw(context, request, cq));
    }
    ::grpc::Status DeleteAnnotations(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationsRequest& request, ::clarifai::api::status::BaseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> AsyncDeleteAnnotations(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(AsyncDeleteAnnotationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteAnnotations(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteAnnotationsRaw(context, request, cq));
    }
    ::grpc::Status PostAnnotationsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsSearchesRequest& request, ::clarifai::api::MultiSearchResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>> AsyncPostAnnotationsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsSearchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>>(AsyncPostAnnotationsSearchesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>> PrepareAsyncPostAnnotationsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsSearchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>>(PrepareAsyncPostAnnotationsSearchesRaw(context, request, cq));
    }
    ::grpc::Status GetInputCount(::grpc::ClientContext* context, const ::clarifai::api::GetInputCountRequest& request, ::clarifai::api::SingleInputCountResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleInputCountResponse>> AsyncGetInputCount(::grpc::ClientContext* context, const ::clarifai::api::GetInputCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleInputCountResponse>>(AsyncGetInputCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleInputCountResponse>> PrepareAsyncGetInputCount(::grpc::ClientContext* context, const ::clarifai::api::GetInputCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleInputCountResponse>>(PrepareAsyncGetInputCountRaw(context, request, cq));
    }
    ::grpc::Status StreamInputs(::grpc::ClientContext* context, const ::clarifai::api::StreamInputsRequest& request, ::clarifai::api::MultiInputResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>> AsyncStreamInputs(::grpc::ClientContext* context, const ::clarifai::api::StreamInputsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>>(AsyncStreamInputsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>> PrepareAsyncStreamInputs(::grpc::ClientContext* context, const ::clarifai::api::StreamInputsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>>(PrepareAsyncStreamInputsRaw(context, request, cq));
    }
    ::grpc::Status GetInputSamples(::grpc::ClientContext* context, const ::clarifai::api::GetInputSamplesRequest& request, ::clarifai::api::MultiInputAnnotationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputAnnotationResponse>> AsyncGetInputSamples(::grpc::ClientContext* context, const ::clarifai::api::GetInputSamplesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputAnnotationResponse>>(AsyncGetInputSamplesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputAnnotationResponse>> PrepareAsyncGetInputSamples(::grpc::ClientContext* context, const ::clarifai::api::GetInputSamplesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputAnnotationResponse>>(PrepareAsyncGetInputSamplesRaw(context, request, cq));
    }
    ::grpc::Status GetInput(::grpc::ClientContext* context, const ::clarifai::api::GetInputRequest& request, ::clarifai::api::SingleInputResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleInputResponse>> AsyncGetInput(::grpc::ClientContext* context, const ::clarifai::api::GetInputRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleInputResponse>>(AsyncGetInputRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleInputResponse>> PrepareAsyncGetInput(::grpc::ClientContext* context, const ::clarifai::api::GetInputRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleInputResponse>>(PrepareAsyncGetInputRaw(context, request, cq));
    }
    ::grpc::Status ListInputs(::grpc::ClientContext* context, const ::clarifai::api::ListInputsRequest& request, ::clarifai::api::MultiInputResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>> AsyncListInputs(::grpc::ClientContext* context, const ::clarifai::api::ListInputsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>>(AsyncListInputsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>> PrepareAsyncListInputs(::grpc::ClientContext* context, const ::clarifai::api::ListInputsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>>(PrepareAsyncListInputsRaw(context, request, cq));
    }
    ::grpc::Status PostInputs(::grpc::ClientContext* context, const ::clarifai::api::PostInputsRequest& request, ::clarifai::api::MultiInputResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>> AsyncPostInputs(::grpc::ClientContext* context, const ::clarifai::api::PostInputsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>>(AsyncPostInputsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>> PrepareAsyncPostInputs(::grpc::ClientContext* context, const ::clarifai::api::PostInputsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>>(PrepareAsyncPostInputsRaw(context, request, cq));
    }
    ::grpc::Status PatchInputs(::grpc::ClientContext* context, const ::clarifai::api::PatchInputsRequest& request, ::clarifai::api::MultiInputResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>> AsyncPatchInputs(::grpc::ClientContext* context, const ::clarifai::api::PatchInputsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>>(AsyncPatchInputsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>> PrepareAsyncPatchInputs(::grpc::ClientContext* context, const ::clarifai::api::PatchInputsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>>(PrepareAsyncPatchInputsRaw(context, request, cq));
    }
    ::grpc::Status DeleteInput(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputRequest& request, ::clarifai::api::status::BaseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> AsyncDeleteInput(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(AsyncDeleteInputRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteInput(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteInputRaw(context, request, cq));
    }
    ::grpc::Status DeleteInputs(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputsRequest& request, ::clarifai::api::status::BaseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> AsyncDeleteInputs(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(AsyncDeleteInputsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteInputs(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteInputsRaw(context, request, cq));
    }
    ::grpc::Status PostInputsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostInputsSearchesRequest& request, ::clarifai::api::MultiSearchResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>> AsyncPostInputsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostInputsSearchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>>(AsyncPostInputsSearchesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>> PrepareAsyncPostInputsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostInputsSearchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>>(PrepareAsyncPostInputsSearchesRaw(context, request, cq));
    }
    ::grpc::Status PostModelOutputs(::grpc::ClientContext* context, const ::clarifai::api::PostModelOutputsRequest& request, ::clarifai::api::MultiOutputResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiOutputResponse>> AsyncPostModelOutputs(::grpc::ClientContext* context, const ::clarifai::api::PostModelOutputsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiOutputResponse>>(AsyncPostModelOutputsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiOutputResponse>> PrepareAsyncPostModelOutputs(::grpc::ClientContext* context, const ::clarifai::api::PostModelOutputsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiOutputResponse>>(PrepareAsyncPostModelOutputsRaw(context, request, cq));
    }
    ::grpc::Status GetModelType(::grpc::ClientContext* context, const ::clarifai::api::GetModelTypeRequest& request, ::clarifai::api::SingleModelTypeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelTypeResponse>> AsyncGetModelType(::grpc::ClientContext* context, const ::clarifai::api::GetModelTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelTypeResponse>>(AsyncGetModelTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelTypeResponse>> PrepareAsyncGetModelType(::grpc::ClientContext* context, const ::clarifai::api::GetModelTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelTypeResponse>>(PrepareAsyncGetModelTypeRaw(context, request, cq));
    }
    ::grpc::Status ListModelTypes(::grpc::ClientContext* context, const ::clarifai::api::ListModelTypesRequest& request, ::clarifai::api::MultiModelTypeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelTypeResponse>> AsyncListModelTypes(::grpc::ClientContext* context, const ::clarifai::api::ListModelTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelTypeResponse>>(AsyncListModelTypesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelTypeResponse>> PrepareAsyncListModelTypes(::grpc::ClientContext* context, const ::clarifai::api::ListModelTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelTypeResponse>>(PrepareAsyncListModelTypesRaw(context, request, cq));
    }
    ::grpc::Status GetModel(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest& request, ::clarifai::api::SingleModelResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelResponse>> AsyncGetModel(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelResponse>>(AsyncGetModelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelResponse>> PrepareAsyncGetModel(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelResponse>>(PrepareAsyncGetModelRaw(context, request, cq));
    }
    ::grpc::Status GetModelOutputInfo(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest& request, ::clarifai::api::SingleModelResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelResponse>> AsyncGetModelOutputInfo(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelResponse>>(AsyncGetModelOutputInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelResponse>> PrepareAsyncGetModelOutputInfo(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelResponse>>(PrepareAsyncGetModelOutputInfoRaw(context, request, cq));
    }
    ::grpc::Status ListModels(::grpc::ClientContext* context, const ::clarifai::api::ListModelsRequest& request, ::clarifai::api::MultiModelResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelResponse>> AsyncListModels(::grpc::ClientContext* context, const ::clarifai::api::ListModelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelResponse>>(AsyncListModelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelResponse>> PrepareAsyncListModels(::grpc::ClientContext* context, const ::clarifai::api::ListModelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelResponse>>(PrepareAsyncListModelsRaw(context, request, cq));
    }
    ::grpc::Status PostModelsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostModelsSearchesRequest& request, ::clarifai::api::MultiModelResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelResponse>> AsyncPostModelsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostModelsSearchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelResponse>>(AsyncPostModelsSearchesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelResponse>> PrepareAsyncPostModelsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostModelsSearchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelResponse>>(PrepareAsyncPostModelsSearchesRaw(context, request, cq));
    }
    ::grpc::Status PostModels(::grpc::ClientContext* context, const ::clarifai::api::PostModelsRequest& request, ::clarifai::api::SingleModelResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelResponse>> AsyncPostModels(::grpc::ClientContext* context, const ::clarifai::api::PostModelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelResponse>>(AsyncPostModelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelResponse>> PrepareAsyncPostModels(::grpc::ClientContext* context, const ::clarifai::api::PostModelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelResponse>>(PrepareAsyncPostModelsRaw(context, request, cq));
    }
    ::grpc::Status PatchModels(::grpc::ClientContext* context, const ::clarifai::api::PatchModelsRequest& request, ::clarifai::api::MultiModelResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelResponse>> AsyncPatchModels(::grpc::ClientContext* context, const ::clarifai::api::PatchModelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelResponse>>(AsyncPatchModelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelResponse>> PrepareAsyncPatchModels(::grpc::ClientContext* context, const ::clarifai::api::PatchModelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelResponse>>(PrepareAsyncPatchModelsRaw(context, request, cq));
    }
    ::grpc::Status DeleteModel(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelRequest& request, ::clarifai::api::status::BaseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> AsyncDeleteModel(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(AsyncDeleteModelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteModel(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteModelRaw(context, request, cq));
    }
    ::grpc::Status DeleteModels(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelsRequest& request, ::clarifai::api::status::BaseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> AsyncDeleteModels(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(AsyncDeleteModelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteModels(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteModelsRaw(context, request, cq));
    }
    ::grpc::Status ListModelInputs(::grpc::ClientContext* context, const ::clarifai::api::ListModelInputsRequest& request, ::clarifai::api::MultiInputResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>> AsyncListModelInputs(::grpc::ClientContext* context, const ::clarifai::api::ListModelInputsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>>(AsyncListModelInputsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>> PrepareAsyncListModelInputs(::grpc::ClientContext* context, const ::clarifai::api::ListModelInputsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>>(PrepareAsyncListModelInputsRaw(context, request, cq));
    }
    ::grpc::Status GetModelVersion(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionRequest& request, ::clarifai::api::SingleModelVersionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelVersionResponse>> AsyncGetModelVersion(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelVersionResponse>>(AsyncGetModelVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelVersionResponse>> PrepareAsyncGetModelVersion(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelVersionResponse>>(PrepareAsyncGetModelVersionRaw(context, request, cq));
    }
    ::grpc::Status ListModelVersions(::grpc::ClientContext* context, const ::clarifai::api::ListModelVersionsRequest& request, ::clarifai::api::MultiModelVersionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelVersionResponse>> AsyncListModelVersions(::grpc::ClientContext* context, const ::clarifai::api::ListModelVersionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelVersionResponse>>(AsyncListModelVersionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelVersionResponse>> PrepareAsyncListModelVersions(::grpc::ClientContext* context, const ::clarifai::api::ListModelVersionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelVersionResponse>>(PrepareAsyncListModelVersionsRaw(context, request, cq));
    }
    ::grpc::Status PostModelVersions(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionsRequest& request, ::clarifai::api::SingleModelResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelResponse>> AsyncPostModelVersions(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelResponse>>(AsyncPostModelVersionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelResponse>> PrepareAsyncPostModelVersions(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelResponse>>(PrepareAsyncPostModelVersionsRaw(context, request, cq));
    }
    ::grpc::Status DeleteModelVersion(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelVersionRequest& request, ::clarifai::api::status::BaseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> AsyncDeleteModelVersion(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(AsyncDeleteModelVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteModelVersion(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteModelVersionRaw(context, request, cq));
    }
    ::grpc::Status GetModelVersionMetrics(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionMetricsRequest& request, ::clarifai::api::SingleModelVersionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelVersionResponse>> AsyncGetModelVersionMetrics(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelVersionResponse>>(AsyncGetModelVersionMetricsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelVersionResponse>> PrepareAsyncGetModelVersionMetrics(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelVersionResponse>>(PrepareAsyncGetModelVersionMetricsRaw(context, request, cq));
    }
    ::grpc::Status PostModelVersionMetrics(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionMetricsRequest& request, ::clarifai::api::SingleModelVersionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelVersionResponse>> AsyncPostModelVersionMetrics(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelVersionResponse>>(AsyncPostModelVersionMetricsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelVersionResponse>> PrepareAsyncPostModelVersionMetrics(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelVersionResponse>>(PrepareAsyncPostModelVersionMetricsRaw(context, request, cq));
    }
    ::grpc::Status GetWorkflow(::grpc::ClientContext* context, const ::clarifai::api::GetWorkflowRequest& request, ::clarifai::api::SingleWorkflowResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleWorkflowResponse>> AsyncGetWorkflow(::grpc::ClientContext* context, const ::clarifai::api::GetWorkflowRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleWorkflowResponse>>(AsyncGetWorkflowRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleWorkflowResponse>> PrepareAsyncGetWorkflow(::grpc::ClientContext* context, const ::clarifai::api::GetWorkflowRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleWorkflowResponse>>(PrepareAsyncGetWorkflowRaw(context, request, cq));
    }
    ::grpc::Status ListWorkflows(::grpc::ClientContext* context, const ::clarifai::api::ListWorkflowsRequest& request, ::clarifai::api::MultiWorkflowResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiWorkflowResponse>> AsyncListWorkflows(::grpc::ClientContext* context, const ::clarifai::api::ListWorkflowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiWorkflowResponse>>(AsyncListWorkflowsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiWorkflowResponse>> PrepareAsyncListWorkflows(::grpc::ClientContext* context, const ::clarifai::api::ListWorkflowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiWorkflowResponse>>(PrepareAsyncListWorkflowsRaw(context, request, cq));
    }
    ::grpc::Status PostWorkflows(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowsRequest& request, ::clarifai::api::MultiWorkflowResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiWorkflowResponse>> AsyncPostWorkflows(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiWorkflowResponse>>(AsyncPostWorkflowsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiWorkflowResponse>> PrepareAsyncPostWorkflows(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiWorkflowResponse>>(PrepareAsyncPostWorkflowsRaw(context, request, cq));
    }
    ::grpc::Status PatchWorkflows(::grpc::ClientContext* context, const ::clarifai::api::PatchWorkflowsRequest& request, ::clarifai::api::MultiWorkflowResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiWorkflowResponse>> AsyncPatchWorkflows(::grpc::ClientContext* context, const ::clarifai::api::PatchWorkflowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiWorkflowResponse>>(AsyncPatchWorkflowsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiWorkflowResponse>> PrepareAsyncPatchWorkflows(::grpc::ClientContext* context, const ::clarifai::api::PatchWorkflowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiWorkflowResponse>>(PrepareAsyncPatchWorkflowsRaw(context, request, cq));
    }
    ::grpc::Status DeleteWorkflow(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowRequest& request, ::clarifai::api::status::BaseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> AsyncDeleteWorkflow(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(AsyncDeleteWorkflowRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteWorkflow(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteWorkflowRaw(context, request, cq));
    }
    ::grpc::Status DeleteWorkflows(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowsRequest& request, ::clarifai::api::status::BaseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> AsyncDeleteWorkflows(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(AsyncDeleteWorkflowsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteWorkflows(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteWorkflowsRaw(context, request, cq));
    }
    ::grpc::Status PostWorkflowResults(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsRequest& request, ::clarifai::api::PostWorkflowResultsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::PostWorkflowResultsResponse>> AsyncPostWorkflowResults(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::PostWorkflowResultsResponse>>(AsyncPostWorkflowResultsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::PostWorkflowResultsResponse>> PrepareAsyncPostWorkflowResults(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::PostWorkflowResultsResponse>>(PrepareAsyncPostWorkflowResultsRaw(context, request, cq));
    }
    ::grpc::Status PostWorkflowResultsSimilarity(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsSimilarityRequest& request, ::clarifai::api::PostWorkflowResultsSimilarityResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::PostWorkflowResultsSimilarityResponse>> AsyncPostWorkflowResultsSimilarity(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsSimilarityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::PostWorkflowResultsSimilarityResponse>>(AsyncPostWorkflowResultsSimilarityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::PostWorkflowResultsSimilarityResponse>> PrepareAsyncPostWorkflowResultsSimilarity(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsSimilarityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::PostWorkflowResultsSimilarityResponse>>(PrepareAsyncPostWorkflowResultsSimilarityRaw(context, request, cq));
    }
    ::grpc::Status GetKey(::grpc::ClientContext* context, const ::clarifai::api::GetKeyRequest& request, ::clarifai::api::SingleKeyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleKeyResponse>> AsyncGetKey(::grpc::ClientContext* context, const ::clarifai::api::GetKeyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleKeyResponse>>(AsyncGetKeyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleKeyResponse>> PrepareAsyncGetKey(::grpc::ClientContext* context, const ::clarifai::api::GetKeyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleKeyResponse>>(PrepareAsyncGetKeyRaw(context, request, cq));
    }
    ::grpc::Status ListKeys(::grpc::ClientContext* context, const ::clarifai::api::ListKeysRequest& request, ::clarifai::api::MultiKeyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKeyResponse>> AsyncListKeys(::grpc::ClientContext* context, const ::clarifai::api::ListKeysRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKeyResponse>>(AsyncListKeysRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKeyResponse>> PrepareAsyncListKeys(::grpc::ClientContext* context, const ::clarifai::api::ListKeysRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKeyResponse>>(PrepareAsyncListKeysRaw(context, request, cq));
    }
    ::grpc::Status ListAppKeys(::grpc::ClientContext* context, const ::clarifai::api::ListAppKeysRequest& request, ::clarifai::api::MultiKeyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKeyResponse>> AsyncListAppKeys(::grpc::ClientContext* context, const ::clarifai::api::ListAppKeysRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKeyResponse>>(AsyncListAppKeysRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKeyResponse>> PrepareAsyncListAppKeys(::grpc::ClientContext* context, const ::clarifai::api::ListAppKeysRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKeyResponse>>(PrepareAsyncListAppKeysRaw(context, request, cq));
    }
    ::grpc::Status DeleteKey(::grpc::ClientContext* context, const ::clarifai::api::DeleteKeyRequest& request, ::clarifai::api::status::BaseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> AsyncDeleteKey(::grpc::ClientContext* context, const ::clarifai::api::DeleteKeyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(AsyncDeleteKeyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteKey(::grpc::ClientContext* context, const ::clarifai::api::DeleteKeyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteKeyRaw(context, request, cq));
    }
    ::grpc::Status PostKeys(::grpc::ClientContext* context, const ::clarifai::api::PostKeysRequest& request, ::clarifai::api::MultiKeyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKeyResponse>> AsyncPostKeys(::grpc::ClientContext* context, const ::clarifai::api::PostKeysRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKeyResponse>>(AsyncPostKeysRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKeyResponse>> PrepareAsyncPostKeys(::grpc::ClientContext* context, const ::clarifai::api::PostKeysRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKeyResponse>>(PrepareAsyncPostKeysRaw(context, request, cq));
    }
    ::grpc::Status PatchKeys(::grpc::ClientContext* context, const ::clarifai::api::PatchKeysRequest& request, ::clarifai::api::MultiKeyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKeyResponse>> AsyncPatchKeys(::grpc::ClientContext* context, const ::clarifai::api::PatchKeysRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKeyResponse>>(AsyncPatchKeysRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKeyResponse>> PrepareAsyncPatchKeys(::grpc::ClientContext* context, const ::clarifai::api::PatchKeysRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKeyResponse>>(PrepareAsyncPatchKeysRaw(context, request, cq));
    }
    ::grpc::Status MyScopes(::grpc::ClientContext* context, const ::clarifai::api::MyScopesRequest& request, ::clarifai::api::MultiScopeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiScopeResponse>> AsyncMyScopes(::grpc::ClientContext* context, const ::clarifai::api::MyScopesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiScopeResponse>>(AsyncMyScopesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiScopeResponse>> PrepareAsyncMyScopes(::grpc::ClientContext* context, const ::clarifai::api::MyScopesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiScopeResponse>>(PrepareAsyncMyScopesRaw(context, request, cq));
    }
    ::grpc::Status ListScopes(::grpc::ClientContext* context, const ::clarifai::api::ListScopesRequest& request, ::clarifai::api::MultiScopeDepsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiScopeDepsResponse>> AsyncListScopes(::grpc::ClientContext* context, const ::clarifai::api::ListScopesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiScopeDepsResponse>>(AsyncListScopesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiScopeDepsResponse>> PrepareAsyncListScopes(::grpc::ClientContext* context, const ::clarifai::api::ListScopesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiScopeDepsResponse>>(PrepareAsyncListScopesRaw(context, request, cq));
    }
    ::grpc::Status GetApp(::grpc::ClientContext* context, const ::clarifai::api::GetAppRequest& request, ::clarifai::api::SingleAppResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleAppResponse>> AsyncGetApp(::grpc::ClientContext* context, const ::clarifai::api::GetAppRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleAppResponse>>(AsyncGetAppRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleAppResponse>> PrepareAsyncGetApp(::grpc::ClientContext* context, const ::clarifai::api::GetAppRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleAppResponse>>(PrepareAsyncGetAppRaw(context, request, cq));
    }
    ::grpc::Status ListApps(::grpc::ClientContext* context, const ::clarifai::api::ListAppsRequest& request, ::clarifai::api::MultiAppResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppResponse>> AsyncListApps(::grpc::ClientContext* context, const ::clarifai::api::ListAppsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppResponse>>(AsyncListAppsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppResponse>> PrepareAsyncListApps(::grpc::ClientContext* context, const ::clarifai::api::ListAppsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppResponse>>(PrepareAsyncListAppsRaw(context, request, cq));
    }
    ::grpc::Status DeleteApp(::grpc::ClientContext* context, const ::clarifai::api::DeleteAppRequest& request, ::clarifai::api::status::BaseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> AsyncDeleteApp(::grpc::ClientContext* context, const ::clarifai::api::DeleteAppRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(AsyncDeleteAppRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteApp(::grpc::ClientContext* context, const ::clarifai::api::DeleteAppRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteAppRaw(context, request, cq));
    }
    ::grpc::Status PostApps(::grpc::ClientContext* context, const ::clarifai::api::PostAppsRequest& request, ::clarifai::api::MultiAppResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppResponse>> AsyncPostApps(::grpc::ClientContext* context, const ::clarifai::api::PostAppsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppResponse>>(AsyncPostAppsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppResponse>> PrepareAsyncPostApps(::grpc::ClientContext* context, const ::clarifai::api::PostAppsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppResponse>>(PrepareAsyncPostAppsRaw(context, request, cq));
    }
    ::grpc::Status PatchApps(::grpc::ClientContext* context, const ::clarifai::api::PatchAppsRequest& request, ::clarifai::api::MultiAppResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppResponse>> AsyncPatchApps(::grpc::ClientContext* context, const ::clarifai::api::PatchAppsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppResponse>>(AsyncPatchAppsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppResponse>> PrepareAsyncPatchApps(::grpc::ClientContext* context, const ::clarifai::api::PatchAppsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppResponse>>(PrepareAsyncPatchAppsRaw(context, request, cq));
    }
    ::grpc::Status PostAppsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostAppsSearchesRequest& request, ::clarifai::api::MultiAppResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppResponse>> AsyncPostAppsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostAppsSearchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppResponse>>(AsyncPostAppsSearchesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppResponse>> PrepareAsyncPostAppsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostAppsSearchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppResponse>>(PrepareAsyncPostAppsSearchesRaw(context, request, cq));
    }
    ::grpc::Status PostValidatePassword(::grpc::ClientContext* context, const ::clarifai::api::PostValidatePasswordRequest& request, ::clarifai::api::SinglePasswordValidationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SinglePasswordValidationResponse>> AsyncPostValidatePassword(::grpc::ClientContext* context, const ::clarifai::api::PostValidatePasswordRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SinglePasswordValidationResponse>>(AsyncPostValidatePasswordRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SinglePasswordValidationResponse>> PrepareAsyncPostValidatePassword(::grpc::ClientContext* context, const ::clarifai::api::PostValidatePasswordRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SinglePasswordValidationResponse>>(PrepareAsyncPostValidatePasswordRaw(context, request, cq));
    }
    ::grpc::Status GetSearch(::grpc::ClientContext* context, const ::clarifai::api::GetSearchRequest& request, ::clarifai::api::SingleSearchResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleSearchResponse>> AsyncGetSearch(::grpc::ClientContext* context, const ::clarifai::api::GetSearchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleSearchResponse>>(AsyncGetSearchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleSearchResponse>> PrepareAsyncGetSearch(::grpc::ClientContext* context, const ::clarifai::api::GetSearchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleSearchResponse>>(PrepareAsyncGetSearchRaw(context, request, cq));
    }
    ::grpc::Status ListSearches(::grpc::ClientContext* context, const ::clarifai::api::ListSearchesRequest& request, ::clarifai::api::MultiSearchResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>> AsyncListSearches(::grpc::ClientContext* context, const ::clarifai::api::ListSearchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>>(AsyncListSearchesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>> PrepareAsyncListSearches(::grpc::ClientContext* context, const ::clarifai::api::ListSearchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>>(PrepareAsyncListSearchesRaw(context, request, cq));
    }
    ::grpc::Status PostSearches(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesRequest& request, ::clarifai::api::MultiSearchResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>> AsyncPostSearches(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>>(AsyncPostSearchesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>> PrepareAsyncPostSearches(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>>(PrepareAsyncPostSearchesRaw(context, request, cq));
    }
    ::grpc::Status PostSearchesByID(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesByIDRequest& request, ::clarifai::api::MultiSearchResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>> AsyncPostSearchesByID(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>>(AsyncPostSearchesByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>> PrepareAsyncPostSearchesByID(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>>(PrepareAsyncPostSearchesByIDRaw(context, request, cq));
    }
    ::grpc::Status PostAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationSearchMetricsRequest& request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationSearchMetricsResponse>> AsyncPostAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationSearchMetricsResponse>>(AsyncPostAnnotationSearchMetricsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationSearchMetricsResponse>> PrepareAsyncPostAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationSearchMetricsResponse>>(PrepareAsyncPostAnnotationSearchMetricsRaw(context, request, cq));
    }
    ::grpc::Status GetAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationSearchMetricsRequest& request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationSearchMetricsResponse>> AsyncGetAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationSearchMetricsResponse>>(AsyncGetAnnotationSearchMetricsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationSearchMetricsResponse>> PrepareAsyncGetAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationSearchMetricsResponse>>(PrepareAsyncGetAnnotationSearchMetricsRaw(context, request, cq));
    }
    ::grpc::Status ListAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationSearchMetricsRequest& request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationSearchMetricsResponse>> AsyncListAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationSearchMetricsResponse>>(AsyncListAnnotationSearchMetricsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationSearchMetricsResponse>> PrepareAsyncListAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationSearchMetricsResponse>>(PrepareAsyncListAnnotationSearchMetricsRaw(context, request, cq));
    }
    ::grpc::Status DeleteAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationSearchMetricsRequest& request, ::clarifai::api::status::BaseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> AsyncDeleteAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(AsyncDeleteAnnotationSearchMetricsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteAnnotationSearchMetricsRaw(context, request, cq));
    }
    ::grpc::Status DeleteSearch(::grpc::ClientContext* context, const ::clarifai::api::DeleteSearchRequest& request, ::clarifai::api::status::BaseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> AsyncDeleteSearch(::grpc::ClientContext* context, const ::clarifai::api::DeleteSearchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(AsyncDeleteSearchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteSearch(::grpc::ClientContext* context, const ::clarifai::api::DeleteSearchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteSearchRaw(context, request, cq));
    }
    ::grpc::Status ListStatusCodes(::grpc::ClientContext* context, const ::clarifai::api::ListStatusCodesRequest& request, ::clarifai::api::MultiStatusCodeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiStatusCodeResponse>> AsyncListStatusCodes(::grpc::ClientContext* context, const ::clarifai::api::ListStatusCodesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiStatusCodeResponse>>(AsyncListStatusCodesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiStatusCodeResponse>> PrepareAsyncListStatusCodes(::grpc::ClientContext* context, const ::clarifai::api::ListStatusCodesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiStatusCodeResponse>>(PrepareAsyncListStatusCodesRaw(context, request, cq));
    }
    ::grpc::Status GetStatusCode(::grpc::ClientContext* context, const ::clarifai::api::GetStatusCodeRequest& request, ::clarifai::api::SingleStatusCodeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleStatusCodeResponse>> AsyncGetStatusCode(::grpc::ClientContext* context, const ::clarifai::api::GetStatusCodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleStatusCodeResponse>>(AsyncGetStatusCodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleStatusCodeResponse>> PrepareAsyncGetStatusCode(::grpc::ClientContext* context, const ::clarifai::api::GetStatusCodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleStatusCodeResponse>>(PrepareAsyncGetStatusCodeRaw(context, request, cq));
    }
    ::grpc::Status ListCollaborators(::grpc::ClientContext* context, const ::clarifai::api::ListCollaboratorsRequest& request, ::clarifai::api::MultiCollaboratorsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollaboratorsResponse>> AsyncListCollaborators(::grpc::ClientContext* context, const ::clarifai::api::ListCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollaboratorsResponse>>(AsyncListCollaboratorsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollaboratorsResponse>> PrepareAsyncListCollaborators(::grpc::ClientContext* context, const ::clarifai::api::ListCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollaboratorsResponse>>(PrepareAsyncListCollaboratorsRaw(context, request, cq));
    }
    ::grpc::Status PostCollaborators(::grpc::ClientContext* context, const ::clarifai::api::PostCollaboratorsRequest& request, ::clarifai::api::MultiCollaboratorsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollaboratorsResponse>> AsyncPostCollaborators(::grpc::ClientContext* context, const ::clarifai::api::PostCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollaboratorsResponse>>(AsyncPostCollaboratorsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollaboratorsResponse>> PrepareAsyncPostCollaborators(::grpc::ClientContext* context, const ::clarifai::api::PostCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollaboratorsResponse>>(PrepareAsyncPostCollaboratorsRaw(context, request, cq));
    }
    ::grpc::Status PatchCollaborators(::grpc::ClientContext* context, const ::clarifai::api::PatchCollaboratorsRequest& request, ::clarifai::api::MultiCollaboratorsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollaboratorsResponse>> AsyncPatchCollaborators(::grpc::ClientContext* context, const ::clarifai::api::PatchCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollaboratorsResponse>>(AsyncPatchCollaboratorsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollaboratorsResponse>> PrepareAsyncPatchCollaborators(::grpc::ClientContext* context, const ::clarifai::api::PatchCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollaboratorsResponse>>(PrepareAsyncPatchCollaboratorsRaw(context, request, cq));
    }
    ::grpc::Status DeleteCollaborators(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollaboratorsRequest& request, ::clarifai::api::status::BaseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> AsyncDeleteCollaborators(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(AsyncDeleteCollaboratorsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteCollaborators(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteCollaboratorsRaw(context, request, cq));
    }
    ::grpc::Status ListCollaborations(::grpc::ClientContext* context, const ::clarifai::api::ListCollaborationsRequest& request, ::clarifai::api::MultiCollaborationsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollaborationsResponse>> AsyncListCollaborations(::grpc::ClientContext* context, const ::clarifai::api::ListCollaborationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollaborationsResponse>>(AsyncListCollaborationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollaborationsResponse>> PrepareAsyncListCollaborations(::grpc::ClientContext* context, const ::clarifai::api::ListCollaborationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollaborationsResponse>>(PrepareAsyncListCollaborationsRaw(context, request, cq));
    }
    ::grpc::Status PostAppDuplications(::grpc::ClientContext* context, const ::clarifai::api::PostAppDuplicationsRequest& request, ::clarifai::api::MultiAppDuplicationsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppDuplicationsResponse>> AsyncPostAppDuplications(::grpc::ClientContext* context, const ::clarifai::api::PostAppDuplicationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppDuplicationsResponse>>(AsyncPostAppDuplicationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppDuplicationsResponse>> PrepareAsyncPostAppDuplications(::grpc::ClientContext* context, const ::clarifai::api::PostAppDuplicationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppDuplicationsResponse>>(PrepareAsyncPostAppDuplicationsRaw(context, request, cq));
    }
    ::grpc::Status ListAppDuplications(::grpc::ClientContext* context, const ::clarifai::api::ListAppDuplicationsRequest& request, ::clarifai::api::MultiAppDuplicationsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppDuplicationsResponse>> AsyncListAppDuplications(::grpc::ClientContext* context, const ::clarifai::api::ListAppDuplicationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppDuplicationsResponse>>(AsyncListAppDuplicationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppDuplicationsResponse>> PrepareAsyncListAppDuplications(::grpc::ClientContext* context, const ::clarifai::api::ListAppDuplicationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppDuplicationsResponse>>(PrepareAsyncListAppDuplicationsRaw(context, request, cq));
    }
    ::grpc::Status GetAppDuplication(::grpc::ClientContext* context, const ::clarifai::api::GetAppDuplicationRequest& request, ::clarifai::api::SingleAppDuplicationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleAppDuplicationResponse>> AsyncGetAppDuplication(::grpc::ClientContext* context, const ::clarifai::api::GetAppDuplicationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleAppDuplicationResponse>>(AsyncGetAppDuplicationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleAppDuplicationResponse>> PrepareAsyncGetAppDuplication(::grpc::ClientContext* context, const ::clarifai::api::GetAppDuplicationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleAppDuplicationResponse>>(PrepareAsyncGetAppDuplicationRaw(context, request, cq));
    }
    ::grpc::Status PostTasks(::grpc::ClientContext* context, const ::clarifai::api::PostTasksRequest& request, ::clarifai::api::MultiTaskResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiTaskResponse>> AsyncPostTasks(::grpc::ClientContext* context, const ::clarifai::api::PostTasksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiTaskResponse>>(AsyncPostTasksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiTaskResponse>> PrepareAsyncPostTasks(::grpc::ClientContext* context, const ::clarifai::api::PostTasksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiTaskResponse>>(PrepareAsyncPostTasksRaw(context, request, cq));
    }
    ::grpc::Status GetTaskAnnotationCount(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest& request, ::clarifai::api::SingleTaskCountResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleTaskCountResponse>> AsyncGetTaskAnnotationCount(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleTaskCountResponse>>(AsyncGetTaskAnnotationCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleTaskCountResponse>> PrepareAsyncGetTaskAnnotationCount(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleTaskCountResponse>>(PrepareAsyncGetTaskAnnotationCountRaw(context, request, cq));
    }
    ::grpc::Status GetTaskInputCount(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest& request, ::clarifai::api::SingleTaskCountResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleTaskCountResponse>> AsyncGetTaskInputCount(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleTaskCountResponse>>(AsyncGetTaskInputCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleTaskCountResponse>> PrepareAsyncGetTaskInputCount(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleTaskCountResponse>>(PrepareAsyncGetTaskInputCountRaw(context, request, cq));
    }
    ::grpc::Status GetTask(::grpc::ClientContext* context, const ::clarifai::api::GetTaskRequest& request, ::clarifai::api::SingleTaskResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleTaskResponse>> AsyncGetTask(::grpc::ClientContext* context, const ::clarifai::api::GetTaskRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleTaskResponse>>(AsyncGetTaskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleTaskResponse>> PrepareAsyncGetTask(::grpc::ClientContext* context, const ::clarifai::api::GetTaskRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleTaskResponse>>(PrepareAsyncGetTaskRaw(context, request, cq));
    }
    ::grpc::Status ListTasks(::grpc::ClientContext* context, const ::clarifai::api::ListTasksRequest& request, ::clarifai::api::MultiTaskResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiTaskResponse>> AsyncListTasks(::grpc::ClientContext* context, const ::clarifai::api::ListTasksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiTaskResponse>>(AsyncListTasksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiTaskResponse>> PrepareAsyncListTasks(::grpc::ClientContext* context, const ::clarifai::api::ListTasksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiTaskResponse>>(PrepareAsyncListTasksRaw(context, request, cq));
    }
    ::grpc::Status PatchTasks(::grpc::ClientContext* context, const ::clarifai::api::PatchTasksRequest& request, ::clarifai::api::MultiTaskResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiTaskResponse>> AsyncPatchTasks(::grpc::ClientContext* context, const ::clarifai::api::PatchTasksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiTaskResponse>>(AsyncPatchTasksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiTaskResponse>> PrepareAsyncPatchTasks(::grpc::ClientContext* context, const ::clarifai::api::PatchTasksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiTaskResponse>>(PrepareAsyncPatchTasksRaw(context, request, cq));
    }
    ::grpc::Status DeleteTasks(::grpc::ClientContext* context, const ::clarifai::api::DeleteTasksRequest& request, ::clarifai::api::status::BaseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> AsyncDeleteTasks(::grpc::ClientContext* context, const ::clarifai::api::DeleteTasksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(AsyncDeleteTasksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteTasks(::grpc::ClientContext* context, const ::clarifai::api::DeleteTasksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteTasksRaw(context, request, cq));
    }
    ::grpc::Status PostCollectors(::grpc::ClientContext* context, const ::clarifai::api::PostCollectorsRequest& request, ::clarifai::api::MultiCollectorResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollectorResponse>> AsyncPostCollectors(::grpc::ClientContext* context, const ::clarifai::api::PostCollectorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollectorResponse>>(AsyncPostCollectorsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollectorResponse>> PrepareAsyncPostCollectors(::grpc::ClientContext* context, const ::clarifai::api::PostCollectorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollectorResponse>>(PrepareAsyncPostCollectorsRaw(context, request, cq));
    }
    ::grpc::Status GetCollector(::grpc::ClientContext* context, const ::clarifai::api::GetCollectorRequest& request, ::clarifai::api::SingleCollectorResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleCollectorResponse>> AsyncGetCollector(::grpc::ClientContext* context, const ::clarifai::api::GetCollectorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleCollectorResponse>>(AsyncGetCollectorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleCollectorResponse>> PrepareAsyncGetCollector(::grpc::ClientContext* context, const ::clarifai::api::GetCollectorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleCollectorResponse>>(PrepareAsyncGetCollectorRaw(context, request, cq));
    }
    ::grpc::Status ListCollectors(::grpc::ClientContext* context, const ::clarifai::api::ListCollectorsRequest& request, ::clarifai::api::MultiCollectorResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollectorResponse>> AsyncListCollectors(::grpc::ClientContext* context, const ::clarifai::api::ListCollectorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollectorResponse>>(AsyncListCollectorsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollectorResponse>> PrepareAsyncListCollectors(::grpc::ClientContext* context, const ::clarifai::api::ListCollectorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollectorResponse>>(PrepareAsyncListCollectorsRaw(context, request, cq));
    }
    ::grpc::Status PatchCollectors(::grpc::ClientContext* context, const ::clarifai::api::PatchCollectorsRequest& request, ::clarifai::api::MultiCollectorResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollectorResponse>> AsyncPatchCollectors(::grpc::ClientContext* context, const ::clarifai::api::PatchCollectorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollectorResponse>>(AsyncPatchCollectorsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollectorResponse>> PrepareAsyncPatchCollectors(::grpc::ClientContext* context, const ::clarifai::api::PatchCollectorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollectorResponse>>(PrepareAsyncPatchCollectorsRaw(context, request, cq));
    }
    ::grpc::Status DeleteCollectors(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollectorsRequest& request, ::clarifai::api::status::BaseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> AsyncDeleteCollectors(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollectorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(AsyncDeleteCollectorsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>> PrepareAsyncDeleteCollectors(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollectorsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>>(PrepareAsyncDeleteCollectorsRaw(context, request, cq));
    }
    ::grpc::Status PostStatValues(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesRequest& request, ::clarifai::api::MultiStatValueResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiStatValueResponse>> AsyncPostStatValues(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiStatValueResponse>>(AsyncPostStatValuesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiStatValueResponse>> PrepareAsyncPostStatValues(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiStatValueResponse>>(PrepareAsyncPostStatValuesRaw(context, request, cq));
    }
    ::grpc::Status PostStatValuesAggregate(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesAggregateRequest& request, ::clarifai::api::MultiStatValueAggregateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiStatValueAggregateResponse>> AsyncPostStatValuesAggregate(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesAggregateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiStatValueAggregateResponse>>(AsyncPostStatValuesAggregateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiStatValueAggregateResponse>> PrepareAsyncPostStatValuesAggregate(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesAggregateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiStatValueAggregateResponse>>(PrepareAsyncPostStatValuesAggregateRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void ListConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::ListConceptRelationsRequest* request, ::clarifai::api::MultiConceptRelationResponse* response, std::function<void(::grpc::Status)>) override;
      void ListConceptRelations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptRelationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::ListConceptRelationsRequest* request, ::clarifai::api::MultiConceptRelationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::ListConceptRelationsRequest* request, ::clarifai::api::MultiConceptRelationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListConceptRelations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptRelationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListConceptRelations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptRelationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::PostConceptRelationsRequest* request, ::clarifai::api::MultiConceptRelationResponse* response, std::function<void(::grpc::Status)>) override;
      void PostConceptRelations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptRelationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::PostConceptRelationsRequest* request, ::clarifai::api::MultiConceptRelationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::PostConceptRelationsRequest* request, ::clarifai::api::MultiConceptRelationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostConceptRelations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptRelationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostConceptRelations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptRelationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::DeleteConceptRelationsRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteConceptRelations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::DeleteConceptRelationsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteConceptRelations(::grpc::ClientContext* context, const ::clarifai::api::DeleteConceptRelationsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteConceptRelations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteConceptRelations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetConceptCounts(::grpc::ClientContext* context, const ::clarifai::api::GetConceptCountsRequest* request, ::clarifai::api::MultiConceptCountResponse* response, std::function<void(::grpc::Status)>) override;
      void GetConceptCounts(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptCountResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetConceptCounts(::grpc::ClientContext* context, const ::clarifai::api::GetConceptCountsRequest* request, ::clarifai::api::MultiConceptCountResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetConceptCounts(::grpc::ClientContext* context, const ::clarifai::api::GetConceptCountsRequest* request, ::clarifai::api::MultiConceptCountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetConceptCounts(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptCountResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetConceptCounts(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptCountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetConcept(::grpc::ClientContext* context, const ::clarifai::api::GetConceptRequest* request, ::clarifai::api::SingleConceptResponse* response, std::function<void(::grpc::Status)>) override;
      void GetConcept(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleConceptResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetConcept(::grpc::ClientContext* context, const ::clarifai::api::GetConceptRequest* request, ::clarifai::api::SingleConceptResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetConcept(::grpc::ClientContext* context, const ::clarifai::api::GetConceptRequest* request, ::clarifai::api::SingleConceptResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetConcept(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleConceptResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetConcept(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleConceptResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListConcepts(::grpc::ClientContext* context, const ::clarifai::api::ListConceptsRequest* request, ::clarifai::api::MultiConceptResponse* response, std::function<void(::grpc::Status)>) override;
      void ListConcepts(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListConcepts(::grpc::ClientContext* context, const ::clarifai::api::ListConceptsRequest* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListConcepts(::grpc::ClientContext* context, const ::clarifai::api::ListConceptsRequest* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListConcepts(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListConcepts(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostConceptsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsSearchesRequest* request, ::clarifai::api::MultiConceptResponse* response, std::function<void(::grpc::Status)>) override;
      void PostConceptsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostConceptsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsSearchesRequest* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostConceptsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsSearchesRequest* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostConceptsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostConceptsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostConcepts(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsRequest* request, ::clarifai::api::MultiConceptResponse* response, std::function<void(::grpc::Status)>) override;
      void PostConcepts(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostConcepts(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsRequest* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostConcepts(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsRequest* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostConcepts(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostConcepts(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PatchConcepts(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptsRequest* request, ::clarifai::api::MultiConceptResponse* response, std::function<void(::grpc::Status)>) override;
      void PatchConcepts(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PatchConcepts(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptsRequest* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PatchConcepts(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptsRequest* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PatchConcepts(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PatchConcepts(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetConceptLanguage(::grpc::ClientContext* context, const ::clarifai::api::GetConceptLanguageRequest* request, ::clarifai::api::SingleConceptLanguageResponse* response, std::function<void(::grpc::Status)>) override;
      void GetConceptLanguage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleConceptLanguageResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetConceptLanguage(::grpc::ClientContext* context, const ::clarifai::api::GetConceptLanguageRequest* request, ::clarifai::api::SingleConceptLanguageResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetConceptLanguage(::grpc::ClientContext* context, const ::clarifai::api::GetConceptLanguageRequest* request, ::clarifai::api::SingleConceptLanguageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetConceptLanguage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleConceptLanguageResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetConceptLanguage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleConceptLanguageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::ListConceptLanguagesRequest* request, ::clarifai::api::MultiConceptLanguageResponse* response, std::function<void(::grpc::Status)>) override;
      void ListConceptLanguages(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptLanguageResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::ListConceptLanguagesRequest* request, ::clarifai::api::MultiConceptLanguageResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::ListConceptLanguagesRequest* request, ::clarifai::api::MultiConceptLanguageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListConceptLanguages(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptLanguageResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListConceptLanguages(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptLanguageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::PostConceptLanguagesRequest* request, ::clarifai::api::MultiConceptLanguageResponse* response, std::function<void(::grpc::Status)>) override;
      void PostConceptLanguages(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptLanguageResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::PostConceptLanguagesRequest* request, ::clarifai::api::MultiConceptLanguageResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::PostConceptLanguagesRequest* request, ::clarifai::api::MultiConceptLanguageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostConceptLanguages(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptLanguageResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostConceptLanguages(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptLanguageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PatchConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptLanguagesRequest* request, ::clarifai::api::MultiConceptLanguageResponse* response, std::function<void(::grpc::Status)>) override;
      void PatchConceptLanguages(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptLanguageResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PatchConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptLanguagesRequest* request, ::clarifai::api::MultiConceptLanguageResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PatchConceptLanguages(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptLanguagesRequest* request, ::clarifai::api::MultiConceptLanguageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PatchConceptLanguages(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptLanguageResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PatchConceptLanguages(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptLanguageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListKnowledgeGraphs(::grpc::ClientContext* context, const ::clarifai::api::ListKnowledgeGraphsRequest* request, ::clarifai::api::MultiKnowledgeGraphResponse* response, std::function<void(::grpc::Status)>) override;
      void ListKnowledgeGraphs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKnowledgeGraphResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListKnowledgeGraphs(::grpc::ClientContext* context, const ::clarifai::api::ListKnowledgeGraphsRequest* request, ::clarifai::api::MultiKnowledgeGraphResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListKnowledgeGraphs(::grpc::ClientContext* context, const ::clarifai::api::ListKnowledgeGraphsRequest* request, ::clarifai::api::MultiKnowledgeGraphResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListKnowledgeGraphs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKnowledgeGraphResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListKnowledgeGraphs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKnowledgeGraphResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostKnowledgeGraphs(::grpc::ClientContext* context, const ::clarifai::api::PostKnowledgeGraphsRequest* request, ::clarifai::api::MultiKnowledgeGraphResponse* response, std::function<void(::grpc::Status)>) override;
      void PostKnowledgeGraphs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKnowledgeGraphResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostKnowledgeGraphs(::grpc::ClientContext* context, const ::clarifai::api::PostKnowledgeGraphsRequest* request, ::clarifai::api::MultiKnowledgeGraphResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostKnowledgeGraphs(::grpc::ClientContext* context, const ::clarifai::api::PostKnowledgeGraphsRequest* request, ::clarifai::api::MultiKnowledgeGraphResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostKnowledgeGraphs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKnowledgeGraphResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostKnowledgeGraphs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKnowledgeGraphResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostConceptMappingJobs(::grpc::ClientContext* context, const ::clarifai::api::PostConceptMappingJobsRequest* request, ::clarifai::api::MultiConceptMappingJobResponse* response, std::function<void(::grpc::Status)>) override;
      void PostConceptMappingJobs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptMappingJobResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostConceptMappingJobs(::grpc::ClientContext* context, const ::clarifai::api::PostConceptMappingJobsRequest* request, ::clarifai::api::MultiConceptMappingJobResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostConceptMappingJobs(::grpc::ClientContext* context, const ::clarifai::api::PostConceptMappingJobsRequest* request, ::clarifai::api::MultiConceptMappingJobResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostConceptMappingJobs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptMappingJobResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostConceptMappingJobs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiConceptMappingJobResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetAnnotation(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationRequest* request, ::clarifai::api::SingleAnnotationResponse* response, std::function<void(::grpc::Status)>) override;
      void GetAnnotation(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleAnnotationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetAnnotation(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationRequest* request, ::clarifai::api::SingleAnnotationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetAnnotation(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationRequest* request, ::clarifai::api::SingleAnnotationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetAnnotation(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleAnnotationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetAnnotation(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleAnnotationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListAnnotations(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationsRequest* request, ::clarifai::api::MultiAnnotationResponse* response, std::function<void(::grpc::Status)>) override;
      void ListAnnotations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListAnnotations(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationsRequest* request, ::clarifai::api::MultiAnnotationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListAnnotations(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationsRequest* request, ::clarifai::api::MultiAnnotationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListAnnotations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListAnnotations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostAnnotations(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsRequest* request, ::clarifai::api::MultiAnnotationResponse* response, std::function<void(::grpc::Status)>) override;
      void PostAnnotations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostAnnotations(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsRequest* request, ::clarifai::api::MultiAnnotationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostAnnotations(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsRequest* request, ::clarifai::api::MultiAnnotationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostAnnotations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostAnnotations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PatchAnnotations(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsRequest* request, ::clarifai::api::MultiAnnotationResponse* response, std::function<void(::grpc::Status)>) override;
      void PatchAnnotations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PatchAnnotations(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsRequest* request, ::clarifai::api::MultiAnnotationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PatchAnnotations(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsRequest* request, ::clarifai::api::MultiAnnotationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PatchAnnotations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PatchAnnotations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PatchAnnotationsStatus(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsStatusRequest* request, ::clarifai::api::PatchAnnotationsStatusResponse* response, std::function<void(::grpc::Status)>) override;
      void PatchAnnotationsStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::PatchAnnotationsStatusResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PatchAnnotationsStatus(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsStatusRequest* request, ::clarifai::api::PatchAnnotationsStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PatchAnnotationsStatus(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsStatusRequest* request, ::clarifai::api::PatchAnnotationsStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PatchAnnotationsStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::PatchAnnotationsStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PatchAnnotationsStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::PatchAnnotationsStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteAnnotation(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteAnnotation(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteAnnotation(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteAnnotation(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteAnnotation(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteAnnotation(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteAnnotations(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationsRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteAnnotations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteAnnotations(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteAnnotations(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteAnnotations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteAnnotations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostAnnotationsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response, std::function<void(::grpc::Status)>) override;
      void PostAnnotationsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostAnnotationsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostAnnotationsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostAnnotationsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostAnnotationsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetInputCount(::grpc::ClientContext* context, const ::clarifai::api::GetInputCountRequest* request, ::clarifai::api::SingleInputCountResponse* response, std::function<void(::grpc::Status)>) override;
      void GetInputCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleInputCountResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetInputCount(::grpc::ClientContext* context, const ::clarifai::api::GetInputCountRequest* request, ::clarifai::api::SingleInputCountResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetInputCount(::grpc::ClientContext* context, const ::clarifai::api::GetInputCountRequest* request, ::clarifai::api::SingleInputCountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetInputCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleInputCountResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetInputCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleInputCountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void StreamInputs(::grpc::ClientContext* context, const ::clarifai::api::StreamInputsRequest* request, ::clarifai::api::MultiInputResponse* response, std::function<void(::grpc::Status)>) override;
      void StreamInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void StreamInputs(::grpc::ClientContext* context, const ::clarifai::api::StreamInputsRequest* request, ::clarifai::api::MultiInputResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void StreamInputs(::grpc::ClientContext* context, const ::clarifai::api::StreamInputsRequest* request, ::clarifai::api::MultiInputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void StreamInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void StreamInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetInputSamples(::grpc::ClientContext* context, const ::clarifai::api::GetInputSamplesRequest* request, ::clarifai::api::MultiInputAnnotationResponse* response, std::function<void(::grpc::Status)>) override;
      void GetInputSamples(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputAnnotationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetInputSamples(::grpc::ClientContext* context, const ::clarifai::api::GetInputSamplesRequest* request, ::clarifai::api::MultiInputAnnotationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetInputSamples(::grpc::ClientContext* context, const ::clarifai::api::GetInputSamplesRequest* request, ::clarifai::api::MultiInputAnnotationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetInputSamples(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputAnnotationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetInputSamples(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputAnnotationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetInput(::grpc::ClientContext* context, const ::clarifai::api::GetInputRequest* request, ::clarifai::api::SingleInputResponse* response, std::function<void(::grpc::Status)>) override;
      void GetInput(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleInputResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetInput(::grpc::ClientContext* context, const ::clarifai::api::GetInputRequest* request, ::clarifai::api::SingleInputResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetInput(::grpc::ClientContext* context, const ::clarifai::api::GetInputRequest* request, ::clarifai::api::SingleInputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetInput(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleInputResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetInput(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleInputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListInputs(::grpc::ClientContext* context, const ::clarifai::api::ListInputsRequest* request, ::clarifai::api::MultiInputResponse* response, std::function<void(::grpc::Status)>) override;
      void ListInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListInputs(::grpc::ClientContext* context, const ::clarifai::api::ListInputsRequest* request, ::clarifai::api::MultiInputResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListInputs(::grpc::ClientContext* context, const ::clarifai::api::ListInputsRequest* request, ::clarifai::api::MultiInputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostInputs(::grpc::ClientContext* context, const ::clarifai::api::PostInputsRequest* request, ::clarifai::api::MultiInputResponse* response, std::function<void(::grpc::Status)>) override;
      void PostInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostInputs(::grpc::ClientContext* context, const ::clarifai::api::PostInputsRequest* request, ::clarifai::api::MultiInputResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostInputs(::grpc::ClientContext* context, const ::clarifai::api::PostInputsRequest* request, ::clarifai::api::MultiInputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PatchInputs(::grpc::ClientContext* context, const ::clarifai::api::PatchInputsRequest* request, ::clarifai::api::MultiInputResponse* response, std::function<void(::grpc::Status)>) override;
      void PatchInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PatchInputs(::grpc::ClientContext* context, const ::clarifai::api::PatchInputsRequest* request, ::clarifai::api::MultiInputResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PatchInputs(::grpc::ClientContext* context, const ::clarifai::api::PatchInputsRequest* request, ::clarifai::api::MultiInputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PatchInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PatchInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteInput(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteInput(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteInput(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteInput(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteInput(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteInput(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteInputs(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputsRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteInputs(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteInputs(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostInputsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostInputsSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response, std::function<void(::grpc::Status)>) override;
      void PostInputsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostInputsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostInputsSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostInputsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostInputsSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostInputsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostInputsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostModelOutputs(::grpc::ClientContext* context, const ::clarifai::api::PostModelOutputsRequest* request, ::clarifai::api::MultiOutputResponse* response, std::function<void(::grpc::Status)>) override;
      void PostModelOutputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiOutputResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostModelOutputs(::grpc::ClientContext* context, const ::clarifai::api::PostModelOutputsRequest* request, ::clarifai::api::MultiOutputResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostModelOutputs(::grpc::ClientContext* context, const ::clarifai::api::PostModelOutputsRequest* request, ::clarifai::api::MultiOutputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostModelOutputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiOutputResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostModelOutputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiOutputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetModelType(::grpc::ClientContext* context, const ::clarifai::api::GetModelTypeRequest* request, ::clarifai::api::SingleModelTypeResponse* response, std::function<void(::grpc::Status)>) override;
      void GetModelType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelTypeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetModelType(::grpc::ClientContext* context, const ::clarifai::api::GetModelTypeRequest* request, ::clarifai::api::SingleModelTypeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetModelType(::grpc::ClientContext* context, const ::clarifai::api::GetModelTypeRequest* request, ::clarifai::api::SingleModelTypeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetModelType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelTypeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetModelType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelTypeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListModelTypes(::grpc::ClientContext* context, const ::clarifai::api::ListModelTypesRequest* request, ::clarifai::api::MultiModelTypeResponse* response, std::function<void(::grpc::Status)>) override;
      void ListModelTypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelTypeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListModelTypes(::grpc::ClientContext* context, const ::clarifai::api::ListModelTypesRequest* request, ::clarifai::api::MultiModelTypeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListModelTypes(::grpc::ClientContext* context, const ::clarifai::api::ListModelTypesRequest* request, ::clarifai::api::MultiModelTypeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListModelTypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelTypeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListModelTypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelTypeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetModel(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest* request, ::clarifai::api::SingleModelResponse* response, std::function<void(::grpc::Status)>) override;
      void GetModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetModel(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest* request, ::clarifai::api::SingleModelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetModel(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest* request, ::clarifai::api::SingleModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetModelOutputInfo(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest* request, ::clarifai::api::SingleModelResponse* response, std::function<void(::grpc::Status)>) override;
      void GetModelOutputInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetModelOutputInfo(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest* request, ::clarifai::api::SingleModelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetModelOutputInfo(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest* request, ::clarifai::api::SingleModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetModelOutputInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetModelOutputInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListModels(::grpc::ClientContext* context, const ::clarifai::api::ListModelsRequest* request, ::clarifai::api::MultiModelResponse* response, std::function<void(::grpc::Status)>) override;
      void ListModels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListModels(::grpc::ClientContext* context, const ::clarifai::api::ListModelsRequest* request, ::clarifai::api::MultiModelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListModels(::grpc::ClientContext* context, const ::clarifai::api::ListModelsRequest* request, ::clarifai::api::MultiModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListModels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListModels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostModelsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostModelsSearchesRequest* request, ::clarifai::api::MultiModelResponse* response, std::function<void(::grpc::Status)>) override;
      void PostModelsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostModelsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostModelsSearchesRequest* request, ::clarifai::api::MultiModelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostModelsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostModelsSearchesRequest* request, ::clarifai::api::MultiModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostModelsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostModelsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostModels(::grpc::ClientContext* context, const ::clarifai::api::PostModelsRequest* request, ::clarifai::api::SingleModelResponse* response, std::function<void(::grpc::Status)>) override;
      void PostModels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostModels(::grpc::ClientContext* context, const ::clarifai::api::PostModelsRequest* request, ::clarifai::api::SingleModelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostModels(::grpc::ClientContext* context, const ::clarifai::api::PostModelsRequest* request, ::clarifai::api::SingleModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostModels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostModels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PatchModels(::grpc::ClientContext* context, const ::clarifai::api::PatchModelsRequest* request, ::clarifai::api::MultiModelResponse* response, std::function<void(::grpc::Status)>) override;
      void PatchModels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PatchModels(::grpc::ClientContext* context, const ::clarifai::api::PatchModelsRequest* request, ::clarifai::api::MultiModelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PatchModels(::grpc::ClientContext* context, const ::clarifai::api::PatchModelsRequest* request, ::clarifai::api::MultiModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PatchModels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PatchModels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteModel(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteModel(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteModel(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteModels(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelsRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteModels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteModels(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteModels(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteModels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteModels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListModelInputs(::grpc::ClientContext* context, const ::clarifai::api::ListModelInputsRequest* request, ::clarifai::api::MultiInputResponse* response, std::function<void(::grpc::Status)>) override;
      void ListModelInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListModelInputs(::grpc::ClientContext* context, const ::clarifai::api::ListModelInputsRequest* request, ::clarifai::api::MultiInputResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListModelInputs(::grpc::ClientContext* context, const ::clarifai::api::ListModelInputsRequest* request, ::clarifai::api::MultiInputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListModelInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListModelInputs(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiInputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetModelVersion(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionRequest* request, ::clarifai::api::SingleModelVersionResponse* response, std::function<void(::grpc::Status)>) override;
      void GetModelVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelVersionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetModelVersion(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionRequest* request, ::clarifai::api::SingleModelVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetModelVersion(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionRequest* request, ::clarifai::api::SingleModelVersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetModelVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetModelVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelVersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListModelVersions(::grpc::ClientContext* context, const ::clarifai::api::ListModelVersionsRequest* request, ::clarifai::api::MultiModelVersionResponse* response, std::function<void(::grpc::Status)>) override;
      void ListModelVersions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelVersionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListModelVersions(::grpc::ClientContext* context, const ::clarifai::api::ListModelVersionsRequest* request, ::clarifai::api::MultiModelVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListModelVersions(::grpc::ClientContext* context, const ::clarifai::api::ListModelVersionsRequest* request, ::clarifai::api::MultiModelVersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListModelVersions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListModelVersions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiModelVersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostModelVersions(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionsRequest* request, ::clarifai::api::SingleModelResponse* response, std::function<void(::grpc::Status)>) override;
      void PostModelVersions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostModelVersions(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionsRequest* request, ::clarifai::api::SingleModelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostModelVersions(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionsRequest* request, ::clarifai::api::SingleModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostModelVersions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostModelVersions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteModelVersion(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelVersionRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteModelVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteModelVersion(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelVersionRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteModelVersion(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelVersionRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteModelVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteModelVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetModelVersionMetrics(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionMetricsRequest* request, ::clarifai::api::SingleModelVersionResponse* response, std::function<void(::grpc::Status)>) override;
      void GetModelVersionMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelVersionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetModelVersionMetrics(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionMetricsRequest* request, ::clarifai::api::SingleModelVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetModelVersionMetrics(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionMetricsRequest* request, ::clarifai::api::SingleModelVersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetModelVersionMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetModelVersionMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelVersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostModelVersionMetrics(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionMetricsRequest* request, ::clarifai::api::SingleModelVersionResponse* response, std::function<void(::grpc::Status)>) override;
      void PostModelVersionMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelVersionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostModelVersionMetrics(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionMetricsRequest* request, ::clarifai::api::SingleModelVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostModelVersionMetrics(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionMetricsRequest* request, ::clarifai::api::SingleModelVersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostModelVersionMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostModelVersionMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleModelVersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetWorkflow(::grpc::ClientContext* context, const ::clarifai::api::GetWorkflowRequest* request, ::clarifai::api::SingleWorkflowResponse* response, std::function<void(::grpc::Status)>) override;
      void GetWorkflow(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleWorkflowResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetWorkflow(::grpc::ClientContext* context, const ::clarifai::api::GetWorkflowRequest* request, ::clarifai::api::SingleWorkflowResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetWorkflow(::grpc::ClientContext* context, const ::clarifai::api::GetWorkflowRequest* request, ::clarifai::api::SingleWorkflowResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetWorkflow(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleWorkflowResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetWorkflow(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleWorkflowResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListWorkflows(::grpc::ClientContext* context, const ::clarifai::api::ListWorkflowsRequest* request, ::clarifai::api::MultiWorkflowResponse* response, std::function<void(::grpc::Status)>) override;
      void ListWorkflows(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiWorkflowResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListWorkflows(::grpc::ClientContext* context, const ::clarifai::api::ListWorkflowsRequest* request, ::clarifai::api::MultiWorkflowResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListWorkflows(::grpc::ClientContext* context, const ::clarifai::api::ListWorkflowsRequest* request, ::clarifai::api::MultiWorkflowResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListWorkflows(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiWorkflowResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListWorkflows(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiWorkflowResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostWorkflows(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowsRequest* request, ::clarifai::api::MultiWorkflowResponse* response, std::function<void(::grpc::Status)>) override;
      void PostWorkflows(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiWorkflowResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostWorkflows(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowsRequest* request, ::clarifai::api::MultiWorkflowResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostWorkflows(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowsRequest* request, ::clarifai::api::MultiWorkflowResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostWorkflows(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiWorkflowResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostWorkflows(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiWorkflowResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PatchWorkflows(::grpc::ClientContext* context, const ::clarifai::api::PatchWorkflowsRequest* request, ::clarifai::api::MultiWorkflowResponse* response, std::function<void(::grpc::Status)>) override;
      void PatchWorkflows(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiWorkflowResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PatchWorkflows(::grpc::ClientContext* context, const ::clarifai::api::PatchWorkflowsRequest* request, ::clarifai::api::MultiWorkflowResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PatchWorkflows(::grpc::ClientContext* context, const ::clarifai::api::PatchWorkflowsRequest* request, ::clarifai::api::MultiWorkflowResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PatchWorkflows(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiWorkflowResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PatchWorkflows(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiWorkflowResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteWorkflow(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteWorkflow(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteWorkflow(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteWorkflow(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteWorkflow(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteWorkflow(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteWorkflows(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowsRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteWorkflows(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteWorkflows(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteWorkflows(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteWorkflows(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteWorkflows(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostWorkflowResults(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsRequest* request, ::clarifai::api::PostWorkflowResultsResponse* response, std::function<void(::grpc::Status)>) override;
      void PostWorkflowResults(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::PostWorkflowResultsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostWorkflowResults(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsRequest* request, ::clarifai::api::PostWorkflowResultsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostWorkflowResults(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsRequest* request, ::clarifai::api::PostWorkflowResultsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostWorkflowResults(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::PostWorkflowResultsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostWorkflowResults(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::PostWorkflowResultsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostWorkflowResultsSimilarity(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsSimilarityRequest* request, ::clarifai::api::PostWorkflowResultsSimilarityResponse* response, std::function<void(::grpc::Status)>) override;
      void PostWorkflowResultsSimilarity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::PostWorkflowResultsSimilarityResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostWorkflowResultsSimilarity(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsSimilarityRequest* request, ::clarifai::api::PostWorkflowResultsSimilarityResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostWorkflowResultsSimilarity(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsSimilarityRequest* request, ::clarifai::api::PostWorkflowResultsSimilarityResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostWorkflowResultsSimilarity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::PostWorkflowResultsSimilarityResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostWorkflowResultsSimilarity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::PostWorkflowResultsSimilarityResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetKey(::grpc::ClientContext* context, const ::clarifai::api::GetKeyRequest* request, ::clarifai::api::SingleKeyResponse* response, std::function<void(::grpc::Status)>) override;
      void GetKey(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleKeyResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetKey(::grpc::ClientContext* context, const ::clarifai::api::GetKeyRequest* request, ::clarifai::api::SingleKeyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetKey(::grpc::ClientContext* context, const ::clarifai::api::GetKeyRequest* request, ::clarifai::api::SingleKeyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetKey(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleKeyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetKey(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleKeyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListKeys(::grpc::ClientContext* context, const ::clarifai::api::ListKeysRequest* request, ::clarifai::api::MultiKeyResponse* response, std::function<void(::grpc::Status)>) override;
      void ListKeys(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKeyResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListKeys(::grpc::ClientContext* context, const ::clarifai::api::ListKeysRequest* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListKeys(::grpc::ClientContext* context, const ::clarifai::api::ListKeysRequest* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListKeys(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListKeys(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListAppKeys(::grpc::ClientContext* context, const ::clarifai::api::ListAppKeysRequest* request, ::clarifai::api::MultiKeyResponse* response, std::function<void(::grpc::Status)>) override;
      void ListAppKeys(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKeyResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListAppKeys(::grpc::ClientContext* context, const ::clarifai::api::ListAppKeysRequest* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListAppKeys(::grpc::ClientContext* context, const ::clarifai::api::ListAppKeysRequest* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListAppKeys(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListAppKeys(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteKey(::grpc::ClientContext* context, const ::clarifai::api::DeleteKeyRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteKey(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteKey(::grpc::ClientContext* context, const ::clarifai::api::DeleteKeyRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteKey(::grpc::ClientContext* context, const ::clarifai::api::DeleteKeyRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteKey(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteKey(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostKeys(::grpc::ClientContext* context, const ::clarifai::api::PostKeysRequest* request, ::clarifai::api::MultiKeyResponse* response, std::function<void(::grpc::Status)>) override;
      void PostKeys(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKeyResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostKeys(::grpc::ClientContext* context, const ::clarifai::api::PostKeysRequest* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostKeys(::grpc::ClientContext* context, const ::clarifai::api::PostKeysRequest* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostKeys(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostKeys(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PatchKeys(::grpc::ClientContext* context, const ::clarifai::api::PatchKeysRequest* request, ::clarifai::api::MultiKeyResponse* response, std::function<void(::grpc::Status)>) override;
      void PatchKeys(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKeyResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PatchKeys(::grpc::ClientContext* context, const ::clarifai::api::PatchKeysRequest* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PatchKeys(::grpc::ClientContext* context, const ::clarifai::api::PatchKeysRequest* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PatchKeys(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PatchKeys(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiKeyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MyScopes(::grpc::ClientContext* context, const ::clarifai::api::MyScopesRequest* request, ::clarifai::api::MultiScopeResponse* response, std::function<void(::grpc::Status)>) override;
      void MyScopes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiScopeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MyScopes(::grpc::ClientContext* context, const ::clarifai::api::MyScopesRequest* request, ::clarifai::api::MultiScopeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MyScopes(::grpc::ClientContext* context, const ::clarifai::api::MyScopesRequest* request, ::clarifai::api::MultiScopeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MyScopes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiScopeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MyScopes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiScopeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListScopes(::grpc::ClientContext* context, const ::clarifai::api::ListScopesRequest* request, ::clarifai::api::MultiScopeDepsResponse* response, std::function<void(::grpc::Status)>) override;
      void ListScopes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiScopeDepsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListScopes(::grpc::ClientContext* context, const ::clarifai::api::ListScopesRequest* request, ::clarifai::api::MultiScopeDepsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListScopes(::grpc::ClientContext* context, const ::clarifai::api::ListScopesRequest* request, ::clarifai::api::MultiScopeDepsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListScopes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiScopeDepsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListScopes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiScopeDepsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetApp(::grpc::ClientContext* context, const ::clarifai::api::GetAppRequest* request, ::clarifai::api::SingleAppResponse* response, std::function<void(::grpc::Status)>) override;
      void GetApp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleAppResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetApp(::grpc::ClientContext* context, const ::clarifai::api::GetAppRequest* request, ::clarifai::api::SingleAppResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetApp(::grpc::ClientContext* context, const ::clarifai::api::GetAppRequest* request, ::clarifai::api::SingleAppResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetApp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleAppResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetApp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleAppResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListApps(::grpc::ClientContext* context, const ::clarifai::api::ListAppsRequest* request, ::clarifai::api::MultiAppResponse* response, std::function<void(::grpc::Status)>) override;
      void ListApps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListApps(::grpc::ClientContext* context, const ::clarifai::api::ListAppsRequest* request, ::clarifai::api::MultiAppResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListApps(::grpc::ClientContext* context, const ::clarifai::api::ListAppsRequest* request, ::clarifai::api::MultiAppResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListApps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListApps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteApp(::grpc::ClientContext* context, const ::clarifai::api::DeleteAppRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteApp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteApp(::grpc::ClientContext* context, const ::clarifai::api::DeleteAppRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteApp(::grpc::ClientContext* context, const ::clarifai::api::DeleteAppRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteApp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteApp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostApps(::grpc::ClientContext* context, const ::clarifai::api::PostAppsRequest* request, ::clarifai::api::MultiAppResponse* response, std::function<void(::grpc::Status)>) override;
      void PostApps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostApps(::grpc::ClientContext* context, const ::clarifai::api::PostAppsRequest* request, ::clarifai::api::MultiAppResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostApps(::grpc::ClientContext* context, const ::clarifai::api::PostAppsRequest* request, ::clarifai::api::MultiAppResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostApps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostApps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PatchApps(::grpc::ClientContext* context, const ::clarifai::api::PatchAppsRequest* request, ::clarifai::api::MultiAppResponse* response, std::function<void(::grpc::Status)>) override;
      void PatchApps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PatchApps(::grpc::ClientContext* context, const ::clarifai::api::PatchAppsRequest* request, ::clarifai::api::MultiAppResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PatchApps(::grpc::ClientContext* context, const ::clarifai::api::PatchAppsRequest* request, ::clarifai::api::MultiAppResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PatchApps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PatchApps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostAppsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostAppsSearchesRequest* request, ::clarifai::api::MultiAppResponse* response, std::function<void(::grpc::Status)>) override;
      void PostAppsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostAppsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostAppsSearchesRequest* request, ::clarifai::api::MultiAppResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostAppsSearches(::grpc::ClientContext* context, const ::clarifai::api::PostAppsSearchesRequest* request, ::clarifai::api::MultiAppResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostAppsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostAppsSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostValidatePassword(::grpc::ClientContext* context, const ::clarifai::api::PostValidatePasswordRequest* request, ::clarifai::api::SinglePasswordValidationResponse* response, std::function<void(::grpc::Status)>) override;
      void PostValidatePassword(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SinglePasswordValidationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostValidatePassword(::grpc::ClientContext* context, const ::clarifai::api::PostValidatePasswordRequest* request, ::clarifai::api::SinglePasswordValidationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostValidatePassword(::grpc::ClientContext* context, const ::clarifai::api::PostValidatePasswordRequest* request, ::clarifai::api::SinglePasswordValidationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostValidatePassword(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SinglePasswordValidationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostValidatePassword(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SinglePasswordValidationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetSearch(::grpc::ClientContext* context, const ::clarifai::api::GetSearchRequest* request, ::clarifai::api::SingleSearchResponse* response, std::function<void(::grpc::Status)>) override;
      void GetSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleSearchResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetSearch(::grpc::ClientContext* context, const ::clarifai::api::GetSearchRequest* request, ::clarifai::api::SingleSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetSearch(::grpc::ClientContext* context, const ::clarifai::api::GetSearchRequest* request, ::clarifai::api::SingleSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListSearches(::grpc::ClientContext* context, const ::clarifai::api::ListSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response, std::function<void(::grpc::Status)>) override;
      void ListSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListSearches(::grpc::ClientContext* context, const ::clarifai::api::ListSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListSearches(::grpc::ClientContext* context, const ::clarifai::api::ListSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostSearches(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response, std::function<void(::grpc::Status)>) override;
      void PostSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostSearches(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostSearches(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostSearches(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostSearchesByID(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesByIDRequest* request, ::clarifai::api::MultiSearchResponse* response, std::function<void(::grpc::Status)>) override;
      void PostSearchesByID(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostSearchesByID(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesByIDRequest* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostSearchesByID(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesByIDRequest* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostSearchesByID(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostSearchesByID(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationSearchMetricsRequest* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, std::function<void(::grpc::Status)>) override;
      void PostAnnotationSearchMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationSearchMetricsRequest* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationSearchMetricsRequest* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostAnnotationSearchMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostAnnotationSearchMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationSearchMetricsRequest* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetAnnotationSearchMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationSearchMetricsRequest* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationSearchMetricsRequest* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetAnnotationSearchMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetAnnotationSearchMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationSearchMetricsRequest* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, std::function<void(::grpc::Status)>) override;
      void ListAnnotationSearchMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationSearchMetricsRequest* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationSearchMetricsRequest* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListAnnotationSearchMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListAnnotationSearchMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationSearchMetricsRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteAnnotationSearchMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationSearchMetricsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteAnnotationSearchMetrics(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationSearchMetricsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteAnnotationSearchMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteAnnotationSearchMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteSearch(::grpc::ClientContext* context, const ::clarifai::api::DeleteSearchRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteSearch(::grpc::ClientContext* context, const ::clarifai::api::DeleteSearchRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteSearch(::grpc::ClientContext* context, const ::clarifai::api::DeleteSearchRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListStatusCodes(::grpc::ClientContext* context, const ::clarifai::api::ListStatusCodesRequest* request, ::clarifai::api::MultiStatusCodeResponse* response, std::function<void(::grpc::Status)>) override;
      void ListStatusCodes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiStatusCodeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListStatusCodes(::grpc::ClientContext* context, const ::clarifai::api::ListStatusCodesRequest* request, ::clarifai::api::MultiStatusCodeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListStatusCodes(::grpc::ClientContext* context, const ::clarifai::api::ListStatusCodesRequest* request, ::clarifai::api::MultiStatusCodeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListStatusCodes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiStatusCodeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListStatusCodes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiStatusCodeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetStatusCode(::grpc::ClientContext* context, const ::clarifai::api::GetStatusCodeRequest* request, ::clarifai::api::SingleStatusCodeResponse* response, std::function<void(::grpc::Status)>) override;
      void GetStatusCode(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleStatusCodeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetStatusCode(::grpc::ClientContext* context, const ::clarifai::api::GetStatusCodeRequest* request, ::clarifai::api::SingleStatusCodeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetStatusCode(::grpc::ClientContext* context, const ::clarifai::api::GetStatusCodeRequest* request, ::clarifai::api::SingleStatusCodeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetStatusCode(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleStatusCodeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetStatusCode(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleStatusCodeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListCollaborators(::grpc::ClientContext* context, const ::clarifai::api::ListCollaboratorsRequest* request, ::clarifai::api::MultiCollaboratorsResponse* response, std::function<void(::grpc::Status)>) override;
      void ListCollaborators(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollaboratorsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListCollaborators(::grpc::ClientContext* context, const ::clarifai::api::ListCollaboratorsRequest* request, ::clarifai::api::MultiCollaboratorsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListCollaborators(::grpc::ClientContext* context, const ::clarifai::api::ListCollaboratorsRequest* request, ::clarifai::api::MultiCollaboratorsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListCollaborators(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollaboratorsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListCollaborators(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollaboratorsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostCollaborators(::grpc::ClientContext* context, const ::clarifai::api::PostCollaboratorsRequest* request, ::clarifai::api::MultiCollaboratorsResponse* response, std::function<void(::grpc::Status)>) override;
      void PostCollaborators(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollaboratorsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostCollaborators(::grpc::ClientContext* context, const ::clarifai::api::PostCollaboratorsRequest* request, ::clarifai::api::MultiCollaboratorsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostCollaborators(::grpc::ClientContext* context, const ::clarifai::api::PostCollaboratorsRequest* request, ::clarifai::api::MultiCollaboratorsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostCollaborators(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollaboratorsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostCollaborators(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollaboratorsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PatchCollaborators(::grpc::ClientContext* context, const ::clarifai::api::PatchCollaboratorsRequest* request, ::clarifai::api::MultiCollaboratorsResponse* response, std::function<void(::grpc::Status)>) override;
      void PatchCollaborators(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollaboratorsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PatchCollaborators(::grpc::ClientContext* context, const ::clarifai::api::PatchCollaboratorsRequest* request, ::clarifai::api::MultiCollaboratorsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PatchCollaborators(::grpc::ClientContext* context, const ::clarifai::api::PatchCollaboratorsRequest* request, ::clarifai::api::MultiCollaboratorsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PatchCollaborators(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollaboratorsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PatchCollaborators(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollaboratorsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteCollaborators(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollaboratorsRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteCollaborators(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteCollaborators(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollaboratorsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteCollaborators(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollaboratorsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteCollaborators(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteCollaborators(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListCollaborations(::grpc::ClientContext* context, const ::clarifai::api::ListCollaborationsRequest* request, ::clarifai::api::MultiCollaborationsResponse* response, std::function<void(::grpc::Status)>) override;
      void ListCollaborations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollaborationsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListCollaborations(::grpc::ClientContext* context, const ::clarifai::api::ListCollaborationsRequest* request, ::clarifai::api::MultiCollaborationsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListCollaborations(::grpc::ClientContext* context, const ::clarifai::api::ListCollaborationsRequest* request, ::clarifai::api::MultiCollaborationsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListCollaborations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollaborationsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListCollaborations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollaborationsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostAppDuplications(::grpc::ClientContext* context, const ::clarifai::api::PostAppDuplicationsRequest* request, ::clarifai::api::MultiAppDuplicationsResponse* response, std::function<void(::grpc::Status)>) override;
      void PostAppDuplications(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppDuplicationsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostAppDuplications(::grpc::ClientContext* context, const ::clarifai::api::PostAppDuplicationsRequest* request, ::clarifai::api::MultiAppDuplicationsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostAppDuplications(::grpc::ClientContext* context, const ::clarifai::api::PostAppDuplicationsRequest* request, ::clarifai::api::MultiAppDuplicationsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostAppDuplications(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppDuplicationsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostAppDuplications(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppDuplicationsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListAppDuplications(::grpc::ClientContext* context, const ::clarifai::api::ListAppDuplicationsRequest* request, ::clarifai::api::MultiAppDuplicationsResponse* response, std::function<void(::grpc::Status)>) override;
      void ListAppDuplications(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppDuplicationsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListAppDuplications(::grpc::ClientContext* context, const ::clarifai::api::ListAppDuplicationsRequest* request, ::clarifai::api::MultiAppDuplicationsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListAppDuplications(::grpc::ClientContext* context, const ::clarifai::api::ListAppDuplicationsRequest* request, ::clarifai::api::MultiAppDuplicationsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListAppDuplications(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppDuplicationsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListAppDuplications(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiAppDuplicationsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetAppDuplication(::grpc::ClientContext* context, const ::clarifai::api::GetAppDuplicationRequest* request, ::clarifai::api::SingleAppDuplicationResponse* response, std::function<void(::grpc::Status)>) override;
      void GetAppDuplication(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleAppDuplicationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetAppDuplication(::grpc::ClientContext* context, const ::clarifai::api::GetAppDuplicationRequest* request, ::clarifai::api::SingleAppDuplicationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetAppDuplication(::grpc::ClientContext* context, const ::clarifai::api::GetAppDuplicationRequest* request, ::clarifai::api::SingleAppDuplicationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetAppDuplication(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleAppDuplicationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetAppDuplication(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleAppDuplicationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostTasks(::grpc::ClientContext* context, const ::clarifai::api::PostTasksRequest* request, ::clarifai::api::MultiTaskResponse* response, std::function<void(::grpc::Status)>) override;
      void PostTasks(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiTaskResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostTasks(::grpc::ClientContext* context, const ::clarifai::api::PostTasksRequest* request, ::clarifai::api::MultiTaskResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostTasks(::grpc::ClientContext* context, const ::clarifai::api::PostTasksRequest* request, ::clarifai::api::MultiTaskResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostTasks(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiTaskResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostTasks(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiTaskResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetTaskAnnotationCount(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest* request, ::clarifai::api::SingleTaskCountResponse* response, std::function<void(::grpc::Status)>) override;
      void GetTaskAnnotationCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleTaskCountResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetTaskAnnotationCount(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest* request, ::clarifai::api::SingleTaskCountResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetTaskAnnotationCount(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest* request, ::clarifai::api::SingleTaskCountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetTaskAnnotationCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleTaskCountResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetTaskAnnotationCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleTaskCountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetTaskInputCount(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest* request, ::clarifai::api::SingleTaskCountResponse* response, std::function<void(::grpc::Status)>) override;
      void GetTaskInputCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleTaskCountResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetTaskInputCount(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest* request, ::clarifai::api::SingleTaskCountResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetTaskInputCount(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest* request, ::clarifai::api::SingleTaskCountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetTaskInputCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleTaskCountResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetTaskInputCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleTaskCountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetTask(::grpc::ClientContext* context, const ::clarifai::api::GetTaskRequest* request, ::clarifai::api::SingleTaskResponse* response, std::function<void(::grpc::Status)>) override;
      void GetTask(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleTaskResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetTask(::grpc::ClientContext* context, const ::clarifai::api::GetTaskRequest* request, ::clarifai::api::SingleTaskResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetTask(::grpc::ClientContext* context, const ::clarifai::api::GetTaskRequest* request, ::clarifai::api::SingleTaskResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetTask(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleTaskResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetTask(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleTaskResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListTasks(::grpc::ClientContext* context, const ::clarifai::api::ListTasksRequest* request, ::clarifai::api::MultiTaskResponse* response, std::function<void(::grpc::Status)>) override;
      void ListTasks(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiTaskResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListTasks(::grpc::ClientContext* context, const ::clarifai::api::ListTasksRequest* request, ::clarifai::api::MultiTaskResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListTasks(::grpc::ClientContext* context, const ::clarifai::api::ListTasksRequest* request, ::clarifai::api::MultiTaskResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListTasks(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiTaskResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListTasks(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiTaskResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PatchTasks(::grpc::ClientContext* context, const ::clarifai::api::PatchTasksRequest* request, ::clarifai::api::MultiTaskResponse* response, std::function<void(::grpc::Status)>) override;
      void PatchTasks(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiTaskResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PatchTasks(::grpc::ClientContext* context, const ::clarifai::api::PatchTasksRequest* request, ::clarifai::api::MultiTaskResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PatchTasks(::grpc::ClientContext* context, const ::clarifai::api::PatchTasksRequest* request, ::clarifai::api::MultiTaskResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PatchTasks(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiTaskResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PatchTasks(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiTaskResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteTasks(::grpc::ClientContext* context, const ::clarifai::api::DeleteTasksRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteTasks(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteTasks(::grpc::ClientContext* context, const ::clarifai::api::DeleteTasksRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteTasks(::grpc::ClientContext* context, const ::clarifai::api::DeleteTasksRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteTasks(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteTasks(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostCollectors(::grpc::ClientContext* context, const ::clarifai::api::PostCollectorsRequest* request, ::clarifai::api::MultiCollectorResponse* response, std::function<void(::grpc::Status)>) override;
      void PostCollectors(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollectorResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostCollectors(::grpc::ClientContext* context, const ::clarifai::api::PostCollectorsRequest* request, ::clarifai::api::MultiCollectorResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostCollectors(::grpc::ClientContext* context, const ::clarifai::api::PostCollectorsRequest* request, ::clarifai::api::MultiCollectorResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostCollectors(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollectorResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostCollectors(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollectorResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetCollector(::grpc::ClientContext* context, const ::clarifai::api::GetCollectorRequest* request, ::clarifai::api::SingleCollectorResponse* response, std::function<void(::grpc::Status)>) override;
      void GetCollector(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleCollectorResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetCollector(::grpc::ClientContext* context, const ::clarifai::api::GetCollectorRequest* request, ::clarifai::api::SingleCollectorResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetCollector(::grpc::ClientContext* context, const ::clarifai::api::GetCollectorRequest* request, ::clarifai::api::SingleCollectorResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetCollector(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleCollectorResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetCollector(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::SingleCollectorResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListCollectors(::grpc::ClientContext* context, const ::clarifai::api::ListCollectorsRequest* request, ::clarifai::api::MultiCollectorResponse* response, std::function<void(::grpc::Status)>) override;
      void ListCollectors(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollectorResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListCollectors(::grpc::ClientContext* context, const ::clarifai::api::ListCollectorsRequest* request, ::clarifai::api::MultiCollectorResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListCollectors(::grpc::ClientContext* context, const ::clarifai::api::ListCollectorsRequest* request, ::clarifai::api::MultiCollectorResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListCollectors(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollectorResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListCollectors(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollectorResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PatchCollectors(::grpc::ClientContext* context, const ::clarifai::api::PatchCollectorsRequest* request, ::clarifai::api::MultiCollectorResponse* response, std::function<void(::grpc::Status)>) override;
      void PatchCollectors(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollectorResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PatchCollectors(::grpc::ClientContext* context, const ::clarifai::api::PatchCollectorsRequest* request, ::clarifai::api::MultiCollectorResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PatchCollectors(::grpc::ClientContext* context, const ::clarifai::api::PatchCollectorsRequest* request, ::clarifai::api::MultiCollectorResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PatchCollectors(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollectorResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PatchCollectors(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiCollectorResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteCollectors(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollectorsRequest* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteCollectors(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteCollectors(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollectorsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteCollectors(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollectorsRequest* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteCollectors(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteCollectors(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::status::BaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostStatValues(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesRequest* request, ::clarifai::api::MultiStatValueResponse* response, std::function<void(::grpc::Status)>) override;
      void PostStatValues(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiStatValueResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostStatValues(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesRequest* request, ::clarifai::api::MultiStatValueResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostStatValues(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesRequest* request, ::clarifai::api::MultiStatValueResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostStatValues(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiStatValueResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostStatValues(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiStatValueResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PostStatValuesAggregate(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesAggregateRequest* request, ::clarifai::api::MultiStatValueAggregateResponse* response, std::function<void(::grpc::Status)>) override;
      void PostStatValuesAggregate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiStatValueAggregateResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostStatValuesAggregate(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesAggregateRequest* request, ::clarifai::api::MultiStatValueAggregateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostStatValuesAggregate(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesAggregateRequest* request, ::clarifai::api::MultiStatValueAggregateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PostStatValuesAggregate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiStatValueAggregateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PostStatValuesAggregate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::clarifai::api::MultiStatValueAggregateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptRelationResponse>* AsyncListConceptRelationsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListConceptRelationsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptRelationResponse>* PrepareAsyncListConceptRelationsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListConceptRelationsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptRelationResponse>* AsyncPostConceptRelationsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostConceptRelationsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptRelationResponse>* PrepareAsyncPostConceptRelationsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostConceptRelationsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* AsyncDeleteConceptRelationsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteConceptRelationsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteConceptRelationsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteConceptRelationsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptCountResponse>* AsyncGetConceptCountsRaw(::grpc::ClientContext* context, const ::clarifai::api::GetConceptCountsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptCountResponse>* PrepareAsyncGetConceptCountsRaw(::grpc::ClientContext* context, const ::clarifai::api::GetConceptCountsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleConceptResponse>* AsyncGetConceptRaw(::grpc::ClientContext* context, const ::clarifai::api::GetConceptRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleConceptResponse>* PrepareAsyncGetConceptRaw(::grpc::ClientContext* context, const ::clarifai::api::GetConceptRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptResponse>* AsyncListConceptsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListConceptsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptResponse>* PrepareAsyncListConceptsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListConceptsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptResponse>* AsyncPostConceptsSearchesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsSearchesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptResponse>* PrepareAsyncPostConceptsSearchesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsSearchesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptResponse>* AsyncPostConceptsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptResponse>* PrepareAsyncPostConceptsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostConceptsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptResponse>* AsyncPatchConceptsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptResponse>* PrepareAsyncPatchConceptsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleConceptLanguageResponse>* AsyncGetConceptLanguageRaw(::grpc::ClientContext* context, const ::clarifai::api::GetConceptLanguageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleConceptLanguageResponse>* PrepareAsyncGetConceptLanguageRaw(::grpc::ClientContext* context, const ::clarifai::api::GetConceptLanguageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptLanguageResponse>* AsyncListConceptLanguagesRaw(::grpc::ClientContext* context, const ::clarifai::api::ListConceptLanguagesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptLanguageResponse>* PrepareAsyncListConceptLanguagesRaw(::grpc::ClientContext* context, const ::clarifai::api::ListConceptLanguagesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptLanguageResponse>* AsyncPostConceptLanguagesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostConceptLanguagesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptLanguageResponse>* PrepareAsyncPostConceptLanguagesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostConceptLanguagesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptLanguageResponse>* AsyncPatchConceptLanguagesRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptLanguagesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptLanguageResponse>* PrepareAsyncPatchConceptLanguagesRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchConceptLanguagesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKnowledgeGraphResponse>* AsyncListKnowledgeGraphsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListKnowledgeGraphsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKnowledgeGraphResponse>* PrepareAsyncListKnowledgeGraphsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListKnowledgeGraphsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKnowledgeGraphResponse>* AsyncPostKnowledgeGraphsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostKnowledgeGraphsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKnowledgeGraphResponse>* PrepareAsyncPostKnowledgeGraphsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostKnowledgeGraphsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptMappingJobResponse>* AsyncPostConceptMappingJobsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostConceptMappingJobsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiConceptMappingJobResponse>* PrepareAsyncPostConceptMappingJobsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostConceptMappingJobsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleAnnotationResponse>* AsyncGetAnnotationRaw(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleAnnotationResponse>* PrepareAsyncGetAnnotationRaw(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationResponse>* AsyncListAnnotationsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationResponse>* PrepareAsyncListAnnotationsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationResponse>* AsyncPostAnnotationsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationResponse>* PrepareAsyncPostAnnotationsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationResponse>* AsyncPatchAnnotationsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationResponse>* PrepareAsyncPatchAnnotationsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::PatchAnnotationsStatusResponse>* AsyncPatchAnnotationsStatusRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::PatchAnnotationsStatusResponse>* PrepareAsyncPatchAnnotationsStatusRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchAnnotationsStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* AsyncDeleteAnnotationRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteAnnotationRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* AsyncDeleteAnnotationsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteAnnotationsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>* AsyncPostAnnotationsSearchesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsSearchesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>* PrepareAsyncPostAnnotationsSearchesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationsSearchesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleInputCountResponse>* AsyncGetInputCountRaw(::grpc::ClientContext* context, const ::clarifai::api::GetInputCountRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleInputCountResponse>* PrepareAsyncGetInputCountRaw(::grpc::ClientContext* context, const ::clarifai::api::GetInputCountRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>* AsyncStreamInputsRaw(::grpc::ClientContext* context, const ::clarifai::api::StreamInputsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>* PrepareAsyncStreamInputsRaw(::grpc::ClientContext* context, const ::clarifai::api::StreamInputsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputAnnotationResponse>* AsyncGetInputSamplesRaw(::grpc::ClientContext* context, const ::clarifai::api::GetInputSamplesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputAnnotationResponse>* PrepareAsyncGetInputSamplesRaw(::grpc::ClientContext* context, const ::clarifai::api::GetInputSamplesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleInputResponse>* AsyncGetInputRaw(::grpc::ClientContext* context, const ::clarifai::api::GetInputRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleInputResponse>* PrepareAsyncGetInputRaw(::grpc::ClientContext* context, const ::clarifai::api::GetInputRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>* AsyncListInputsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListInputsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>* PrepareAsyncListInputsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListInputsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>* AsyncPostInputsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostInputsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>* PrepareAsyncPostInputsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostInputsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>* AsyncPatchInputsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchInputsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>* PrepareAsyncPatchInputsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchInputsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* AsyncDeleteInputRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteInputRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* AsyncDeleteInputsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteInputsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteInputsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>* AsyncPostInputsSearchesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostInputsSearchesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>* PrepareAsyncPostInputsSearchesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostInputsSearchesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiOutputResponse>* AsyncPostModelOutputsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostModelOutputsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiOutputResponse>* PrepareAsyncPostModelOutputsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostModelOutputsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelTypeResponse>* AsyncGetModelTypeRaw(::grpc::ClientContext* context, const ::clarifai::api::GetModelTypeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelTypeResponse>* PrepareAsyncGetModelTypeRaw(::grpc::ClientContext* context, const ::clarifai::api::GetModelTypeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelTypeResponse>* AsyncListModelTypesRaw(::grpc::ClientContext* context, const ::clarifai::api::ListModelTypesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelTypeResponse>* PrepareAsyncListModelTypesRaw(::grpc::ClientContext* context, const ::clarifai::api::ListModelTypesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelResponse>* AsyncGetModelRaw(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelResponse>* PrepareAsyncGetModelRaw(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelResponse>* AsyncGetModelOutputInfoRaw(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelResponse>* PrepareAsyncGetModelOutputInfoRaw(::grpc::ClientContext* context, const ::clarifai::api::GetModelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelResponse>* AsyncListModelsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListModelsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelResponse>* PrepareAsyncListModelsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListModelsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelResponse>* AsyncPostModelsSearchesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostModelsSearchesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelResponse>* PrepareAsyncPostModelsSearchesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostModelsSearchesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelResponse>* AsyncPostModelsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostModelsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelResponse>* PrepareAsyncPostModelsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostModelsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelResponse>* AsyncPatchModelsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchModelsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelResponse>* PrepareAsyncPatchModelsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchModelsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* AsyncDeleteModelRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteModelRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* AsyncDeleteModelsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteModelsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>* AsyncListModelInputsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListModelInputsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiInputResponse>* PrepareAsyncListModelInputsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListModelInputsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelVersionResponse>* AsyncGetModelVersionRaw(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelVersionResponse>* PrepareAsyncGetModelVersionRaw(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelVersionResponse>* AsyncListModelVersionsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListModelVersionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiModelVersionResponse>* PrepareAsyncListModelVersionsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListModelVersionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelResponse>* AsyncPostModelVersionsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelResponse>* PrepareAsyncPostModelVersionsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* AsyncDeleteModelVersionRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelVersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteModelVersionRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteModelVersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelVersionResponse>* AsyncGetModelVersionMetricsRaw(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionMetricsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelVersionResponse>* PrepareAsyncGetModelVersionMetricsRaw(::grpc::ClientContext* context, const ::clarifai::api::GetModelVersionMetricsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelVersionResponse>* AsyncPostModelVersionMetricsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionMetricsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleModelVersionResponse>* PrepareAsyncPostModelVersionMetricsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostModelVersionMetricsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleWorkflowResponse>* AsyncGetWorkflowRaw(::grpc::ClientContext* context, const ::clarifai::api::GetWorkflowRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleWorkflowResponse>* PrepareAsyncGetWorkflowRaw(::grpc::ClientContext* context, const ::clarifai::api::GetWorkflowRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiWorkflowResponse>* AsyncListWorkflowsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListWorkflowsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiWorkflowResponse>* PrepareAsyncListWorkflowsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListWorkflowsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiWorkflowResponse>* AsyncPostWorkflowsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiWorkflowResponse>* PrepareAsyncPostWorkflowsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiWorkflowResponse>* AsyncPatchWorkflowsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchWorkflowsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiWorkflowResponse>* PrepareAsyncPatchWorkflowsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchWorkflowsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* AsyncDeleteWorkflowRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteWorkflowRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* AsyncDeleteWorkflowsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteWorkflowsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteWorkflowsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::PostWorkflowResultsResponse>* AsyncPostWorkflowResultsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::PostWorkflowResultsResponse>* PrepareAsyncPostWorkflowResultsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::PostWorkflowResultsSimilarityResponse>* AsyncPostWorkflowResultsSimilarityRaw(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsSimilarityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::PostWorkflowResultsSimilarityResponse>* PrepareAsyncPostWorkflowResultsSimilarityRaw(::grpc::ClientContext* context, const ::clarifai::api::PostWorkflowResultsSimilarityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleKeyResponse>* AsyncGetKeyRaw(::grpc::ClientContext* context, const ::clarifai::api::GetKeyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleKeyResponse>* PrepareAsyncGetKeyRaw(::grpc::ClientContext* context, const ::clarifai::api::GetKeyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKeyResponse>* AsyncListKeysRaw(::grpc::ClientContext* context, const ::clarifai::api::ListKeysRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKeyResponse>* PrepareAsyncListKeysRaw(::grpc::ClientContext* context, const ::clarifai::api::ListKeysRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKeyResponse>* AsyncListAppKeysRaw(::grpc::ClientContext* context, const ::clarifai::api::ListAppKeysRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKeyResponse>* PrepareAsyncListAppKeysRaw(::grpc::ClientContext* context, const ::clarifai::api::ListAppKeysRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* AsyncDeleteKeyRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteKeyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteKeyRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteKeyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKeyResponse>* AsyncPostKeysRaw(::grpc::ClientContext* context, const ::clarifai::api::PostKeysRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKeyResponse>* PrepareAsyncPostKeysRaw(::grpc::ClientContext* context, const ::clarifai::api::PostKeysRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKeyResponse>* AsyncPatchKeysRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchKeysRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiKeyResponse>* PrepareAsyncPatchKeysRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchKeysRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiScopeResponse>* AsyncMyScopesRaw(::grpc::ClientContext* context, const ::clarifai::api::MyScopesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiScopeResponse>* PrepareAsyncMyScopesRaw(::grpc::ClientContext* context, const ::clarifai::api::MyScopesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiScopeDepsResponse>* AsyncListScopesRaw(::grpc::ClientContext* context, const ::clarifai::api::ListScopesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiScopeDepsResponse>* PrepareAsyncListScopesRaw(::grpc::ClientContext* context, const ::clarifai::api::ListScopesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleAppResponse>* AsyncGetAppRaw(::grpc::ClientContext* context, const ::clarifai::api::GetAppRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleAppResponse>* PrepareAsyncGetAppRaw(::grpc::ClientContext* context, const ::clarifai::api::GetAppRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppResponse>* AsyncListAppsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListAppsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppResponse>* PrepareAsyncListAppsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListAppsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* AsyncDeleteAppRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteAppRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteAppRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteAppRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppResponse>* AsyncPostAppsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostAppsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppResponse>* PrepareAsyncPostAppsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostAppsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppResponse>* AsyncPatchAppsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchAppsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppResponse>* PrepareAsyncPatchAppsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchAppsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppResponse>* AsyncPostAppsSearchesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostAppsSearchesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppResponse>* PrepareAsyncPostAppsSearchesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostAppsSearchesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SinglePasswordValidationResponse>* AsyncPostValidatePasswordRaw(::grpc::ClientContext* context, const ::clarifai::api::PostValidatePasswordRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SinglePasswordValidationResponse>* PrepareAsyncPostValidatePasswordRaw(::grpc::ClientContext* context, const ::clarifai::api::PostValidatePasswordRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleSearchResponse>* AsyncGetSearchRaw(::grpc::ClientContext* context, const ::clarifai::api::GetSearchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleSearchResponse>* PrepareAsyncGetSearchRaw(::grpc::ClientContext* context, const ::clarifai::api::GetSearchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>* AsyncListSearchesRaw(::grpc::ClientContext* context, const ::clarifai::api::ListSearchesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>* PrepareAsyncListSearchesRaw(::grpc::ClientContext* context, const ::clarifai::api::ListSearchesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>* AsyncPostSearchesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>* PrepareAsyncPostSearchesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>* AsyncPostSearchesByIDRaw(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesByIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiSearchResponse>* PrepareAsyncPostSearchesByIDRaw(::grpc::ClientContext* context, const ::clarifai::api::PostSearchesByIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationSearchMetricsResponse>* AsyncPostAnnotationSearchMetricsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationSearchMetricsResponse>* PrepareAsyncPostAnnotationSearchMetricsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationSearchMetricsResponse>* AsyncGetAnnotationSearchMetricsRaw(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationSearchMetricsResponse>* PrepareAsyncGetAnnotationSearchMetricsRaw(::grpc::ClientContext* context, const ::clarifai::api::GetAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationSearchMetricsResponse>* AsyncListAnnotationSearchMetricsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAnnotationSearchMetricsResponse>* PrepareAsyncListAnnotationSearchMetricsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* AsyncDeleteAnnotationSearchMetricsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteAnnotationSearchMetricsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteAnnotationSearchMetricsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* AsyncDeleteSearchRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteSearchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteSearchRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteSearchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiStatusCodeResponse>* AsyncListStatusCodesRaw(::grpc::ClientContext* context, const ::clarifai::api::ListStatusCodesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiStatusCodeResponse>* PrepareAsyncListStatusCodesRaw(::grpc::ClientContext* context, const ::clarifai::api::ListStatusCodesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleStatusCodeResponse>* AsyncGetStatusCodeRaw(::grpc::ClientContext* context, const ::clarifai::api::GetStatusCodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleStatusCodeResponse>* PrepareAsyncGetStatusCodeRaw(::grpc::ClientContext* context, const ::clarifai::api::GetStatusCodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollaboratorsResponse>* AsyncListCollaboratorsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollaboratorsResponse>* PrepareAsyncListCollaboratorsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollaboratorsResponse>* AsyncPostCollaboratorsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollaboratorsResponse>* PrepareAsyncPostCollaboratorsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollaboratorsResponse>* AsyncPatchCollaboratorsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollaboratorsResponse>* PrepareAsyncPatchCollaboratorsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* AsyncDeleteCollaboratorsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteCollaboratorsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollaboratorsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollaborationsResponse>* AsyncListCollaborationsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListCollaborationsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollaborationsResponse>* PrepareAsyncListCollaborationsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListCollaborationsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppDuplicationsResponse>* AsyncPostAppDuplicationsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostAppDuplicationsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppDuplicationsResponse>* PrepareAsyncPostAppDuplicationsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostAppDuplicationsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppDuplicationsResponse>* AsyncListAppDuplicationsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListAppDuplicationsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiAppDuplicationsResponse>* PrepareAsyncListAppDuplicationsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListAppDuplicationsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleAppDuplicationResponse>* AsyncGetAppDuplicationRaw(::grpc::ClientContext* context, const ::clarifai::api::GetAppDuplicationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleAppDuplicationResponse>* PrepareAsyncGetAppDuplicationRaw(::grpc::ClientContext* context, const ::clarifai::api::GetAppDuplicationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiTaskResponse>* AsyncPostTasksRaw(::grpc::ClientContext* context, const ::clarifai::api::PostTasksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiTaskResponse>* PrepareAsyncPostTasksRaw(::grpc::ClientContext* context, const ::clarifai::api::PostTasksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleTaskCountResponse>* AsyncGetTaskAnnotationCountRaw(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleTaskCountResponse>* PrepareAsyncGetTaskAnnotationCountRaw(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleTaskCountResponse>* AsyncGetTaskInputCountRaw(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleTaskCountResponse>* PrepareAsyncGetTaskInputCountRaw(::grpc::ClientContext* context, const ::clarifai::api::GetTaskCountRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleTaskResponse>* AsyncGetTaskRaw(::grpc::ClientContext* context, const ::clarifai::api::GetTaskRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleTaskResponse>* PrepareAsyncGetTaskRaw(::grpc::ClientContext* context, const ::clarifai::api::GetTaskRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiTaskResponse>* AsyncListTasksRaw(::grpc::ClientContext* context, const ::clarifai::api::ListTasksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiTaskResponse>* PrepareAsyncListTasksRaw(::grpc::ClientContext* context, const ::clarifai::api::ListTasksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiTaskResponse>* AsyncPatchTasksRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchTasksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiTaskResponse>* PrepareAsyncPatchTasksRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchTasksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* AsyncDeleteTasksRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteTasksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteTasksRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteTasksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollectorResponse>* AsyncPostCollectorsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostCollectorsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollectorResponse>* PrepareAsyncPostCollectorsRaw(::grpc::ClientContext* context, const ::clarifai::api::PostCollectorsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleCollectorResponse>* AsyncGetCollectorRaw(::grpc::ClientContext* context, const ::clarifai::api::GetCollectorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::SingleCollectorResponse>* PrepareAsyncGetCollectorRaw(::grpc::ClientContext* context, const ::clarifai::api::GetCollectorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollectorResponse>* AsyncListCollectorsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListCollectorsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollectorResponse>* PrepareAsyncListCollectorsRaw(::grpc::ClientContext* context, const ::clarifai::api::ListCollectorsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollectorResponse>* AsyncPatchCollectorsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchCollectorsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiCollectorResponse>* PrepareAsyncPatchCollectorsRaw(::grpc::ClientContext* context, const ::clarifai::api::PatchCollectorsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* AsyncDeleteCollectorsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollectorsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::status::BaseResponse>* PrepareAsyncDeleteCollectorsRaw(::grpc::ClientContext* context, const ::clarifai::api::DeleteCollectorsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiStatValueResponse>* AsyncPostStatValuesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiStatValueResponse>* PrepareAsyncPostStatValuesRaw(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiStatValueAggregateResponse>* AsyncPostStatValuesAggregateRaw(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesAggregateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::clarifai::api::MultiStatValueAggregateResponse>* PrepareAsyncPostStatValuesAggregateRaw(::grpc::ClientContext* context, const ::clarifai::api::PostStatValuesAggregateRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_ListConceptRelations_;
    const ::grpc::internal::RpcMethod rpcmethod_PostConceptRelations_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteConceptRelations_;
    const ::grpc::internal::RpcMethod rpcmethod_GetConceptCounts_;
    const ::grpc::internal::RpcMethod rpcmethod_GetConcept_;
    const ::grpc::internal::RpcMethod rpcmethod_ListConcepts_;
    const ::grpc::internal::RpcMethod rpcmethod_PostConceptsSearches_;
    const ::grpc::internal::RpcMethod rpcmethod_PostConcepts_;
    const ::grpc::internal::RpcMethod rpcmethod_PatchConcepts_;
    const ::grpc::internal::RpcMethod rpcmethod_GetConceptLanguage_;
    const ::grpc::internal::RpcMethod rpcmethod_ListConceptLanguages_;
    const ::grpc::internal::RpcMethod rpcmethod_PostConceptLanguages_;
    const ::grpc::internal::RpcMethod rpcmethod_PatchConceptLanguages_;
    const ::grpc::internal::RpcMethod rpcmethod_ListKnowledgeGraphs_;
    const ::grpc::internal::RpcMethod rpcmethod_PostKnowledgeGraphs_;
    const ::grpc::internal::RpcMethod rpcmethod_PostConceptMappingJobs_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAnnotation_;
    const ::grpc::internal::RpcMethod rpcmethod_ListAnnotations_;
    const ::grpc::internal::RpcMethod rpcmethod_PostAnnotations_;
    const ::grpc::internal::RpcMethod rpcmethod_PatchAnnotations_;
    const ::grpc::internal::RpcMethod rpcmethod_PatchAnnotationsStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteAnnotation_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteAnnotations_;
    const ::grpc::internal::RpcMethod rpcmethod_PostAnnotationsSearches_;
    const ::grpc::internal::RpcMethod rpcmethod_GetInputCount_;
    const ::grpc::internal::RpcMethod rpcmethod_StreamInputs_;
    const ::grpc::internal::RpcMethod rpcmethod_GetInputSamples_;
    const ::grpc::internal::RpcMethod rpcmethod_GetInput_;
    const ::grpc::internal::RpcMethod rpcmethod_ListInputs_;
    const ::grpc::internal::RpcMethod rpcmethod_PostInputs_;
    const ::grpc::internal::RpcMethod rpcmethod_PatchInputs_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteInput_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteInputs_;
    const ::grpc::internal::RpcMethod rpcmethod_PostInputsSearches_;
    const ::grpc::internal::RpcMethod rpcmethod_PostModelOutputs_;
    const ::grpc::internal::RpcMethod rpcmethod_GetModelType_;
    const ::grpc::internal::RpcMethod rpcmethod_ListModelTypes_;
    const ::grpc::internal::RpcMethod rpcmethod_GetModel_;
    const ::grpc::internal::RpcMethod rpcmethod_GetModelOutputInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_ListModels_;
    const ::grpc::internal::RpcMethod rpcmethod_PostModelsSearches_;
    const ::grpc::internal::RpcMethod rpcmethod_PostModels_;
    const ::grpc::internal::RpcMethod rpcmethod_PatchModels_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteModel_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteModels_;
    const ::grpc::internal::RpcMethod rpcmethod_ListModelInputs_;
    const ::grpc::internal::RpcMethod rpcmethod_GetModelVersion_;
    const ::grpc::internal::RpcMethod rpcmethod_ListModelVersions_;
    const ::grpc::internal::RpcMethod rpcmethod_PostModelVersions_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteModelVersion_;
    const ::grpc::internal::RpcMethod rpcmethod_GetModelVersionMetrics_;
    const ::grpc::internal::RpcMethod rpcmethod_PostModelVersionMetrics_;
    const ::grpc::internal::RpcMethod rpcmethod_GetWorkflow_;
    const ::grpc::internal::RpcMethod rpcmethod_ListWorkflows_;
    const ::grpc::internal::RpcMethod rpcmethod_PostWorkflows_;
    const ::grpc::internal::RpcMethod rpcmethod_PatchWorkflows_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteWorkflow_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteWorkflows_;
    const ::grpc::internal::RpcMethod rpcmethod_PostWorkflowResults_;
    const ::grpc::internal::RpcMethod rpcmethod_PostWorkflowResultsSimilarity_;
    const ::grpc::internal::RpcMethod rpcmethod_GetKey_;
    const ::grpc::internal::RpcMethod rpcmethod_ListKeys_;
    const ::grpc::internal::RpcMethod rpcmethod_ListAppKeys_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteKey_;
    const ::grpc::internal::RpcMethod rpcmethod_PostKeys_;
    const ::grpc::internal::RpcMethod rpcmethod_PatchKeys_;
    const ::grpc::internal::RpcMethod rpcmethod_MyScopes_;
    const ::grpc::internal::RpcMethod rpcmethod_ListScopes_;
    const ::grpc::internal::RpcMethod rpcmethod_GetApp_;
    const ::grpc::internal::RpcMethod rpcmethod_ListApps_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteApp_;
    const ::grpc::internal::RpcMethod rpcmethod_PostApps_;
    const ::grpc::internal::RpcMethod rpcmethod_PatchApps_;
    const ::grpc::internal::RpcMethod rpcmethod_PostAppsSearches_;
    const ::grpc::internal::RpcMethod rpcmethod_PostValidatePassword_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSearch_;
    const ::grpc::internal::RpcMethod rpcmethod_ListSearches_;
    const ::grpc::internal::RpcMethod rpcmethod_PostSearches_;
    const ::grpc::internal::RpcMethod rpcmethod_PostSearchesByID_;
    const ::grpc::internal::RpcMethod rpcmethod_PostAnnotationSearchMetrics_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAnnotationSearchMetrics_;
    const ::grpc::internal::RpcMethod rpcmethod_ListAnnotationSearchMetrics_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteAnnotationSearchMetrics_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteSearch_;
    const ::grpc::internal::RpcMethod rpcmethod_ListStatusCodes_;
    const ::grpc::internal::RpcMethod rpcmethod_GetStatusCode_;
    const ::grpc::internal::RpcMethod rpcmethod_ListCollaborators_;
    const ::grpc::internal::RpcMethod rpcmethod_PostCollaborators_;
    const ::grpc::internal::RpcMethod rpcmethod_PatchCollaborators_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteCollaborators_;
    const ::grpc::internal::RpcMethod rpcmethod_ListCollaborations_;
    const ::grpc::internal::RpcMethod rpcmethod_PostAppDuplications_;
    const ::grpc::internal::RpcMethod rpcmethod_ListAppDuplications_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAppDuplication_;
    const ::grpc::internal::RpcMethod rpcmethod_PostTasks_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTaskAnnotationCount_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTaskInputCount_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTask_;
    const ::grpc::internal::RpcMethod rpcmethod_ListTasks_;
    const ::grpc::internal::RpcMethod rpcmethod_PatchTasks_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteTasks_;
    const ::grpc::internal::RpcMethod rpcmethod_PostCollectors_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCollector_;
    const ::grpc::internal::RpcMethod rpcmethod_ListCollectors_;
    const ::grpc::internal::RpcMethod rpcmethod_PatchCollectors_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteCollectors_;
    const ::grpc::internal::RpcMethod rpcmethod_PostStatValues_;
    const ::grpc::internal::RpcMethod rpcmethod_PostStatValuesAggregate_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // //////////////////////////////////////
    // Concept Relationships
    // //////////////////////////////////////
    //
    // List concept relations between concepts in the platform.
    // MUST be above ListConcepts so that if concept_id is empty this will still match
    // /concepts/relations to list all the concept relations in the app.
    virtual ::grpc::Status ListConceptRelations(::grpc::ServerContext* context, const ::clarifai::api::ListConceptRelationsRequest* request, ::clarifai::api::MultiConceptRelationResponse* response);
    // Post concept relations to create relations between concepts in the platform.
    virtual ::grpc::Status PostConceptRelations(::grpc::ServerContext* context, const ::clarifai::api::PostConceptRelationsRequest* request, ::clarifai::api::MultiConceptRelationResponse* response);
    // Post concept relations to create relations between concepts in the platform.
    virtual ::grpc::Status DeleteConceptRelations(::grpc::ServerContext* context, const ::clarifai::api::DeleteConceptRelationsRequest* request, ::clarifai::api::status::BaseResponse* response);
    // //////////////////////////////////////
    // Concepts
    // //////////////////////////////////////
    //
    // List all the concepts with their positive and negative counts
    virtual ::grpc::Status GetConceptCounts(::grpc::ServerContext* context, const ::clarifai::api::GetConceptCountsRequest* request, ::clarifai::api::MultiConceptCountResponse* response);
    // Get a specific concept from an app.
    virtual ::grpc::Status GetConcept(::grpc::ServerContext* context, const ::clarifai::api::GetConceptRequest* request, ::clarifai::api::SingleConceptResponse* response);
    // List all the concepts.
    virtual ::grpc::Status ListConcepts(::grpc::ServerContext* context, const ::clarifai::api::ListConceptsRequest* request, ::clarifai::api::MultiConceptResponse* response);
    // Search over the concepts to find one or more you're looking for.
    // This leverage the "body" parameter because we also have page and
    // per_page as url query param variables in this request.
    virtual ::grpc::Status PostConceptsSearches(::grpc::ServerContext* context, const ::clarifai::api::PostConceptsSearchesRequest* request, ::clarifai::api::MultiConceptResponse* response);
    // Add a concept to an app.
    virtual ::grpc::Status PostConcepts(::grpc::ServerContext* context, const ::clarifai::api::PostConceptsRequest* request, ::clarifai::api::MultiConceptResponse* response);
    // Patch one or more concepts.
    virtual ::grpc::Status PatchConcepts(::grpc::ServerContext* context, const ::clarifai::api::PatchConceptsRequest* request, ::clarifai::api::MultiConceptResponse* response);
    // //////////////////////////////////////
    //
    // //////////////////////////////////////
    // Concept Languages
    // //////////////////////////////////////
    //
    // Get a specific concept from an app.
    virtual ::grpc::Status GetConceptLanguage(::grpc::ServerContext* context, const ::clarifai::api::GetConceptLanguageRequest* request, ::clarifai::api::SingleConceptLanguageResponse* response);
    // List the concept in all the translated languages.
    virtual ::grpc::Status ListConceptLanguages(::grpc::ServerContext* context, const ::clarifai::api::ListConceptLanguagesRequest* request, ::clarifai::api::MultiConceptLanguageResponse* response);
    // Add a new tranlsation for this concept.
    virtual ::grpc::Status PostConceptLanguages(::grpc::ServerContext* context, const ::clarifai::api::PostConceptLanguagesRequest* request, ::clarifai::api::MultiConceptLanguageResponse* response);
    // Patch the name for a given language names by passing in a list of concepts with the new names
    // for the languages.
    virtual ::grpc::Status PatchConceptLanguages(::grpc::ServerContext* context, const ::clarifai::api::PatchConceptLanguagesRequest* request, ::clarifai::api::MultiConceptLanguageResponse* response);
    // //////////////////////////////////////
    // Knowledge Graph
    // //////////////////////////////////////
    //
    // List all domain graphs.
    virtual ::grpc::Status ListKnowledgeGraphs(::grpc::ServerContext* context, const ::clarifai::api::ListKnowledgeGraphsRequest* request, ::clarifai::api::MultiKnowledgeGraphResponse* response);
    // Post domain graphs.
    virtual ::grpc::Status PostKnowledgeGraphs(::grpc::ServerContext* context, const ::clarifai::api::PostKnowledgeGraphsRequest* request, ::clarifai::api::MultiKnowledgeGraphResponse* response);
    // Start concept mapping jobs.
    virtual ::grpc::Status PostConceptMappingJobs(::grpc::ServerContext* context, const ::clarifai::api::PostConceptMappingJobsRequest* request, ::clarifai::api::MultiConceptMappingJobResponse* response);
    // //////////////////////////////////////
    // annotations
    // //////////////////////////////////////
    //
    // Get a specific annotation from an app.
    virtual ::grpc::Status GetAnnotation(::grpc::ServerContext* context, const ::clarifai::api::GetAnnotationRequest* request, ::clarifai::api::SingleAnnotationResponse* response);
    // List all the annotation.
    virtual ::grpc::Status ListAnnotations(::grpc::ServerContext* context, const ::clarifai::api::ListAnnotationsRequest* request, ::clarifai::api::MultiAnnotationResponse* response);
    // Post annotations.
    virtual ::grpc::Status PostAnnotations(::grpc::ServerContext* context, const ::clarifai::api::PostAnnotationsRequest* request, ::clarifai::api::MultiAnnotationResponse* response);
    // Patch one or more annotations.
    virtual ::grpc::Status PatchAnnotations(::grpc::ServerContext* context, const ::clarifai::api::PatchAnnotationsRequest* request, ::clarifai::api::MultiAnnotationResponse* response);
    // Patch annotations status by worker id and task id.
    virtual ::grpc::Status PatchAnnotationsStatus(::grpc::ServerContext* context, const ::clarifai::api::PatchAnnotationsStatusRequest* request, ::clarifai::api::PatchAnnotationsStatusResponse* response);
    // Delete a single annotation.
    virtual ::grpc::Status DeleteAnnotation(::grpc::ServerContext* context, const ::clarifai::api::DeleteAnnotationRequest* request, ::clarifai::api::status::BaseResponse* response);
    // Delete multiple annotations in one request.
    virtual ::grpc::Status DeleteAnnotations(::grpc::ServerContext* context, const ::clarifai::api::DeleteAnnotationsRequest* request, ::clarifai::api::status::BaseResponse* response);
    // Execute a search over annotation
    virtual ::grpc::Status PostAnnotationsSearches(::grpc::ServerContext* context, const ::clarifai::api::PostAnnotationsSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response);
    // //////////////////////////////////////
    // Inputs
    // //////////////////////////////////////
    //
    // Get input count per status.
    virtual ::grpc::Status GetInputCount(::grpc::ServerContext* context, const ::clarifai::api::GetInputCountRequest* request, ::clarifai::api::SingleInputCountResponse* response);
    // Streams all the inputs starting from oldest assets.
    virtual ::grpc::Status StreamInputs(::grpc::ServerContext* context, const ::clarifai::api::StreamInputsRequest* request, ::clarifai::api::MultiInputResponse* response);
    // Get a specific input from an app.
    virtual ::grpc::Status GetInputSamples(::grpc::ServerContext* context, const ::clarifai::api::GetInputSamplesRequest* request, ::clarifai::api::MultiInputAnnotationResponse* response);
    // Get a specific input from an app.
    virtual ::grpc::Status GetInput(::grpc::ServerContext* context, const ::clarifai::api::GetInputRequest* request, ::clarifai::api::SingleInputResponse* response);
    // List all the inputs.
    virtual ::grpc::Status ListInputs(::grpc::ServerContext* context, const ::clarifai::api::ListInputsRequest* request, ::clarifai::api::MultiInputResponse* response);
    // Add an input (or set of inputs) to an app.
    // This call is synchronous if the PostInputsRequest contains exactly one image input. Otherwise,
    // it is asynchronous.
    virtual ::grpc::Status PostInputs(::grpc::ServerContext* context, const ::clarifai::api::PostInputsRequest* request, ::clarifai::api::MultiInputResponse* response);
    // Patch one or more inputs.
    virtual ::grpc::Status PatchInputs(::grpc::ServerContext* context, const ::clarifai::api::PatchInputsRequest* request, ::clarifai::api::MultiInputResponse* response);
    // Delete a single input.  This call is synchronous.
    virtual ::grpc::Status DeleteInput(::grpc::ServerContext* context, const ::clarifai::api::DeleteInputRequest* request, ::clarifai::api::status::BaseResponse* response);
    // Delete multiple inputs in one request.
    // This call is asynchronous. Use DeleteInput if you want a synchronous version.
    virtual ::grpc::Status DeleteInputs(::grpc::ServerContext* context, const ::clarifai::api::DeleteInputsRequest* request, ::clarifai::api::status::BaseResponse* response);
    // Execute a search over input
    virtual ::grpc::Status PostInputsSearches(::grpc::ServerContext* context, const ::clarifai::api::PostInputsSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response);
    // Get predicted outputs from the model.
    virtual ::grpc::Status PostModelOutputs(::grpc::ServerContext* context, const ::clarifai::api::PostModelOutputsRequest* request, ::clarifai::api::MultiOutputResponse* response);
    // //////////////////////////////////////
    //
    // //////////////////////////////////////
    // Models
    // //////////////////////////////////////
    //
    // Get a specific model type.
    virtual ::grpc::Status GetModelType(::grpc::ServerContext* context, const ::clarifai::api::GetModelTypeRequest* request, ::clarifai::api::SingleModelTypeResponse* response);
    // List all the model types available in the platform.
    // This MUST be above ListModels so that the /models/types endpoint takes precedence.
    virtual ::grpc::Status ListModelTypes(::grpc::ServerContext* context, const ::clarifai::api::ListModelTypesRequest* request, ::clarifai::api::MultiModelTypeResponse* response);
    // Get a specific model from an app.
    virtual ::grpc::Status GetModel(::grpc::ServerContext* context, const ::clarifai::api::GetModelRequest* request, ::clarifai::api::SingleModelResponse* response);
    // Get a the output info for a given model_id or model_id/version_id
    // combo.
    virtual ::grpc::Status GetModelOutputInfo(::grpc::ServerContext* context, const ::clarifai::api::GetModelRequest* request, ::clarifai::api::SingleModelResponse* response);
    // List all the models.
    virtual ::grpc::Status ListModels(::grpc::ServerContext* context, const ::clarifai::api::ListModelsRequest* request, ::clarifai::api::MultiModelResponse* response);
    // Search over the models to find one or more you're looking for.
    // This leverage the "body" parameter because we also have page and
    // per_page as url query param variables in this request.
    virtual ::grpc::Status PostModelsSearches(::grpc::ServerContext* context, const ::clarifai::api::PostModelsSearchesRequest* request, ::clarifai::api::MultiModelResponse* response);
    // Add a models to an app.
    // FIXME(zeiler): this should have been a plural response.
    virtual ::grpc::Status PostModels(::grpc::ServerContext* context, const ::clarifai::api::PostModelsRequest* request, ::clarifai::api::SingleModelResponse* response);
    // Patch one or more models.
    virtual ::grpc::Status PatchModels(::grpc::ServerContext* context, const ::clarifai::api::PatchModelsRequest* request, ::clarifai::api::MultiModelResponse* response);
    // Delete a single model.
    virtual ::grpc::Status DeleteModel(::grpc::ServerContext* context, const ::clarifai::api::DeleteModelRequest* request, ::clarifai::api::status::BaseResponse* response);
    // Delete multiple models in one request.
    virtual ::grpc::Status DeleteModels(::grpc::ServerContext* context, const ::clarifai::api::DeleteModelsRequest* request, ::clarifai::api::status::BaseResponse* response);
    // List all the inputs.
    virtual ::grpc::Status ListModelInputs(::grpc::ServerContext* context, const ::clarifai::api::ListModelInputsRequest* request, ::clarifai::api::MultiInputResponse* response);
    // //////////////////////////////////////
    //
    // //////////////////////////////////////
    // Model versions
    // //////////////////////////////////////
    //
    // Get a specific model from an app.
    virtual ::grpc::Status GetModelVersion(::grpc::ServerContext* context, const ::clarifai::api::GetModelVersionRequest* request, ::clarifai::api::SingleModelVersionResponse* response);
    // List all the models.
    virtual ::grpc::Status ListModelVersions(::grpc::ServerContext* context, const ::clarifai::api::ListModelVersionsRequest* request, ::clarifai::api::MultiModelVersionResponse* response);
    // NOTE: inconsistency: do we want this to return a SingleModelResponse?
    //
    // Create a new model version to trigger training of the model.
    // FIXME(zeiler): this should have been a plural response.
    virtual ::grpc::Status PostModelVersions(::grpc::ServerContext* context, const ::clarifai::api::PostModelVersionsRequest* request, ::clarifai::api::SingleModelResponse* response);
    // Delete a single model.
    virtual ::grpc::Status DeleteModelVersion(::grpc::ServerContext* context, const ::clarifai::api::DeleteModelVersionRequest* request, ::clarifai::api::status::BaseResponse* response);
    // Get the evaluation metrics for a model version.
    virtual ::grpc::Status GetModelVersionMetrics(::grpc::ServerContext* context, const ::clarifai::api::GetModelVersionMetricsRequest* request, ::clarifai::api::SingleModelVersionResponse* response);
    // Run the evaluation metrics for a model version.
    virtual ::grpc::Status PostModelVersionMetrics(::grpc::ServerContext* context, const ::clarifai::api::PostModelVersionMetricsRequest* request, ::clarifai::api::SingleModelVersionResponse* response);
    // //////////////////////////////////////
    //
    // //////////////////////////////////////
    // Workflows
    // //////////////////////////////////////
    //
    // Get a specific workflow from an app.
    virtual ::grpc::Status GetWorkflow(::grpc::ServerContext* context, const ::clarifai::api::GetWorkflowRequest* request, ::clarifai::api::SingleWorkflowResponse* response);
    // List all the workflows.
    virtual ::grpc::Status ListWorkflows(::grpc::ServerContext* context, const ::clarifai::api::ListWorkflowsRequest* request, ::clarifai::api::MultiWorkflowResponse* response);
    // Add a workflow to an app.
    virtual ::grpc::Status PostWorkflows(::grpc::ServerContext* context, const ::clarifai::api::PostWorkflowsRequest* request, ::clarifai::api::MultiWorkflowResponse* response);
    // Patch one or more workflows.
    virtual ::grpc::Status PatchWorkflows(::grpc::ServerContext* context, const ::clarifai::api::PatchWorkflowsRequest* request, ::clarifai::api::MultiWorkflowResponse* response);
    // Delete a single workflow.
    virtual ::grpc::Status DeleteWorkflow(::grpc::ServerContext* context, const ::clarifai::api::DeleteWorkflowRequest* request, ::clarifai::api::status::BaseResponse* response);
    // Delete multiple workflows in one request.
    virtual ::grpc::Status DeleteWorkflows(::grpc::ServerContext* context, const ::clarifai::api::DeleteWorkflowsRequest* request, ::clarifai::api::status::BaseResponse* response);
    // Predict using a workflow.
    virtual ::grpc::Status PostWorkflowResults(::grpc::ServerContext* context, const ::clarifai::api::PostWorkflowResultsRequest* request, ::clarifai::api::PostWorkflowResultsResponse* response);
    // Compare embeddings distances using a workflow
    //
    virtual ::grpc::Status PostWorkflowResultsSimilarity(::grpc::ServerContext* context, const ::clarifai::api::PostWorkflowResultsSimilarityRequest* request, ::clarifai::api::PostWorkflowResultsSimilarityResponse* response);
    // //////////////////////////////////////
    // API Keys
    // //////////////////////////////////////
    //
    // Get a specific key from an app.
    virtual ::grpc::Status GetKey(::grpc::ServerContext* context, const ::clarifai::api::GetKeyRequest* request, ::clarifai::api::SingleKeyResponse* response);
    // List all the keys.
    virtual ::grpc::Status ListKeys(::grpc::ServerContext* context, const ::clarifai::api::ListKeysRequest* request, ::clarifai::api::MultiKeyResponse* response);
    // List keys by app_id
    virtual ::grpc::Status ListAppKeys(::grpc::ServerContext* context, const ::clarifai::api::ListAppKeysRequest* request, ::clarifai::api::MultiKeyResponse* response);
    // Search over the keys to find one or more you're looking for.
    // This leverage the "body" parameter because we also have page and
    // per_page as url query param variables in this request.
    virtual ::grpc::Status DeleteKey(::grpc::ServerContext* context, const ::clarifai::api::DeleteKeyRequest* request, ::clarifai::api::status::BaseResponse* response);
    // Add a key to an app.
    virtual ::grpc::Status PostKeys(::grpc::ServerContext* context, const ::clarifai::api::PostKeysRequest* request, ::clarifai::api::MultiKeyResponse* response);
    // Patch one or more keys.
    virtual ::grpc::Status PatchKeys(::grpc::ServerContext* context, const ::clarifai::api::PatchKeysRequest* request, ::clarifai::api::MultiKeyResponse* response);
    // API Keys in the public API -- request is itself Key authorized, and will tell
    // the user the scopes/access of the key/credential they're providing, as computed by
    // our authorizer:
    virtual ::grpc::Status MyScopes(::grpc::ServerContext* context, const ::clarifai::api::MyScopesRequest* request, ::clarifai::api::MultiScopeResponse* response);
    // List all auth scopes available.
    virtual ::grpc::Status ListScopes(::grpc::ServerContext* context, const ::clarifai::api::ListScopesRequest* request, ::clarifai::api::MultiScopeDepsResponse* response);
    // //////////////////////////////////////
    // Apps
    // //////////////////////////////////////
    //
    // Get a specific app from an app.
    virtual ::grpc::Status GetApp(::grpc::ServerContext* context, const ::clarifai::api::GetAppRequest* request, ::clarifai::api::SingleAppResponse* response);
    // List all the apps.
    virtual ::grpc::Status ListApps(::grpc::ServerContext* context, const ::clarifai::api::ListAppsRequest* request, ::clarifai::api::MultiAppResponse* response);
    // Search over the apps to find one or more you're looking for.
    // This leverage the "body" parameter because we also have page and
    // per_page as url query param variables in this request.
    virtual ::grpc::Status DeleteApp(::grpc::ServerContext* context, const ::clarifai::api::DeleteAppRequest* request, ::clarifai::api::status::BaseResponse* response);
    // Add a app to an app.
    // This needs to load the default workflow to make a copy, validating all the models in it, and
    // then writing the new workflow back to this new app.
    virtual ::grpc::Status PostApps(::grpc::ServerContext* context, const ::clarifai::api::PostAppsRequest* request, ::clarifai::api::MultiAppResponse* response);
    // Patch one or more apps.
    virtual ::grpc::Status PatchApps(::grpc::ServerContext* context, const ::clarifai::api::PatchAppsRequest* request, ::clarifai::api::MultiAppResponse* response);
    // Search over the applications to find one or more you're looking for.
    virtual ::grpc::Status PostAppsSearches(::grpc::ServerContext* context, const ::clarifai::api::PostAppsSearchesRequest* request, ::clarifai::api::MultiAppResponse* response);
    // //////////////////////////////////////
    //
    // //////////////////////////////////////
    // Password
    // //////////////////////////////////////
    //
    // Validate new password in real-time for a user
    virtual ::grpc::Status PostValidatePassword(::grpc::ServerContext* context, const ::clarifai::api::PostValidatePasswordRequest* request, ::clarifai::api::SinglePasswordValidationResponse* response);
    // //////////////////////////////////////
    // Searches
    // //////////////////////////////////////
    //
    // Get a saved search.
    virtual ::grpc::Status GetSearch(::grpc::ServerContext* context, const ::clarifai::api::GetSearchRequest* request, ::clarifai::api::SingleSearchResponse* response);
    // List all saved searches.
    virtual ::grpc::Status ListSearches(::grpc::ServerContext* context, const ::clarifai::api::ListSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response);
    // Execute a new search and optionally save it.
    virtual ::grpc::Status PostSearches(::grpc::ServerContext* context, const ::clarifai::api::PostSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response);
    // Execute a previously saved search.
    virtual ::grpc::Status PostSearchesByID(::grpc::ServerContext* context, const ::clarifai::api::PostSearchesByIDRequest* request, ::clarifai::api::MultiSearchResponse* response);
    // Evaluate the results of two search requests
    virtual ::grpc::Status PostAnnotationSearchMetrics(::grpc::ServerContext* context, const ::clarifai::api::PostAnnotationSearchMetricsRequest* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response);
    // Get the evaluation results between two search requests
    virtual ::grpc::Status GetAnnotationSearchMetrics(::grpc::ServerContext* context, const ::clarifai::api::GetAnnotationSearchMetricsRequest* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response);
    // List the evaluation results between two search requests
    virtual ::grpc::Status ListAnnotationSearchMetrics(::grpc::ServerContext* context, const ::clarifai::api::ListAnnotationSearchMetricsRequest* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response);
    virtual ::grpc::Status DeleteAnnotationSearchMetrics(::grpc::ServerContext* context, const ::clarifai::api::DeleteAnnotationSearchMetricsRequest* request, ::clarifai::api::status::BaseResponse* response);
    // Delete a saved search.
    virtual ::grpc::Status DeleteSearch(::grpc::ServerContext* context, const ::clarifai::api::DeleteSearchRequest* request, ::clarifai::api::status::BaseResponse* response);
    // //////////////////////////////////////
    //
    // //////////////////////////////////////
    // Status Codes
    // //////////////////////////////////////
    //
    // List all status codes.
    virtual ::grpc::Status ListStatusCodes(::grpc::ServerContext* context, const ::clarifai::api::ListStatusCodesRequest* request, ::clarifai::api::MultiStatusCodeResponse* response);
    // Get more details for a status code.
    virtual ::grpc::Status GetStatusCode(::grpc::ServerContext* context, const ::clarifai::api::GetStatusCodeRequest* request, ::clarifai::api::SingleStatusCodeResponse* response);
    // //////////////////////////////////////
    // App Sharing
    // //////////////////////////////////////
    //
    // owner list users who the app is shared with
    virtual ::grpc::Status ListCollaborators(::grpc::ServerContext* context, const ::clarifai::api::ListCollaboratorsRequest* request, ::clarifai::api::MultiCollaboratorsResponse* response);
    // add collaborators to an app.
    virtual ::grpc::Status PostCollaborators(::grpc::ServerContext* context, const ::clarifai::api::PostCollaboratorsRequest* request, ::clarifai::api::MultiCollaboratorsResponse* response);
    // Patch existing collaborators.
    virtual ::grpc::Status PatchCollaborators(::grpc::ServerContext* context, const ::clarifai::api::PatchCollaboratorsRequest* request, ::clarifai::api::MultiCollaboratorsResponse* response);
    // Delete existing collaborators.
    virtual ::grpc::Status DeleteCollaborators(::grpc::ServerContext* context, const ::clarifai::api::DeleteCollaboratorsRequest* request, ::clarifai::api::status::BaseResponse* response);
    // Collaboration includes the app user are invitied to work on
    virtual ::grpc::Status ListCollaborations(::grpc::ServerContext* context, const ::clarifai::api::ListCollaborationsRequest* request, ::clarifai::api::MultiCollaborationsResponse* response);
    // //////////////////////////////////////
    // App duplication
    // //////////////////////////////////////
    //
    // start to duplicate an app which copies all the inputs, annotations, models, concepts etc. to a new app.
    // this is an async process, you should use ListAppDuplications or GetAppDuplication to check the status.
    virtual ::grpc::Status PostAppDuplications(::grpc::ServerContext* context, const ::clarifai::api::PostAppDuplicationsRequest* request, ::clarifai::api::MultiAppDuplicationsResponse* response);
    // list all the app duplications user triggers
    virtual ::grpc::Status ListAppDuplications(::grpc::ServerContext* context, const ::clarifai::api::ListAppDuplicationsRequest* request, ::clarifai::api::MultiAppDuplicationsResponse* response);
    // get the app duplication status
    virtual ::grpc::Status GetAppDuplication(::grpc::ServerContext* context, const ::clarifai::api::GetAppDuplicationRequest* request, ::clarifai::api::SingleAppDuplicationResponse* response);
    // //////////////////////////////////////
    // Tasks
    // //////////////////////////////////////
    //
    // Add tasks to an app.
    virtual ::grpc::Status PostTasks(::grpc::ServerContext* context, const ::clarifai::api::PostTasksRequest* request, ::clarifai::api::MultiTaskResponse* response);
    // Task annotation count
    virtual ::grpc::Status GetTaskAnnotationCount(::grpc::ServerContext* context, const ::clarifai::api::GetTaskCountRequest* request, ::clarifai::api::SingleTaskCountResponse* response);
    // Task Input count
    virtual ::grpc::Status GetTaskInputCount(::grpc::ServerContext* context, const ::clarifai::api::GetTaskCountRequest* request, ::clarifai::api::SingleTaskCountResponse* response);
    // Get a specific task from an app.
    virtual ::grpc::Status GetTask(::grpc::ServerContext* context, const ::clarifai::api::GetTaskRequest* request, ::clarifai::api::SingleTaskResponse* response);
    // List tasks from an app.
    virtual ::grpc::Status ListTasks(::grpc::ServerContext* context, const ::clarifai::api::ListTasksRequest* request, ::clarifai::api::MultiTaskResponse* response);
    // Patch one or more tasks.
    virtual ::grpc::Status PatchTasks(::grpc::ServerContext* context, const ::clarifai::api::PatchTasksRequest* request, ::clarifai::api::MultiTaskResponse* response);
    // Delete multiple tasks in one request.
    virtual ::grpc::Status DeleteTasks(::grpc::ServerContext* context, const ::clarifai::api::DeleteTasksRequest* request, ::clarifai::api::status::BaseResponse* response);
    // //////////////////////////////////////
    // Collectors
    // //////////////////////////////////////
    //
    // Add a list of Collectors to an app.
    // In the handler of this endpoint we also check for all the scopes of the  POST /inputs
    // endpoint.
    // Those current scopes are listed here as a hard requirement.
    // They are needed when adding the collectors just so we now that you have permission with
    // that key at least to do the writing to this app with POST /inputs.
    virtual ::grpc::Status PostCollectors(::grpc::ServerContext* context, const ::clarifai::api::PostCollectorsRequest* request, ::clarifai::api::MultiCollectorResponse* response);
    // Get a specific collector from an app.
    virtual ::grpc::Status GetCollector(::grpc::ServerContext* context, const ::clarifai::api::GetCollectorRequest* request, ::clarifai::api::SingleCollectorResponse* response);
    // List all the collectors.
    virtual ::grpc::Status ListCollectors(::grpc::ServerContext* context, const ::clarifai::api::ListCollectorsRequest* request, ::clarifai::api::MultiCollectorResponse* response);
    // Patch one or more collectors.
    virtual ::grpc::Status PatchCollectors(::grpc::ServerContext* context, const ::clarifai::api::PatchCollectorsRequest* request, ::clarifai::api::MultiCollectorResponse* response);
    // Delete multiple collectors in one request.
    // This call is asynchronous. Use DeleteCollector if you want a synchronous version.
    virtual ::grpc::Status DeleteCollectors(::grpc::ServerContext* context, const ::clarifai::api::DeleteCollectorsRequest* request, ::clarifai::api::status::BaseResponse* response);
    // //////////////////////////////////////////////////////////////////////////////
    // Stats Collection Endpoints.
    // //////////////////////////////////////////////////////////////////////////////
    //
    virtual ::grpc::Status PostStatValues(::grpc::ServerContext* context, const ::clarifai::api::PostStatValuesRequest* request, ::clarifai::api::MultiStatValueResponse* response);
    virtual ::grpc::Status PostStatValuesAggregate(::grpc::ServerContext* context, const ::clarifai::api::PostStatValuesAggregateRequest* request, ::clarifai::api::MultiStatValueAggregateResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_ListConceptRelations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListConceptRelations() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_ListConceptRelations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListConceptRelations(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListConceptRelationsRequest* /*request*/, ::clarifai::api::MultiConceptRelationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListConceptRelations(::grpc::ServerContext* context, ::clarifai::api::ListConceptRelationsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiConceptRelationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostConceptRelations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostConceptRelations() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_PostConceptRelations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostConceptRelations(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptRelationsRequest* /*request*/, ::clarifai::api::MultiConceptRelationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostConceptRelations(::grpc::ServerContext* context, ::clarifai::api::PostConceptRelationsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiConceptRelationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteConceptRelations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteConceptRelations() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_DeleteConceptRelations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteConceptRelations(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteConceptRelationsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteConceptRelations(::grpc::ServerContext* context, ::clarifai::api::DeleteConceptRelationsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::status::BaseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetConceptCounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetConceptCounts() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetConceptCounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConceptCounts(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetConceptCountsRequest* /*request*/, ::clarifai::api::MultiConceptCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConceptCounts(::grpc::ServerContext* context, ::clarifai::api::GetConceptCountsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiConceptCountResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetConcept : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetConcept() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GetConcept() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConcept(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetConceptRequest* /*request*/, ::clarifai::api::SingleConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConcept(::grpc::ServerContext* context, ::clarifai::api::GetConceptRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::SingleConceptResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListConcepts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListConcepts() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_ListConcepts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListConcepts(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListConceptsRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListConcepts(::grpc::ServerContext* context, ::clarifai::api::ListConceptsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiConceptResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostConceptsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostConceptsSearches() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_PostConceptsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostConceptsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptsSearchesRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostConceptsSearches(::grpc::ServerContext* context, ::clarifai::api::PostConceptsSearchesRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiConceptResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostConcepts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostConcepts() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_PostConcepts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostConcepts(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptsRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostConcepts(::grpc::ServerContext* context, ::clarifai::api::PostConceptsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiConceptResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PatchConcepts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PatchConcepts() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_PatchConcepts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchConcepts(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchConceptsRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPatchConcepts(::grpc::ServerContext* context, ::clarifai::api::PatchConceptsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiConceptResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetConceptLanguage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetConceptLanguage() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_GetConceptLanguage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConceptLanguage(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetConceptLanguageRequest* /*request*/, ::clarifai::api::SingleConceptLanguageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConceptLanguage(::grpc::ServerContext* context, ::clarifai::api::GetConceptLanguageRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::SingleConceptLanguageResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListConceptLanguages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListConceptLanguages() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_ListConceptLanguages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListConceptLanguages(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListConceptLanguagesRequest* /*request*/, ::clarifai::api::MultiConceptLanguageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListConceptLanguages(::grpc::ServerContext* context, ::clarifai::api::ListConceptLanguagesRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiConceptLanguageResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostConceptLanguages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostConceptLanguages() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_PostConceptLanguages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostConceptLanguages(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptLanguagesRequest* /*request*/, ::clarifai::api::MultiConceptLanguageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostConceptLanguages(::grpc::ServerContext* context, ::clarifai::api::PostConceptLanguagesRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiConceptLanguageResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PatchConceptLanguages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PatchConceptLanguages() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_PatchConceptLanguages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchConceptLanguages(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchConceptLanguagesRequest* /*request*/, ::clarifai::api::MultiConceptLanguageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPatchConceptLanguages(::grpc::ServerContext* context, ::clarifai::api::PatchConceptLanguagesRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiConceptLanguageResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListKnowledgeGraphs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListKnowledgeGraphs() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_ListKnowledgeGraphs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListKnowledgeGraphs(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListKnowledgeGraphsRequest* /*request*/, ::clarifai::api::MultiKnowledgeGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListKnowledgeGraphs(::grpc::ServerContext* context, ::clarifai::api::ListKnowledgeGraphsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiKnowledgeGraphResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostKnowledgeGraphs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostKnowledgeGraphs() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_PostKnowledgeGraphs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostKnowledgeGraphs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostKnowledgeGraphsRequest* /*request*/, ::clarifai::api::MultiKnowledgeGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostKnowledgeGraphs(::grpc::ServerContext* context, ::clarifai::api::PostKnowledgeGraphsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiKnowledgeGraphResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostConceptMappingJobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostConceptMappingJobs() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_PostConceptMappingJobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostConceptMappingJobs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptMappingJobsRequest* /*request*/, ::clarifai::api::MultiConceptMappingJobResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostConceptMappingJobs(::grpc::ServerContext* context, ::clarifai::api::PostConceptMappingJobsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiConceptMappingJobResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAnnotation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAnnotation() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_GetAnnotation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAnnotation(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetAnnotationRequest* /*request*/, ::clarifai::api::SingleAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAnnotation(::grpc::ServerContext* context, ::clarifai::api::GetAnnotationRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::SingleAnnotationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListAnnotations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListAnnotations() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_ListAnnotations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAnnotations(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAnnotationsRequest* /*request*/, ::clarifai::api::MultiAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListAnnotations(::grpc::ServerContext* context, ::clarifai::api::ListAnnotationsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiAnnotationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostAnnotations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostAnnotations() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_PostAnnotations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAnnotations(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAnnotationsRequest* /*request*/, ::clarifai::api::MultiAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostAnnotations(::grpc::ServerContext* context, ::clarifai::api::PostAnnotationsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiAnnotationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PatchAnnotations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PatchAnnotations() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_PatchAnnotations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchAnnotations(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchAnnotationsRequest* /*request*/, ::clarifai::api::MultiAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPatchAnnotations(::grpc::ServerContext* context, ::clarifai::api::PatchAnnotationsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiAnnotationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PatchAnnotationsStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PatchAnnotationsStatus() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_PatchAnnotationsStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchAnnotationsStatus(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchAnnotationsStatusRequest* /*request*/, ::clarifai::api::PatchAnnotationsStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPatchAnnotationsStatus(::grpc::ServerContext* context, ::clarifai::api::PatchAnnotationsStatusRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::PatchAnnotationsStatusResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteAnnotation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteAnnotation() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_DeleteAnnotation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAnnotation(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteAnnotationRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteAnnotation(::grpc::ServerContext* context, ::clarifai::api::DeleteAnnotationRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::status::BaseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteAnnotations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteAnnotations() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_DeleteAnnotations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAnnotations(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteAnnotationsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteAnnotations(::grpc::ServerContext* context, ::clarifai::api::DeleteAnnotationsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::status::BaseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostAnnotationsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostAnnotationsSearches() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_PostAnnotationsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAnnotationsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAnnotationsSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostAnnotationsSearches(::grpc::ServerContext* context, ::clarifai::api::PostAnnotationsSearchesRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiSearchResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetInputCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetInputCount() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_GetInputCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInputCount(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetInputCountRequest* /*request*/, ::clarifai::api::SingleInputCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetInputCount(::grpc::ServerContext* context, ::clarifai::api::GetInputCountRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::SingleInputCountResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StreamInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StreamInputs() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_StreamInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::StreamInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamInputs(::grpc::ServerContext* context, ::clarifai::api::StreamInputsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiInputResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetInputSamples : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetInputSamples() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_GetInputSamples() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInputSamples(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetInputSamplesRequest* /*request*/, ::clarifai::api::MultiInputAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetInputSamples(::grpc::ServerContext* context, ::clarifai::api::GetInputSamplesRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiInputAnnotationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetInput() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_GetInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInput(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetInputRequest* /*request*/, ::clarifai::api::SingleInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetInput(::grpc::ServerContext* context, ::clarifai::api::GetInputRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::SingleInputResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListInputs() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_ListInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListInputs(::grpc::ServerContext* context, ::clarifai::api::ListInputsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiInputResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostInputs() {
      ::grpc::Service::MarkMethodAsync(29);
    }
    ~WithAsyncMethod_PostInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostInputs(::grpc::ServerContext* context, ::clarifai::api::PostInputsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiInputResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PatchInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PatchInputs() {
      ::grpc::Service::MarkMethodAsync(30);
    }
    ~WithAsyncMethod_PatchInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPatchInputs(::grpc::ServerContext* context, ::clarifai::api::PatchInputsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiInputResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteInput() {
      ::grpc::Service::MarkMethodAsync(31);
    }
    ~WithAsyncMethod_DeleteInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteInput(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteInputRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteInput(::grpc::ServerContext* context, ::clarifai::api::DeleteInputRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::status::BaseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteInputs() {
      ::grpc::Service::MarkMethodAsync(32);
    }
    ~WithAsyncMethod_DeleteInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteInputsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteInputs(::grpc::ServerContext* context, ::clarifai::api::DeleteInputsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::status::BaseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostInputsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostInputsSearches() {
      ::grpc::Service::MarkMethodAsync(33);
    }
    ~WithAsyncMethod_PostInputsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostInputsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostInputsSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostInputsSearches(::grpc::ServerContext* context, ::clarifai::api::PostInputsSearchesRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiSearchResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostModelOutputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostModelOutputs() {
      ::grpc::Service::MarkMethodAsync(34);
    }
    ~WithAsyncMethod_PostModelOutputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostModelOutputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelOutputsRequest* /*request*/, ::clarifai::api::MultiOutputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostModelOutputs(::grpc::ServerContext* context, ::clarifai::api::PostModelOutputsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiOutputResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetModelType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetModelType() {
      ::grpc::Service::MarkMethodAsync(35);
    }
    ~WithAsyncMethod_GetModelType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModelType(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelTypeRequest* /*request*/, ::clarifai::api::SingleModelTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetModelType(::grpc::ServerContext* context, ::clarifai::api::GetModelTypeRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::SingleModelTypeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListModelTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListModelTypes() {
      ::grpc::Service::MarkMethodAsync(36);
    }
    ~WithAsyncMethod_ListModelTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListModelTypes(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListModelTypesRequest* /*request*/, ::clarifai::api::MultiModelTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListModelTypes(::grpc::ServerContext* context, ::clarifai::api::ListModelTypesRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiModelTypeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetModel() {
      ::grpc::Service::MarkMethodAsync(37);
    }
    ~WithAsyncMethod_GetModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModel(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetModel(::grpc::ServerContext* context, ::clarifai::api::GetModelRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::SingleModelResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetModelOutputInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetModelOutputInfo() {
      ::grpc::Service::MarkMethodAsync(38);
    }
    ~WithAsyncMethod_GetModelOutputInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModelOutputInfo(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetModelOutputInfo(::grpc::ServerContext* context, ::clarifai::api::GetModelRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::SingleModelResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListModels() {
      ::grpc::Service::MarkMethodAsync(39);
    }
    ~WithAsyncMethod_ListModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListModels(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListModelsRequest* /*request*/, ::clarifai::api::MultiModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListModels(::grpc::ServerContext* context, ::clarifai::api::ListModelsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiModelResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostModelsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostModelsSearches() {
      ::grpc::Service::MarkMethodAsync(40);
    }
    ~WithAsyncMethod_PostModelsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostModelsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelsSearchesRequest* /*request*/, ::clarifai::api::MultiModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostModelsSearches(::grpc::ServerContext* context, ::clarifai::api::PostModelsSearchesRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiModelResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostModels() {
      ::grpc::Service::MarkMethodAsync(41);
    }
    ~WithAsyncMethod_PostModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostModels(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelsRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostModels(::grpc::ServerContext* context, ::clarifai::api::PostModelsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::SingleModelResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PatchModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PatchModels() {
      ::grpc::Service::MarkMethodAsync(42);
    }
    ~WithAsyncMethod_PatchModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchModels(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchModelsRequest* /*request*/, ::clarifai::api::MultiModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPatchModels(::grpc::ServerContext* context, ::clarifai::api::PatchModelsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiModelResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteModel() {
      ::grpc::Service::MarkMethodAsync(43);
    }
    ~WithAsyncMethod_DeleteModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteModel(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteModelRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteModel(::grpc::ServerContext* context, ::clarifai::api::DeleteModelRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::status::BaseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteModels() {
      ::grpc::Service::MarkMethodAsync(44);
    }
    ~WithAsyncMethod_DeleteModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteModels(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteModelsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteModels(::grpc::ServerContext* context, ::clarifai::api::DeleteModelsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::status::BaseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListModelInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListModelInputs() {
      ::grpc::Service::MarkMethodAsync(45);
    }
    ~WithAsyncMethod_ListModelInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListModelInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListModelInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListModelInputs(::grpc::ServerContext* context, ::clarifai::api::ListModelInputsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiInputResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(45, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetModelVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetModelVersion() {
      ::grpc::Service::MarkMethodAsync(46);
    }
    ~WithAsyncMethod_GetModelVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModelVersion(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelVersionRequest* /*request*/, ::clarifai::api::SingleModelVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetModelVersion(::grpc::ServerContext* context, ::clarifai::api::GetModelVersionRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::SingleModelVersionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(46, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListModelVersions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListModelVersions() {
      ::grpc::Service::MarkMethodAsync(47);
    }
    ~WithAsyncMethod_ListModelVersions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListModelVersions(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListModelVersionsRequest* /*request*/, ::clarifai::api::MultiModelVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListModelVersions(::grpc::ServerContext* context, ::clarifai::api::ListModelVersionsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiModelVersionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(47, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostModelVersions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostModelVersions() {
      ::grpc::Service::MarkMethodAsync(48);
    }
    ~WithAsyncMethod_PostModelVersions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostModelVersions(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelVersionsRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostModelVersions(::grpc::ServerContext* context, ::clarifai::api::PostModelVersionsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::SingleModelResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(48, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteModelVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteModelVersion() {
      ::grpc::Service::MarkMethodAsync(49);
    }
    ~WithAsyncMethod_DeleteModelVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteModelVersion(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteModelVersionRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteModelVersion(::grpc::ServerContext* context, ::clarifai::api::DeleteModelVersionRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::status::BaseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(49, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetModelVersionMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetModelVersionMetrics() {
      ::grpc::Service::MarkMethodAsync(50);
    }
    ~WithAsyncMethod_GetModelVersionMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModelVersionMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelVersionMetricsRequest* /*request*/, ::clarifai::api::SingleModelVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetModelVersionMetrics(::grpc::ServerContext* context, ::clarifai::api::GetModelVersionMetricsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::SingleModelVersionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(50, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostModelVersionMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostModelVersionMetrics() {
      ::grpc::Service::MarkMethodAsync(51);
    }
    ~WithAsyncMethod_PostModelVersionMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostModelVersionMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelVersionMetricsRequest* /*request*/, ::clarifai::api::SingleModelVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostModelVersionMetrics(::grpc::ServerContext* context, ::clarifai::api::PostModelVersionMetricsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::SingleModelVersionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(51, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetWorkflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetWorkflow() {
      ::grpc::Service::MarkMethodAsync(52);
    }
    ~WithAsyncMethod_GetWorkflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkflow(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetWorkflowRequest* /*request*/, ::clarifai::api::SingleWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetWorkflow(::grpc::ServerContext* context, ::clarifai::api::GetWorkflowRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::SingleWorkflowResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(52, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListWorkflows() {
      ::grpc::Service::MarkMethodAsync(53);
    }
    ~WithAsyncMethod_ListWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListWorkflows(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListWorkflowsRequest* /*request*/, ::clarifai::api::MultiWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListWorkflows(::grpc::ServerContext* context, ::clarifai::api::ListWorkflowsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiWorkflowResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(53, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostWorkflows() {
      ::grpc::Service::MarkMethodAsync(54);
    }
    ~WithAsyncMethod_PostWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostWorkflows(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostWorkflowsRequest* /*request*/, ::clarifai::api::MultiWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostWorkflows(::grpc::ServerContext* context, ::clarifai::api::PostWorkflowsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiWorkflowResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(54, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PatchWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PatchWorkflows() {
      ::grpc::Service::MarkMethodAsync(55);
    }
    ~WithAsyncMethod_PatchWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchWorkflows(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchWorkflowsRequest* /*request*/, ::clarifai::api::MultiWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPatchWorkflows(::grpc::ServerContext* context, ::clarifai::api::PatchWorkflowsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiWorkflowResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(55, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteWorkflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteWorkflow() {
      ::grpc::Service::MarkMethodAsync(56);
    }
    ~WithAsyncMethod_DeleteWorkflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteWorkflow(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteWorkflowRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteWorkflow(::grpc::ServerContext* context, ::clarifai::api::DeleteWorkflowRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::status::BaseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(56, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteWorkflows() {
      ::grpc::Service::MarkMethodAsync(57);
    }
    ~WithAsyncMethod_DeleteWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteWorkflows(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteWorkflowsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteWorkflows(::grpc::ServerContext* context, ::clarifai::api::DeleteWorkflowsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::status::BaseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(57, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostWorkflowResults : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostWorkflowResults() {
      ::grpc::Service::MarkMethodAsync(58);
    }
    ~WithAsyncMethod_PostWorkflowResults() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostWorkflowResults(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostWorkflowResultsRequest* /*request*/, ::clarifai::api::PostWorkflowResultsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostWorkflowResults(::grpc::ServerContext* context, ::clarifai::api::PostWorkflowResultsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::PostWorkflowResultsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(58, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostWorkflowResultsSimilarity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostWorkflowResultsSimilarity() {
      ::grpc::Service::MarkMethodAsync(59);
    }
    ~WithAsyncMethod_PostWorkflowResultsSimilarity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostWorkflowResultsSimilarity(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostWorkflowResultsSimilarityRequest* /*request*/, ::clarifai::api::PostWorkflowResultsSimilarityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostWorkflowResultsSimilarity(::grpc::ServerContext* context, ::clarifai::api::PostWorkflowResultsSimilarityRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::PostWorkflowResultsSimilarityResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(59, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetKey() {
      ::grpc::Service::MarkMethodAsync(60);
    }
    ~WithAsyncMethod_GetKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetKey(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetKeyRequest* /*request*/, ::clarifai::api::SingleKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetKey(::grpc::ServerContext* context, ::clarifai::api::GetKeyRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::SingleKeyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(60, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListKeys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListKeys() {
      ::grpc::Service::MarkMethodAsync(61);
    }
    ~WithAsyncMethod_ListKeys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListKeys(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListKeys(::grpc::ServerContext* context, ::clarifai::api::ListKeysRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiKeyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(61, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListAppKeys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListAppKeys() {
      ::grpc::Service::MarkMethodAsync(62);
    }
    ~WithAsyncMethod_ListAppKeys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAppKeys(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAppKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListAppKeys(::grpc::ServerContext* context, ::clarifai::api::ListAppKeysRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiKeyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(62, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteKey() {
      ::grpc::Service::MarkMethodAsync(63);
    }
    ~WithAsyncMethod_DeleteKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteKey(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteKeyRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteKey(::grpc::ServerContext* context, ::clarifai::api::DeleteKeyRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::status::BaseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(63, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostKeys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostKeys() {
      ::grpc::Service::MarkMethodAsync(64);
    }
    ~WithAsyncMethod_PostKeys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostKeys(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostKeys(::grpc::ServerContext* context, ::clarifai::api::PostKeysRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiKeyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(64, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PatchKeys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PatchKeys() {
      ::grpc::Service::MarkMethodAsync(65);
    }
    ~WithAsyncMethod_PatchKeys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchKeys(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPatchKeys(::grpc::ServerContext* context, ::clarifai::api::PatchKeysRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiKeyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(65, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MyScopes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MyScopes() {
      ::grpc::Service::MarkMethodAsync(66);
    }
    ~WithAsyncMethod_MyScopes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MyScopes(::grpc::ServerContext* /*context*/, const ::clarifai::api::MyScopesRequest* /*request*/, ::clarifai::api::MultiScopeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMyScopes(::grpc::ServerContext* context, ::clarifai::api::MyScopesRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiScopeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(66, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListScopes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListScopes() {
      ::grpc::Service::MarkMethodAsync(67);
    }
    ~WithAsyncMethod_ListScopes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListScopes(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListScopesRequest* /*request*/, ::clarifai::api::MultiScopeDepsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListScopes(::grpc::ServerContext* context, ::clarifai::api::ListScopesRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiScopeDepsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(67, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetApp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetApp() {
      ::grpc::Service::MarkMethodAsync(68);
    }
    ~WithAsyncMethod_GetApp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetApp(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetAppRequest* /*request*/, ::clarifai::api::SingleAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetApp(::grpc::ServerContext* context, ::clarifai::api::GetAppRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::SingleAppResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(68, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListApps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListApps() {
      ::grpc::Service::MarkMethodAsync(69);
    }
    ~WithAsyncMethod_ListApps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListApps(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAppsRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListApps(::grpc::ServerContext* context, ::clarifai::api::ListAppsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiAppResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(69, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteApp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteApp() {
      ::grpc::Service::MarkMethodAsync(70);
    }
    ~WithAsyncMethod_DeleteApp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteApp(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteAppRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteApp(::grpc::ServerContext* context, ::clarifai::api::DeleteAppRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::status::BaseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(70, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostApps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostApps() {
      ::grpc::Service::MarkMethodAsync(71);
    }
    ~WithAsyncMethod_PostApps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostApps(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAppsRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostApps(::grpc::ServerContext* context, ::clarifai::api::PostAppsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiAppResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(71, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PatchApps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PatchApps() {
      ::grpc::Service::MarkMethodAsync(72);
    }
    ~WithAsyncMethod_PatchApps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchApps(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchAppsRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPatchApps(::grpc::ServerContext* context, ::clarifai::api::PatchAppsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiAppResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(72, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostAppsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostAppsSearches() {
      ::grpc::Service::MarkMethodAsync(73);
    }
    ~WithAsyncMethod_PostAppsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAppsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAppsSearchesRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostAppsSearches(::grpc::ServerContext* context, ::clarifai::api::PostAppsSearchesRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiAppResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(73, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostValidatePassword : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostValidatePassword() {
      ::grpc::Service::MarkMethodAsync(74);
    }
    ~WithAsyncMethod_PostValidatePassword() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostValidatePassword(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostValidatePasswordRequest* /*request*/, ::clarifai::api::SinglePasswordValidationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostValidatePassword(::grpc::ServerContext* context, ::clarifai::api::PostValidatePasswordRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::SinglePasswordValidationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(74, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSearch() {
      ::grpc::Service::MarkMethodAsync(75);
    }
    ~WithAsyncMethod_GetSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSearch(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetSearchRequest* /*request*/, ::clarifai::api::SingleSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSearch(::grpc::ServerContext* context, ::clarifai::api::GetSearchRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::SingleSearchResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(75, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListSearches() {
      ::grpc::Service::MarkMethodAsync(76);
    }
    ~WithAsyncMethod_ListSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListSearches(::grpc::ServerContext* context, ::clarifai::api::ListSearchesRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiSearchResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(76, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostSearches() {
      ::grpc::Service::MarkMethodAsync(77);
    }
    ~WithAsyncMethod_PostSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostSearches(::grpc::ServerContext* context, ::clarifai::api::PostSearchesRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiSearchResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(77, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostSearchesByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostSearchesByID() {
      ::grpc::Service::MarkMethodAsync(78);
    }
    ~WithAsyncMethod_PostSearchesByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostSearchesByID(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostSearchesByIDRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostSearchesByID(::grpc::ServerContext* context, ::clarifai::api::PostSearchesByIDRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiSearchResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(78, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostAnnotationSearchMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostAnnotationSearchMetrics() {
      ::grpc::Service::MarkMethodAsync(79);
    }
    ~WithAsyncMethod_PostAnnotationSearchMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAnnotationSearchMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::MultiAnnotationSearchMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostAnnotationSearchMetrics(::grpc::ServerContext* context, ::clarifai::api::PostAnnotationSearchMetricsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiAnnotationSearchMetricsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(79, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAnnotationSearchMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAnnotationSearchMetrics() {
      ::grpc::Service::MarkMethodAsync(80);
    }
    ~WithAsyncMethod_GetAnnotationSearchMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAnnotationSearchMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::MultiAnnotationSearchMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAnnotationSearchMetrics(::grpc::ServerContext* context, ::clarifai::api::GetAnnotationSearchMetricsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiAnnotationSearchMetricsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(80, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListAnnotationSearchMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListAnnotationSearchMetrics() {
      ::grpc::Service::MarkMethodAsync(81);
    }
    ~WithAsyncMethod_ListAnnotationSearchMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAnnotationSearchMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::MultiAnnotationSearchMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListAnnotationSearchMetrics(::grpc::ServerContext* context, ::clarifai::api::ListAnnotationSearchMetricsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiAnnotationSearchMetricsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(81, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteAnnotationSearchMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteAnnotationSearchMetrics() {
      ::grpc::Service::MarkMethodAsync(82);
    }
    ~WithAsyncMethod_DeleteAnnotationSearchMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAnnotationSearchMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteAnnotationSearchMetrics(::grpc::ServerContext* context, ::clarifai::api::DeleteAnnotationSearchMetricsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::status::BaseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(82, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteSearch() {
      ::grpc::Service::MarkMethodAsync(83);
    }
    ~WithAsyncMethod_DeleteSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSearch(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteSearchRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteSearch(::grpc::ServerContext* context, ::clarifai::api::DeleteSearchRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::status::BaseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(83, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListStatusCodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListStatusCodes() {
      ::grpc::Service::MarkMethodAsync(84);
    }
    ~WithAsyncMethod_ListStatusCodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListStatusCodes(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListStatusCodesRequest* /*request*/, ::clarifai::api::MultiStatusCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListStatusCodes(::grpc::ServerContext* context, ::clarifai::api::ListStatusCodesRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiStatusCodeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(84, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetStatusCode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetStatusCode() {
      ::grpc::Service::MarkMethodAsync(85);
    }
    ~WithAsyncMethod_GetStatusCode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStatusCode(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetStatusCodeRequest* /*request*/, ::clarifai::api::SingleStatusCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStatusCode(::grpc::ServerContext* context, ::clarifai::api::GetStatusCodeRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::SingleStatusCodeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(85, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListCollaborators : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListCollaborators() {
      ::grpc::Service::MarkMethodAsync(86);
    }
    ~WithAsyncMethod_ListCollaborators() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListCollaborators(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListCollaboratorsRequest* /*request*/, ::clarifai::api::MultiCollaboratorsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListCollaborators(::grpc::ServerContext* context, ::clarifai::api::ListCollaboratorsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiCollaboratorsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(86, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostCollaborators : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostCollaborators() {
      ::grpc::Service::MarkMethodAsync(87);
    }
    ~WithAsyncMethod_PostCollaborators() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostCollaborators(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostCollaboratorsRequest* /*request*/, ::clarifai::api::MultiCollaboratorsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostCollaborators(::grpc::ServerContext* context, ::clarifai::api::PostCollaboratorsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiCollaboratorsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(87, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PatchCollaborators : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PatchCollaborators() {
      ::grpc::Service::MarkMethodAsync(88);
    }
    ~WithAsyncMethod_PatchCollaborators() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchCollaborators(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchCollaboratorsRequest* /*request*/, ::clarifai::api::MultiCollaboratorsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPatchCollaborators(::grpc::ServerContext* context, ::clarifai::api::PatchCollaboratorsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiCollaboratorsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(88, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteCollaborators : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteCollaborators() {
      ::grpc::Service::MarkMethodAsync(89);
    }
    ~WithAsyncMethod_DeleteCollaborators() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteCollaborators(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteCollaboratorsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteCollaborators(::grpc::ServerContext* context, ::clarifai::api::DeleteCollaboratorsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::status::BaseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(89, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListCollaborations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListCollaborations() {
      ::grpc::Service::MarkMethodAsync(90);
    }
    ~WithAsyncMethod_ListCollaborations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListCollaborations(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListCollaborationsRequest* /*request*/, ::clarifai::api::MultiCollaborationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListCollaborations(::grpc::ServerContext* context, ::clarifai::api::ListCollaborationsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiCollaborationsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(90, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostAppDuplications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostAppDuplications() {
      ::grpc::Service::MarkMethodAsync(91);
    }
    ~WithAsyncMethod_PostAppDuplications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAppDuplications(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAppDuplicationsRequest* /*request*/, ::clarifai::api::MultiAppDuplicationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostAppDuplications(::grpc::ServerContext* context, ::clarifai::api::PostAppDuplicationsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiAppDuplicationsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(91, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListAppDuplications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListAppDuplications() {
      ::grpc::Service::MarkMethodAsync(92);
    }
    ~WithAsyncMethod_ListAppDuplications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAppDuplications(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAppDuplicationsRequest* /*request*/, ::clarifai::api::MultiAppDuplicationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListAppDuplications(::grpc::ServerContext* context, ::clarifai::api::ListAppDuplicationsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiAppDuplicationsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(92, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAppDuplication : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAppDuplication() {
      ::grpc::Service::MarkMethodAsync(93);
    }
    ~WithAsyncMethod_GetAppDuplication() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAppDuplication(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetAppDuplicationRequest* /*request*/, ::clarifai::api::SingleAppDuplicationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAppDuplication(::grpc::ServerContext* context, ::clarifai::api::GetAppDuplicationRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::SingleAppDuplicationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(93, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostTasks() {
      ::grpc::Service::MarkMethodAsync(94);
    }
    ~WithAsyncMethod_PostTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostTasks(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostTasksRequest* /*request*/, ::clarifai::api::MultiTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostTasks(::grpc::ServerContext* context, ::clarifai::api::PostTasksRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiTaskResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(94, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTaskAnnotationCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTaskAnnotationCount() {
      ::grpc::Service::MarkMethodAsync(95);
    }
    ~WithAsyncMethod_GetTaskAnnotationCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskAnnotationCount(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetTaskCountRequest* /*request*/, ::clarifai::api::SingleTaskCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTaskAnnotationCount(::grpc::ServerContext* context, ::clarifai::api::GetTaskCountRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::SingleTaskCountResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(95, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTaskInputCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTaskInputCount() {
      ::grpc::Service::MarkMethodAsync(96);
    }
    ~WithAsyncMethod_GetTaskInputCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskInputCount(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetTaskCountRequest* /*request*/, ::clarifai::api::SingleTaskCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTaskInputCount(::grpc::ServerContext* context, ::clarifai::api::GetTaskCountRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::SingleTaskCountResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(96, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTask() {
      ::grpc::Service::MarkMethodAsync(97);
    }
    ~WithAsyncMethod_GetTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTask(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetTaskRequest* /*request*/, ::clarifai::api::SingleTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTask(::grpc::ServerContext* context, ::clarifai::api::GetTaskRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::SingleTaskResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(97, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListTasks() {
      ::grpc::Service::MarkMethodAsync(98);
    }
    ~WithAsyncMethod_ListTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTasks(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListTasksRequest* /*request*/, ::clarifai::api::MultiTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListTasks(::grpc::ServerContext* context, ::clarifai::api::ListTasksRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiTaskResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(98, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PatchTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PatchTasks() {
      ::grpc::Service::MarkMethodAsync(99);
    }
    ~WithAsyncMethod_PatchTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchTasks(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchTasksRequest* /*request*/, ::clarifai::api::MultiTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPatchTasks(::grpc::ServerContext* context, ::clarifai::api::PatchTasksRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiTaskResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(99, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteTasks() {
      ::grpc::Service::MarkMethodAsync(100);
    }
    ~WithAsyncMethod_DeleteTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteTasks(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteTasksRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteTasks(::grpc::ServerContext* context, ::clarifai::api::DeleteTasksRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::status::BaseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(100, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostCollectors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostCollectors() {
      ::grpc::Service::MarkMethodAsync(101);
    }
    ~WithAsyncMethod_PostCollectors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostCollectors(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostCollectorsRequest* /*request*/, ::clarifai::api::MultiCollectorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostCollectors(::grpc::ServerContext* context, ::clarifai::api::PostCollectorsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiCollectorResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(101, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCollector : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCollector() {
      ::grpc::Service::MarkMethodAsync(102);
    }
    ~WithAsyncMethod_GetCollector() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollector(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetCollectorRequest* /*request*/, ::clarifai::api::SingleCollectorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCollector(::grpc::ServerContext* context, ::clarifai::api::GetCollectorRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::SingleCollectorResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(102, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListCollectors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListCollectors() {
      ::grpc::Service::MarkMethodAsync(103);
    }
    ~WithAsyncMethod_ListCollectors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListCollectors(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListCollectorsRequest* /*request*/, ::clarifai::api::MultiCollectorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListCollectors(::grpc::ServerContext* context, ::clarifai::api::ListCollectorsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiCollectorResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(103, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PatchCollectors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PatchCollectors() {
      ::grpc::Service::MarkMethodAsync(104);
    }
    ~WithAsyncMethod_PatchCollectors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchCollectors(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchCollectorsRequest* /*request*/, ::clarifai::api::MultiCollectorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPatchCollectors(::grpc::ServerContext* context, ::clarifai::api::PatchCollectorsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiCollectorResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(104, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteCollectors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteCollectors() {
      ::grpc::Service::MarkMethodAsync(105);
    }
    ~WithAsyncMethod_DeleteCollectors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteCollectors(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteCollectorsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteCollectors(::grpc::ServerContext* context, ::clarifai::api::DeleteCollectorsRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::status::BaseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(105, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostStatValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostStatValues() {
      ::grpc::Service::MarkMethodAsync(106);
    }
    ~WithAsyncMethod_PostStatValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostStatValues(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostStatValuesRequest* /*request*/, ::clarifai::api::MultiStatValueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostStatValues(::grpc::ServerContext* context, ::clarifai::api::PostStatValuesRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiStatValueResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(106, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostStatValuesAggregate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostStatValuesAggregate() {
      ::grpc::Service::MarkMethodAsync(107);
    }
    ~WithAsyncMethod_PostStatValuesAggregate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostStatValuesAggregate(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostStatValuesAggregateRequest* /*request*/, ::clarifai::api::MultiStatValueAggregateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostStatValuesAggregate(::grpc::ServerContext* context, ::clarifai::api::PostStatValuesAggregateRequest* request, ::grpc::ServerAsyncResponseWriter< ::clarifai::api::MultiStatValueAggregateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(107, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ListConceptRelations<WithAsyncMethod_PostConceptRelations<WithAsyncMethod_DeleteConceptRelations<WithAsyncMethod_GetConceptCounts<WithAsyncMethod_GetConcept<WithAsyncMethod_ListConcepts<WithAsyncMethod_PostConceptsSearches<WithAsyncMethod_PostConcepts<WithAsyncMethod_PatchConcepts<WithAsyncMethod_GetConceptLanguage<WithAsyncMethod_ListConceptLanguages<WithAsyncMethod_PostConceptLanguages<WithAsyncMethod_PatchConceptLanguages<WithAsyncMethod_ListKnowledgeGraphs<WithAsyncMethod_PostKnowledgeGraphs<WithAsyncMethod_PostConceptMappingJobs<WithAsyncMethod_GetAnnotation<WithAsyncMethod_ListAnnotations<WithAsyncMethod_PostAnnotations<WithAsyncMethod_PatchAnnotations<WithAsyncMethod_PatchAnnotationsStatus<WithAsyncMethod_DeleteAnnotation<WithAsyncMethod_DeleteAnnotations<WithAsyncMethod_PostAnnotationsSearches<WithAsyncMethod_GetInputCount<WithAsyncMethod_StreamInputs<WithAsyncMethod_GetInputSamples<WithAsyncMethod_GetInput<WithAsyncMethod_ListInputs<WithAsyncMethod_PostInputs<WithAsyncMethod_PatchInputs<WithAsyncMethod_DeleteInput<WithAsyncMethod_DeleteInputs<WithAsyncMethod_PostInputsSearches<WithAsyncMethod_PostModelOutputs<WithAsyncMethod_GetModelType<WithAsyncMethod_ListModelTypes<WithAsyncMethod_GetModel<WithAsyncMethod_GetModelOutputInfo<WithAsyncMethod_ListModels<WithAsyncMethod_PostModelsSearches<WithAsyncMethod_PostModels<WithAsyncMethod_PatchModels<WithAsyncMethod_DeleteModel<WithAsyncMethod_DeleteModels<WithAsyncMethod_ListModelInputs<WithAsyncMethod_GetModelVersion<WithAsyncMethod_ListModelVersions<WithAsyncMethod_PostModelVersions<WithAsyncMethod_DeleteModelVersion<WithAsyncMethod_GetModelVersionMetrics<WithAsyncMethod_PostModelVersionMetrics<WithAsyncMethod_GetWorkflow<WithAsyncMethod_ListWorkflows<WithAsyncMethod_PostWorkflows<WithAsyncMethod_PatchWorkflows<WithAsyncMethod_DeleteWorkflow<WithAsyncMethod_DeleteWorkflows<WithAsyncMethod_PostWorkflowResults<WithAsyncMethod_PostWorkflowResultsSimilarity<WithAsyncMethod_GetKey<WithAsyncMethod_ListKeys<WithAsyncMethod_ListAppKeys<WithAsyncMethod_DeleteKey<WithAsyncMethod_PostKeys<WithAsyncMethod_PatchKeys<WithAsyncMethod_MyScopes<WithAsyncMethod_ListScopes<WithAsyncMethod_GetApp<WithAsyncMethod_ListApps<WithAsyncMethod_DeleteApp<WithAsyncMethod_PostApps<WithAsyncMethod_PatchApps<WithAsyncMethod_PostAppsSearches<WithAsyncMethod_PostValidatePassword<WithAsyncMethod_GetSearch<WithAsyncMethod_ListSearches<WithAsyncMethod_PostSearches<WithAsyncMethod_PostSearchesByID<WithAsyncMethod_PostAnnotationSearchMetrics<WithAsyncMethod_GetAnnotationSearchMetrics<WithAsyncMethod_ListAnnotationSearchMetrics<WithAsyncMethod_DeleteAnnotationSearchMetrics<WithAsyncMethod_DeleteSearch<WithAsyncMethod_ListStatusCodes<WithAsyncMethod_GetStatusCode<WithAsyncMethod_ListCollaborators<WithAsyncMethod_PostCollaborators<WithAsyncMethod_PatchCollaborators<WithAsyncMethod_DeleteCollaborators<WithAsyncMethod_ListCollaborations<WithAsyncMethod_PostAppDuplications<WithAsyncMethod_ListAppDuplications<WithAsyncMethod_GetAppDuplication<WithAsyncMethod_PostTasks<WithAsyncMethod_GetTaskAnnotationCount<WithAsyncMethod_GetTaskInputCount<WithAsyncMethod_GetTask<WithAsyncMethod_ListTasks<WithAsyncMethod_PatchTasks<WithAsyncMethod_DeleteTasks<WithAsyncMethod_PostCollectors<WithAsyncMethod_GetCollector<WithAsyncMethod_ListCollectors<WithAsyncMethod_PatchCollectors<WithAsyncMethod_DeleteCollectors<WithAsyncMethod_PostStatValues<WithAsyncMethod_PostStatValuesAggregate<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListConceptRelations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListConceptRelations() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListConceptRelationsRequest, ::clarifai::api::MultiConceptRelationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::ListConceptRelationsRequest* request, ::clarifai::api::MultiConceptRelationResponse* response) { return this->ListConceptRelations(context, request, response); }));}
    void SetMessageAllocatorFor_ListConceptRelations(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::ListConceptRelationsRequest, ::clarifai::api::MultiConceptRelationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListConceptRelationsRequest, ::clarifai::api::MultiConceptRelationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListConceptRelations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListConceptRelations(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListConceptRelationsRequest* /*request*/, ::clarifai::api::MultiConceptRelationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListConceptRelations(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::ListConceptRelationsRequest* /*request*/, ::clarifai::api::MultiConceptRelationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListConceptRelations(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::ListConceptRelationsRequest* /*request*/, ::clarifai::api::MultiConceptRelationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostConceptRelations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostConceptRelations() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostConceptRelationsRequest, ::clarifai::api::MultiConceptRelationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostConceptRelationsRequest* request, ::clarifai::api::MultiConceptRelationResponse* response) { return this->PostConceptRelations(context, request, response); }));}
    void SetMessageAllocatorFor_PostConceptRelations(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostConceptRelationsRequest, ::clarifai::api::MultiConceptRelationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostConceptRelationsRequest, ::clarifai::api::MultiConceptRelationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostConceptRelations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostConceptRelations(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptRelationsRequest* /*request*/, ::clarifai::api::MultiConceptRelationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostConceptRelations(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostConceptRelationsRequest* /*request*/, ::clarifai::api::MultiConceptRelationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostConceptRelations(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostConceptRelationsRequest* /*request*/, ::clarifai::api::MultiConceptRelationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteConceptRelations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteConceptRelations() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteConceptRelationsRequest, ::clarifai::api::status::BaseResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::DeleteConceptRelationsRequest* request, ::clarifai::api::status::BaseResponse* response) { return this->DeleteConceptRelations(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteConceptRelations(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::DeleteConceptRelationsRequest, ::clarifai::api::status::BaseResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteConceptRelationsRequest, ::clarifai::api::status::BaseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteConceptRelations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteConceptRelations(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteConceptRelationsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteConceptRelations(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteConceptRelationsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteConceptRelations(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteConceptRelationsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetConceptCounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetConceptCounts() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetConceptCountsRequest, ::clarifai::api::MultiConceptCountResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::GetConceptCountsRequest* request, ::clarifai::api::MultiConceptCountResponse* response) { return this->GetConceptCounts(context, request, response); }));}
    void SetMessageAllocatorFor_GetConceptCounts(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::GetConceptCountsRequest, ::clarifai::api::MultiConceptCountResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetConceptCountsRequest, ::clarifai::api::MultiConceptCountResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetConceptCounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConceptCounts(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetConceptCountsRequest* /*request*/, ::clarifai::api::MultiConceptCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetConceptCounts(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::GetConceptCountsRequest* /*request*/, ::clarifai::api::MultiConceptCountResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetConceptCounts(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::GetConceptCountsRequest* /*request*/, ::clarifai::api::MultiConceptCountResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetConcept : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetConcept() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetConceptRequest, ::clarifai::api::SingleConceptResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::GetConceptRequest* request, ::clarifai::api::SingleConceptResponse* response) { return this->GetConcept(context, request, response); }));}
    void SetMessageAllocatorFor_GetConcept(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::GetConceptRequest, ::clarifai::api::SingleConceptResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetConceptRequest, ::clarifai::api::SingleConceptResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetConcept() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConcept(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetConceptRequest* /*request*/, ::clarifai::api::SingleConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetConcept(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::GetConceptRequest* /*request*/, ::clarifai::api::SingleConceptResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetConcept(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::GetConceptRequest* /*request*/, ::clarifai::api::SingleConceptResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListConcepts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListConcepts() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListConceptsRequest, ::clarifai::api::MultiConceptResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::ListConceptsRequest* request, ::clarifai::api::MultiConceptResponse* response) { return this->ListConcepts(context, request, response); }));}
    void SetMessageAllocatorFor_ListConcepts(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::ListConceptsRequest, ::clarifai::api::MultiConceptResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListConceptsRequest, ::clarifai::api::MultiConceptResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListConcepts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListConcepts(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListConceptsRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListConcepts(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::ListConceptsRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListConcepts(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::ListConceptsRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostConceptsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostConceptsSearches() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostConceptsSearchesRequest, ::clarifai::api::MultiConceptResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostConceptsSearchesRequest* request, ::clarifai::api::MultiConceptResponse* response) { return this->PostConceptsSearches(context, request, response); }));}
    void SetMessageAllocatorFor_PostConceptsSearches(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostConceptsSearchesRequest, ::clarifai::api::MultiConceptResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostConceptsSearchesRequest, ::clarifai::api::MultiConceptResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostConceptsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostConceptsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptsSearchesRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostConceptsSearches(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostConceptsSearchesRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostConceptsSearches(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostConceptsSearchesRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostConcepts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostConcepts() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostConceptsRequest, ::clarifai::api::MultiConceptResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostConceptsRequest* request, ::clarifai::api::MultiConceptResponse* response) { return this->PostConcepts(context, request, response); }));}
    void SetMessageAllocatorFor_PostConcepts(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostConceptsRequest, ::clarifai::api::MultiConceptResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostConceptsRequest, ::clarifai::api::MultiConceptResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostConcepts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostConcepts(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptsRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostConcepts(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostConceptsRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostConcepts(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostConceptsRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PatchConcepts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PatchConcepts() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PatchConceptsRequest, ::clarifai::api::MultiConceptResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PatchConceptsRequest* request, ::clarifai::api::MultiConceptResponse* response) { return this->PatchConcepts(context, request, response); }));}
    void SetMessageAllocatorFor_PatchConcepts(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PatchConceptsRequest, ::clarifai::api::MultiConceptResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PatchConceptsRequest, ::clarifai::api::MultiConceptResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PatchConcepts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchConcepts(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchConceptsRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PatchConcepts(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PatchConceptsRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PatchConcepts(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PatchConceptsRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetConceptLanguage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetConceptLanguage() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetConceptLanguageRequest, ::clarifai::api::SingleConceptLanguageResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::GetConceptLanguageRequest* request, ::clarifai::api::SingleConceptLanguageResponse* response) { return this->GetConceptLanguage(context, request, response); }));}
    void SetMessageAllocatorFor_GetConceptLanguage(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::GetConceptLanguageRequest, ::clarifai::api::SingleConceptLanguageResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetConceptLanguageRequest, ::clarifai::api::SingleConceptLanguageResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetConceptLanguage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConceptLanguage(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetConceptLanguageRequest* /*request*/, ::clarifai::api::SingleConceptLanguageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetConceptLanguage(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::GetConceptLanguageRequest* /*request*/, ::clarifai::api::SingleConceptLanguageResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetConceptLanguage(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::GetConceptLanguageRequest* /*request*/, ::clarifai::api::SingleConceptLanguageResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListConceptLanguages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListConceptLanguages() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListConceptLanguagesRequest, ::clarifai::api::MultiConceptLanguageResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::ListConceptLanguagesRequest* request, ::clarifai::api::MultiConceptLanguageResponse* response) { return this->ListConceptLanguages(context, request, response); }));}
    void SetMessageAllocatorFor_ListConceptLanguages(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::ListConceptLanguagesRequest, ::clarifai::api::MultiConceptLanguageResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListConceptLanguagesRequest, ::clarifai::api::MultiConceptLanguageResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListConceptLanguages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListConceptLanguages(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListConceptLanguagesRequest* /*request*/, ::clarifai::api::MultiConceptLanguageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListConceptLanguages(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::ListConceptLanguagesRequest* /*request*/, ::clarifai::api::MultiConceptLanguageResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListConceptLanguages(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::ListConceptLanguagesRequest* /*request*/, ::clarifai::api::MultiConceptLanguageResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostConceptLanguages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostConceptLanguages() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostConceptLanguagesRequest, ::clarifai::api::MultiConceptLanguageResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostConceptLanguagesRequest* request, ::clarifai::api::MultiConceptLanguageResponse* response) { return this->PostConceptLanguages(context, request, response); }));}
    void SetMessageAllocatorFor_PostConceptLanguages(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostConceptLanguagesRequest, ::clarifai::api::MultiConceptLanguageResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostConceptLanguagesRequest, ::clarifai::api::MultiConceptLanguageResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostConceptLanguages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostConceptLanguages(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptLanguagesRequest* /*request*/, ::clarifai::api::MultiConceptLanguageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostConceptLanguages(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostConceptLanguagesRequest* /*request*/, ::clarifai::api::MultiConceptLanguageResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostConceptLanguages(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostConceptLanguagesRequest* /*request*/, ::clarifai::api::MultiConceptLanguageResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PatchConceptLanguages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PatchConceptLanguages() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PatchConceptLanguagesRequest, ::clarifai::api::MultiConceptLanguageResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PatchConceptLanguagesRequest* request, ::clarifai::api::MultiConceptLanguageResponse* response) { return this->PatchConceptLanguages(context, request, response); }));}
    void SetMessageAllocatorFor_PatchConceptLanguages(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PatchConceptLanguagesRequest, ::clarifai::api::MultiConceptLanguageResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PatchConceptLanguagesRequest, ::clarifai::api::MultiConceptLanguageResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PatchConceptLanguages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchConceptLanguages(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchConceptLanguagesRequest* /*request*/, ::clarifai::api::MultiConceptLanguageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PatchConceptLanguages(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PatchConceptLanguagesRequest* /*request*/, ::clarifai::api::MultiConceptLanguageResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PatchConceptLanguages(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PatchConceptLanguagesRequest* /*request*/, ::clarifai::api::MultiConceptLanguageResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListKnowledgeGraphs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListKnowledgeGraphs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(13,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListKnowledgeGraphsRequest, ::clarifai::api::MultiKnowledgeGraphResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::ListKnowledgeGraphsRequest* request, ::clarifai::api::MultiKnowledgeGraphResponse* response) { return this->ListKnowledgeGraphs(context, request, response); }));}
    void SetMessageAllocatorFor_ListKnowledgeGraphs(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::ListKnowledgeGraphsRequest, ::clarifai::api::MultiKnowledgeGraphResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(13);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListKnowledgeGraphsRequest, ::clarifai::api::MultiKnowledgeGraphResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListKnowledgeGraphs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListKnowledgeGraphs(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListKnowledgeGraphsRequest* /*request*/, ::clarifai::api::MultiKnowledgeGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListKnowledgeGraphs(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::ListKnowledgeGraphsRequest* /*request*/, ::clarifai::api::MultiKnowledgeGraphResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListKnowledgeGraphs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::ListKnowledgeGraphsRequest* /*request*/, ::clarifai::api::MultiKnowledgeGraphResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostKnowledgeGraphs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostKnowledgeGraphs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(14,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostKnowledgeGraphsRequest, ::clarifai::api::MultiKnowledgeGraphResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostKnowledgeGraphsRequest* request, ::clarifai::api::MultiKnowledgeGraphResponse* response) { return this->PostKnowledgeGraphs(context, request, response); }));}
    void SetMessageAllocatorFor_PostKnowledgeGraphs(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostKnowledgeGraphsRequest, ::clarifai::api::MultiKnowledgeGraphResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(14);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostKnowledgeGraphsRequest, ::clarifai::api::MultiKnowledgeGraphResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostKnowledgeGraphs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostKnowledgeGraphs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostKnowledgeGraphsRequest* /*request*/, ::clarifai::api::MultiKnowledgeGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostKnowledgeGraphs(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostKnowledgeGraphsRequest* /*request*/, ::clarifai::api::MultiKnowledgeGraphResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostKnowledgeGraphs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostKnowledgeGraphsRequest* /*request*/, ::clarifai::api::MultiKnowledgeGraphResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostConceptMappingJobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostConceptMappingJobs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(15,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostConceptMappingJobsRequest, ::clarifai::api::MultiConceptMappingJobResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostConceptMappingJobsRequest* request, ::clarifai::api::MultiConceptMappingJobResponse* response) { return this->PostConceptMappingJobs(context, request, response); }));}
    void SetMessageAllocatorFor_PostConceptMappingJobs(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostConceptMappingJobsRequest, ::clarifai::api::MultiConceptMappingJobResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(15);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostConceptMappingJobsRequest, ::clarifai::api::MultiConceptMappingJobResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostConceptMappingJobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostConceptMappingJobs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptMappingJobsRequest* /*request*/, ::clarifai::api::MultiConceptMappingJobResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostConceptMappingJobs(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostConceptMappingJobsRequest* /*request*/, ::clarifai::api::MultiConceptMappingJobResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostConceptMappingJobs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostConceptMappingJobsRequest* /*request*/, ::clarifai::api::MultiConceptMappingJobResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetAnnotation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetAnnotation() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(16,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetAnnotationRequest, ::clarifai::api::SingleAnnotationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::GetAnnotationRequest* request, ::clarifai::api::SingleAnnotationResponse* response) { return this->GetAnnotation(context, request, response); }));}
    void SetMessageAllocatorFor_GetAnnotation(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::GetAnnotationRequest, ::clarifai::api::SingleAnnotationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(16);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetAnnotationRequest, ::clarifai::api::SingleAnnotationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetAnnotation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAnnotation(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetAnnotationRequest* /*request*/, ::clarifai::api::SingleAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetAnnotation(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::GetAnnotationRequest* /*request*/, ::clarifai::api::SingleAnnotationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetAnnotation(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::GetAnnotationRequest* /*request*/, ::clarifai::api::SingleAnnotationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListAnnotations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListAnnotations() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(17,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListAnnotationsRequest, ::clarifai::api::MultiAnnotationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::ListAnnotationsRequest* request, ::clarifai::api::MultiAnnotationResponse* response) { return this->ListAnnotations(context, request, response); }));}
    void SetMessageAllocatorFor_ListAnnotations(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::ListAnnotationsRequest, ::clarifai::api::MultiAnnotationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(17);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListAnnotationsRequest, ::clarifai::api::MultiAnnotationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListAnnotations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAnnotations(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAnnotationsRequest* /*request*/, ::clarifai::api::MultiAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListAnnotations(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::ListAnnotationsRequest* /*request*/, ::clarifai::api::MultiAnnotationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListAnnotations(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::ListAnnotationsRequest* /*request*/, ::clarifai::api::MultiAnnotationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostAnnotations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostAnnotations() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(18,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostAnnotationsRequest, ::clarifai::api::MultiAnnotationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostAnnotationsRequest* request, ::clarifai::api::MultiAnnotationResponse* response) { return this->PostAnnotations(context, request, response); }));}
    void SetMessageAllocatorFor_PostAnnotations(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostAnnotationsRequest, ::clarifai::api::MultiAnnotationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(18);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostAnnotationsRequest, ::clarifai::api::MultiAnnotationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostAnnotations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAnnotations(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAnnotationsRequest* /*request*/, ::clarifai::api::MultiAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostAnnotations(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostAnnotationsRequest* /*request*/, ::clarifai::api::MultiAnnotationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostAnnotations(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostAnnotationsRequest* /*request*/, ::clarifai::api::MultiAnnotationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PatchAnnotations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PatchAnnotations() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(19,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PatchAnnotationsRequest, ::clarifai::api::MultiAnnotationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PatchAnnotationsRequest* request, ::clarifai::api::MultiAnnotationResponse* response) { return this->PatchAnnotations(context, request, response); }));}
    void SetMessageAllocatorFor_PatchAnnotations(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PatchAnnotationsRequest, ::clarifai::api::MultiAnnotationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(19);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PatchAnnotationsRequest, ::clarifai::api::MultiAnnotationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PatchAnnotations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchAnnotations(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchAnnotationsRequest* /*request*/, ::clarifai::api::MultiAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PatchAnnotations(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PatchAnnotationsRequest* /*request*/, ::clarifai::api::MultiAnnotationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PatchAnnotations(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PatchAnnotationsRequest* /*request*/, ::clarifai::api::MultiAnnotationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PatchAnnotationsStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PatchAnnotationsStatus() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(20,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PatchAnnotationsStatusRequest, ::clarifai::api::PatchAnnotationsStatusResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PatchAnnotationsStatusRequest* request, ::clarifai::api::PatchAnnotationsStatusResponse* response) { return this->PatchAnnotationsStatus(context, request, response); }));}
    void SetMessageAllocatorFor_PatchAnnotationsStatus(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PatchAnnotationsStatusRequest, ::clarifai::api::PatchAnnotationsStatusResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(20);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PatchAnnotationsStatusRequest, ::clarifai::api::PatchAnnotationsStatusResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PatchAnnotationsStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchAnnotationsStatus(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchAnnotationsStatusRequest* /*request*/, ::clarifai::api::PatchAnnotationsStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PatchAnnotationsStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PatchAnnotationsStatusRequest* /*request*/, ::clarifai::api::PatchAnnotationsStatusResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PatchAnnotationsStatus(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PatchAnnotationsStatusRequest* /*request*/, ::clarifai::api::PatchAnnotationsStatusResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteAnnotation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteAnnotation() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(21,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteAnnotationRequest, ::clarifai::api::status::BaseResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::DeleteAnnotationRequest* request, ::clarifai::api::status::BaseResponse* response) { return this->DeleteAnnotation(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteAnnotation(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::DeleteAnnotationRequest, ::clarifai::api::status::BaseResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(21);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteAnnotationRequest, ::clarifai::api::status::BaseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteAnnotation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAnnotation(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteAnnotationRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteAnnotation(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteAnnotationRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteAnnotation(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteAnnotationRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteAnnotations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteAnnotations() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(22,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteAnnotationsRequest, ::clarifai::api::status::BaseResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::DeleteAnnotationsRequest* request, ::clarifai::api::status::BaseResponse* response) { return this->DeleteAnnotations(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteAnnotations(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::DeleteAnnotationsRequest, ::clarifai::api::status::BaseResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(22);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(22);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteAnnotationsRequest, ::clarifai::api::status::BaseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteAnnotations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAnnotations(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteAnnotationsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteAnnotations(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteAnnotationsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteAnnotations(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteAnnotationsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostAnnotationsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostAnnotationsSearches() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(23,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostAnnotationsSearchesRequest, ::clarifai::api::MultiSearchResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostAnnotationsSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response) { return this->PostAnnotationsSearches(context, request, response); }));}
    void SetMessageAllocatorFor_PostAnnotationsSearches(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostAnnotationsSearchesRequest, ::clarifai::api::MultiSearchResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(23);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(23);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostAnnotationsSearchesRequest, ::clarifai::api::MultiSearchResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostAnnotationsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAnnotationsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAnnotationsSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostAnnotationsSearches(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostAnnotationsSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostAnnotationsSearches(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostAnnotationsSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetInputCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetInputCount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(24,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetInputCountRequest, ::clarifai::api::SingleInputCountResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::GetInputCountRequest* request, ::clarifai::api::SingleInputCountResponse* response) { return this->GetInputCount(context, request, response); }));}
    void SetMessageAllocatorFor_GetInputCount(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::GetInputCountRequest, ::clarifai::api::SingleInputCountResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(24);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(24);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetInputCountRequest, ::clarifai::api::SingleInputCountResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetInputCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInputCount(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetInputCountRequest* /*request*/, ::clarifai::api::SingleInputCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetInputCount(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::GetInputCountRequest* /*request*/, ::clarifai::api::SingleInputCountResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetInputCount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::GetInputCountRequest* /*request*/, ::clarifai::api::SingleInputCountResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StreamInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_StreamInputs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(25,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::StreamInputsRequest, ::clarifai::api::MultiInputResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::StreamInputsRequest* request, ::clarifai::api::MultiInputResponse* response) { return this->StreamInputs(context, request, response); }));}
    void SetMessageAllocatorFor_StreamInputs(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::StreamInputsRequest, ::clarifai::api::MultiInputResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(25);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(25);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::StreamInputsRequest, ::clarifai::api::MultiInputResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StreamInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::StreamInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* StreamInputs(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::StreamInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* StreamInputs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::StreamInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetInputSamples : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetInputSamples() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(26,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetInputSamplesRequest, ::clarifai::api::MultiInputAnnotationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::GetInputSamplesRequest* request, ::clarifai::api::MultiInputAnnotationResponse* response) { return this->GetInputSamples(context, request, response); }));}
    void SetMessageAllocatorFor_GetInputSamples(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::GetInputSamplesRequest, ::clarifai::api::MultiInputAnnotationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(26);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(26);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetInputSamplesRequest, ::clarifai::api::MultiInputAnnotationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetInputSamples() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInputSamples(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetInputSamplesRequest* /*request*/, ::clarifai::api::MultiInputAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetInputSamples(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::GetInputSamplesRequest* /*request*/, ::clarifai::api::MultiInputAnnotationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetInputSamples(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::GetInputSamplesRequest* /*request*/, ::clarifai::api::MultiInputAnnotationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetInput() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(27,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetInputRequest, ::clarifai::api::SingleInputResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::GetInputRequest* request, ::clarifai::api::SingleInputResponse* response) { return this->GetInput(context, request, response); }));}
    void SetMessageAllocatorFor_GetInput(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::GetInputRequest, ::clarifai::api::SingleInputResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(27);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(27);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetInputRequest, ::clarifai::api::SingleInputResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInput(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetInputRequest* /*request*/, ::clarifai::api::SingleInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetInput(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::GetInputRequest* /*request*/, ::clarifai::api::SingleInputResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetInput(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::GetInputRequest* /*request*/, ::clarifai::api::SingleInputResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListInputs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(28,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListInputsRequest, ::clarifai::api::MultiInputResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::ListInputsRequest* request, ::clarifai::api::MultiInputResponse* response) { return this->ListInputs(context, request, response); }));}
    void SetMessageAllocatorFor_ListInputs(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::ListInputsRequest, ::clarifai::api::MultiInputResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(28);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(28);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListInputsRequest, ::clarifai::api::MultiInputResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListInputs(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::ListInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListInputs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::ListInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostInputs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(29,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostInputsRequest, ::clarifai::api::MultiInputResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostInputsRequest* request, ::clarifai::api::MultiInputResponse* response) { return this->PostInputs(context, request, response); }));}
    void SetMessageAllocatorFor_PostInputs(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostInputsRequest, ::clarifai::api::MultiInputResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(29);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(29);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostInputsRequest, ::clarifai::api::MultiInputResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostInputs(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostInputs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PatchInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PatchInputs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(30,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PatchInputsRequest, ::clarifai::api::MultiInputResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PatchInputsRequest* request, ::clarifai::api::MultiInputResponse* response) { return this->PatchInputs(context, request, response); }));}
    void SetMessageAllocatorFor_PatchInputs(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PatchInputsRequest, ::clarifai::api::MultiInputResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(30);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(30);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PatchInputsRequest, ::clarifai::api::MultiInputResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PatchInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PatchInputs(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PatchInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PatchInputs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PatchInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteInput() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(31,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteInputRequest, ::clarifai::api::status::BaseResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::DeleteInputRequest* request, ::clarifai::api::status::BaseResponse* response) { return this->DeleteInput(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteInput(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::DeleteInputRequest, ::clarifai::api::status::BaseResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(31);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(31);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteInputRequest, ::clarifai::api::status::BaseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteInput(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteInputRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteInput(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteInputRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteInput(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteInputRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteInputs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(32,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteInputsRequest, ::clarifai::api::status::BaseResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::DeleteInputsRequest* request, ::clarifai::api::status::BaseResponse* response) { return this->DeleteInputs(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteInputs(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::DeleteInputsRequest, ::clarifai::api::status::BaseResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(32);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(32);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteInputsRequest, ::clarifai::api::status::BaseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteInputsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteInputs(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteInputsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteInputs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteInputsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostInputsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostInputsSearches() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(33,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostInputsSearchesRequest, ::clarifai::api::MultiSearchResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostInputsSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response) { return this->PostInputsSearches(context, request, response); }));}
    void SetMessageAllocatorFor_PostInputsSearches(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostInputsSearchesRequest, ::clarifai::api::MultiSearchResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(33);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(33);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostInputsSearchesRequest, ::clarifai::api::MultiSearchResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostInputsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostInputsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostInputsSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostInputsSearches(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostInputsSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostInputsSearches(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostInputsSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostModelOutputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostModelOutputs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(34,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostModelOutputsRequest, ::clarifai::api::MultiOutputResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostModelOutputsRequest* request, ::clarifai::api::MultiOutputResponse* response) { return this->PostModelOutputs(context, request, response); }));}
    void SetMessageAllocatorFor_PostModelOutputs(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostModelOutputsRequest, ::clarifai::api::MultiOutputResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(34);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(34);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostModelOutputsRequest, ::clarifai::api::MultiOutputResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostModelOutputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostModelOutputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelOutputsRequest* /*request*/, ::clarifai::api::MultiOutputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostModelOutputs(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostModelOutputsRequest* /*request*/, ::clarifai::api::MultiOutputResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostModelOutputs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostModelOutputsRequest* /*request*/, ::clarifai::api::MultiOutputResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetModelType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetModelType() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(35,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetModelTypeRequest, ::clarifai::api::SingleModelTypeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::GetModelTypeRequest* request, ::clarifai::api::SingleModelTypeResponse* response) { return this->GetModelType(context, request, response); }));}
    void SetMessageAllocatorFor_GetModelType(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::GetModelTypeRequest, ::clarifai::api::SingleModelTypeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(35);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(35);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetModelTypeRequest, ::clarifai::api::SingleModelTypeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetModelType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModelType(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelTypeRequest* /*request*/, ::clarifai::api::SingleModelTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetModelType(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::GetModelTypeRequest* /*request*/, ::clarifai::api::SingleModelTypeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetModelType(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::GetModelTypeRequest* /*request*/, ::clarifai::api::SingleModelTypeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListModelTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListModelTypes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(36,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListModelTypesRequest, ::clarifai::api::MultiModelTypeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::ListModelTypesRequest* request, ::clarifai::api::MultiModelTypeResponse* response) { return this->ListModelTypes(context, request, response); }));}
    void SetMessageAllocatorFor_ListModelTypes(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::ListModelTypesRequest, ::clarifai::api::MultiModelTypeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(36);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(36);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListModelTypesRequest, ::clarifai::api::MultiModelTypeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListModelTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListModelTypes(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListModelTypesRequest* /*request*/, ::clarifai::api::MultiModelTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListModelTypes(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::ListModelTypesRequest* /*request*/, ::clarifai::api::MultiModelTypeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListModelTypes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::ListModelTypesRequest* /*request*/, ::clarifai::api::MultiModelTypeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetModel() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(37,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetModelRequest, ::clarifai::api::SingleModelResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::GetModelRequest* request, ::clarifai::api::SingleModelResponse* response) { return this->GetModel(context, request, response); }));}
    void SetMessageAllocatorFor_GetModel(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::GetModelRequest, ::clarifai::api::SingleModelResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(37);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(37);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetModelRequest, ::clarifai::api::SingleModelResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModel(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetModel(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::GetModelRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetModel(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::GetModelRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetModelOutputInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetModelOutputInfo() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(38,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetModelRequest, ::clarifai::api::SingleModelResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::GetModelRequest* request, ::clarifai::api::SingleModelResponse* response) { return this->GetModelOutputInfo(context, request, response); }));}
    void SetMessageAllocatorFor_GetModelOutputInfo(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::GetModelRequest, ::clarifai::api::SingleModelResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(38);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(38);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetModelRequest, ::clarifai::api::SingleModelResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetModelOutputInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModelOutputInfo(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetModelOutputInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::GetModelRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetModelOutputInfo(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::GetModelRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListModels() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(39,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListModelsRequest, ::clarifai::api::MultiModelResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::ListModelsRequest* request, ::clarifai::api::MultiModelResponse* response) { return this->ListModels(context, request, response); }));}
    void SetMessageAllocatorFor_ListModels(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::ListModelsRequest, ::clarifai::api::MultiModelResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(39);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(39);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListModelsRequest, ::clarifai::api::MultiModelResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListModels(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListModelsRequest* /*request*/, ::clarifai::api::MultiModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListModels(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::ListModelsRequest* /*request*/, ::clarifai::api::MultiModelResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListModels(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::ListModelsRequest* /*request*/, ::clarifai::api::MultiModelResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostModelsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostModelsSearches() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(40,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostModelsSearchesRequest, ::clarifai::api::MultiModelResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostModelsSearchesRequest* request, ::clarifai::api::MultiModelResponse* response) { return this->PostModelsSearches(context, request, response); }));}
    void SetMessageAllocatorFor_PostModelsSearches(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostModelsSearchesRequest, ::clarifai::api::MultiModelResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(40);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(40);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostModelsSearchesRequest, ::clarifai::api::MultiModelResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostModelsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostModelsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelsSearchesRequest* /*request*/, ::clarifai::api::MultiModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostModelsSearches(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostModelsSearchesRequest* /*request*/, ::clarifai::api::MultiModelResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostModelsSearches(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostModelsSearchesRequest* /*request*/, ::clarifai::api::MultiModelResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostModels() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(41,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostModelsRequest, ::clarifai::api::SingleModelResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostModelsRequest* request, ::clarifai::api::SingleModelResponse* response) { return this->PostModels(context, request, response); }));}
    void SetMessageAllocatorFor_PostModels(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostModelsRequest, ::clarifai::api::SingleModelResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(41);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(41);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostModelsRequest, ::clarifai::api::SingleModelResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostModels(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelsRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostModels(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostModelsRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostModels(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostModelsRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PatchModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PatchModels() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(42,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PatchModelsRequest, ::clarifai::api::MultiModelResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PatchModelsRequest* request, ::clarifai::api::MultiModelResponse* response) { return this->PatchModels(context, request, response); }));}
    void SetMessageAllocatorFor_PatchModels(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PatchModelsRequest, ::clarifai::api::MultiModelResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(42);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(42);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PatchModelsRequest, ::clarifai::api::MultiModelResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PatchModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchModels(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchModelsRequest* /*request*/, ::clarifai::api::MultiModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PatchModels(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PatchModelsRequest* /*request*/, ::clarifai::api::MultiModelResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PatchModels(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PatchModelsRequest* /*request*/, ::clarifai::api::MultiModelResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteModel() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(43,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteModelRequest, ::clarifai::api::status::BaseResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::DeleteModelRequest* request, ::clarifai::api::status::BaseResponse* response) { return this->DeleteModel(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteModel(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::DeleteModelRequest, ::clarifai::api::status::BaseResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(43);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(43);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteModelRequest, ::clarifai::api::status::BaseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteModel(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteModelRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteModel(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteModelRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteModel(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteModelRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteModels() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(44,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteModelsRequest, ::clarifai::api::status::BaseResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::DeleteModelsRequest* request, ::clarifai::api::status::BaseResponse* response) { return this->DeleteModels(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteModels(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::DeleteModelsRequest, ::clarifai::api::status::BaseResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(44);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(44);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteModelsRequest, ::clarifai::api::status::BaseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteModels(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteModelsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteModels(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteModelsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteModels(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteModelsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListModelInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListModelInputs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(45,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListModelInputsRequest, ::clarifai::api::MultiInputResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::ListModelInputsRequest* request, ::clarifai::api::MultiInputResponse* response) { return this->ListModelInputs(context, request, response); }));}
    void SetMessageAllocatorFor_ListModelInputs(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::ListModelInputsRequest, ::clarifai::api::MultiInputResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(45);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(45);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListModelInputsRequest, ::clarifai::api::MultiInputResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListModelInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListModelInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListModelInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListModelInputs(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::ListModelInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListModelInputs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::ListModelInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetModelVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetModelVersion() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(46,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetModelVersionRequest, ::clarifai::api::SingleModelVersionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::GetModelVersionRequest* request, ::clarifai::api::SingleModelVersionResponse* response) { return this->GetModelVersion(context, request, response); }));}
    void SetMessageAllocatorFor_GetModelVersion(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::GetModelVersionRequest, ::clarifai::api::SingleModelVersionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(46);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(46);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetModelVersionRequest, ::clarifai::api::SingleModelVersionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetModelVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModelVersion(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelVersionRequest* /*request*/, ::clarifai::api::SingleModelVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetModelVersion(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::GetModelVersionRequest* /*request*/, ::clarifai::api::SingleModelVersionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetModelVersion(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::GetModelVersionRequest* /*request*/, ::clarifai::api::SingleModelVersionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListModelVersions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListModelVersions() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(47,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListModelVersionsRequest, ::clarifai::api::MultiModelVersionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::ListModelVersionsRequest* request, ::clarifai::api::MultiModelVersionResponse* response) { return this->ListModelVersions(context, request, response); }));}
    void SetMessageAllocatorFor_ListModelVersions(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::ListModelVersionsRequest, ::clarifai::api::MultiModelVersionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(47);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(47);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListModelVersionsRequest, ::clarifai::api::MultiModelVersionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListModelVersions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListModelVersions(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListModelVersionsRequest* /*request*/, ::clarifai::api::MultiModelVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListModelVersions(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::ListModelVersionsRequest* /*request*/, ::clarifai::api::MultiModelVersionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListModelVersions(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::ListModelVersionsRequest* /*request*/, ::clarifai::api::MultiModelVersionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostModelVersions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostModelVersions() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(48,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostModelVersionsRequest, ::clarifai::api::SingleModelResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostModelVersionsRequest* request, ::clarifai::api::SingleModelResponse* response) { return this->PostModelVersions(context, request, response); }));}
    void SetMessageAllocatorFor_PostModelVersions(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostModelVersionsRequest, ::clarifai::api::SingleModelResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(48);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(48);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostModelVersionsRequest, ::clarifai::api::SingleModelResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostModelVersions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostModelVersions(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelVersionsRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostModelVersions(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostModelVersionsRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostModelVersions(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostModelVersionsRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteModelVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteModelVersion() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(49,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteModelVersionRequest, ::clarifai::api::status::BaseResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::DeleteModelVersionRequest* request, ::clarifai::api::status::BaseResponse* response) { return this->DeleteModelVersion(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteModelVersion(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::DeleteModelVersionRequest, ::clarifai::api::status::BaseResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(49);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(49);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteModelVersionRequest, ::clarifai::api::status::BaseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteModelVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteModelVersion(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteModelVersionRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteModelVersion(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteModelVersionRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteModelVersion(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteModelVersionRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetModelVersionMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetModelVersionMetrics() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(50,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetModelVersionMetricsRequest, ::clarifai::api::SingleModelVersionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::GetModelVersionMetricsRequest* request, ::clarifai::api::SingleModelVersionResponse* response) { return this->GetModelVersionMetrics(context, request, response); }));}
    void SetMessageAllocatorFor_GetModelVersionMetrics(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::GetModelVersionMetricsRequest, ::clarifai::api::SingleModelVersionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(50);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(50);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetModelVersionMetricsRequest, ::clarifai::api::SingleModelVersionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetModelVersionMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModelVersionMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelVersionMetricsRequest* /*request*/, ::clarifai::api::SingleModelVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetModelVersionMetrics(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::GetModelVersionMetricsRequest* /*request*/, ::clarifai::api::SingleModelVersionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetModelVersionMetrics(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::GetModelVersionMetricsRequest* /*request*/, ::clarifai::api::SingleModelVersionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostModelVersionMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostModelVersionMetrics() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(51,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostModelVersionMetricsRequest, ::clarifai::api::SingleModelVersionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostModelVersionMetricsRequest* request, ::clarifai::api::SingleModelVersionResponse* response) { return this->PostModelVersionMetrics(context, request, response); }));}
    void SetMessageAllocatorFor_PostModelVersionMetrics(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostModelVersionMetricsRequest, ::clarifai::api::SingleModelVersionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(51);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(51);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostModelVersionMetricsRequest, ::clarifai::api::SingleModelVersionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostModelVersionMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostModelVersionMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelVersionMetricsRequest* /*request*/, ::clarifai::api::SingleModelVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostModelVersionMetrics(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostModelVersionMetricsRequest* /*request*/, ::clarifai::api::SingleModelVersionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostModelVersionMetrics(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostModelVersionMetricsRequest* /*request*/, ::clarifai::api::SingleModelVersionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetWorkflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetWorkflow() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(52,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetWorkflowRequest, ::clarifai::api::SingleWorkflowResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::GetWorkflowRequest* request, ::clarifai::api::SingleWorkflowResponse* response) { return this->GetWorkflow(context, request, response); }));}
    void SetMessageAllocatorFor_GetWorkflow(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::GetWorkflowRequest, ::clarifai::api::SingleWorkflowResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(52);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(52);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetWorkflowRequest, ::clarifai::api::SingleWorkflowResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetWorkflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkflow(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetWorkflowRequest* /*request*/, ::clarifai::api::SingleWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetWorkflow(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::GetWorkflowRequest* /*request*/, ::clarifai::api::SingleWorkflowResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetWorkflow(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::GetWorkflowRequest* /*request*/, ::clarifai::api::SingleWorkflowResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListWorkflows() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(53,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListWorkflowsRequest, ::clarifai::api::MultiWorkflowResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::ListWorkflowsRequest* request, ::clarifai::api::MultiWorkflowResponse* response) { return this->ListWorkflows(context, request, response); }));}
    void SetMessageAllocatorFor_ListWorkflows(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::ListWorkflowsRequest, ::clarifai::api::MultiWorkflowResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(53);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(53);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListWorkflowsRequest, ::clarifai::api::MultiWorkflowResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListWorkflows(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListWorkflowsRequest* /*request*/, ::clarifai::api::MultiWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListWorkflows(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::ListWorkflowsRequest* /*request*/, ::clarifai::api::MultiWorkflowResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListWorkflows(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::ListWorkflowsRequest* /*request*/, ::clarifai::api::MultiWorkflowResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostWorkflows() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(54,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostWorkflowsRequest, ::clarifai::api::MultiWorkflowResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostWorkflowsRequest* request, ::clarifai::api::MultiWorkflowResponse* response) { return this->PostWorkflows(context, request, response); }));}
    void SetMessageAllocatorFor_PostWorkflows(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostWorkflowsRequest, ::clarifai::api::MultiWorkflowResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(54);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(54);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostWorkflowsRequest, ::clarifai::api::MultiWorkflowResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostWorkflows(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostWorkflowsRequest* /*request*/, ::clarifai::api::MultiWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostWorkflows(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostWorkflowsRequest* /*request*/, ::clarifai::api::MultiWorkflowResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostWorkflows(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostWorkflowsRequest* /*request*/, ::clarifai::api::MultiWorkflowResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PatchWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PatchWorkflows() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(55,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PatchWorkflowsRequest, ::clarifai::api::MultiWorkflowResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PatchWorkflowsRequest* request, ::clarifai::api::MultiWorkflowResponse* response) { return this->PatchWorkflows(context, request, response); }));}
    void SetMessageAllocatorFor_PatchWorkflows(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PatchWorkflowsRequest, ::clarifai::api::MultiWorkflowResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(55);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(55);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PatchWorkflowsRequest, ::clarifai::api::MultiWorkflowResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PatchWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchWorkflows(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchWorkflowsRequest* /*request*/, ::clarifai::api::MultiWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PatchWorkflows(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PatchWorkflowsRequest* /*request*/, ::clarifai::api::MultiWorkflowResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PatchWorkflows(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PatchWorkflowsRequest* /*request*/, ::clarifai::api::MultiWorkflowResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteWorkflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteWorkflow() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(56,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteWorkflowRequest, ::clarifai::api::status::BaseResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::DeleteWorkflowRequest* request, ::clarifai::api::status::BaseResponse* response) { return this->DeleteWorkflow(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteWorkflow(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::DeleteWorkflowRequest, ::clarifai::api::status::BaseResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(56);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(56);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteWorkflowRequest, ::clarifai::api::status::BaseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteWorkflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteWorkflow(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteWorkflowRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteWorkflow(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteWorkflowRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteWorkflow(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteWorkflowRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteWorkflows() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(57,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteWorkflowsRequest, ::clarifai::api::status::BaseResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::DeleteWorkflowsRequest* request, ::clarifai::api::status::BaseResponse* response) { return this->DeleteWorkflows(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteWorkflows(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::DeleteWorkflowsRequest, ::clarifai::api::status::BaseResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(57);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(57);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteWorkflowsRequest, ::clarifai::api::status::BaseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteWorkflows(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteWorkflowsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteWorkflows(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteWorkflowsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteWorkflows(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteWorkflowsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostWorkflowResults : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostWorkflowResults() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(58,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostWorkflowResultsRequest, ::clarifai::api::PostWorkflowResultsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostWorkflowResultsRequest* request, ::clarifai::api::PostWorkflowResultsResponse* response) { return this->PostWorkflowResults(context, request, response); }));}
    void SetMessageAllocatorFor_PostWorkflowResults(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostWorkflowResultsRequest, ::clarifai::api::PostWorkflowResultsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(58);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(58);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostWorkflowResultsRequest, ::clarifai::api::PostWorkflowResultsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostWorkflowResults() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostWorkflowResults(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostWorkflowResultsRequest* /*request*/, ::clarifai::api::PostWorkflowResultsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostWorkflowResults(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostWorkflowResultsRequest* /*request*/, ::clarifai::api::PostWorkflowResultsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostWorkflowResults(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostWorkflowResultsRequest* /*request*/, ::clarifai::api::PostWorkflowResultsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostWorkflowResultsSimilarity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostWorkflowResultsSimilarity() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(59,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostWorkflowResultsSimilarityRequest, ::clarifai::api::PostWorkflowResultsSimilarityResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostWorkflowResultsSimilarityRequest* request, ::clarifai::api::PostWorkflowResultsSimilarityResponse* response) { return this->PostWorkflowResultsSimilarity(context, request, response); }));}
    void SetMessageAllocatorFor_PostWorkflowResultsSimilarity(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostWorkflowResultsSimilarityRequest, ::clarifai::api::PostWorkflowResultsSimilarityResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(59);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(59);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostWorkflowResultsSimilarityRequest, ::clarifai::api::PostWorkflowResultsSimilarityResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostWorkflowResultsSimilarity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostWorkflowResultsSimilarity(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostWorkflowResultsSimilarityRequest* /*request*/, ::clarifai::api::PostWorkflowResultsSimilarityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostWorkflowResultsSimilarity(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostWorkflowResultsSimilarityRequest* /*request*/, ::clarifai::api::PostWorkflowResultsSimilarityResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostWorkflowResultsSimilarity(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostWorkflowResultsSimilarityRequest* /*request*/, ::clarifai::api::PostWorkflowResultsSimilarityResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetKey() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(60,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetKeyRequest, ::clarifai::api::SingleKeyResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::GetKeyRequest* request, ::clarifai::api::SingleKeyResponse* response) { return this->GetKey(context, request, response); }));}
    void SetMessageAllocatorFor_GetKey(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::GetKeyRequest, ::clarifai::api::SingleKeyResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(60);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(60);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetKeyRequest, ::clarifai::api::SingleKeyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetKey(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetKeyRequest* /*request*/, ::clarifai::api::SingleKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetKey(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::GetKeyRequest* /*request*/, ::clarifai::api::SingleKeyResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetKey(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::GetKeyRequest* /*request*/, ::clarifai::api::SingleKeyResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListKeys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListKeys() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(61,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListKeysRequest, ::clarifai::api::MultiKeyResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::ListKeysRequest* request, ::clarifai::api::MultiKeyResponse* response) { return this->ListKeys(context, request, response); }));}
    void SetMessageAllocatorFor_ListKeys(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::ListKeysRequest, ::clarifai::api::MultiKeyResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(61);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(61);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListKeysRequest, ::clarifai::api::MultiKeyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListKeys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListKeys(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListKeys(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::ListKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListKeys(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::ListKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListAppKeys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListAppKeys() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(62,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListAppKeysRequest, ::clarifai::api::MultiKeyResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::ListAppKeysRequest* request, ::clarifai::api::MultiKeyResponse* response) { return this->ListAppKeys(context, request, response); }));}
    void SetMessageAllocatorFor_ListAppKeys(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::ListAppKeysRequest, ::clarifai::api::MultiKeyResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(62);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(62);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListAppKeysRequest, ::clarifai::api::MultiKeyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListAppKeys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAppKeys(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAppKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListAppKeys(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::ListAppKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListAppKeys(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::ListAppKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteKey() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(63,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteKeyRequest, ::clarifai::api::status::BaseResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::DeleteKeyRequest* request, ::clarifai::api::status::BaseResponse* response) { return this->DeleteKey(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteKey(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::DeleteKeyRequest, ::clarifai::api::status::BaseResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(63);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(63);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteKeyRequest, ::clarifai::api::status::BaseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteKey(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteKeyRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteKey(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteKeyRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteKey(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteKeyRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostKeys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostKeys() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(64,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostKeysRequest, ::clarifai::api::MultiKeyResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostKeysRequest* request, ::clarifai::api::MultiKeyResponse* response) { return this->PostKeys(context, request, response); }));}
    void SetMessageAllocatorFor_PostKeys(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostKeysRequest, ::clarifai::api::MultiKeyResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(64);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(64);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostKeysRequest, ::clarifai::api::MultiKeyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostKeys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostKeys(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostKeys(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostKeys(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PatchKeys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PatchKeys() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(65,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PatchKeysRequest, ::clarifai::api::MultiKeyResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PatchKeysRequest* request, ::clarifai::api::MultiKeyResponse* response) { return this->PatchKeys(context, request, response); }));}
    void SetMessageAllocatorFor_PatchKeys(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PatchKeysRequest, ::clarifai::api::MultiKeyResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(65);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(65);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PatchKeysRequest, ::clarifai::api::MultiKeyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PatchKeys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchKeys(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PatchKeys(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PatchKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PatchKeys(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PatchKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MyScopes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MyScopes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(66,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::MyScopesRequest, ::clarifai::api::MultiScopeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::MyScopesRequest* request, ::clarifai::api::MultiScopeResponse* response) { return this->MyScopes(context, request, response); }));}
    void SetMessageAllocatorFor_MyScopes(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::MyScopesRequest, ::clarifai::api::MultiScopeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(66);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(66);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::MyScopesRequest, ::clarifai::api::MultiScopeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MyScopes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MyScopes(::grpc::ServerContext* /*context*/, const ::clarifai::api::MyScopesRequest* /*request*/, ::clarifai::api::MultiScopeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MyScopes(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::MyScopesRequest* /*request*/, ::clarifai::api::MultiScopeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MyScopes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::MyScopesRequest* /*request*/, ::clarifai::api::MultiScopeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListScopes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListScopes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(67,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListScopesRequest, ::clarifai::api::MultiScopeDepsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::ListScopesRequest* request, ::clarifai::api::MultiScopeDepsResponse* response) { return this->ListScopes(context, request, response); }));}
    void SetMessageAllocatorFor_ListScopes(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::ListScopesRequest, ::clarifai::api::MultiScopeDepsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(67);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(67);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListScopesRequest, ::clarifai::api::MultiScopeDepsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListScopes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListScopes(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListScopesRequest* /*request*/, ::clarifai::api::MultiScopeDepsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListScopes(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::ListScopesRequest* /*request*/, ::clarifai::api::MultiScopeDepsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListScopes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::ListScopesRequest* /*request*/, ::clarifai::api::MultiScopeDepsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetApp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetApp() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(68,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetAppRequest, ::clarifai::api::SingleAppResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::GetAppRequest* request, ::clarifai::api::SingleAppResponse* response) { return this->GetApp(context, request, response); }));}
    void SetMessageAllocatorFor_GetApp(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::GetAppRequest, ::clarifai::api::SingleAppResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(68);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(68);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetAppRequest, ::clarifai::api::SingleAppResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetApp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetApp(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetAppRequest* /*request*/, ::clarifai::api::SingleAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetApp(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::GetAppRequest* /*request*/, ::clarifai::api::SingleAppResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetApp(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::GetAppRequest* /*request*/, ::clarifai::api::SingleAppResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListApps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListApps() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(69,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListAppsRequest, ::clarifai::api::MultiAppResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::ListAppsRequest* request, ::clarifai::api::MultiAppResponse* response) { return this->ListApps(context, request, response); }));}
    void SetMessageAllocatorFor_ListApps(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::ListAppsRequest, ::clarifai::api::MultiAppResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(69);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(69);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListAppsRequest, ::clarifai::api::MultiAppResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListApps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListApps(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAppsRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListApps(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::ListAppsRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListApps(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::ListAppsRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteApp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteApp() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(70,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteAppRequest, ::clarifai::api::status::BaseResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::DeleteAppRequest* request, ::clarifai::api::status::BaseResponse* response) { return this->DeleteApp(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteApp(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::DeleteAppRequest, ::clarifai::api::status::BaseResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(70);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(70);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteAppRequest, ::clarifai::api::status::BaseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteApp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteApp(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteAppRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteApp(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteAppRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteApp(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteAppRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostApps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostApps() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(71,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostAppsRequest, ::clarifai::api::MultiAppResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostAppsRequest* request, ::clarifai::api::MultiAppResponse* response) { return this->PostApps(context, request, response); }));}
    void SetMessageAllocatorFor_PostApps(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostAppsRequest, ::clarifai::api::MultiAppResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(71);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(71);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostAppsRequest, ::clarifai::api::MultiAppResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostApps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostApps(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAppsRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostApps(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostAppsRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostApps(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostAppsRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PatchApps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PatchApps() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(72,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PatchAppsRequest, ::clarifai::api::MultiAppResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PatchAppsRequest* request, ::clarifai::api::MultiAppResponse* response) { return this->PatchApps(context, request, response); }));}
    void SetMessageAllocatorFor_PatchApps(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PatchAppsRequest, ::clarifai::api::MultiAppResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(72);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(72);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PatchAppsRequest, ::clarifai::api::MultiAppResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PatchApps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchApps(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchAppsRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PatchApps(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PatchAppsRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PatchApps(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PatchAppsRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostAppsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostAppsSearches() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(73,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostAppsSearchesRequest, ::clarifai::api::MultiAppResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostAppsSearchesRequest* request, ::clarifai::api::MultiAppResponse* response) { return this->PostAppsSearches(context, request, response); }));}
    void SetMessageAllocatorFor_PostAppsSearches(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostAppsSearchesRequest, ::clarifai::api::MultiAppResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(73);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(73);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostAppsSearchesRequest, ::clarifai::api::MultiAppResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostAppsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAppsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAppsSearchesRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostAppsSearches(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostAppsSearchesRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostAppsSearches(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostAppsSearchesRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostValidatePassword : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostValidatePassword() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(74,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostValidatePasswordRequest, ::clarifai::api::SinglePasswordValidationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostValidatePasswordRequest* request, ::clarifai::api::SinglePasswordValidationResponse* response) { return this->PostValidatePassword(context, request, response); }));}
    void SetMessageAllocatorFor_PostValidatePassword(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostValidatePasswordRequest, ::clarifai::api::SinglePasswordValidationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(74);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(74);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostValidatePasswordRequest, ::clarifai::api::SinglePasswordValidationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostValidatePassword() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostValidatePassword(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostValidatePasswordRequest* /*request*/, ::clarifai::api::SinglePasswordValidationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostValidatePassword(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostValidatePasswordRequest* /*request*/, ::clarifai::api::SinglePasswordValidationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostValidatePassword(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostValidatePasswordRequest* /*request*/, ::clarifai::api::SinglePasswordValidationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetSearch() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(75,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetSearchRequest, ::clarifai::api::SingleSearchResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::GetSearchRequest* request, ::clarifai::api::SingleSearchResponse* response) { return this->GetSearch(context, request, response); }));}
    void SetMessageAllocatorFor_GetSearch(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::GetSearchRequest, ::clarifai::api::SingleSearchResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(75);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(75);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetSearchRequest, ::clarifai::api::SingleSearchResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSearch(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetSearchRequest* /*request*/, ::clarifai::api::SingleSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetSearch(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::GetSearchRequest* /*request*/, ::clarifai::api::SingleSearchResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetSearch(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::GetSearchRequest* /*request*/, ::clarifai::api::SingleSearchResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListSearches() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(76,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListSearchesRequest, ::clarifai::api::MultiSearchResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::ListSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response) { return this->ListSearches(context, request, response); }));}
    void SetMessageAllocatorFor_ListSearches(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::ListSearchesRequest, ::clarifai::api::MultiSearchResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(76);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(76);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListSearchesRequest, ::clarifai::api::MultiSearchResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListSearches(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::ListSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListSearches(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::ListSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostSearches() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(77,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostSearchesRequest, ::clarifai::api::MultiSearchResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostSearchesRequest* request, ::clarifai::api::MultiSearchResponse* response) { return this->PostSearches(context, request, response); }));}
    void SetMessageAllocatorFor_PostSearches(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostSearchesRequest, ::clarifai::api::MultiSearchResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(77);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(77);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostSearchesRequest, ::clarifai::api::MultiSearchResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostSearches(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostSearches(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostSearchesByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostSearchesByID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(78,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostSearchesByIDRequest, ::clarifai::api::MultiSearchResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostSearchesByIDRequest* request, ::clarifai::api::MultiSearchResponse* response) { return this->PostSearchesByID(context, request, response); }));}
    void SetMessageAllocatorFor_PostSearchesByID(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostSearchesByIDRequest, ::clarifai::api::MultiSearchResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(78);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(78);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostSearchesByIDRequest, ::clarifai::api::MultiSearchResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostSearchesByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostSearchesByID(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostSearchesByIDRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostSearchesByID(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostSearchesByIDRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostSearchesByID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostSearchesByIDRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostAnnotationSearchMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostAnnotationSearchMetrics() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(79,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostAnnotationSearchMetricsRequest, ::clarifai::api::MultiAnnotationSearchMetricsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostAnnotationSearchMetricsRequest* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response) { return this->PostAnnotationSearchMetrics(context, request, response); }));}
    void SetMessageAllocatorFor_PostAnnotationSearchMetrics(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostAnnotationSearchMetricsRequest, ::clarifai::api::MultiAnnotationSearchMetricsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(79);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(79);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostAnnotationSearchMetricsRequest, ::clarifai::api::MultiAnnotationSearchMetricsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostAnnotationSearchMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAnnotationSearchMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::MultiAnnotationSearchMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostAnnotationSearchMetrics(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::MultiAnnotationSearchMetricsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostAnnotationSearchMetrics(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::MultiAnnotationSearchMetricsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetAnnotationSearchMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetAnnotationSearchMetrics() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(80,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetAnnotationSearchMetricsRequest, ::clarifai::api::MultiAnnotationSearchMetricsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::GetAnnotationSearchMetricsRequest* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response) { return this->GetAnnotationSearchMetrics(context, request, response); }));}
    void SetMessageAllocatorFor_GetAnnotationSearchMetrics(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::GetAnnotationSearchMetricsRequest, ::clarifai::api::MultiAnnotationSearchMetricsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(80);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(80);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetAnnotationSearchMetricsRequest, ::clarifai::api::MultiAnnotationSearchMetricsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetAnnotationSearchMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAnnotationSearchMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::MultiAnnotationSearchMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetAnnotationSearchMetrics(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::GetAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::MultiAnnotationSearchMetricsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetAnnotationSearchMetrics(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::GetAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::MultiAnnotationSearchMetricsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListAnnotationSearchMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListAnnotationSearchMetrics() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(81,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListAnnotationSearchMetricsRequest, ::clarifai::api::MultiAnnotationSearchMetricsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::ListAnnotationSearchMetricsRequest* request, ::clarifai::api::MultiAnnotationSearchMetricsResponse* response) { return this->ListAnnotationSearchMetrics(context, request, response); }));}
    void SetMessageAllocatorFor_ListAnnotationSearchMetrics(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::ListAnnotationSearchMetricsRequest, ::clarifai::api::MultiAnnotationSearchMetricsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(81);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(81);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListAnnotationSearchMetricsRequest, ::clarifai::api::MultiAnnotationSearchMetricsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListAnnotationSearchMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAnnotationSearchMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::MultiAnnotationSearchMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListAnnotationSearchMetrics(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::ListAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::MultiAnnotationSearchMetricsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListAnnotationSearchMetrics(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::ListAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::MultiAnnotationSearchMetricsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteAnnotationSearchMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteAnnotationSearchMetrics() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(82,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteAnnotationSearchMetricsRequest, ::clarifai::api::status::BaseResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::DeleteAnnotationSearchMetricsRequest* request, ::clarifai::api::status::BaseResponse* response) { return this->DeleteAnnotationSearchMetrics(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteAnnotationSearchMetrics(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::DeleteAnnotationSearchMetricsRequest, ::clarifai::api::status::BaseResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(82);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(82);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteAnnotationSearchMetricsRequest, ::clarifai::api::status::BaseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteAnnotationSearchMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAnnotationSearchMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteAnnotationSearchMetrics(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteAnnotationSearchMetrics(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteSearch() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(83,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteSearchRequest, ::clarifai::api::status::BaseResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::DeleteSearchRequest* request, ::clarifai::api::status::BaseResponse* response) { return this->DeleteSearch(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteSearch(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::DeleteSearchRequest, ::clarifai::api::status::BaseResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(83);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(83);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteSearchRequest, ::clarifai::api::status::BaseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSearch(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteSearchRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteSearch(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteSearchRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteSearch(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteSearchRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListStatusCodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListStatusCodes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(84,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListStatusCodesRequest, ::clarifai::api::MultiStatusCodeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::ListStatusCodesRequest* request, ::clarifai::api::MultiStatusCodeResponse* response) { return this->ListStatusCodes(context, request, response); }));}
    void SetMessageAllocatorFor_ListStatusCodes(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::ListStatusCodesRequest, ::clarifai::api::MultiStatusCodeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(84);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(84);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListStatusCodesRequest, ::clarifai::api::MultiStatusCodeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListStatusCodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListStatusCodes(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListStatusCodesRequest* /*request*/, ::clarifai::api::MultiStatusCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListStatusCodes(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::ListStatusCodesRequest* /*request*/, ::clarifai::api::MultiStatusCodeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListStatusCodes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::ListStatusCodesRequest* /*request*/, ::clarifai::api::MultiStatusCodeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetStatusCode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetStatusCode() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(85,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetStatusCodeRequest, ::clarifai::api::SingleStatusCodeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::GetStatusCodeRequest* request, ::clarifai::api::SingleStatusCodeResponse* response) { return this->GetStatusCode(context, request, response); }));}
    void SetMessageAllocatorFor_GetStatusCode(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::GetStatusCodeRequest, ::clarifai::api::SingleStatusCodeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(85);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(85);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetStatusCodeRequest, ::clarifai::api::SingleStatusCodeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetStatusCode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStatusCode(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetStatusCodeRequest* /*request*/, ::clarifai::api::SingleStatusCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetStatusCode(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::GetStatusCodeRequest* /*request*/, ::clarifai::api::SingleStatusCodeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetStatusCode(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::GetStatusCodeRequest* /*request*/, ::clarifai::api::SingleStatusCodeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListCollaborators : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListCollaborators() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(86,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListCollaboratorsRequest, ::clarifai::api::MultiCollaboratorsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::ListCollaboratorsRequest* request, ::clarifai::api::MultiCollaboratorsResponse* response) { return this->ListCollaborators(context, request, response); }));}
    void SetMessageAllocatorFor_ListCollaborators(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::ListCollaboratorsRequest, ::clarifai::api::MultiCollaboratorsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(86);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(86);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListCollaboratorsRequest, ::clarifai::api::MultiCollaboratorsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListCollaborators() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListCollaborators(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListCollaboratorsRequest* /*request*/, ::clarifai::api::MultiCollaboratorsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListCollaborators(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::ListCollaboratorsRequest* /*request*/, ::clarifai::api::MultiCollaboratorsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListCollaborators(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::ListCollaboratorsRequest* /*request*/, ::clarifai::api::MultiCollaboratorsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostCollaborators : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostCollaborators() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(87,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostCollaboratorsRequest, ::clarifai::api::MultiCollaboratorsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostCollaboratorsRequest* request, ::clarifai::api::MultiCollaboratorsResponse* response) { return this->PostCollaborators(context, request, response); }));}
    void SetMessageAllocatorFor_PostCollaborators(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostCollaboratorsRequest, ::clarifai::api::MultiCollaboratorsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(87);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(87);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostCollaboratorsRequest, ::clarifai::api::MultiCollaboratorsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostCollaborators() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostCollaborators(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostCollaboratorsRequest* /*request*/, ::clarifai::api::MultiCollaboratorsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostCollaborators(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostCollaboratorsRequest* /*request*/, ::clarifai::api::MultiCollaboratorsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostCollaborators(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostCollaboratorsRequest* /*request*/, ::clarifai::api::MultiCollaboratorsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PatchCollaborators : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PatchCollaborators() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(88,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PatchCollaboratorsRequest, ::clarifai::api::MultiCollaboratorsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PatchCollaboratorsRequest* request, ::clarifai::api::MultiCollaboratorsResponse* response) { return this->PatchCollaborators(context, request, response); }));}
    void SetMessageAllocatorFor_PatchCollaborators(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PatchCollaboratorsRequest, ::clarifai::api::MultiCollaboratorsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(88);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(88);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PatchCollaboratorsRequest, ::clarifai::api::MultiCollaboratorsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PatchCollaborators() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchCollaborators(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchCollaboratorsRequest* /*request*/, ::clarifai::api::MultiCollaboratorsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PatchCollaborators(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PatchCollaboratorsRequest* /*request*/, ::clarifai::api::MultiCollaboratorsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PatchCollaborators(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PatchCollaboratorsRequest* /*request*/, ::clarifai::api::MultiCollaboratorsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteCollaborators : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteCollaborators() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(89,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteCollaboratorsRequest, ::clarifai::api::status::BaseResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::DeleteCollaboratorsRequest* request, ::clarifai::api::status::BaseResponse* response) { return this->DeleteCollaborators(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteCollaborators(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::DeleteCollaboratorsRequest, ::clarifai::api::status::BaseResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(89);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(89);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteCollaboratorsRequest, ::clarifai::api::status::BaseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteCollaborators() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteCollaborators(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteCollaboratorsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteCollaborators(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteCollaboratorsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteCollaborators(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteCollaboratorsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListCollaborations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListCollaborations() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(90,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListCollaborationsRequest, ::clarifai::api::MultiCollaborationsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::ListCollaborationsRequest* request, ::clarifai::api::MultiCollaborationsResponse* response) { return this->ListCollaborations(context, request, response); }));}
    void SetMessageAllocatorFor_ListCollaborations(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::ListCollaborationsRequest, ::clarifai::api::MultiCollaborationsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(90);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(90);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListCollaborationsRequest, ::clarifai::api::MultiCollaborationsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListCollaborations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListCollaborations(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListCollaborationsRequest* /*request*/, ::clarifai::api::MultiCollaborationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListCollaborations(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::ListCollaborationsRequest* /*request*/, ::clarifai::api::MultiCollaborationsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListCollaborations(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::ListCollaborationsRequest* /*request*/, ::clarifai::api::MultiCollaborationsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostAppDuplications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostAppDuplications() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(91,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostAppDuplicationsRequest, ::clarifai::api::MultiAppDuplicationsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostAppDuplicationsRequest* request, ::clarifai::api::MultiAppDuplicationsResponse* response) { return this->PostAppDuplications(context, request, response); }));}
    void SetMessageAllocatorFor_PostAppDuplications(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostAppDuplicationsRequest, ::clarifai::api::MultiAppDuplicationsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(91);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(91);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostAppDuplicationsRequest, ::clarifai::api::MultiAppDuplicationsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostAppDuplications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAppDuplications(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAppDuplicationsRequest* /*request*/, ::clarifai::api::MultiAppDuplicationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostAppDuplications(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostAppDuplicationsRequest* /*request*/, ::clarifai::api::MultiAppDuplicationsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostAppDuplications(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostAppDuplicationsRequest* /*request*/, ::clarifai::api::MultiAppDuplicationsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListAppDuplications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListAppDuplications() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(92,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListAppDuplicationsRequest, ::clarifai::api::MultiAppDuplicationsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::ListAppDuplicationsRequest* request, ::clarifai::api::MultiAppDuplicationsResponse* response) { return this->ListAppDuplications(context, request, response); }));}
    void SetMessageAllocatorFor_ListAppDuplications(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::ListAppDuplicationsRequest, ::clarifai::api::MultiAppDuplicationsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(92);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(92);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListAppDuplicationsRequest, ::clarifai::api::MultiAppDuplicationsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListAppDuplications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAppDuplications(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAppDuplicationsRequest* /*request*/, ::clarifai::api::MultiAppDuplicationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListAppDuplications(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::ListAppDuplicationsRequest* /*request*/, ::clarifai::api::MultiAppDuplicationsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListAppDuplications(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::ListAppDuplicationsRequest* /*request*/, ::clarifai::api::MultiAppDuplicationsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetAppDuplication : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetAppDuplication() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(93,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetAppDuplicationRequest, ::clarifai::api::SingleAppDuplicationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::GetAppDuplicationRequest* request, ::clarifai::api::SingleAppDuplicationResponse* response) { return this->GetAppDuplication(context, request, response); }));}
    void SetMessageAllocatorFor_GetAppDuplication(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::GetAppDuplicationRequest, ::clarifai::api::SingleAppDuplicationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(93);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(93);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetAppDuplicationRequest, ::clarifai::api::SingleAppDuplicationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetAppDuplication() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAppDuplication(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetAppDuplicationRequest* /*request*/, ::clarifai::api::SingleAppDuplicationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetAppDuplication(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::GetAppDuplicationRequest* /*request*/, ::clarifai::api::SingleAppDuplicationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetAppDuplication(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::GetAppDuplicationRequest* /*request*/, ::clarifai::api::SingleAppDuplicationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostTasks() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(94,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostTasksRequest, ::clarifai::api::MultiTaskResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostTasksRequest* request, ::clarifai::api::MultiTaskResponse* response) { return this->PostTasks(context, request, response); }));}
    void SetMessageAllocatorFor_PostTasks(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostTasksRequest, ::clarifai::api::MultiTaskResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(94);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(94);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostTasksRequest, ::clarifai::api::MultiTaskResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostTasks(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostTasksRequest* /*request*/, ::clarifai::api::MultiTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostTasks(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostTasksRequest* /*request*/, ::clarifai::api::MultiTaskResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostTasks(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostTasksRequest* /*request*/, ::clarifai::api::MultiTaskResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetTaskAnnotationCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetTaskAnnotationCount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(95,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetTaskCountRequest, ::clarifai::api::SingleTaskCountResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::GetTaskCountRequest* request, ::clarifai::api::SingleTaskCountResponse* response) { return this->GetTaskAnnotationCount(context, request, response); }));}
    void SetMessageAllocatorFor_GetTaskAnnotationCount(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::GetTaskCountRequest, ::clarifai::api::SingleTaskCountResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(95);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(95);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetTaskCountRequest, ::clarifai::api::SingleTaskCountResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetTaskAnnotationCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskAnnotationCount(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetTaskCountRequest* /*request*/, ::clarifai::api::SingleTaskCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetTaskAnnotationCount(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::GetTaskCountRequest* /*request*/, ::clarifai::api::SingleTaskCountResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetTaskAnnotationCount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::GetTaskCountRequest* /*request*/, ::clarifai::api::SingleTaskCountResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetTaskInputCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetTaskInputCount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(96,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetTaskCountRequest, ::clarifai::api::SingleTaskCountResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::GetTaskCountRequest* request, ::clarifai::api::SingleTaskCountResponse* response) { return this->GetTaskInputCount(context, request, response); }));}
    void SetMessageAllocatorFor_GetTaskInputCount(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::GetTaskCountRequest, ::clarifai::api::SingleTaskCountResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(96);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(96);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetTaskCountRequest, ::clarifai::api::SingleTaskCountResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetTaskInputCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskInputCount(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetTaskCountRequest* /*request*/, ::clarifai::api::SingleTaskCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetTaskInputCount(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::GetTaskCountRequest* /*request*/, ::clarifai::api::SingleTaskCountResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetTaskInputCount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::GetTaskCountRequest* /*request*/, ::clarifai::api::SingleTaskCountResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetTask() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(97,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetTaskRequest, ::clarifai::api::SingleTaskResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::GetTaskRequest* request, ::clarifai::api::SingleTaskResponse* response) { return this->GetTask(context, request, response); }));}
    void SetMessageAllocatorFor_GetTask(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::GetTaskRequest, ::clarifai::api::SingleTaskResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(97);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(97);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetTaskRequest, ::clarifai::api::SingleTaskResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTask(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetTaskRequest* /*request*/, ::clarifai::api::SingleTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetTask(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::GetTaskRequest* /*request*/, ::clarifai::api::SingleTaskResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetTask(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::GetTaskRequest* /*request*/, ::clarifai::api::SingleTaskResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListTasks() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(98,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListTasksRequest, ::clarifai::api::MultiTaskResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::ListTasksRequest* request, ::clarifai::api::MultiTaskResponse* response) { return this->ListTasks(context, request, response); }));}
    void SetMessageAllocatorFor_ListTasks(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::ListTasksRequest, ::clarifai::api::MultiTaskResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(98);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(98);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListTasksRequest, ::clarifai::api::MultiTaskResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTasks(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListTasksRequest* /*request*/, ::clarifai::api::MultiTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListTasks(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::ListTasksRequest* /*request*/, ::clarifai::api::MultiTaskResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListTasks(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::ListTasksRequest* /*request*/, ::clarifai::api::MultiTaskResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PatchTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PatchTasks() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(99,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PatchTasksRequest, ::clarifai::api::MultiTaskResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PatchTasksRequest* request, ::clarifai::api::MultiTaskResponse* response) { return this->PatchTasks(context, request, response); }));}
    void SetMessageAllocatorFor_PatchTasks(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PatchTasksRequest, ::clarifai::api::MultiTaskResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(99);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(99);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PatchTasksRequest, ::clarifai::api::MultiTaskResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PatchTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchTasks(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchTasksRequest* /*request*/, ::clarifai::api::MultiTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PatchTasks(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PatchTasksRequest* /*request*/, ::clarifai::api::MultiTaskResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PatchTasks(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PatchTasksRequest* /*request*/, ::clarifai::api::MultiTaskResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteTasks() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(100,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteTasksRequest, ::clarifai::api::status::BaseResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::DeleteTasksRequest* request, ::clarifai::api::status::BaseResponse* response) { return this->DeleteTasks(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteTasks(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::DeleteTasksRequest, ::clarifai::api::status::BaseResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(100);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(100);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteTasksRequest, ::clarifai::api::status::BaseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteTasks(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteTasksRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteTasks(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteTasksRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteTasks(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteTasksRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostCollectors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostCollectors() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(101,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostCollectorsRequest, ::clarifai::api::MultiCollectorResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostCollectorsRequest* request, ::clarifai::api::MultiCollectorResponse* response) { return this->PostCollectors(context, request, response); }));}
    void SetMessageAllocatorFor_PostCollectors(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostCollectorsRequest, ::clarifai::api::MultiCollectorResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(101);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(101);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostCollectorsRequest, ::clarifai::api::MultiCollectorResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostCollectors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostCollectors(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostCollectorsRequest* /*request*/, ::clarifai::api::MultiCollectorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostCollectors(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostCollectorsRequest* /*request*/, ::clarifai::api::MultiCollectorResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostCollectors(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostCollectorsRequest* /*request*/, ::clarifai::api::MultiCollectorResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetCollector : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetCollector() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(102,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetCollectorRequest, ::clarifai::api::SingleCollectorResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::GetCollectorRequest* request, ::clarifai::api::SingleCollectorResponse* response) { return this->GetCollector(context, request, response); }));}
    void SetMessageAllocatorFor_GetCollector(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::GetCollectorRequest, ::clarifai::api::SingleCollectorResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(102);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(102);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::GetCollectorRequest, ::clarifai::api::SingleCollectorResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetCollector() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollector(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetCollectorRequest* /*request*/, ::clarifai::api::SingleCollectorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetCollector(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::GetCollectorRequest* /*request*/, ::clarifai::api::SingleCollectorResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetCollector(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::GetCollectorRequest* /*request*/, ::clarifai::api::SingleCollectorResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListCollectors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListCollectors() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(103,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListCollectorsRequest, ::clarifai::api::MultiCollectorResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::ListCollectorsRequest* request, ::clarifai::api::MultiCollectorResponse* response) { return this->ListCollectors(context, request, response); }));}
    void SetMessageAllocatorFor_ListCollectors(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::ListCollectorsRequest, ::clarifai::api::MultiCollectorResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(103);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(103);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::ListCollectorsRequest, ::clarifai::api::MultiCollectorResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListCollectors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListCollectors(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListCollectorsRequest* /*request*/, ::clarifai::api::MultiCollectorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListCollectors(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::ListCollectorsRequest* /*request*/, ::clarifai::api::MultiCollectorResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListCollectors(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::ListCollectorsRequest* /*request*/, ::clarifai::api::MultiCollectorResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PatchCollectors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PatchCollectors() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(104,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PatchCollectorsRequest, ::clarifai::api::MultiCollectorResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PatchCollectorsRequest* request, ::clarifai::api::MultiCollectorResponse* response) { return this->PatchCollectors(context, request, response); }));}
    void SetMessageAllocatorFor_PatchCollectors(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PatchCollectorsRequest, ::clarifai::api::MultiCollectorResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(104);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(104);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PatchCollectorsRequest, ::clarifai::api::MultiCollectorResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PatchCollectors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchCollectors(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchCollectorsRequest* /*request*/, ::clarifai::api::MultiCollectorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PatchCollectors(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PatchCollectorsRequest* /*request*/, ::clarifai::api::MultiCollectorResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PatchCollectors(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PatchCollectorsRequest* /*request*/, ::clarifai::api::MultiCollectorResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteCollectors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteCollectors() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(105,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteCollectorsRequest, ::clarifai::api::status::BaseResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::DeleteCollectorsRequest* request, ::clarifai::api::status::BaseResponse* response) { return this->DeleteCollectors(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteCollectors(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::DeleteCollectorsRequest, ::clarifai::api::status::BaseResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(105);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(105);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::DeleteCollectorsRequest, ::clarifai::api::status::BaseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteCollectors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteCollectors(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteCollectorsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteCollectors(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteCollectorsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteCollectors(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::DeleteCollectorsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostStatValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostStatValues() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(106,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostStatValuesRequest, ::clarifai::api::MultiStatValueResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostStatValuesRequest* request, ::clarifai::api::MultiStatValueResponse* response) { return this->PostStatValues(context, request, response); }));}
    void SetMessageAllocatorFor_PostStatValues(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostStatValuesRequest, ::clarifai::api::MultiStatValueResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(106);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(106);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostStatValuesRequest, ::clarifai::api::MultiStatValueResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostStatValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostStatValues(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostStatValuesRequest* /*request*/, ::clarifai::api::MultiStatValueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostStatValues(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostStatValuesRequest* /*request*/, ::clarifai::api::MultiStatValueResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostStatValues(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostStatValuesRequest* /*request*/, ::clarifai::api::MultiStatValueResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PostStatValuesAggregate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PostStatValuesAggregate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(107,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostStatValuesAggregateRequest, ::clarifai::api::MultiStatValueAggregateResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::clarifai::api::PostStatValuesAggregateRequest* request, ::clarifai::api::MultiStatValueAggregateResponse* response) { return this->PostStatValuesAggregate(context, request, response); }));}
    void SetMessageAllocatorFor_PostStatValuesAggregate(
        ::grpc::experimental::MessageAllocator< ::clarifai::api::PostStatValuesAggregateRequest, ::clarifai::api::MultiStatValueAggregateResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(107);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(107);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::clarifai::api::PostStatValuesAggregateRequest, ::clarifai::api::MultiStatValueAggregateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PostStatValuesAggregate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostStatValuesAggregate(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostStatValuesAggregateRequest* /*request*/, ::clarifai::api::MultiStatValueAggregateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostStatValuesAggregate(
      ::grpc::CallbackServerContext* /*context*/, const ::clarifai::api::PostStatValuesAggregateRequest* /*request*/, ::clarifai::api::MultiStatValueAggregateResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostStatValuesAggregate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::clarifai::api::PostStatValuesAggregateRequest* /*request*/, ::clarifai::api::MultiStatValueAggregateResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_ListConceptRelations<ExperimentalWithCallbackMethod_PostConceptRelations<ExperimentalWithCallbackMethod_DeleteConceptRelations<ExperimentalWithCallbackMethod_GetConceptCounts<ExperimentalWithCallbackMethod_GetConcept<ExperimentalWithCallbackMethod_ListConcepts<ExperimentalWithCallbackMethod_PostConceptsSearches<ExperimentalWithCallbackMethod_PostConcepts<ExperimentalWithCallbackMethod_PatchConcepts<ExperimentalWithCallbackMethod_GetConceptLanguage<ExperimentalWithCallbackMethod_ListConceptLanguages<ExperimentalWithCallbackMethod_PostConceptLanguages<ExperimentalWithCallbackMethod_PatchConceptLanguages<ExperimentalWithCallbackMethod_ListKnowledgeGraphs<ExperimentalWithCallbackMethod_PostKnowledgeGraphs<ExperimentalWithCallbackMethod_PostConceptMappingJobs<ExperimentalWithCallbackMethod_GetAnnotation<ExperimentalWithCallbackMethod_ListAnnotations<ExperimentalWithCallbackMethod_PostAnnotations<ExperimentalWithCallbackMethod_PatchAnnotations<ExperimentalWithCallbackMethod_PatchAnnotationsStatus<ExperimentalWithCallbackMethod_DeleteAnnotation<ExperimentalWithCallbackMethod_DeleteAnnotations<ExperimentalWithCallbackMethod_PostAnnotationsSearches<ExperimentalWithCallbackMethod_GetInputCount<ExperimentalWithCallbackMethod_StreamInputs<ExperimentalWithCallbackMethod_GetInputSamples<ExperimentalWithCallbackMethod_GetInput<ExperimentalWithCallbackMethod_ListInputs<ExperimentalWithCallbackMethod_PostInputs<ExperimentalWithCallbackMethod_PatchInputs<ExperimentalWithCallbackMethod_DeleteInput<ExperimentalWithCallbackMethod_DeleteInputs<ExperimentalWithCallbackMethod_PostInputsSearches<ExperimentalWithCallbackMethod_PostModelOutputs<ExperimentalWithCallbackMethod_GetModelType<ExperimentalWithCallbackMethod_ListModelTypes<ExperimentalWithCallbackMethod_GetModel<ExperimentalWithCallbackMethod_GetModelOutputInfo<ExperimentalWithCallbackMethod_ListModels<ExperimentalWithCallbackMethod_PostModelsSearches<ExperimentalWithCallbackMethod_PostModels<ExperimentalWithCallbackMethod_PatchModels<ExperimentalWithCallbackMethod_DeleteModel<ExperimentalWithCallbackMethod_DeleteModels<ExperimentalWithCallbackMethod_ListModelInputs<ExperimentalWithCallbackMethod_GetModelVersion<ExperimentalWithCallbackMethod_ListModelVersions<ExperimentalWithCallbackMethod_PostModelVersions<ExperimentalWithCallbackMethod_DeleteModelVersion<ExperimentalWithCallbackMethod_GetModelVersionMetrics<ExperimentalWithCallbackMethod_PostModelVersionMetrics<ExperimentalWithCallbackMethod_GetWorkflow<ExperimentalWithCallbackMethod_ListWorkflows<ExperimentalWithCallbackMethod_PostWorkflows<ExperimentalWithCallbackMethod_PatchWorkflows<ExperimentalWithCallbackMethod_DeleteWorkflow<ExperimentalWithCallbackMethod_DeleteWorkflows<ExperimentalWithCallbackMethod_PostWorkflowResults<ExperimentalWithCallbackMethod_PostWorkflowResultsSimilarity<ExperimentalWithCallbackMethod_GetKey<ExperimentalWithCallbackMethod_ListKeys<ExperimentalWithCallbackMethod_ListAppKeys<ExperimentalWithCallbackMethod_DeleteKey<ExperimentalWithCallbackMethod_PostKeys<ExperimentalWithCallbackMethod_PatchKeys<ExperimentalWithCallbackMethod_MyScopes<ExperimentalWithCallbackMethod_ListScopes<ExperimentalWithCallbackMethod_GetApp<ExperimentalWithCallbackMethod_ListApps<ExperimentalWithCallbackMethod_DeleteApp<ExperimentalWithCallbackMethod_PostApps<ExperimentalWithCallbackMethod_PatchApps<ExperimentalWithCallbackMethod_PostAppsSearches<ExperimentalWithCallbackMethod_PostValidatePassword<ExperimentalWithCallbackMethod_GetSearch<ExperimentalWithCallbackMethod_ListSearches<ExperimentalWithCallbackMethod_PostSearches<ExperimentalWithCallbackMethod_PostSearchesByID<ExperimentalWithCallbackMethod_PostAnnotationSearchMetrics<ExperimentalWithCallbackMethod_GetAnnotationSearchMetrics<ExperimentalWithCallbackMethod_ListAnnotationSearchMetrics<ExperimentalWithCallbackMethod_DeleteAnnotationSearchMetrics<ExperimentalWithCallbackMethod_DeleteSearch<ExperimentalWithCallbackMethod_ListStatusCodes<ExperimentalWithCallbackMethod_GetStatusCode<ExperimentalWithCallbackMethod_ListCollaborators<ExperimentalWithCallbackMethod_PostCollaborators<ExperimentalWithCallbackMethod_PatchCollaborators<ExperimentalWithCallbackMethod_DeleteCollaborators<ExperimentalWithCallbackMethod_ListCollaborations<ExperimentalWithCallbackMethod_PostAppDuplications<ExperimentalWithCallbackMethod_ListAppDuplications<ExperimentalWithCallbackMethod_GetAppDuplication<ExperimentalWithCallbackMethod_PostTasks<ExperimentalWithCallbackMethod_GetTaskAnnotationCount<ExperimentalWithCallbackMethod_GetTaskInputCount<ExperimentalWithCallbackMethod_GetTask<ExperimentalWithCallbackMethod_ListTasks<ExperimentalWithCallbackMethod_PatchTasks<ExperimentalWithCallbackMethod_DeleteTasks<ExperimentalWithCallbackMethod_PostCollectors<ExperimentalWithCallbackMethod_GetCollector<ExperimentalWithCallbackMethod_ListCollectors<ExperimentalWithCallbackMethod_PatchCollectors<ExperimentalWithCallbackMethod_DeleteCollectors<ExperimentalWithCallbackMethod_PostStatValues<ExperimentalWithCallbackMethod_PostStatValuesAggregate<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_ListConceptRelations<ExperimentalWithCallbackMethod_PostConceptRelations<ExperimentalWithCallbackMethod_DeleteConceptRelations<ExperimentalWithCallbackMethod_GetConceptCounts<ExperimentalWithCallbackMethod_GetConcept<ExperimentalWithCallbackMethod_ListConcepts<ExperimentalWithCallbackMethod_PostConceptsSearches<ExperimentalWithCallbackMethod_PostConcepts<ExperimentalWithCallbackMethod_PatchConcepts<ExperimentalWithCallbackMethod_GetConceptLanguage<ExperimentalWithCallbackMethod_ListConceptLanguages<ExperimentalWithCallbackMethod_PostConceptLanguages<ExperimentalWithCallbackMethod_PatchConceptLanguages<ExperimentalWithCallbackMethod_ListKnowledgeGraphs<ExperimentalWithCallbackMethod_PostKnowledgeGraphs<ExperimentalWithCallbackMethod_PostConceptMappingJobs<ExperimentalWithCallbackMethod_GetAnnotation<ExperimentalWithCallbackMethod_ListAnnotations<ExperimentalWithCallbackMethod_PostAnnotations<ExperimentalWithCallbackMethod_PatchAnnotations<ExperimentalWithCallbackMethod_PatchAnnotationsStatus<ExperimentalWithCallbackMethod_DeleteAnnotation<ExperimentalWithCallbackMethod_DeleteAnnotations<ExperimentalWithCallbackMethod_PostAnnotationsSearches<ExperimentalWithCallbackMethod_GetInputCount<ExperimentalWithCallbackMethod_StreamInputs<ExperimentalWithCallbackMethod_GetInputSamples<ExperimentalWithCallbackMethod_GetInput<ExperimentalWithCallbackMethod_ListInputs<ExperimentalWithCallbackMethod_PostInputs<ExperimentalWithCallbackMethod_PatchInputs<ExperimentalWithCallbackMethod_DeleteInput<ExperimentalWithCallbackMethod_DeleteInputs<ExperimentalWithCallbackMethod_PostInputsSearches<ExperimentalWithCallbackMethod_PostModelOutputs<ExperimentalWithCallbackMethod_GetModelType<ExperimentalWithCallbackMethod_ListModelTypes<ExperimentalWithCallbackMethod_GetModel<ExperimentalWithCallbackMethod_GetModelOutputInfo<ExperimentalWithCallbackMethod_ListModels<ExperimentalWithCallbackMethod_PostModelsSearches<ExperimentalWithCallbackMethod_PostModels<ExperimentalWithCallbackMethod_PatchModels<ExperimentalWithCallbackMethod_DeleteModel<ExperimentalWithCallbackMethod_DeleteModels<ExperimentalWithCallbackMethod_ListModelInputs<ExperimentalWithCallbackMethod_GetModelVersion<ExperimentalWithCallbackMethod_ListModelVersions<ExperimentalWithCallbackMethod_PostModelVersions<ExperimentalWithCallbackMethod_DeleteModelVersion<ExperimentalWithCallbackMethod_GetModelVersionMetrics<ExperimentalWithCallbackMethod_PostModelVersionMetrics<ExperimentalWithCallbackMethod_GetWorkflow<ExperimentalWithCallbackMethod_ListWorkflows<ExperimentalWithCallbackMethod_PostWorkflows<ExperimentalWithCallbackMethod_PatchWorkflows<ExperimentalWithCallbackMethod_DeleteWorkflow<ExperimentalWithCallbackMethod_DeleteWorkflows<ExperimentalWithCallbackMethod_PostWorkflowResults<ExperimentalWithCallbackMethod_PostWorkflowResultsSimilarity<ExperimentalWithCallbackMethod_GetKey<ExperimentalWithCallbackMethod_ListKeys<ExperimentalWithCallbackMethod_ListAppKeys<ExperimentalWithCallbackMethod_DeleteKey<ExperimentalWithCallbackMethod_PostKeys<ExperimentalWithCallbackMethod_PatchKeys<ExperimentalWithCallbackMethod_MyScopes<ExperimentalWithCallbackMethod_ListScopes<ExperimentalWithCallbackMethod_GetApp<ExperimentalWithCallbackMethod_ListApps<ExperimentalWithCallbackMethod_DeleteApp<ExperimentalWithCallbackMethod_PostApps<ExperimentalWithCallbackMethod_PatchApps<ExperimentalWithCallbackMethod_PostAppsSearches<ExperimentalWithCallbackMethod_PostValidatePassword<ExperimentalWithCallbackMethod_GetSearch<ExperimentalWithCallbackMethod_ListSearches<ExperimentalWithCallbackMethod_PostSearches<ExperimentalWithCallbackMethod_PostSearchesByID<ExperimentalWithCallbackMethod_PostAnnotationSearchMetrics<ExperimentalWithCallbackMethod_GetAnnotationSearchMetrics<ExperimentalWithCallbackMethod_ListAnnotationSearchMetrics<ExperimentalWithCallbackMethod_DeleteAnnotationSearchMetrics<ExperimentalWithCallbackMethod_DeleteSearch<ExperimentalWithCallbackMethod_ListStatusCodes<ExperimentalWithCallbackMethod_GetStatusCode<ExperimentalWithCallbackMethod_ListCollaborators<ExperimentalWithCallbackMethod_PostCollaborators<ExperimentalWithCallbackMethod_PatchCollaborators<ExperimentalWithCallbackMethod_DeleteCollaborators<ExperimentalWithCallbackMethod_ListCollaborations<ExperimentalWithCallbackMethod_PostAppDuplications<ExperimentalWithCallbackMethod_ListAppDuplications<ExperimentalWithCallbackMethod_GetAppDuplication<ExperimentalWithCallbackMethod_PostTasks<ExperimentalWithCallbackMethod_GetTaskAnnotationCount<ExperimentalWithCallbackMethod_GetTaskInputCount<ExperimentalWithCallbackMethod_GetTask<ExperimentalWithCallbackMethod_ListTasks<ExperimentalWithCallbackMethod_PatchTasks<ExperimentalWithCallbackMethod_DeleteTasks<ExperimentalWithCallbackMethod_PostCollectors<ExperimentalWithCallbackMethod_GetCollector<ExperimentalWithCallbackMethod_ListCollectors<ExperimentalWithCallbackMethod_PatchCollectors<ExperimentalWithCallbackMethod_DeleteCollectors<ExperimentalWithCallbackMethod_PostStatValues<ExperimentalWithCallbackMethod_PostStatValuesAggregate<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_ListConceptRelations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListConceptRelations() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ListConceptRelations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListConceptRelations(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListConceptRelationsRequest* /*request*/, ::clarifai::api::MultiConceptRelationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostConceptRelations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostConceptRelations() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_PostConceptRelations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostConceptRelations(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptRelationsRequest* /*request*/, ::clarifai::api::MultiConceptRelationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteConceptRelations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteConceptRelations() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_DeleteConceptRelations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteConceptRelations(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteConceptRelationsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetConceptCounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetConceptCounts() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetConceptCounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConceptCounts(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetConceptCountsRequest* /*request*/, ::clarifai::api::MultiConceptCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetConcept : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetConcept() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GetConcept() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConcept(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetConceptRequest* /*request*/, ::clarifai::api::SingleConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListConcepts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListConcepts() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_ListConcepts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListConcepts(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListConceptsRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostConceptsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostConceptsSearches() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_PostConceptsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostConceptsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptsSearchesRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostConcepts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostConcepts() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_PostConcepts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostConcepts(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptsRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PatchConcepts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PatchConcepts() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_PatchConcepts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchConcepts(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchConceptsRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetConceptLanguage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetConceptLanguage() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_GetConceptLanguage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConceptLanguage(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetConceptLanguageRequest* /*request*/, ::clarifai::api::SingleConceptLanguageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListConceptLanguages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListConceptLanguages() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_ListConceptLanguages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListConceptLanguages(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListConceptLanguagesRequest* /*request*/, ::clarifai::api::MultiConceptLanguageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostConceptLanguages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostConceptLanguages() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_PostConceptLanguages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostConceptLanguages(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptLanguagesRequest* /*request*/, ::clarifai::api::MultiConceptLanguageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PatchConceptLanguages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PatchConceptLanguages() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_PatchConceptLanguages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchConceptLanguages(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchConceptLanguagesRequest* /*request*/, ::clarifai::api::MultiConceptLanguageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListKnowledgeGraphs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListKnowledgeGraphs() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_ListKnowledgeGraphs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListKnowledgeGraphs(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListKnowledgeGraphsRequest* /*request*/, ::clarifai::api::MultiKnowledgeGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostKnowledgeGraphs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostKnowledgeGraphs() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_PostKnowledgeGraphs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostKnowledgeGraphs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostKnowledgeGraphsRequest* /*request*/, ::clarifai::api::MultiKnowledgeGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostConceptMappingJobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostConceptMappingJobs() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_PostConceptMappingJobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostConceptMappingJobs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptMappingJobsRequest* /*request*/, ::clarifai::api::MultiConceptMappingJobResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAnnotation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAnnotation() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_GetAnnotation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAnnotation(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetAnnotationRequest* /*request*/, ::clarifai::api::SingleAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListAnnotations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListAnnotations() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_ListAnnotations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAnnotations(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAnnotationsRequest* /*request*/, ::clarifai::api::MultiAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostAnnotations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostAnnotations() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_PostAnnotations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAnnotations(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAnnotationsRequest* /*request*/, ::clarifai::api::MultiAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PatchAnnotations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PatchAnnotations() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_PatchAnnotations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchAnnotations(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchAnnotationsRequest* /*request*/, ::clarifai::api::MultiAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PatchAnnotationsStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PatchAnnotationsStatus() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_PatchAnnotationsStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchAnnotationsStatus(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchAnnotationsStatusRequest* /*request*/, ::clarifai::api::PatchAnnotationsStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteAnnotation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteAnnotation() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_DeleteAnnotation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAnnotation(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteAnnotationRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteAnnotations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteAnnotations() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_DeleteAnnotations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAnnotations(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteAnnotationsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostAnnotationsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostAnnotationsSearches() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_PostAnnotationsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAnnotationsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAnnotationsSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetInputCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetInputCount() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_GetInputCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInputCount(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetInputCountRequest* /*request*/, ::clarifai::api::SingleInputCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StreamInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StreamInputs() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_StreamInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::StreamInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetInputSamples : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetInputSamples() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_GetInputSamples() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInputSamples(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetInputSamplesRequest* /*request*/, ::clarifai::api::MultiInputAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetInput() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_GetInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInput(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetInputRequest* /*request*/, ::clarifai::api::SingleInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListInputs() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_ListInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostInputs() {
      ::grpc::Service::MarkMethodGeneric(29);
    }
    ~WithGenericMethod_PostInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PatchInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PatchInputs() {
      ::grpc::Service::MarkMethodGeneric(30);
    }
    ~WithGenericMethod_PatchInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteInput() {
      ::grpc::Service::MarkMethodGeneric(31);
    }
    ~WithGenericMethod_DeleteInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteInput(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteInputRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteInputs() {
      ::grpc::Service::MarkMethodGeneric(32);
    }
    ~WithGenericMethod_DeleteInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteInputsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostInputsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostInputsSearches() {
      ::grpc::Service::MarkMethodGeneric(33);
    }
    ~WithGenericMethod_PostInputsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostInputsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostInputsSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostModelOutputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostModelOutputs() {
      ::grpc::Service::MarkMethodGeneric(34);
    }
    ~WithGenericMethod_PostModelOutputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostModelOutputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelOutputsRequest* /*request*/, ::clarifai::api::MultiOutputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetModelType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetModelType() {
      ::grpc::Service::MarkMethodGeneric(35);
    }
    ~WithGenericMethod_GetModelType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModelType(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelTypeRequest* /*request*/, ::clarifai::api::SingleModelTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListModelTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListModelTypes() {
      ::grpc::Service::MarkMethodGeneric(36);
    }
    ~WithGenericMethod_ListModelTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListModelTypes(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListModelTypesRequest* /*request*/, ::clarifai::api::MultiModelTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetModel() {
      ::grpc::Service::MarkMethodGeneric(37);
    }
    ~WithGenericMethod_GetModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModel(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetModelOutputInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetModelOutputInfo() {
      ::grpc::Service::MarkMethodGeneric(38);
    }
    ~WithGenericMethod_GetModelOutputInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModelOutputInfo(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListModels() {
      ::grpc::Service::MarkMethodGeneric(39);
    }
    ~WithGenericMethod_ListModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListModels(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListModelsRequest* /*request*/, ::clarifai::api::MultiModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostModelsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostModelsSearches() {
      ::grpc::Service::MarkMethodGeneric(40);
    }
    ~WithGenericMethod_PostModelsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostModelsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelsSearchesRequest* /*request*/, ::clarifai::api::MultiModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostModels() {
      ::grpc::Service::MarkMethodGeneric(41);
    }
    ~WithGenericMethod_PostModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostModels(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelsRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PatchModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PatchModels() {
      ::grpc::Service::MarkMethodGeneric(42);
    }
    ~WithGenericMethod_PatchModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchModels(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchModelsRequest* /*request*/, ::clarifai::api::MultiModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteModel() {
      ::grpc::Service::MarkMethodGeneric(43);
    }
    ~WithGenericMethod_DeleteModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteModel(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteModelRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteModels() {
      ::grpc::Service::MarkMethodGeneric(44);
    }
    ~WithGenericMethod_DeleteModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteModels(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteModelsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListModelInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListModelInputs() {
      ::grpc::Service::MarkMethodGeneric(45);
    }
    ~WithGenericMethod_ListModelInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListModelInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListModelInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetModelVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetModelVersion() {
      ::grpc::Service::MarkMethodGeneric(46);
    }
    ~WithGenericMethod_GetModelVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModelVersion(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelVersionRequest* /*request*/, ::clarifai::api::SingleModelVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListModelVersions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListModelVersions() {
      ::grpc::Service::MarkMethodGeneric(47);
    }
    ~WithGenericMethod_ListModelVersions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListModelVersions(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListModelVersionsRequest* /*request*/, ::clarifai::api::MultiModelVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostModelVersions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostModelVersions() {
      ::grpc::Service::MarkMethodGeneric(48);
    }
    ~WithGenericMethod_PostModelVersions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostModelVersions(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelVersionsRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteModelVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteModelVersion() {
      ::grpc::Service::MarkMethodGeneric(49);
    }
    ~WithGenericMethod_DeleteModelVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteModelVersion(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteModelVersionRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetModelVersionMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetModelVersionMetrics() {
      ::grpc::Service::MarkMethodGeneric(50);
    }
    ~WithGenericMethod_GetModelVersionMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModelVersionMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelVersionMetricsRequest* /*request*/, ::clarifai::api::SingleModelVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostModelVersionMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostModelVersionMetrics() {
      ::grpc::Service::MarkMethodGeneric(51);
    }
    ~WithGenericMethod_PostModelVersionMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostModelVersionMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelVersionMetricsRequest* /*request*/, ::clarifai::api::SingleModelVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetWorkflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetWorkflow() {
      ::grpc::Service::MarkMethodGeneric(52);
    }
    ~WithGenericMethod_GetWorkflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkflow(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetWorkflowRequest* /*request*/, ::clarifai::api::SingleWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListWorkflows() {
      ::grpc::Service::MarkMethodGeneric(53);
    }
    ~WithGenericMethod_ListWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListWorkflows(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListWorkflowsRequest* /*request*/, ::clarifai::api::MultiWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostWorkflows() {
      ::grpc::Service::MarkMethodGeneric(54);
    }
    ~WithGenericMethod_PostWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostWorkflows(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostWorkflowsRequest* /*request*/, ::clarifai::api::MultiWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PatchWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PatchWorkflows() {
      ::grpc::Service::MarkMethodGeneric(55);
    }
    ~WithGenericMethod_PatchWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchWorkflows(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchWorkflowsRequest* /*request*/, ::clarifai::api::MultiWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteWorkflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteWorkflow() {
      ::grpc::Service::MarkMethodGeneric(56);
    }
    ~WithGenericMethod_DeleteWorkflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteWorkflow(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteWorkflowRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteWorkflows() {
      ::grpc::Service::MarkMethodGeneric(57);
    }
    ~WithGenericMethod_DeleteWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteWorkflows(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteWorkflowsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostWorkflowResults : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostWorkflowResults() {
      ::grpc::Service::MarkMethodGeneric(58);
    }
    ~WithGenericMethod_PostWorkflowResults() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostWorkflowResults(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostWorkflowResultsRequest* /*request*/, ::clarifai::api::PostWorkflowResultsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostWorkflowResultsSimilarity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostWorkflowResultsSimilarity() {
      ::grpc::Service::MarkMethodGeneric(59);
    }
    ~WithGenericMethod_PostWorkflowResultsSimilarity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostWorkflowResultsSimilarity(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostWorkflowResultsSimilarityRequest* /*request*/, ::clarifai::api::PostWorkflowResultsSimilarityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetKey() {
      ::grpc::Service::MarkMethodGeneric(60);
    }
    ~WithGenericMethod_GetKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetKey(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetKeyRequest* /*request*/, ::clarifai::api::SingleKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListKeys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListKeys() {
      ::grpc::Service::MarkMethodGeneric(61);
    }
    ~WithGenericMethod_ListKeys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListKeys(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListAppKeys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListAppKeys() {
      ::grpc::Service::MarkMethodGeneric(62);
    }
    ~WithGenericMethod_ListAppKeys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAppKeys(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAppKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteKey() {
      ::grpc::Service::MarkMethodGeneric(63);
    }
    ~WithGenericMethod_DeleteKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteKey(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteKeyRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostKeys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostKeys() {
      ::grpc::Service::MarkMethodGeneric(64);
    }
    ~WithGenericMethod_PostKeys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostKeys(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PatchKeys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PatchKeys() {
      ::grpc::Service::MarkMethodGeneric(65);
    }
    ~WithGenericMethod_PatchKeys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchKeys(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MyScopes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MyScopes() {
      ::grpc::Service::MarkMethodGeneric(66);
    }
    ~WithGenericMethod_MyScopes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MyScopes(::grpc::ServerContext* /*context*/, const ::clarifai::api::MyScopesRequest* /*request*/, ::clarifai::api::MultiScopeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListScopes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListScopes() {
      ::grpc::Service::MarkMethodGeneric(67);
    }
    ~WithGenericMethod_ListScopes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListScopes(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListScopesRequest* /*request*/, ::clarifai::api::MultiScopeDepsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetApp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetApp() {
      ::grpc::Service::MarkMethodGeneric(68);
    }
    ~WithGenericMethod_GetApp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetApp(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetAppRequest* /*request*/, ::clarifai::api::SingleAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListApps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListApps() {
      ::grpc::Service::MarkMethodGeneric(69);
    }
    ~WithGenericMethod_ListApps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListApps(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAppsRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteApp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteApp() {
      ::grpc::Service::MarkMethodGeneric(70);
    }
    ~WithGenericMethod_DeleteApp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteApp(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteAppRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostApps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostApps() {
      ::grpc::Service::MarkMethodGeneric(71);
    }
    ~WithGenericMethod_PostApps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostApps(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAppsRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PatchApps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PatchApps() {
      ::grpc::Service::MarkMethodGeneric(72);
    }
    ~WithGenericMethod_PatchApps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchApps(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchAppsRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostAppsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostAppsSearches() {
      ::grpc::Service::MarkMethodGeneric(73);
    }
    ~WithGenericMethod_PostAppsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAppsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAppsSearchesRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostValidatePassword : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostValidatePassword() {
      ::grpc::Service::MarkMethodGeneric(74);
    }
    ~WithGenericMethod_PostValidatePassword() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostValidatePassword(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostValidatePasswordRequest* /*request*/, ::clarifai::api::SinglePasswordValidationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSearch() {
      ::grpc::Service::MarkMethodGeneric(75);
    }
    ~WithGenericMethod_GetSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSearch(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetSearchRequest* /*request*/, ::clarifai::api::SingleSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListSearches() {
      ::grpc::Service::MarkMethodGeneric(76);
    }
    ~WithGenericMethod_ListSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostSearches() {
      ::grpc::Service::MarkMethodGeneric(77);
    }
    ~WithGenericMethod_PostSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostSearchesByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostSearchesByID() {
      ::grpc::Service::MarkMethodGeneric(78);
    }
    ~WithGenericMethod_PostSearchesByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostSearchesByID(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostSearchesByIDRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostAnnotationSearchMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostAnnotationSearchMetrics() {
      ::grpc::Service::MarkMethodGeneric(79);
    }
    ~WithGenericMethod_PostAnnotationSearchMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAnnotationSearchMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::MultiAnnotationSearchMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAnnotationSearchMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAnnotationSearchMetrics() {
      ::grpc::Service::MarkMethodGeneric(80);
    }
    ~WithGenericMethod_GetAnnotationSearchMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAnnotationSearchMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::MultiAnnotationSearchMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListAnnotationSearchMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListAnnotationSearchMetrics() {
      ::grpc::Service::MarkMethodGeneric(81);
    }
    ~WithGenericMethod_ListAnnotationSearchMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAnnotationSearchMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::MultiAnnotationSearchMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteAnnotationSearchMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteAnnotationSearchMetrics() {
      ::grpc::Service::MarkMethodGeneric(82);
    }
    ~WithGenericMethod_DeleteAnnotationSearchMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAnnotationSearchMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteSearch() {
      ::grpc::Service::MarkMethodGeneric(83);
    }
    ~WithGenericMethod_DeleteSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSearch(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteSearchRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListStatusCodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListStatusCodes() {
      ::grpc::Service::MarkMethodGeneric(84);
    }
    ~WithGenericMethod_ListStatusCodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListStatusCodes(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListStatusCodesRequest* /*request*/, ::clarifai::api::MultiStatusCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetStatusCode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetStatusCode() {
      ::grpc::Service::MarkMethodGeneric(85);
    }
    ~WithGenericMethod_GetStatusCode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStatusCode(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetStatusCodeRequest* /*request*/, ::clarifai::api::SingleStatusCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListCollaborators : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListCollaborators() {
      ::grpc::Service::MarkMethodGeneric(86);
    }
    ~WithGenericMethod_ListCollaborators() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListCollaborators(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListCollaboratorsRequest* /*request*/, ::clarifai::api::MultiCollaboratorsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostCollaborators : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostCollaborators() {
      ::grpc::Service::MarkMethodGeneric(87);
    }
    ~WithGenericMethod_PostCollaborators() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostCollaborators(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostCollaboratorsRequest* /*request*/, ::clarifai::api::MultiCollaboratorsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PatchCollaborators : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PatchCollaborators() {
      ::grpc::Service::MarkMethodGeneric(88);
    }
    ~WithGenericMethod_PatchCollaborators() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchCollaborators(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchCollaboratorsRequest* /*request*/, ::clarifai::api::MultiCollaboratorsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteCollaborators : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteCollaborators() {
      ::grpc::Service::MarkMethodGeneric(89);
    }
    ~WithGenericMethod_DeleteCollaborators() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteCollaborators(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteCollaboratorsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListCollaborations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListCollaborations() {
      ::grpc::Service::MarkMethodGeneric(90);
    }
    ~WithGenericMethod_ListCollaborations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListCollaborations(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListCollaborationsRequest* /*request*/, ::clarifai::api::MultiCollaborationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostAppDuplications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostAppDuplications() {
      ::grpc::Service::MarkMethodGeneric(91);
    }
    ~WithGenericMethod_PostAppDuplications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAppDuplications(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAppDuplicationsRequest* /*request*/, ::clarifai::api::MultiAppDuplicationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListAppDuplications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListAppDuplications() {
      ::grpc::Service::MarkMethodGeneric(92);
    }
    ~WithGenericMethod_ListAppDuplications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAppDuplications(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAppDuplicationsRequest* /*request*/, ::clarifai::api::MultiAppDuplicationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAppDuplication : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAppDuplication() {
      ::grpc::Service::MarkMethodGeneric(93);
    }
    ~WithGenericMethod_GetAppDuplication() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAppDuplication(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetAppDuplicationRequest* /*request*/, ::clarifai::api::SingleAppDuplicationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostTasks() {
      ::grpc::Service::MarkMethodGeneric(94);
    }
    ~WithGenericMethod_PostTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostTasks(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostTasksRequest* /*request*/, ::clarifai::api::MultiTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTaskAnnotationCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTaskAnnotationCount() {
      ::grpc::Service::MarkMethodGeneric(95);
    }
    ~WithGenericMethod_GetTaskAnnotationCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskAnnotationCount(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetTaskCountRequest* /*request*/, ::clarifai::api::SingleTaskCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTaskInputCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTaskInputCount() {
      ::grpc::Service::MarkMethodGeneric(96);
    }
    ~WithGenericMethod_GetTaskInputCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskInputCount(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetTaskCountRequest* /*request*/, ::clarifai::api::SingleTaskCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTask() {
      ::grpc::Service::MarkMethodGeneric(97);
    }
    ~WithGenericMethod_GetTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTask(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetTaskRequest* /*request*/, ::clarifai::api::SingleTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListTasks() {
      ::grpc::Service::MarkMethodGeneric(98);
    }
    ~WithGenericMethod_ListTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTasks(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListTasksRequest* /*request*/, ::clarifai::api::MultiTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PatchTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PatchTasks() {
      ::grpc::Service::MarkMethodGeneric(99);
    }
    ~WithGenericMethod_PatchTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchTasks(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchTasksRequest* /*request*/, ::clarifai::api::MultiTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteTasks() {
      ::grpc::Service::MarkMethodGeneric(100);
    }
    ~WithGenericMethod_DeleteTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteTasks(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteTasksRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostCollectors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostCollectors() {
      ::grpc::Service::MarkMethodGeneric(101);
    }
    ~WithGenericMethod_PostCollectors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostCollectors(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostCollectorsRequest* /*request*/, ::clarifai::api::MultiCollectorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCollector : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCollector() {
      ::grpc::Service::MarkMethodGeneric(102);
    }
    ~WithGenericMethod_GetCollector() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollector(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetCollectorRequest* /*request*/, ::clarifai::api::SingleCollectorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListCollectors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListCollectors() {
      ::grpc::Service::MarkMethodGeneric(103);
    }
    ~WithGenericMethod_ListCollectors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListCollectors(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListCollectorsRequest* /*request*/, ::clarifai::api::MultiCollectorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PatchCollectors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PatchCollectors() {
      ::grpc::Service::MarkMethodGeneric(104);
    }
    ~WithGenericMethod_PatchCollectors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchCollectors(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchCollectorsRequest* /*request*/, ::clarifai::api::MultiCollectorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteCollectors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteCollectors() {
      ::grpc::Service::MarkMethodGeneric(105);
    }
    ~WithGenericMethod_DeleteCollectors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteCollectors(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteCollectorsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostStatValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostStatValues() {
      ::grpc::Service::MarkMethodGeneric(106);
    }
    ~WithGenericMethod_PostStatValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostStatValues(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostStatValuesRequest* /*request*/, ::clarifai::api::MultiStatValueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostStatValuesAggregate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostStatValuesAggregate() {
      ::grpc::Service::MarkMethodGeneric(107);
    }
    ~WithGenericMethod_PostStatValuesAggregate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostStatValuesAggregate(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostStatValuesAggregateRequest* /*request*/, ::clarifai::api::MultiStatValueAggregateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListConceptRelations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListConceptRelations() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_ListConceptRelations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListConceptRelations(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListConceptRelationsRequest* /*request*/, ::clarifai::api::MultiConceptRelationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListConceptRelations(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostConceptRelations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostConceptRelations() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_PostConceptRelations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostConceptRelations(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptRelationsRequest* /*request*/, ::clarifai::api::MultiConceptRelationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostConceptRelations(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteConceptRelations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteConceptRelations() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_DeleteConceptRelations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteConceptRelations(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteConceptRelationsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteConceptRelations(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetConceptCounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetConceptCounts() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetConceptCounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConceptCounts(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetConceptCountsRequest* /*request*/, ::clarifai::api::MultiConceptCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConceptCounts(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetConcept : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetConcept() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_GetConcept() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConcept(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetConceptRequest* /*request*/, ::clarifai::api::SingleConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConcept(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListConcepts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListConcepts() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_ListConcepts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListConcepts(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListConceptsRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListConcepts(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostConceptsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostConceptsSearches() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_PostConceptsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostConceptsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptsSearchesRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostConceptsSearches(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostConcepts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostConcepts() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_PostConcepts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostConcepts(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptsRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostConcepts(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PatchConcepts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PatchConcepts() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_PatchConcepts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchConcepts(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchConceptsRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPatchConcepts(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetConceptLanguage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetConceptLanguage() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_GetConceptLanguage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConceptLanguage(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetConceptLanguageRequest* /*request*/, ::clarifai::api::SingleConceptLanguageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConceptLanguage(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListConceptLanguages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListConceptLanguages() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_ListConceptLanguages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListConceptLanguages(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListConceptLanguagesRequest* /*request*/, ::clarifai::api::MultiConceptLanguageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListConceptLanguages(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostConceptLanguages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostConceptLanguages() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_PostConceptLanguages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostConceptLanguages(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptLanguagesRequest* /*request*/, ::clarifai::api::MultiConceptLanguageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostConceptLanguages(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PatchConceptLanguages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PatchConceptLanguages() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_PatchConceptLanguages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchConceptLanguages(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchConceptLanguagesRequest* /*request*/, ::clarifai::api::MultiConceptLanguageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPatchConceptLanguages(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListKnowledgeGraphs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListKnowledgeGraphs() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_ListKnowledgeGraphs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListKnowledgeGraphs(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListKnowledgeGraphsRequest* /*request*/, ::clarifai::api::MultiKnowledgeGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListKnowledgeGraphs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostKnowledgeGraphs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostKnowledgeGraphs() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_PostKnowledgeGraphs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostKnowledgeGraphs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostKnowledgeGraphsRequest* /*request*/, ::clarifai::api::MultiKnowledgeGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostKnowledgeGraphs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostConceptMappingJobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostConceptMappingJobs() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_PostConceptMappingJobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostConceptMappingJobs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptMappingJobsRequest* /*request*/, ::clarifai::api::MultiConceptMappingJobResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostConceptMappingJobs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAnnotation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAnnotation() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_GetAnnotation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAnnotation(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetAnnotationRequest* /*request*/, ::clarifai::api::SingleAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAnnotation(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListAnnotations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListAnnotations() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_ListAnnotations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAnnotations(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAnnotationsRequest* /*request*/, ::clarifai::api::MultiAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListAnnotations(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostAnnotations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostAnnotations() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_PostAnnotations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAnnotations(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAnnotationsRequest* /*request*/, ::clarifai::api::MultiAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostAnnotations(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PatchAnnotations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PatchAnnotations() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_PatchAnnotations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchAnnotations(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchAnnotationsRequest* /*request*/, ::clarifai::api::MultiAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPatchAnnotations(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PatchAnnotationsStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PatchAnnotationsStatus() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_PatchAnnotationsStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchAnnotationsStatus(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchAnnotationsStatusRequest* /*request*/, ::clarifai::api::PatchAnnotationsStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPatchAnnotationsStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteAnnotation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteAnnotation() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_DeleteAnnotation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAnnotation(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteAnnotationRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteAnnotation(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteAnnotations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteAnnotations() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_DeleteAnnotations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAnnotations(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteAnnotationsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteAnnotations(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostAnnotationsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostAnnotationsSearches() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_PostAnnotationsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAnnotationsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAnnotationsSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostAnnotationsSearches(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetInputCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetInputCount() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_GetInputCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInputCount(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetInputCountRequest* /*request*/, ::clarifai::api::SingleInputCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetInputCount(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StreamInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StreamInputs() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_StreamInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::StreamInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamInputs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetInputSamples : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetInputSamples() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_GetInputSamples() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInputSamples(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetInputSamplesRequest* /*request*/, ::clarifai::api::MultiInputAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetInputSamples(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetInput() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_GetInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInput(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetInputRequest* /*request*/, ::clarifai::api::SingleInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetInput(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListInputs() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_ListInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListInputs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostInputs() {
      ::grpc::Service::MarkMethodRaw(29);
    }
    ~WithRawMethod_PostInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostInputs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PatchInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PatchInputs() {
      ::grpc::Service::MarkMethodRaw(30);
    }
    ~WithRawMethod_PatchInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPatchInputs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteInput() {
      ::grpc::Service::MarkMethodRaw(31);
    }
    ~WithRawMethod_DeleteInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteInput(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteInputRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteInput(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteInputs() {
      ::grpc::Service::MarkMethodRaw(32);
    }
    ~WithRawMethod_DeleteInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteInputsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteInputs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostInputsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostInputsSearches() {
      ::grpc::Service::MarkMethodRaw(33);
    }
    ~WithRawMethod_PostInputsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostInputsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostInputsSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostInputsSearches(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostModelOutputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostModelOutputs() {
      ::grpc::Service::MarkMethodRaw(34);
    }
    ~WithRawMethod_PostModelOutputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostModelOutputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelOutputsRequest* /*request*/, ::clarifai::api::MultiOutputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostModelOutputs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetModelType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetModelType() {
      ::grpc::Service::MarkMethodRaw(35);
    }
    ~WithRawMethod_GetModelType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModelType(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelTypeRequest* /*request*/, ::clarifai::api::SingleModelTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetModelType(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListModelTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListModelTypes() {
      ::grpc::Service::MarkMethodRaw(36);
    }
    ~WithRawMethod_ListModelTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListModelTypes(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListModelTypesRequest* /*request*/, ::clarifai::api::MultiModelTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListModelTypes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetModel() {
      ::grpc::Service::MarkMethodRaw(37);
    }
    ~WithRawMethod_GetModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModel(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetModel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetModelOutputInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetModelOutputInfo() {
      ::grpc::Service::MarkMethodRaw(38);
    }
    ~WithRawMethod_GetModelOutputInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModelOutputInfo(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetModelOutputInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListModels() {
      ::grpc::Service::MarkMethodRaw(39);
    }
    ~WithRawMethod_ListModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListModels(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListModelsRequest* /*request*/, ::clarifai::api::MultiModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListModels(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostModelsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostModelsSearches() {
      ::grpc::Service::MarkMethodRaw(40);
    }
    ~WithRawMethod_PostModelsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostModelsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelsSearchesRequest* /*request*/, ::clarifai::api::MultiModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostModelsSearches(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostModels() {
      ::grpc::Service::MarkMethodRaw(41);
    }
    ~WithRawMethod_PostModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostModels(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelsRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostModels(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PatchModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PatchModels() {
      ::grpc::Service::MarkMethodRaw(42);
    }
    ~WithRawMethod_PatchModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchModels(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchModelsRequest* /*request*/, ::clarifai::api::MultiModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPatchModels(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteModel() {
      ::grpc::Service::MarkMethodRaw(43);
    }
    ~WithRawMethod_DeleteModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteModel(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteModelRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteModel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteModels() {
      ::grpc::Service::MarkMethodRaw(44);
    }
    ~WithRawMethod_DeleteModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteModels(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteModelsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteModels(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListModelInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListModelInputs() {
      ::grpc::Service::MarkMethodRaw(45);
    }
    ~WithRawMethod_ListModelInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListModelInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListModelInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListModelInputs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(45, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetModelVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetModelVersion() {
      ::grpc::Service::MarkMethodRaw(46);
    }
    ~WithRawMethod_GetModelVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModelVersion(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelVersionRequest* /*request*/, ::clarifai::api::SingleModelVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetModelVersion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(46, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListModelVersions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListModelVersions() {
      ::grpc::Service::MarkMethodRaw(47);
    }
    ~WithRawMethod_ListModelVersions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListModelVersions(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListModelVersionsRequest* /*request*/, ::clarifai::api::MultiModelVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListModelVersions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(47, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostModelVersions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostModelVersions() {
      ::grpc::Service::MarkMethodRaw(48);
    }
    ~WithRawMethod_PostModelVersions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostModelVersions(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelVersionsRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostModelVersions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(48, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteModelVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteModelVersion() {
      ::grpc::Service::MarkMethodRaw(49);
    }
    ~WithRawMethod_DeleteModelVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteModelVersion(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteModelVersionRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteModelVersion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(49, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetModelVersionMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetModelVersionMetrics() {
      ::grpc::Service::MarkMethodRaw(50);
    }
    ~WithRawMethod_GetModelVersionMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModelVersionMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelVersionMetricsRequest* /*request*/, ::clarifai::api::SingleModelVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetModelVersionMetrics(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(50, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostModelVersionMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostModelVersionMetrics() {
      ::grpc::Service::MarkMethodRaw(51);
    }
    ~WithRawMethod_PostModelVersionMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostModelVersionMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelVersionMetricsRequest* /*request*/, ::clarifai::api::SingleModelVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostModelVersionMetrics(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(51, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetWorkflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetWorkflow() {
      ::grpc::Service::MarkMethodRaw(52);
    }
    ~WithRawMethod_GetWorkflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkflow(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetWorkflowRequest* /*request*/, ::clarifai::api::SingleWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetWorkflow(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(52, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListWorkflows() {
      ::grpc::Service::MarkMethodRaw(53);
    }
    ~WithRawMethod_ListWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListWorkflows(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListWorkflowsRequest* /*request*/, ::clarifai::api::MultiWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListWorkflows(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(53, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostWorkflows() {
      ::grpc::Service::MarkMethodRaw(54);
    }
    ~WithRawMethod_PostWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostWorkflows(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostWorkflowsRequest* /*request*/, ::clarifai::api::MultiWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostWorkflows(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(54, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PatchWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PatchWorkflows() {
      ::grpc::Service::MarkMethodRaw(55);
    }
    ~WithRawMethod_PatchWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchWorkflows(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchWorkflowsRequest* /*request*/, ::clarifai::api::MultiWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPatchWorkflows(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(55, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteWorkflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteWorkflow() {
      ::grpc::Service::MarkMethodRaw(56);
    }
    ~WithRawMethod_DeleteWorkflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteWorkflow(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteWorkflowRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteWorkflow(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(56, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteWorkflows() {
      ::grpc::Service::MarkMethodRaw(57);
    }
    ~WithRawMethod_DeleteWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteWorkflows(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteWorkflowsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteWorkflows(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(57, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostWorkflowResults : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostWorkflowResults() {
      ::grpc::Service::MarkMethodRaw(58);
    }
    ~WithRawMethod_PostWorkflowResults() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostWorkflowResults(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostWorkflowResultsRequest* /*request*/, ::clarifai::api::PostWorkflowResultsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostWorkflowResults(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(58, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostWorkflowResultsSimilarity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostWorkflowResultsSimilarity() {
      ::grpc::Service::MarkMethodRaw(59);
    }
    ~WithRawMethod_PostWorkflowResultsSimilarity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostWorkflowResultsSimilarity(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostWorkflowResultsSimilarityRequest* /*request*/, ::clarifai::api::PostWorkflowResultsSimilarityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostWorkflowResultsSimilarity(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(59, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetKey() {
      ::grpc::Service::MarkMethodRaw(60);
    }
    ~WithRawMethod_GetKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetKey(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetKeyRequest* /*request*/, ::clarifai::api::SingleKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetKey(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(60, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListKeys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListKeys() {
      ::grpc::Service::MarkMethodRaw(61);
    }
    ~WithRawMethod_ListKeys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListKeys(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListKeys(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(61, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListAppKeys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListAppKeys() {
      ::grpc::Service::MarkMethodRaw(62);
    }
    ~WithRawMethod_ListAppKeys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAppKeys(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAppKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListAppKeys(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(62, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteKey() {
      ::grpc::Service::MarkMethodRaw(63);
    }
    ~WithRawMethod_DeleteKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteKey(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteKeyRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteKey(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(63, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostKeys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostKeys() {
      ::grpc::Service::MarkMethodRaw(64);
    }
    ~WithRawMethod_PostKeys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostKeys(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostKeys(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(64, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PatchKeys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PatchKeys() {
      ::grpc::Service::MarkMethodRaw(65);
    }
    ~WithRawMethod_PatchKeys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchKeys(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPatchKeys(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(65, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MyScopes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MyScopes() {
      ::grpc::Service::MarkMethodRaw(66);
    }
    ~WithRawMethod_MyScopes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MyScopes(::grpc::ServerContext* /*context*/, const ::clarifai::api::MyScopesRequest* /*request*/, ::clarifai::api::MultiScopeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMyScopes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(66, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListScopes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListScopes() {
      ::grpc::Service::MarkMethodRaw(67);
    }
    ~WithRawMethod_ListScopes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListScopes(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListScopesRequest* /*request*/, ::clarifai::api::MultiScopeDepsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListScopes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(67, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetApp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetApp() {
      ::grpc::Service::MarkMethodRaw(68);
    }
    ~WithRawMethod_GetApp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetApp(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetAppRequest* /*request*/, ::clarifai::api::SingleAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetApp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(68, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListApps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListApps() {
      ::grpc::Service::MarkMethodRaw(69);
    }
    ~WithRawMethod_ListApps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListApps(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAppsRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListApps(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(69, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteApp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteApp() {
      ::grpc::Service::MarkMethodRaw(70);
    }
    ~WithRawMethod_DeleteApp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteApp(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteAppRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteApp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(70, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostApps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostApps() {
      ::grpc::Service::MarkMethodRaw(71);
    }
    ~WithRawMethod_PostApps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostApps(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAppsRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostApps(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(71, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PatchApps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PatchApps() {
      ::grpc::Service::MarkMethodRaw(72);
    }
    ~WithRawMethod_PatchApps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchApps(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchAppsRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPatchApps(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(72, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostAppsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostAppsSearches() {
      ::grpc::Service::MarkMethodRaw(73);
    }
    ~WithRawMethod_PostAppsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAppsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAppsSearchesRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostAppsSearches(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(73, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostValidatePassword : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostValidatePassword() {
      ::grpc::Service::MarkMethodRaw(74);
    }
    ~WithRawMethod_PostValidatePassword() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostValidatePassword(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostValidatePasswordRequest* /*request*/, ::clarifai::api::SinglePasswordValidationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostValidatePassword(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(74, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSearch() {
      ::grpc::Service::MarkMethodRaw(75);
    }
    ~WithRawMethod_GetSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSearch(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetSearchRequest* /*request*/, ::clarifai::api::SingleSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSearch(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(75, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListSearches() {
      ::grpc::Service::MarkMethodRaw(76);
    }
    ~WithRawMethod_ListSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListSearches(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(76, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostSearches() {
      ::grpc::Service::MarkMethodRaw(77);
    }
    ~WithRawMethod_PostSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostSearches(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(77, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostSearchesByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostSearchesByID() {
      ::grpc::Service::MarkMethodRaw(78);
    }
    ~WithRawMethod_PostSearchesByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostSearchesByID(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostSearchesByIDRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostSearchesByID(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(78, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostAnnotationSearchMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostAnnotationSearchMetrics() {
      ::grpc::Service::MarkMethodRaw(79);
    }
    ~WithRawMethod_PostAnnotationSearchMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAnnotationSearchMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::MultiAnnotationSearchMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostAnnotationSearchMetrics(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(79, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAnnotationSearchMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAnnotationSearchMetrics() {
      ::grpc::Service::MarkMethodRaw(80);
    }
    ~WithRawMethod_GetAnnotationSearchMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAnnotationSearchMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::MultiAnnotationSearchMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAnnotationSearchMetrics(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(80, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListAnnotationSearchMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListAnnotationSearchMetrics() {
      ::grpc::Service::MarkMethodRaw(81);
    }
    ~WithRawMethod_ListAnnotationSearchMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAnnotationSearchMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::MultiAnnotationSearchMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListAnnotationSearchMetrics(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(81, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteAnnotationSearchMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteAnnotationSearchMetrics() {
      ::grpc::Service::MarkMethodRaw(82);
    }
    ~WithRawMethod_DeleteAnnotationSearchMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAnnotationSearchMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteAnnotationSearchMetrics(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(82, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteSearch() {
      ::grpc::Service::MarkMethodRaw(83);
    }
    ~WithRawMethod_DeleteSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSearch(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteSearchRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteSearch(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(83, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListStatusCodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListStatusCodes() {
      ::grpc::Service::MarkMethodRaw(84);
    }
    ~WithRawMethod_ListStatusCodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListStatusCodes(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListStatusCodesRequest* /*request*/, ::clarifai::api::MultiStatusCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListStatusCodes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(84, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetStatusCode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetStatusCode() {
      ::grpc::Service::MarkMethodRaw(85);
    }
    ~WithRawMethod_GetStatusCode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStatusCode(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetStatusCodeRequest* /*request*/, ::clarifai::api::SingleStatusCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStatusCode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(85, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListCollaborators : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListCollaborators() {
      ::grpc::Service::MarkMethodRaw(86);
    }
    ~WithRawMethod_ListCollaborators() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListCollaborators(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListCollaboratorsRequest* /*request*/, ::clarifai::api::MultiCollaboratorsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListCollaborators(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(86, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostCollaborators : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostCollaborators() {
      ::grpc::Service::MarkMethodRaw(87);
    }
    ~WithRawMethod_PostCollaborators() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostCollaborators(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostCollaboratorsRequest* /*request*/, ::clarifai::api::MultiCollaboratorsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostCollaborators(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(87, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PatchCollaborators : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PatchCollaborators() {
      ::grpc::Service::MarkMethodRaw(88);
    }
    ~WithRawMethod_PatchCollaborators() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchCollaborators(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchCollaboratorsRequest* /*request*/, ::clarifai::api::MultiCollaboratorsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPatchCollaborators(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(88, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteCollaborators : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteCollaborators() {
      ::grpc::Service::MarkMethodRaw(89);
    }
    ~WithRawMethod_DeleteCollaborators() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteCollaborators(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteCollaboratorsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteCollaborators(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(89, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListCollaborations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListCollaborations() {
      ::grpc::Service::MarkMethodRaw(90);
    }
    ~WithRawMethod_ListCollaborations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListCollaborations(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListCollaborationsRequest* /*request*/, ::clarifai::api::MultiCollaborationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListCollaborations(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(90, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostAppDuplications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostAppDuplications() {
      ::grpc::Service::MarkMethodRaw(91);
    }
    ~WithRawMethod_PostAppDuplications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAppDuplications(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAppDuplicationsRequest* /*request*/, ::clarifai::api::MultiAppDuplicationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostAppDuplications(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(91, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListAppDuplications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListAppDuplications() {
      ::grpc::Service::MarkMethodRaw(92);
    }
    ~WithRawMethod_ListAppDuplications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAppDuplications(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAppDuplicationsRequest* /*request*/, ::clarifai::api::MultiAppDuplicationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListAppDuplications(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(92, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAppDuplication : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAppDuplication() {
      ::grpc::Service::MarkMethodRaw(93);
    }
    ~WithRawMethod_GetAppDuplication() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAppDuplication(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetAppDuplicationRequest* /*request*/, ::clarifai::api::SingleAppDuplicationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAppDuplication(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(93, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostTasks() {
      ::grpc::Service::MarkMethodRaw(94);
    }
    ~WithRawMethod_PostTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostTasks(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostTasksRequest* /*request*/, ::clarifai::api::MultiTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostTasks(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(94, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTaskAnnotationCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTaskAnnotationCount() {
      ::grpc::Service::MarkMethodRaw(95);
    }
    ~WithRawMethod_GetTaskAnnotationCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskAnnotationCount(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetTaskCountRequest* /*request*/, ::clarifai::api::SingleTaskCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTaskAnnotationCount(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(95, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTaskInputCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTaskInputCount() {
      ::grpc::Service::MarkMethodRaw(96);
    }
    ~WithRawMethod_GetTaskInputCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskInputCount(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetTaskCountRequest* /*request*/, ::clarifai::api::SingleTaskCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTaskInputCount(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(96, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTask() {
      ::grpc::Service::MarkMethodRaw(97);
    }
    ~WithRawMethod_GetTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTask(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetTaskRequest* /*request*/, ::clarifai::api::SingleTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTask(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(97, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListTasks() {
      ::grpc::Service::MarkMethodRaw(98);
    }
    ~WithRawMethod_ListTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTasks(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListTasksRequest* /*request*/, ::clarifai::api::MultiTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListTasks(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(98, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PatchTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PatchTasks() {
      ::grpc::Service::MarkMethodRaw(99);
    }
    ~WithRawMethod_PatchTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchTasks(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchTasksRequest* /*request*/, ::clarifai::api::MultiTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPatchTasks(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(99, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteTasks() {
      ::grpc::Service::MarkMethodRaw(100);
    }
    ~WithRawMethod_DeleteTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteTasks(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteTasksRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteTasks(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(100, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostCollectors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostCollectors() {
      ::grpc::Service::MarkMethodRaw(101);
    }
    ~WithRawMethod_PostCollectors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostCollectors(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostCollectorsRequest* /*request*/, ::clarifai::api::MultiCollectorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostCollectors(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(101, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCollector : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCollector() {
      ::grpc::Service::MarkMethodRaw(102);
    }
    ~WithRawMethod_GetCollector() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollector(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetCollectorRequest* /*request*/, ::clarifai::api::SingleCollectorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCollector(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(102, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListCollectors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListCollectors() {
      ::grpc::Service::MarkMethodRaw(103);
    }
    ~WithRawMethod_ListCollectors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListCollectors(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListCollectorsRequest* /*request*/, ::clarifai::api::MultiCollectorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListCollectors(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(103, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PatchCollectors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PatchCollectors() {
      ::grpc::Service::MarkMethodRaw(104);
    }
    ~WithRawMethod_PatchCollectors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchCollectors(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchCollectorsRequest* /*request*/, ::clarifai::api::MultiCollectorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPatchCollectors(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(104, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteCollectors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteCollectors() {
      ::grpc::Service::MarkMethodRaw(105);
    }
    ~WithRawMethod_DeleteCollectors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteCollectors(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteCollectorsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteCollectors(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(105, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostStatValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostStatValues() {
      ::grpc::Service::MarkMethodRaw(106);
    }
    ~WithRawMethod_PostStatValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostStatValues(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostStatValuesRequest* /*request*/, ::clarifai::api::MultiStatValueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostStatValues(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(106, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostStatValuesAggregate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostStatValuesAggregate() {
      ::grpc::Service::MarkMethodRaw(107);
    }
    ~WithRawMethod_PostStatValuesAggregate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostStatValuesAggregate(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostStatValuesAggregateRequest* /*request*/, ::clarifai::api::MultiStatValueAggregateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostStatValuesAggregate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(107, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListConceptRelations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListConceptRelations() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListConceptRelations(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListConceptRelations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListConceptRelations(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListConceptRelationsRequest* /*request*/, ::clarifai::api::MultiConceptRelationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListConceptRelations(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListConceptRelations(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostConceptRelations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostConceptRelations() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostConceptRelations(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostConceptRelations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostConceptRelations(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptRelationsRequest* /*request*/, ::clarifai::api::MultiConceptRelationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostConceptRelations(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostConceptRelations(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteConceptRelations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteConceptRelations() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteConceptRelations(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteConceptRelations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteConceptRelations(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteConceptRelationsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteConceptRelations(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteConceptRelations(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetConceptCounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetConceptCounts() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetConceptCounts(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetConceptCounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConceptCounts(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetConceptCountsRequest* /*request*/, ::clarifai::api::MultiConceptCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetConceptCounts(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetConceptCounts(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetConcept : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetConcept() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetConcept(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetConcept() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConcept(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetConceptRequest* /*request*/, ::clarifai::api::SingleConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetConcept(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetConcept(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListConcepts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListConcepts() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListConcepts(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListConcepts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListConcepts(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListConceptsRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListConcepts(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListConcepts(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostConceptsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostConceptsSearches() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostConceptsSearches(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostConceptsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostConceptsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptsSearchesRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostConceptsSearches(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostConceptsSearches(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostConcepts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostConcepts() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostConcepts(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostConcepts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostConcepts(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptsRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostConcepts(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostConcepts(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PatchConcepts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PatchConcepts() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PatchConcepts(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PatchConcepts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchConcepts(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchConceptsRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PatchConcepts(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PatchConcepts(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetConceptLanguage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetConceptLanguage() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetConceptLanguage(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetConceptLanguage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConceptLanguage(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetConceptLanguageRequest* /*request*/, ::clarifai::api::SingleConceptLanguageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetConceptLanguage(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetConceptLanguage(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListConceptLanguages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListConceptLanguages() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListConceptLanguages(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListConceptLanguages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListConceptLanguages(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListConceptLanguagesRequest* /*request*/, ::clarifai::api::MultiConceptLanguageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListConceptLanguages(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListConceptLanguages(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostConceptLanguages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostConceptLanguages() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostConceptLanguages(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostConceptLanguages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostConceptLanguages(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptLanguagesRequest* /*request*/, ::clarifai::api::MultiConceptLanguageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostConceptLanguages(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostConceptLanguages(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PatchConceptLanguages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PatchConceptLanguages() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PatchConceptLanguages(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PatchConceptLanguages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchConceptLanguages(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchConceptLanguagesRequest* /*request*/, ::clarifai::api::MultiConceptLanguageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PatchConceptLanguages(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PatchConceptLanguages(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListKnowledgeGraphs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListKnowledgeGraphs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(13,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListKnowledgeGraphs(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListKnowledgeGraphs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListKnowledgeGraphs(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListKnowledgeGraphsRequest* /*request*/, ::clarifai::api::MultiKnowledgeGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListKnowledgeGraphs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListKnowledgeGraphs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostKnowledgeGraphs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostKnowledgeGraphs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(14,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostKnowledgeGraphs(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostKnowledgeGraphs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostKnowledgeGraphs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostKnowledgeGraphsRequest* /*request*/, ::clarifai::api::MultiKnowledgeGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostKnowledgeGraphs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostKnowledgeGraphs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostConceptMappingJobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostConceptMappingJobs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(15,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostConceptMappingJobs(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostConceptMappingJobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostConceptMappingJobs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptMappingJobsRequest* /*request*/, ::clarifai::api::MultiConceptMappingJobResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostConceptMappingJobs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostConceptMappingJobs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetAnnotation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetAnnotation() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(16,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetAnnotation(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetAnnotation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAnnotation(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetAnnotationRequest* /*request*/, ::clarifai::api::SingleAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetAnnotation(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetAnnotation(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListAnnotations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListAnnotations() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(17,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListAnnotations(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListAnnotations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAnnotations(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAnnotationsRequest* /*request*/, ::clarifai::api::MultiAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListAnnotations(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListAnnotations(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostAnnotations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostAnnotations() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(18,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostAnnotations(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostAnnotations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAnnotations(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAnnotationsRequest* /*request*/, ::clarifai::api::MultiAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostAnnotations(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostAnnotations(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PatchAnnotations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PatchAnnotations() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(19,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PatchAnnotations(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PatchAnnotations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchAnnotations(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchAnnotationsRequest* /*request*/, ::clarifai::api::MultiAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PatchAnnotations(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PatchAnnotations(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PatchAnnotationsStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PatchAnnotationsStatus() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(20,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PatchAnnotationsStatus(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PatchAnnotationsStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchAnnotationsStatus(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchAnnotationsStatusRequest* /*request*/, ::clarifai::api::PatchAnnotationsStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PatchAnnotationsStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PatchAnnotationsStatus(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteAnnotation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteAnnotation() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(21,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteAnnotation(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteAnnotation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAnnotation(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteAnnotationRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteAnnotation(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteAnnotation(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteAnnotations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteAnnotations() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(22,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteAnnotations(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteAnnotations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAnnotations(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteAnnotationsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteAnnotations(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteAnnotations(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostAnnotationsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostAnnotationsSearches() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(23,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostAnnotationsSearches(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostAnnotationsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAnnotationsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAnnotationsSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostAnnotationsSearches(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostAnnotationsSearches(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetInputCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetInputCount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(24,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetInputCount(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetInputCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInputCount(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetInputCountRequest* /*request*/, ::clarifai::api::SingleInputCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetInputCount(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetInputCount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StreamInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_StreamInputs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(25,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StreamInputs(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_StreamInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::StreamInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* StreamInputs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* StreamInputs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetInputSamples : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetInputSamples() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(26,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetInputSamples(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetInputSamples() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInputSamples(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetInputSamplesRequest* /*request*/, ::clarifai::api::MultiInputAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetInputSamples(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetInputSamples(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetInput() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(27,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetInput(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInput(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetInputRequest* /*request*/, ::clarifai::api::SingleInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetInput(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetInput(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListInputs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(28,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListInputs(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListInputs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListInputs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostInputs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(29,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostInputs(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostInputs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostInputs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PatchInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PatchInputs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(30,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PatchInputs(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PatchInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PatchInputs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PatchInputs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteInput() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(31,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteInput(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteInput(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteInputRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteInput(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteInput(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteInputs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(32,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteInputs(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteInputsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteInputs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteInputs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostInputsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostInputsSearches() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(33,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostInputsSearches(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostInputsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostInputsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostInputsSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostInputsSearches(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostInputsSearches(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostModelOutputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostModelOutputs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(34,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostModelOutputs(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostModelOutputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostModelOutputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelOutputsRequest* /*request*/, ::clarifai::api::MultiOutputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostModelOutputs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostModelOutputs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetModelType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetModelType() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(35,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetModelType(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetModelType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModelType(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelTypeRequest* /*request*/, ::clarifai::api::SingleModelTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetModelType(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetModelType(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListModelTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListModelTypes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(36,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListModelTypes(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListModelTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListModelTypes(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListModelTypesRequest* /*request*/, ::clarifai::api::MultiModelTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListModelTypes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListModelTypes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetModel() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(37,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetModel(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModel(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetModel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetModel(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetModelOutputInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetModelOutputInfo() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(38,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetModelOutputInfo(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetModelOutputInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModelOutputInfo(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetModelOutputInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetModelOutputInfo(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListModels() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(39,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListModels(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListModels(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListModelsRequest* /*request*/, ::clarifai::api::MultiModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListModels(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListModels(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostModelsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostModelsSearches() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(40,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostModelsSearches(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostModelsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostModelsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelsSearchesRequest* /*request*/, ::clarifai::api::MultiModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostModelsSearches(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostModelsSearches(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostModels() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(41,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostModels(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostModels(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelsRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostModels(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostModels(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PatchModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PatchModels() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(42,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PatchModels(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PatchModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchModels(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchModelsRequest* /*request*/, ::clarifai::api::MultiModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PatchModels(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PatchModels(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteModel() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(43,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteModel(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteModel(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteModelRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteModel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteModel(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteModels() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(44,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteModels(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteModels(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteModelsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteModels(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteModels(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListModelInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListModelInputs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(45,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListModelInputs(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListModelInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListModelInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListModelInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListModelInputs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListModelInputs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetModelVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetModelVersion() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(46,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetModelVersion(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetModelVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModelVersion(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelVersionRequest* /*request*/, ::clarifai::api::SingleModelVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetModelVersion(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetModelVersion(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListModelVersions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListModelVersions() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(47,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListModelVersions(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListModelVersions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListModelVersions(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListModelVersionsRequest* /*request*/, ::clarifai::api::MultiModelVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListModelVersions(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListModelVersions(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostModelVersions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostModelVersions() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(48,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostModelVersions(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostModelVersions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostModelVersions(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelVersionsRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostModelVersions(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostModelVersions(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteModelVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteModelVersion() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(49,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteModelVersion(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteModelVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteModelVersion(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteModelVersionRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteModelVersion(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteModelVersion(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetModelVersionMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetModelVersionMetrics() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(50,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetModelVersionMetrics(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetModelVersionMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModelVersionMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelVersionMetricsRequest* /*request*/, ::clarifai::api::SingleModelVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetModelVersionMetrics(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetModelVersionMetrics(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostModelVersionMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostModelVersionMetrics() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(51,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostModelVersionMetrics(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostModelVersionMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostModelVersionMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelVersionMetricsRequest* /*request*/, ::clarifai::api::SingleModelVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostModelVersionMetrics(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostModelVersionMetrics(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetWorkflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetWorkflow() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(52,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetWorkflow(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetWorkflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkflow(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetWorkflowRequest* /*request*/, ::clarifai::api::SingleWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetWorkflow(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetWorkflow(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListWorkflows() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(53,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListWorkflows(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListWorkflows(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListWorkflowsRequest* /*request*/, ::clarifai::api::MultiWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListWorkflows(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListWorkflows(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostWorkflows() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(54,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostWorkflows(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostWorkflows(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostWorkflowsRequest* /*request*/, ::clarifai::api::MultiWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostWorkflows(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostWorkflows(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PatchWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PatchWorkflows() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(55,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PatchWorkflows(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PatchWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchWorkflows(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchWorkflowsRequest* /*request*/, ::clarifai::api::MultiWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PatchWorkflows(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PatchWorkflows(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteWorkflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteWorkflow() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(56,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteWorkflow(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteWorkflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteWorkflow(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteWorkflowRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteWorkflow(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteWorkflow(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteWorkflows() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(57,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteWorkflows(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteWorkflows(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteWorkflowsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteWorkflows(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteWorkflows(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostWorkflowResults : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostWorkflowResults() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(58,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostWorkflowResults(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostWorkflowResults() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostWorkflowResults(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostWorkflowResultsRequest* /*request*/, ::clarifai::api::PostWorkflowResultsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostWorkflowResults(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostWorkflowResults(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostWorkflowResultsSimilarity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostWorkflowResultsSimilarity() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(59,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostWorkflowResultsSimilarity(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostWorkflowResultsSimilarity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostWorkflowResultsSimilarity(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostWorkflowResultsSimilarityRequest* /*request*/, ::clarifai::api::PostWorkflowResultsSimilarityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostWorkflowResultsSimilarity(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostWorkflowResultsSimilarity(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetKey() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(60,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetKey(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetKey(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetKeyRequest* /*request*/, ::clarifai::api::SingleKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetKey(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetKey(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListKeys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListKeys() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(61,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListKeys(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListKeys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListKeys(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListKeys(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListKeys(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListAppKeys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListAppKeys() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(62,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListAppKeys(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListAppKeys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAppKeys(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAppKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListAppKeys(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListAppKeys(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteKey() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(63,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteKey(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteKey(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteKeyRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteKey(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteKey(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostKeys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostKeys() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(64,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostKeys(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostKeys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostKeys(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostKeys(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostKeys(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PatchKeys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PatchKeys() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(65,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PatchKeys(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PatchKeys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchKeys(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PatchKeys(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PatchKeys(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MyScopes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MyScopes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(66,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MyScopes(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MyScopes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MyScopes(::grpc::ServerContext* /*context*/, const ::clarifai::api::MyScopesRequest* /*request*/, ::clarifai::api::MultiScopeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MyScopes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MyScopes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListScopes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListScopes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(67,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListScopes(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListScopes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListScopes(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListScopesRequest* /*request*/, ::clarifai::api::MultiScopeDepsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListScopes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListScopes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetApp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetApp() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(68,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetApp(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetApp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetApp(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetAppRequest* /*request*/, ::clarifai::api::SingleAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetApp(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetApp(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListApps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListApps() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(69,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListApps(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListApps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListApps(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAppsRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListApps(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListApps(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteApp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteApp() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(70,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteApp(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteApp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteApp(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteAppRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteApp(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteApp(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostApps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostApps() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(71,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostApps(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostApps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostApps(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAppsRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostApps(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostApps(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PatchApps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PatchApps() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(72,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PatchApps(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PatchApps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchApps(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchAppsRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PatchApps(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PatchApps(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostAppsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostAppsSearches() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(73,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostAppsSearches(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostAppsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAppsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAppsSearchesRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostAppsSearches(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostAppsSearches(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostValidatePassword : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostValidatePassword() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(74,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostValidatePassword(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostValidatePassword() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostValidatePassword(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostValidatePasswordRequest* /*request*/, ::clarifai::api::SinglePasswordValidationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostValidatePassword(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostValidatePassword(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetSearch() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(75,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSearch(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSearch(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetSearchRequest* /*request*/, ::clarifai::api::SingleSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetSearch(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetSearch(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListSearches() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(76,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListSearches(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListSearches(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListSearches(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostSearches() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(77,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostSearches(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostSearches(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostSearches(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostSearchesByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostSearchesByID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(78,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostSearchesByID(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostSearchesByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostSearchesByID(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostSearchesByIDRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostSearchesByID(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostSearchesByID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostAnnotationSearchMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostAnnotationSearchMetrics() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(79,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostAnnotationSearchMetrics(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostAnnotationSearchMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAnnotationSearchMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::MultiAnnotationSearchMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostAnnotationSearchMetrics(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostAnnotationSearchMetrics(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetAnnotationSearchMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetAnnotationSearchMetrics() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(80,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetAnnotationSearchMetrics(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetAnnotationSearchMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAnnotationSearchMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::MultiAnnotationSearchMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetAnnotationSearchMetrics(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetAnnotationSearchMetrics(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListAnnotationSearchMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListAnnotationSearchMetrics() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(81,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListAnnotationSearchMetrics(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListAnnotationSearchMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAnnotationSearchMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::MultiAnnotationSearchMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListAnnotationSearchMetrics(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListAnnotationSearchMetrics(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteAnnotationSearchMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteAnnotationSearchMetrics() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(82,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteAnnotationSearchMetrics(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteAnnotationSearchMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAnnotationSearchMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteAnnotationSearchMetrics(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteAnnotationSearchMetrics(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteSearch() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(83,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteSearch(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSearch(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteSearchRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteSearch(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteSearch(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListStatusCodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListStatusCodes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(84,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListStatusCodes(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListStatusCodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListStatusCodes(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListStatusCodesRequest* /*request*/, ::clarifai::api::MultiStatusCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListStatusCodes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListStatusCodes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetStatusCode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetStatusCode() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(85,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetStatusCode(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetStatusCode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStatusCode(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetStatusCodeRequest* /*request*/, ::clarifai::api::SingleStatusCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetStatusCode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetStatusCode(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListCollaborators : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListCollaborators() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(86,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListCollaborators(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListCollaborators() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListCollaborators(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListCollaboratorsRequest* /*request*/, ::clarifai::api::MultiCollaboratorsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListCollaborators(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListCollaborators(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostCollaborators : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostCollaborators() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(87,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostCollaborators(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostCollaborators() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostCollaborators(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostCollaboratorsRequest* /*request*/, ::clarifai::api::MultiCollaboratorsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostCollaborators(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostCollaborators(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PatchCollaborators : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PatchCollaborators() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(88,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PatchCollaborators(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PatchCollaborators() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchCollaborators(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchCollaboratorsRequest* /*request*/, ::clarifai::api::MultiCollaboratorsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PatchCollaborators(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PatchCollaborators(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteCollaborators : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteCollaborators() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(89,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteCollaborators(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteCollaborators() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteCollaborators(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteCollaboratorsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteCollaborators(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteCollaborators(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListCollaborations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListCollaborations() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(90,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListCollaborations(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListCollaborations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListCollaborations(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListCollaborationsRequest* /*request*/, ::clarifai::api::MultiCollaborationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListCollaborations(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListCollaborations(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostAppDuplications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostAppDuplications() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(91,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostAppDuplications(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostAppDuplications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAppDuplications(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAppDuplicationsRequest* /*request*/, ::clarifai::api::MultiAppDuplicationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostAppDuplications(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostAppDuplications(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListAppDuplications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListAppDuplications() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(92,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListAppDuplications(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListAppDuplications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAppDuplications(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAppDuplicationsRequest* /*request*/, ::clarifai::api::MultiAppDuplicationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListAppDuplications(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListAppDuplications(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetAppDuplication : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetAppDuplication() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(93,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetAppDuplication(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetAppDuplication() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAppDuplication(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetAppDuplicationRequest* /*request*/, ::clarifai::api::SingleAppDuplicationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetAppDuplication(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetAppDuplication(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostTasks() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(94,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostTasks(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostTasks(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostTasksRequest* /*request*/, ::clarifai::api::MultiTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostTasks(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostTasks(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetTaskAnnotationCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetTaskAnnotationCount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(95,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTaskAnnotationCount(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetTaskAnnotationCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskAnnotationCount(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetTaskCountRequest* /*request*/, ::clarifai::api::SingleTaskCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetTaskAnnotationCount(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetTaskAnnotationCount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetTaskInputCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetTaskInputCount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(96,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTaskInputCount(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetTaskInputCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskInputCount(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetTaskCountRequest* /*request*/, ::clarifai::api::SingleTaskCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetTaskInputCount(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetTaskInputCount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetTask() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(97,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTask(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTask(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetTaskRequest* /*request*/, ::clarifai::api::SingleTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetTask(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetTask(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListTasks() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(98,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListTasks(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTasks(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListTasksRequest* /*request*/, ::clarifai::api::MultiTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListTasks(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListTasks(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PatchTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PatchTasks() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(99,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PatchTasks(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PatchTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchTasks(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchTasksRequest* /*request*/, ::clarifai::api::MultiTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PatchTasks(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PatchTasks(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteTasks() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(100,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteTasks(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteTasks(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteTasksRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteTasks(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteTasks(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostCollectors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostCollectors() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(101,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostCollectors(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostCollectors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostCollectors(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostCollectorsRequest* /*request*/, ::clarifai::api::MultiCollectorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostCollectors(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostCollectors(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetCollector : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetCollector() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(102,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCollector(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetCollector() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollector(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetCollectorRequest* /*request*/, ::clarifai::api::SingleCollectorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetCollector(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetCollector(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListCollectors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListCollectors() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(103,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListCollectors(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListCollectors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListCollectors(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListCollectorsRequest* /*request*/, ::clarifai::api::MultiCollectorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListCollectors(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListCollectors(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PatchCollectors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PatchCollectors() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(104,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PatchCollectors(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PatchCollectors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PatchCollectors(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchCollectorsRequest* /*request*/, ::clarifai::api::MultiCollectorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PatchCollectors(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PatchCollectors(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteCollectors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteCollectors() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(105,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteCollectors(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteCollectors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteCollectors(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteCollectorsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteCollectors(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteCollectors(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostStatValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostStatValues() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(106,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostStatValues(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostStatValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostStatValues(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostStatValuesRequest* /*request*/, ::clarifai::api::MultiStatValueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostStatValues(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostStatValues(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PostStatValuesAggregate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PostStatValuesAggregate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(107,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostStatValuesAggregate(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PostStatValuesAggregate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostStatValuesAggregate(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostStatValuesAggregateRequest* /*request*/, ::clarifai::api::MultiStatValueAggregateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PostStatValuesAggregate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PostStatValuesAggregate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListConceptRelations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListConceptRelations() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::ListConceptRelationsRequest, ::clarifai::api::MultiConceptRelationResponse>(std::bind(&WithStreamedUnaryMethod_ListConceptRelations<BaseClass>::StreamedListConceptRelations, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListConceptRelations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListConceptRelations(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListConceptRelationsRequest* /*request*/, ::clarifai::api::MultiConceptRelationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListConceptRelations(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::ListConceptRelationsRequest,::clarifai::api::MultiConceptRelationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostConceptRelations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostConceptRelations() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostConceptRelationsRequest, ::clarifai::api::MultiConceptRelationResponse>(std::bind(&WithStreamedUnaryMethod_PostConceptRelations<BaseClass>::StreamedPostConceptRelations, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostConceptRelations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostConceptRelations(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptRelationsRequest* /*request*/, ::clarifai::api::MultiConceptRelationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostConceptRelations(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostConceptRelationsRequest,::clarifai::api::MultiConceptRelationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteConceptRelations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteConceptRelations() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::DeleteConceptRelationsRequest, ::clarifai::api::status::BaseResponse>(std::bind(&WithStreamedUnaryMethod_DeleteConceptRelations<BaseClass>::StreamedDeleteConceptRelations, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteConceptRelations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteConceptRelations(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteConceptRelationsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteConceptRelations(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::DeleteConceptRelationsRequest,::clarifai::api::status::BaseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetConceptCounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetConceptCounts() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::GetConceptCountsRequest, ::clarifai::api::MultiConceptCountResponse>(std::bind(&WithStreamedUnaryMethod_GetConceptCounts<BaseClass>::StreamedGetConceptCounts, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetConceptCounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetConceptCounts(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetConceptCountsRequest* /*request*/, ::clarifai::api::MultiConceptCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetConceptCounts(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::GetConceptCountsRequest,::clarifai::api::MultiConceptCountResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetConcept : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetConcept() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::GetConceptRequest, ::clarifai::api::SingleConceptResponse>(std::bind(&WithStreamedUnaryMethod_GetConcept<BaseClass>::StreamedGetConcept, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetConcept() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetConcept(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetConceptRequest* /*request*/, ::clarifai::api::SingleConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetConcept(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::GetConceptRequest,::clarifai::api::SingleConceptResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListConcepts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListConcepts() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::ListConceptsRequest, ::clarifai::api::MultiConceptResponse>(std::bind(&WithStreamedUnaryMethod_ListConcepts<BaseClass>::StreamedListConcepts, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListConcepts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListConcepts(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListConceptsRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListConcepts(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::ListConceptsRequest,::clarifai::api::MultiConceptResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostConceptsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostConceptsSearches() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostConceptsSearchesRequest, ::clarifai::api::MultiConceptResponse>(std::bind(&WithStreamedUnaryMethod_PostConceptsSearches<BaseClass>::StreamedPostConceptsSearches, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostConceptsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostConceptsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptsSearchesRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostConceptsSearches(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostConceptsSearchesRequest,::clarifai::api::MultiConceptResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostConcepts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostConcepts() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostConceptsRequest, ::clarifai::api::MultiConceptResponse>(std::bind(&WithStreamedUnaryMethod_PostConcepts<BaseClass>::StreamedPostConcepts, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostConcepts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostConcepts(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptsRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostConcepts(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostConceptsRequest,::clarifai::api::MultiConceptResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PatchConcepts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PatchConcepts() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PatchConceptsRequest, ::clarifai::api::MultiConceptResponse>(std::bind(&WithStreamedUnaryMethod_PatchConcepts<BaseClass>::StreamedPatchConcepts, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PatchConcepts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PatchConcepts(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchConceptsRequest* /*request*/, ::clarifai::api::MultiConceptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPatchConcepts(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PatchConceptsRequest,::clarifai::api::MultiConceptResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetConceptLanguage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetConceptLanguage() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::GetConceptLanguageRequest, ::clarifai::api::SingleConceptLanguageResponse>(std::bind(&WithStreamedUnaryMethod_GetConceptLanguage<BaseClass>::StreamedGetConceptLanguage, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetConceptLanguage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetConceptLanguage(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetConceptLanguageRequest* /*request*/, ::clarifai::api::SingleConceptLanguageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetConceptLanguage(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::GetConceptLanguageRequest,::clarifai::api::SingleConceptLanguageResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListConceptLanguages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListConceptLanguages() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::ListConceptLanguagesRequest, ::clarifai::api::MultiConceptLanguageResponse>(std::bind(&WithStreamedUnaryMethod_ListConceptLanguages<BaseClass>::StreamedListConceptLanguages, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListConceptLanguages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListConceptLanguages(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListConceptLanguagesRequest* /*request*/, ::clarifai::api::MultiConceptLanguageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListConceptLanguages(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::ListConceptLanguagesRequest,::clarifai::api::MultiConceptLanguageResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostConceptLanguages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostConceptLanguages() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostConceptLanguagesRequest, ::clarifai::api::MultiConceptLanguageResponse>(std::bind(&WithStreamedUnaryMethod_PostConceptLanguages<BaseClass>::StreamedPostConceptLanguages, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostConceptLanguages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostConceptLanguages(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptLanguagesRequest* /*request*/, ::clarifai::api::MultiConceptLanguageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostConceptLanguages(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostConceptLanguagesRequest,::clarifai::api::MultiConceptLanguageResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PatchConceptLanguages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PatchConceptLanguages() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PatchConceptLanguagesRequest, ::clarifai::api::MultiConceptLanguageResponse>(std::bind(&WithStreamedUnaryMethod_PatchConceptLanguages<BaseClass>::StreamedPatchConceptLanguages, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PatchConceptLanguages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PatchConceptLanguages(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchConceptLanguagesRequest* /*request*/, ::clarifai::api::MultiConceptLanguageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPatchConceptLanguages(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PatchConceptLanguagesRequest,::clarifai::api::MultiConceptLanguageResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListKnowledgeGraphs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListKnowledgeGraphs() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::ListKnowledgeGraphsRequest, ::clarifai::api::MultiKnowledgeGraphResponse>(std::bind(&WithStreamedUnaryMethod_ListKnowledgeGraphs<BaseClass>::StreamedListKnowledgeGraphs, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListKnowledgeGraphs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListKnowledgeGraphs(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListKnowledgeGraphsRequest* /*request*/, ::clarifai::api::MultiKnowledgeGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListKnowledgeGraphs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::ListKnowledgeGraphsRequest,::clarifai::api::MultiKnowledgeGraphResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostKnowledgeGraphs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostKnowledgeGraphs() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostKnowledgeGraphsRequest, ::clarifai::api::MultiKnowledgeGraphResponse>(std::bind(&WithStreamedUnaryMethod_PostKnowledgeGraphs<BaseClass>::StreamedPostKnowledgeGraphs, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostKnowledgeGraphs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostKnowledgeGraphs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostKnowledgeGraphsRequest* /*request*/, ::clarifai::api::MultiKnowledgeGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostKnowledgeGraphs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostKnowledgeGraphsRequest,::clarifai::api::MultiKnowledgeGraphResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostConceptMappingJobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostConceptMappingJobs() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostConceptMappingJobsRequest, ::clarifai::api::MultiConceptMappingJobResponse>(std::bind(&WithStreamedUnaryMethod_PostConceptMappingJobs<BaseClass>::StreamedPostConceptMappingJobs, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostConceptMappingJobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostConceptMappingJobs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostConceptMappingJobsRequest* /*request*/, ::clarifai::api::MultiConceptMappingJobResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostConceptMappingJobs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostConceptMappingJobsRequest,::clarifai::api::MultiConceptMappingJobResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAnnotation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAnnotation() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::GetAnnotationRequest, ::clarifai::api::SingleAnnotationResponse>(std::bind(&WithStreamedUnaryMethod_GetAnnotation<BaseClass>::StreamedGetAnnotation, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetAnnotation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAnnotation(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetAnnotationRequest* /*request*/, ::clarifai::api::SingleAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAnnotation(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::GetAnnotationRequest,::clarifai::api::SingleAnnotationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListAnnotations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListAnnotations() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::ListAnnotationsRequest, ::clarifai::api::MultiAnnotationResponse>(std::bind(&WithStreamedUnaryMethod_ListAnnotations<BaseClass>::StreamedListAnnotations, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListAnnotations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListAnnotations(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAnnotationsRequest* /*request*/, ::clarifai::api::MultiAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListAnnotations(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::ListAnnotationsRequest,::clarifai::api::MultiAnnotationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostAnnotations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostAnnotations() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostAnnotationsRequest, ::clarifai::api::MultiAnnotationResponse>(std::bind(&WithStreamedUnaryMethod_PostAnnotations<BaseClass>::StreamedPostAnnotations, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostAnnotations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostAnnotations(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAnnotationsRequest* /*request*/, ::clarifai::api::MultiAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostAnnotations(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostAnnotationsRequest,::clarifai::api::MultiAnnotationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PatchAnnotations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PatchAnnotations() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PatchAnnotationsRequest, ::clarifai::api::MultiAnnotationResponse>(std::bind(&WithStreamedUnaryMethod_PatchAnnotations<BaseClass>::StreamedPatchAnnotations, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PatchAnnotations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PatchAnnotations(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchAnnotationsRequest* /*request*/, ::clarifai::api::MultiAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPatchAnnotations(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PatchAnnotationsRequest,::clarifai::api::MultiAnnotationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PatchAnnotationsStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PatchAnnotationsStatus() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PatchAnnotationsStatusRequest, ::clarifai::api::PatchAnnotationsStatusResponse>(std::bind(&WithStreamedUnaryMethod_PatchAnnotationsStatus<BaseClass>::StreamedPatchAnnotationsStatus, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PatchAnnotationsStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PatchAnnotationsStatus(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchAnnotationsStatusRequest* /*request*/, ::clarifai::api::PatchAnnotationsStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPatchAnnotationsStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PatchAnnotationsStatusRequest,::clarifai::api::PatchAnnotationsStatusResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteAnnotation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteAnnotation() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::DeleteAnnotationRequest, ::clarifai::api::status::BaseResponse>(std::bind(&WithStreamedUnaryMethod_DeleteAnnotation<BaseClass>::StreamedDeleteAnnotation, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteAnnotation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteAnnotation(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteAnnotationRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteAnnotation(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::DeleteAnnotationRequest,::clarifai::api::status::BaseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteAnnotations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteAnnotations() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::DeleteAnnotationsRequest, ::clarifai::api::status::BaseResponse>(std::bind(&WithStreamedUnaryMethod_DeleteAnnotations<BaseClass>::StreamedDeleteAnnotations, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteAnnotations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteAnnotations(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteAnnotationsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteAnnotations(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::DeleteAnnotationsRequest,::clarifai::api::status::BaseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostAnnotationsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostAnnotationsSearches() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostAnnotationsSearchesRequest, ::clarifai::api::MultiSearchResponse>(std::bind(&WithStreamedUnaryMethod_PostAnnotationsSearches<BaseClass>::StreamedPostAnnotationsSearches, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostAnnotationsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostAnnotationsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAnnotationsSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostAnnotationsSearches(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostAnnotationsSearchesRequest,::clarifai::api::MultiSearchResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetInputCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetInputCount() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::GetInputCountRequest, ::clarifai::api::SingleInputCountResponse>(std::bind(&WithStreamedUnaryMethod_GetInputCount<BaseClass>::StreamedGetInputCount, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetInputCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetInputCount(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetInputCountRequest* /*request*/, ::clarifai::api::SingleInputCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetInputCount(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::GetInputCountRequest,::clarifai::api::SingleInputCountResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StreamInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StreamInputs() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::StreamInputsRequest, ::clarifai::api::MultiInputResponse>(std::bind(&WithStreamedUnaryMethod_StreamInputs<BaseClass>::StreamedStreamInputs, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StreamInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StreamInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::StreamInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStreamInputs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::StreamInputsRequest,::clarifai::api::MultiInputResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetInputSamples : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetInputSamples() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::GetInputSamplesRequest, ::clarifai::api::MultiInputAnnotationResponse>(std::bind(&WithStreamedUnaryMethod_GetInputSamples<BaseClass>::StreamedGetInputSamples, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetInputSamples() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetInputSamples(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetInputSamplesRequest* /*request*/, ::clarifai::api::MultiInputAnnotationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetInputSamples(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::GetInputSamplesRequest,::clarifai::api::MultiInputAnnotationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetInput() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::GetInputRequest, ::clarifai::api::SingleInputResponse>(std::bind(&WithStreamedUnaryMethod_GetInput<BaseClass>::StreamedGetInput, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetInput(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetInputRequest* /*request*/, ::clarifai::api::SingleInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetInput(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::GetInputRequest,::clarifai::api::SingleInputResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListInputs() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::ListInputsRequest, ::clarifai::api::MultiInputResponse>(std::bind(&WithStreamedUnaryMethod_ListInputs<BaseClass>::StreamedListInputs, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListInputs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::ListInputsRequest,::clarifai::api::MultiInputResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostInputs() {
      ::grpc::Service::MarkMethodStreamed(29,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostInputsRequest, ::clarifai::api::MultiInputResponse>(std::bind(&WithStreamedUnaryMethod_PostInputs<BaseClass>::StreamedPostInputs, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostInputs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostInputsRequest,::clarifai::api::MultiInputResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PatchInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PatchInputs() {
      ::grpc::Service::MarkMethodStreamed(30,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PatchInputsRequest, ::clarifai::api::MultiInputResponse>(std::bind(&WithStreamedUnaryMethod_PatchInputs<BaseClass>::StreamedPatchInputs, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PatchInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PatchInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPatchInputs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PatchInputsRequest,::clarifai::api::MultiInputResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteInput() {
      ::grpc::Service::MarkMethodStreamed(31,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::DeleteInputRequest, ::clarifai::api::status::BaseResponse>(std::bind(&WithStreamedUnaryMethod_DeleteInput<BaseClass>::StreamedDeleteInput, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteInput(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteInputRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteInput(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::DeleteInputRequest,::clarifai::api::status::BaseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteInputs() {
      ::grpc::Service::MarkMethodStreamed(32,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::DeleteInputsRequest, ::clarifai::api::status::BaseResponse>(std::bind(&WithStreamedUnaryMethod_DeleteInputs<BaseClass>::StreamedDeleteInputs, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteInputsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteInputs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::DeleteInputsRequest,::clarifai::api::status::BaseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostInputsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostInputsSearches() {
      ::grpc::Service::MarkMethodStreamed(33,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostInputsSearchesRequest, ::clarifai::api::MultiSearchResponse>(std::bind(&WithStreamedUnaryMethod_PostInputsSearches<BaseClass>::StreamedPostInputsSearches, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostInputsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostInputsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostInputsSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostInputsSearches(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostInputsSearchesRequest,::clarifai::api::MultiSearchResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostModelOutputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostModelOutputs() {
      ::grpc::Service::MarkMethodStreamed(34,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostModelOutputsRequest, ::clarifai::api::MultiOutputResponse>(std::bind(&WithStreamedUnaryMethod_PostModelOutputs<BaseClass>::StreamedPostModelOutputs, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostModelOutputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostModelOutputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelOutputsRequest* /*request*/, ::clarifai::api::MultiOutputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostModelOutputs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostModelOutputsRequest,::clarifai::api::MultiOutputResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetModelType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetModelType() {
      ::grpc::Service::MarkMethodStreamed(35,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::GetModelTypeRequest, ::clarifai::api::SingleModelTypeResponse>(std::bind(&WithStreamedUnaryMethod_GetModelType<BaseClass>::StreamedGetModelType, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetModelType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetModelType(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelTypeRequest* /*request*/, ::clarifai::api::SingleModelTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetModelType(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::GetModelTypeRequest,::clarifai::api::SingleModelTypeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListModelTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListModelTypes() {
      ::grpc::Service::MarkMethodStreamed(36,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::ListModelTypesRequest, ::clarifai::api::MultiModelTypeResponse>(std::bind(&WithStreamedUnaryMethod_ListModelTypes<BaseClass>::StreamedListModelTypes, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListModelTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListModelTypes(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListModelTypesRequest* /*request*/, ::clarifai::api::MultiModelTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListModelTypes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::ListModelTypesRequest,::clarifai::api::MultiModelTypeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetModel() {
      ::grpc::Service::MarkMethodStreamed(37,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::GetModelRequest, ::clarifai::api::SingleModelResponse>(std::bind(&WithStreamedUnaryMethod_GetModel<BaseClass>::StreamedGetModel, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetModel(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetModel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::GetModelRequest,::clarifai::api::SingleModelResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetModelOutputInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetModelOutputInfo() {
      ::grpc::Service::MarkMethodStreamed(38,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::GetModelRequest, ::clarifai::api::SingleModelResponse>(std::bind(&WithStreamedUnaryMethod_GetModelOutputInfo<BaseClass>::StreamedGetModelOutputInfo, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetModelOutputInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetModelOutputInfo(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetModelOutputInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::GetModelRequest,::clarifai::api::SingleModelResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListModels() {
      ::grpc::Service::MarkMethodStreamed(39,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::ListModelsRequest, ::clarifai::api::MultiModelResponse>(std::bind(&WithStreamedUnaryMethod_ListModels<BaseClass>::StreamedListModels, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListModels(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListModelsRequest* /*request*/, ::clarifai::api::MultiModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListModels(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::ListModelsRequest,::clarifai::api::MultiModelResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostModelsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostModelsSearches() {
      ::grpc::Service::MarkMethodStreamed(40,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostModelsSearchesRequest, ::clarifai::api::MultiModelResponse>(std::bind(&WithStreamedUnaryMethod_PostModelsSearches<BaseClass>::StreamedPostModelsSearches, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostModelsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostModelsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelsSearchesRequest* /*request*/, ::clarifai::api::MultiModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostModelsSearches(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostModelsSearchesRequest,::clarifai::api::MultiModelResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostModels() {
      ::grpc::Service::MarkMethodStreamed(41,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostModelsRequest, ::clarifai::api::SingleModelResponse>(std::bind(&WithStreamedUnaryMethod_PostModels<BaseClass>::StreamedPostModels, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostModels(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelsRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostModels(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostModelsRequest,::clarifai::api::SingleModelResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PatchModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PatchModels() {
      ::grpc::Service::MarkMethodStreamed(42,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PatchModelsRequest, ::clarifai::api::MultiModelResponse>(std::bind(&WithStreamedUnaryMethod_PatchModels<BaseClass>::StreamedPatchModels, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PatchModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PatchModels(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchModelsRequest* /*request*/, ::clarifai::api::MultiModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPatchModels(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PatchModelsRequest,::clarifai::api::MultiModelResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteModel() {
      ::grpc::Service::MarkMethodStreamed(43,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::DeleteModelRequest, ::clarifai::api::status::BaseResponse>(std::bind(&WithStreamedUnaryMethod_DeleteModel<BaseClass>::StreamedDeleteModel, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteModel(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteModelRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteModel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::DeleteModelRequest,::clarifai::api::status::BaseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteModels() {
      ::grpc::Service::MarkMethodStreamed(44,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::DeleteModelsRequest, ::clarifai::api::status::BaseResponse>(std::bind(&WithStreamedUnaryMethod_DeleteModels<BaseClass>::StreamedDeleteModels, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteModels(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteModelsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteModels(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::DeleteModelsRequest,::clarifai::api::status::BaseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListModelInputs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListModelInputs() {
      ::grpc::Service::MarkMethodStreamed(45,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::ListModelInputsRequest, ::clarifai::api::MultiInputResponse>(std::bind(&WithStreamedUnaryMethod_ListModelInputs<BaseClass>::StreamedListModelInputs, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListModelInputs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListModelInputs(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListModelInputsRequest* /*request*/, ::clarifai::api::MultiInputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListModelInputs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::ListModelInputsRequest,::clarifai::api::MultiInputResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetModelVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetModelVersion() {
      ::grpc::Service::MarkMethodStreamed(46,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::GetModelVersionRequest, ::clarifai::api::SingleModelVersionResponse>(std::bind(&WithStreamedUnaryMethod_GetModelVersion<BaseClass>::StreamedGetModelVersion, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetModelVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetModelVersion(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelVersionRequest* /*request*/, ::clarifai::api::SingleModelVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetModelVersion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::GetModelVersionRequest,::clarifai::api::SingleModelVersionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListModelVersions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListModelVersions() {
      ::grpc::Service::MarkMethodStreamed(47,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::ListModelVersionsRequest, ::clarifai::api::MultiModelVersionResponse>(std::bind(&WithStreamedUnaryMethod_ListModelVersions<BaseClass>::StreamedListModelVersions, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListModelVersions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListModelVersions(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListModelVersionsRequest* /*request*/, ::clarifai::api::MultiModelVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListModelVersions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::ListModelVersionsRequest,::clarifai::api::MultiModelVersionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostModelVersions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostModelVersions() {
      ::grpc::Service::MarkMethodStreamed(48,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostModelVersionsRequest, ::clarifai::api::SingleModelResponse>(std::bind(&WithStreamedUnaryMethod_PostModelVersions<BaseClass>::StreamedPostModelVersions, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostModelVersions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostModelVersions(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelVersionsRequest* /*request*/, ::clarifai::api::SingleModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostModelVersions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostModelVersionsRequest,::clarifai::api::SingleModelResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteModelVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteModelVersion() {
      ::grpc::Service::MarkMethodStreamed(49,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::DeleteModelVersionRequest, ::clarifai::api::status::BaseResponse>(std::bind(&WithStreamedUnaryMethod_DeleteModelVersion<BaseClass>::StreamedDeleteModelVersion, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteModelVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteModelVersion(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteModelVersionRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteModelVersion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::DeleteModelVersionRequest,::clarifai::api::status::BaseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetModelVersionMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetModelVersionMetrics() {
      ::grpc::Service::MarkMethodStreamed(50,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::GetModelVersionMetricsRequest, ::clarifai::api::SingleModelVersionResponse>(std::bind(&WithStreamedUnaryMethod_GetModelVersionMetrics<BaseClass>::StreamedGetModelVersionMetrics, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetModelVersionMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetModelVersionMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetModelVersionMetricsRequest* /*request*/, ::clarifai::api::SingleModelVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetModelVersionMetrics(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::GetModelVersionMetricsRequest,::clarifai::api::SingleModelVersionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostModelVersionMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostModelVersionMetrics() {
      ::grpc::Service::MarkMethodStreamed(51,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostModelVersionMetricsRequest, ::clarifai::api::SingleModelVersionResponse>(std::bind(&WithStreamedUnaryMethod_PostModelVersionMetrics<BaseClass>::StreamedPostModelVersionMetrics, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostModelVersionMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostModelVersionMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostModelVersionMetricsRequest* /*request*/, ::clarifai::api::SingleModelVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostModelVersionMetrics(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostModelVersionMetricsRequest,::clarifai::api::SingleModelVersionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetWorkflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetWorkflow() {
      ::grpc::Service::MarkMethodStreamed(52,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::GetWorkflowRequest, ::clarifai::api::SingleWorkflowResponse>(std::bind(&WithStreamedUnaryMethod_GetWorkflow<BaseClass>::StreamedGetWorkflow, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetWorkflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetWorkflow(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetWorkflowRequest* /*request*/, ::clarifai::api::SingleWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetWorkflow(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::GetWorkflowRequest,::clarifai::api::SingleWorkflowResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListWorkflows() {
      ::grpc::Service::MarkMethodStreamed(53,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::ListWorkflowsRequest, ::clarifai::api::MultiWorkflowResponse>(std::bind(&WithStreamedUnaryMethod_ListWorkflows<BaseClass>::StreamedListWorkflows, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListWorkflows(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListWorkflowsRequest* /*request*/, ::clarifai::api::MultiWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListWorkflows(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::ListWorkflowsRequest,::clarifai::api::MultiWorkflowResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostWorkflows() {
      ::grpc::Service::MarkMethodStreamed(54,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostWorkflowsRequest, ::clarifai::api::MultiWorkflowResponse>(std::bind(&WithStreamedUnaryMethod_PostWorkflows<BaseClass>::StreamedPostWorkflows, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostWorkflows(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostWorkflowsRequest* /*request*/, ::clarifai::api::MultiWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostWorkflows(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostWorkflowsRequest,::clarifai::api::MultiWorkflowResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PatchWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PatchWorkflows() {
      ::grpc::Service::MarkMethodStreamed(55,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PatchWorkflowsRequest, ::clarifai::api::MultiWorkflowResponse>(std::bind(&WithStreamedUnaryMethod_PatchWorkflows<BaseClass>::StreamedPatchWorkflows, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PatchWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PatchWorkflows(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchWorkflowsRequest* /*request*/, ::clarifai::api::MultiWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPatchWorkflows(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PatchWorkflowsRequest,::clarifai::api::MultiWorkflowResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteWorkflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteWorkflow() {
      ::grpc::Service::MarkMethodStreamed(56,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::DeleteWorkflowRequest, ::clarifai::api::status::BaseResponse>(std::bind(&WithStreamedUnaryMethod_DeleteWorkflow<BaseClass>::StreamedDeleteWorkflow, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteWorkflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteWorkflow(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteWorkflowRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteWorkflow(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::DeleteWorkflowRequest,::clarifai::api::status::BaseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteWorkflows : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteWorkflows() {
      ::grpc::Service::MarkMethodStreamed(57,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::DeleteWorkflowsRequest, ::clarifai::api::status::BaseResponse>(std::bind(&WithStreamedUnaryMethod_DeleteWorkflows<BaseClass>::StreamedDeleteWorkflows, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteWorkflows() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteWorkflows(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteWorkflowsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteWorkflows(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::DeleteWorkflowsRequest,::clarifai::api::status::BaseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostWorkflowResults : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostWorkflowResults() {
      ::grpc::Service::MarkMethodStreamed(58,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostWorkflowResultsRequest, ::clarifai::api::PostWorkflowResultsResponse>(std::bind(&WithStreamedUnaryMethod_PostWorkflowResults<BaseClass>::StreamedPostWorkflowResults, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostWorkflowResults() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostWorkflowResults(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostWorkflowResultsRequest* /*request*/, ::clarifai::api::PostWorkflowResultsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostWorkflowResults(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostWorkflowResultsRequest,::clarifai::api::PostWorkflowResultsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostWorkflowResultsSimilarity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostWorkflowResultsSimilarity() {
      ::grpc::Service::MarkMethodStreamed(59,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostWorkflowResultsSimilarityRequest, ::clarifai::api::PostWorkflowResultsSimilarityResponse>(std::bind(&WithStreamedUnaryMethod_PostWorkflowResultsSimilarity<BaseClass>::StreamedPostWorkflowResultsSimilarity, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostWorkflowResultsSimilarity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostWorkflowResultsSimilarity(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostWorkflowResultsSimilarityRequest* /*request*/, ::clarifai::api::PostWorkflowResultsSimilarityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostWorkflowResultsSimilarity(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostWorkflowResultsSimilarityRequest,::clarifai::api::PostWorkflowResultsSimilarityResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetKey() {
      ::grpc::Service::MarkMethodStreamed(60,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::GetKeyRequest, ::clarifai::api::SingleKeyResponse>(std::bind(&WithStreamedUnaryMethod_GetKey<BaseClass>::StreamedGetKey, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetKey(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetKeyRequest* /*request*/, ::clarifai::api::SingleKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetKey(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::GetKeyRequest,::clarifai::api::SingleKeyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListKeys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListKeys() {
      ::grpc::Service::MarkMethodStreamed(61,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::ListKeysRequest, ::clarifai::api::MultiKeyResponse>(std::bind(&WithStreamedUnaryMethod_ListKeys<BaseClass>::StreamedListKeys, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListKeys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListKeys(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListKeys(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::ListKeysRequest,::clarifai::api::MultiKeyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListAppKeys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListAppKeys() {
      ::grpc::Service::MarkMethodStreamed(62,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::ListAppKeysRequest, ::clarifai::api::MultiKeyResponse>(std::bind(&WithStreamedUnaryMethod_ListAppKeys<BaseClass>::StreamedListAppKeys, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListAppKeys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListAppKeys(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAppKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListAppKeys(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::ListAppKeysRequest,::clarifai::api::MultiKeyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteKey() {
      ::grpc::Service::MarkMethodStreamed(63,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::DeleteKeyRequest, ::clarifai::api::status::BaseResponse>(std::bind(&WithStreamedUnaryMethod_DeleteKey<BaseClass>::StreamedDeleteKey, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteKey(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteKeyRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteKey(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::DeleteKeyRequest,::clarifai::api::status::BaseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostKeys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostKeys() {
      ::grpc::Service::MarkMethodStreamed(64,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostKeysRequest, ::clarifai::api::MultiKeyResponse>(std::bind(&WithStreamedUnaryMethod_PostKeys<BaseClass>::StreamedPostKeys, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostKeys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostKeys(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostKeys(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostKeysRequest,::clarifai::api::MultiKeyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PatchKeys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PatchKeys() {
      ::grpc::Service::MarkMethodStreamed(65,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PatchKeysRequest, ::clarifai::api::MultiKeyResponse>(std::bind(&WithStreamedUnaryMethod_PatchKeys<BaseClass>::StreamedPatchKeys, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PatchKeys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PatchKeys(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchKeysRequest* /*request*/, ::clarifai::api::MultiKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPatchKeys(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PatchKeysRequest,::clarifai::api::MultiKeyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MyScopes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MyScopes() {
      ::grpc::Service::MarkMethodStreamed(66,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::MyScopesRequest, ::clarifai::api::MultiScopeResponse>(std::bind(&WithStreamedUnaryMethod_MyScopes<BaseClass>::StreamedMyScopes, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_MyScopes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MyScopes(::grpc::ServerContext* /*context*/, const ::clarifai::api::MyScopesRequest* /*request*/, ::clarifai::api::MultiScopeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMyScopes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::MyScopesRequest,::clarifai::api::MultiScopeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListScopes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListScopes() {
      ::grpc::Service::MarkMethodStreamed(67,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::ListScopesRequest, ::clarifai::api::MultiScopeDepsResponse>(std::bind(&WithStreamedUnaryMethod_ListScopes<BaseClass>::StreamedListScopes, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListScopes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListScopes(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListScopesRequest* /*request*/, ::clarifai::api::MultiScopeDepsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListScopes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::ListScopesRequest,::clarifai::api::MultiScopeDepsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetApp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetApp() {
      ::grpc::Service::MarkMethodStreamed(68,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::GetAppRequest, ::clarifai::api::SingleAppResponse>(std::bind(&WithStreamedUnaryMethod_GetApp<BaseClass>::StreamedGetApp, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetApp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetApp(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetAppRequest* /*request*/, ::clarifai::api::SingleAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetApp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::GetAppRequest,::clarifai::api::SingleAppResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListApps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListApps() {
      ::grpc::Service::MarkMethodStreamed(69,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::ListAppsRequest, ::clarifai::api::MultiAppResponse>(std::bind(&WithStreamedUnaryMethod_ListApps<BaseClass>::StreamedListApps, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListApps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListApps(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAppsRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListApps(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::ListAppsRequest,::clarifai::api::MultiAppResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteApp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteApp() {
      ::grpc::Service::MarkMethodStreamed(70,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::DeleteAppRequest, ::clarifai::api::status::BaseResponse>(std::bind(&WithStreamedUnaryMethod_DeleteApp<BaseClass>::StreamedDeleteApp, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteApp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteApp(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteAppRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteApp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::DeleteAppRequest,::clarifai::api::status::BaseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostApps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostApps() {
      ::grpc::Service::MarkMethodStreamed(71,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostAppsRequest, ::clarifai::api::MultiAppResponse>(std::bind(&WithStreamedUnaryMethod_PostApps<BaseClass>::StreamedPostApps, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostApps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostApps(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAppsRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostApps(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostAppsRequest,::clarifai::api::MultiAppResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PatchApps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PatchApps() {
      ::grpc::Service::MarkMethodStreamed(72,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PatchAppsRequest, ::clarifai::api::MultiAppResponse>(std::bind(&WithStreamedUnaryMethod_PatchApps<BaseClass>::StreamedPatchApps, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PatchApps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PatchApps(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchAppsRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPatchApps(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PatchAppsRequest,::clarifai::api::MultiAppResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostAppsSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostAppsSearches() {
      ::grpc::Service::MarkMethodStreamed(73,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostAppsSearchesRequest, ::clarifai::api::MultiAppResponse>(std::bind(&WithStreamedUnaryMethod_PostAppsSearches<BaseClass>::StreamedPostAppsSearches, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostAppsSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostAppsSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAppsSearchesRequest* /*request*/, ::clarifai::api::MultiAppResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostAppsSearches(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostAppsSearchesRequest,::clarifai::api::MultiAppResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostValidatePassword : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostValidatePassword() {
      ::grpc::Service::MarkMethodStreamed(74,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostValidatePasswordRequest, ::clarifai::api::SinglePasswordValidationResponse>(std::bind(&WithStreamedUnaryMethod_PostValidatePassword<BaseClass>::StreamedPostValidatePassword, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostValidatePassword() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostValidatePassword(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostValidatePasswordRequest* /*request*/, ::clarifai::api::SinglePasswordValidationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostValidatePassword(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostValidatePasswordRequest,::clarifai::api::SinglePasswordValidationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSearch() {
      ::grpc::Service::MarkMethodStreamed(75,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::GetSearchRequest, ::clarifai::api::SingleSearchResponse>(std::bind(&WithStreamedUnaryMethod_GetSearch<BaseClass>::StreamedGetSearch, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSearch(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetSearchRequest* /*request*/, ::clarifai::api::SingleSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSearch(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::GetSearchRequest,::clarifai::api::SingleSearchResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListSearches() {
      ::grpc::Service::MarkMethodStreamed(76,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::ListSearchesRequest, ::clarifai::api::MultiSearchResponse>(std::bind(&WithStreamedUnaryMethod_ListSearches<BaseClass>::StreamedListSearches, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListSearches(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::ListSearchesRequest,::clarifai::api::MultiSearchResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostSearches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostSearches() {
      ::grpc::Service::MarkMethodStreamed(77,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostSearchesRequest, ::clarifai::api::MultiSearchResponse>(std::bind(&WithStreamedUnaryMethod_PostSearches<BaseClass>::StreamedPostSearches, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostSearches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostSearches(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostSearchesRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostSearches(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostSearchesRequest,::clarifai::api::MultiSearchResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostSearchesByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostSearchesByID() {
      ::grpc::Service::MarkMethodStreamed(78,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostSearchesByIDRequest, ::clarifai::api::MultiSearchResponse>(std::bind(&WithStreamedUnaryMethod_PostSearchesByID<BaseClass>::StreamedPostSearchesByID, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostSearchesByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostSearchesByID(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostSearchesByIDRequest* /*request*/, ::clarifai::api::MultiSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostSearchesByID(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostSearchesByIDRequest,::clarifai::api::MultiSearchResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostAnnotationSearchMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostAnnotationSearchMetrics() {
      ::grpc::Service::MarkMethodStreamed(79,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostAnnotationSearchMetricsRequest, ::clarifai::api::MultiAnnotationSearchMetricsResponse>(std::bind(&WithStreamedUnaryMethod_PostAnnotationSearchMetrics<BaseClass>::StreamedPostAnnotationSearchMetrics, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostAnnotationSearchMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostAnnotationSearchMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::MultiAnnotationSearchMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostAnnotationSearchMetrics(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostAnnotationSearchMetricsRequest,::clarifai::api::MultiAnnotationSearchMetricsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAnnotationSearchMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAnnotationSearchMetrics() {
      ::grpc::Service::MarkMethodStreamed(80,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::GetAnnotationSearchMetricsRequest, ::clarifai::api::MultiAnnotationSearchMetricsResponse>(std::bind(&WithStreamedUnaryMethod_GetAnnotationSearchMetrics<BaseClass>::StreamedGetAnnotationSearchMetrics, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetAnnotationSearchMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAnnotationSearchMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::MultiAnnotationSearchMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAnnotationSearchMetrics(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::GetAnnotationSearchMetricsRequest,::clarifai::api::MultiAnnotationSearchMetricsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListAnnotationSearchMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListAnnotationSearchMetrics() {
      ::grpc::Service::MarkMethodStreamed(81,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::ListAnnotationSearchMetricsRequest, ::clarifai::api::MultiAnnotationSearchMetricsResponse>(std::bind(&WithStreamedUnaryMethod_ListAnnotationSearchMetrics<BaseClass>::StreamedListAnnotationSearchMetrics, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListAnnotationSearchMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListAnnotationSearchMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::MultiAnnotationSearchMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListAnnotationSearchMetrics(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::ListAnnotationSearchMetricsRequest,::clarifai::api::MultiAnnotationSearchMetricsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteAnnotationSearchMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteAnnotationSearchMetrics() {
      ::grpc::Service::MarkMethodStreamed(82,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::DeleteAnnotationSearchMetricsRequest, ::clarifai::api::status::BaseResponse>(std::bind(&WithStreamedUnaryMethod_DeleteAnnotationSearchMetrics<BaseClass>::StreamedDeleteAnnotationSearchMetrics, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteAnnotationSearchMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteAnnotationSearchMetrics(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteAnnotationSearchMetricsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteAnnotationSearchMetrics(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::DeleteAnnotationSearchMetricsRequest,::clarifai::api::status::BaseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteSearch() {
      ::grpc::Service::MarkMethodStreamed(83,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::DeleteSearchRequest, ::clarifai::api::status::BaseResponse>(std::bind(&WithStreamedUnaryMethod_DeleteSearch<BaseClass>::StreamedDeleteSearch, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteSearch(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteSearchRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteSearch(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::DeleteSearchRequest,::clarifai::api::status::BaseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListStatusCodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListStatusCodes() {
      ::grpc::Service::MarkMethodStreamed(84,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::ListStatusCodesRequest, ::clarifai::api::MultiStatusCodeResponse>(std::bind(&WithStreamedUnaryMethod_ListStatusCodes<BaseClass>::StreamedListStatusCodes, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListStatusCodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListStatusCodes(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListStatusCodesRequest* /*request*/, ::clarifai::api::MultiStatusCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListStatusCodes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::ListStatusCodesRequest,::clarifai::api::MultiStatusCodeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetStatusCode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetStatusCode() {
      ::grpc::Service::MarkMethodStreamed(85,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::GetStatusCodeRequest, ::clarifai::api::SingleStatusCodeResponse>(std::bind(&WithStreamedUnaryMethod_GetStatusCode<BaseClass>::StreamedGetStatusCode, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetStatusCode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetStatusCode(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetStatusCodeRequest* /*request*/, ::clarifai::api::SingleStatusCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetStatusCode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::GetStatusCodeRequest,::clarifai::api::SingleStatusCodeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListCollaborators : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListCollaborators() {
      ::grpc::Service::MarkMethodStreamed(86,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::ListCollaboratorsRequest, ::clarifai::api::MultiCollaboratorsResponse>(std::bind(&WithStreamedUnaryMethod_ListCollaborators<BaseClass>::StreamedListCollaborators, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListCollaborators() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListCollaborators(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListCollaboratorsRequest* /*request*/, ::clarifai::api::MultiCollaboratorsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListCollaborators(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::ListCollaboratorsRequest,::clarifai::api::MultiCollaboratorsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostCollaborators : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostCollaborators() {
      ::grpc::Service::MarkMethodStreamed(87,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostCollaboratorsRequest, ::clarifai::api::MultiCollaboratorsResponse>(std::bind(&WithStreamedUnaryMethod_PostCollaborators<BaseClass>::StreamedPostCollaborators, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostCollaborators() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostCollaborators(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostCollaboratorsRequest* /*request*/, ::clarifai::api::MultiCollaboratorsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostCollaborators(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostCollaboratorsRequest,::clarifai::api::MultiCollaboratorsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PatchCollaborators : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PatchCollaborators() {
      ::grpc::Service::MarkMethodStreamed(88,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PatchCollaboratorsRequest, ::clarifai::api::MultiCollaboratorsResponse>(std::bind(&WithStreamedUnaryMethod_PatchCollaborators<BaseClass>::StreamedPatchCollaborators, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PatchCollaborators() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PatchCollaborators(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchCollaboratorsRequest* /*request*/, ::clarifai::api::MultiCollaboratorsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPatchCollaborators(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PatchCollaboratorsRequest,::clarifai::api::MultiCollaboratorsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteCollaborators : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteCollaborators() {
      ::grpc::Service::MarkMethodStreamed(89,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::DeleteCollaboratorsRequest, ::clarifai::api::status::BaseResponse>(std::bind(&WithStreamedUnaryMethod_DeleteCollaborators<BaseClass>::StreamedDeleteCollaborators, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteCollaborators() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteCollaborators(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteCollaboratorsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteCollaborators(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::DeleteCollaboratorsRequest,::clarifai::api::status::BaseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListCollaborations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListCollaborations() {
      ::grpc::Service::MarkMethodStreamed(90,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::ListCollaborationsRequest, ::clarifai::api::MultiCollaborationsResponse>(std::bind(&WithStreamedUnaryMethod_ListCollaborations<BaseClass>::StreamedListCollaborations, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListCollaborations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListCollaborations(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListCollaborationsRequest* /*request*/, ::clarifai::api::MultiCollaborationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListCollaborations(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::ListCollaborationsRequest,::clarifai::api::MultiCollaborationsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostAppDuplications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostAppDuplications() {
      ::grpc::Service::MarkMethodStreamed(91,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostAppDuplicationsRequest, ::clarifai::api::MultiAppDuplicationsResponse>(std::bind(&WithStreamedUnaryMethod_PostAppDuplications<BaseClass>::StreamedPostAppDuplications, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostAppDuplications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostAppDuplications(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostAppDuplicationsRequest* /*request*/, ::clarifai::api::MultiAppDuplicationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostAppDuplications(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostAppDuplicationsRequest,::clarifai::api::MultiAppDuplicationsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListAppDuplications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListAppDuplications() {
      ::grpc::Service::MarkMethodStreamed(92,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::ListAppDuplicationsRequest, ::clarifai::api::MultiAppDuplicationsResponse>(std::bind(&WithStreamedUnaryMethod_ListAppDuplications<BaseClass>::StreamedListAppDuplications, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListAppDuplications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListAppDuplications(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListAppDuplicationsRequest* /*request*/, ::clarifai::api::MultiAppDuplicationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListAppDuplications(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::ListAppDuplicationsRequest,::clarifai::api::MultiAppDuplicationsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAppDuplication : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAppDuplication() {
      ::grpc::Service::MarkMethodStreamed(93,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::GetAppDuplicationRequest, ::clarifai::api::SingleAppDuplicationResponse>(std::bind(&WithStreamedUnaryMethod_GetAppDuplication<BaseClass>::StreamedGetAppDuplication, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetAppDuplication() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAppDuplication(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetAppDuplicationRequest* /*request*/, ::clarifai::api::SingleAppDuplicationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAppDuplication(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::GetAppDuplicationRequest,::clarifai::api::SingleAppDuplicationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostTasks() {
      ::grpc::Service::MarkMethodStreamed(94,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostTasksRequest, ::clarifai::api::MultiTaskResponse>(std::bind(&WithStreamedUnaryMethod_PostTasks<BaseClass>::StreamedPostTasks, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostTasks(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostTasksRequest* /*request*/, ::clarifai::api::MultiTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostTasks(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostTasksRequest,::clarifai::api::MultiTaskResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTaskAnnotationCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTaskAnnotationCount() {
      ::grpc::Service::MarkMethodStreamed(95,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::GetTaskCountRequest, ::clarifai::api::SingleTaskCountResponse>(std::bind(&WithStreamedUnaryMethod_GetTaskAnnotationCount<BaseClass>::StreamedGetTaskAnnotationCount, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetTaskAnnotationCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTaskAnnotationCount(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetTaskCountRequest* /*request*/, ::clarifai::api::SingleTaskCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTaskAnnotationCount(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::GetTaskCountRequest,::clarifai::api::SingleTaskCountResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTaskInputCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTaskInputCount() {
      ::grpc::Service::MarkMethodStreamed(96,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::GetTaskCountRequest, ::clarifai::api::SingleTaskCountResponse>(std::bind(&WithStreamedUnaryMethod_GetTaskInputCount<BaseClass>::StreamedGetTaskInputCount, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetTaskInputCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTaskInputCount(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetTaskCountRequest* /*request*/, ::clarifai::api::SingleTaskCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTaskInputCount(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::GetTaskCountRequest,::clarifai::api::SingleTaskCountResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTask() {
      ::grpc::Service::MarkMethodStreamed(97,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::GetTaskRequest, ::clarifai::api::SingleTaskResponse>(std::bind(&WithStreamedUnaryMethod_GetTask<BaseClass>::StreamedGetTask, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTask(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetTaskRequest* /*request*/, ::clarifai::api::SingleTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTask(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::GetTaskRequest,::clarifai::api::SingleTaskResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListTasks() {
      ::grpc::Service::MarkMethodStreamed(98,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::ListTasksRequest, ::clarifai::api::MultiTaskResponse>(std::bind(&WithStreamedUnaryMethod_ListTasks<BaseClass>::StreamedListTasks, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListTasks(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListTasksRequest* /*request*/, ::clarifai::api::MultiTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListTasks(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::ListTasksRequest,::clarifai::api::MultiTaskResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PatchTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PatchTasks() {
      ::grpc::Service::MarkMethodStreamed(99,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PatchTasksRequest, ::clarifai::api::MultiTaskResponse>(std::bind(&WithStreamedUnaryMethod_PatchTasks<BaseClass>::StreamedPatchTasks, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PatchTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PatchTasks(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchTasksRequest* /*request*/, ::clarifai::api::MultiTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPatchTasks(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PatchTasksRequest,::clarifai::api::MultiTaskResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteTasks() {
      ::grpc::Service::MarkMethodStreamed(100,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::DeleteTasksRequest, ::clarifai::api::status::BaseResponse>(std::bind(&WithStreamedUnaryMethod_DeleteTasks<BaseClass>::StreamedDeleteTasks, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteTasks(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteTasksRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteTasks(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::DeleteTasksRequest,::clarifai::api::status::BaseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostCollectors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostCollectors() {
      ::grpc::Service::MarkMethodStreamed(101,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostCollectorsRequest, ::clarifai::api::MultiCollectorResponse>(std::bind(&WithStreamedUnaryMethod_PostCollectors<BaseClass>::StreamedPostCollectors, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostCollectors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostCollectors(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostCollectorsRequest* /*request*/, ::clarifai::api::MultiCollectorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostCollectors(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostCollectorsRequest,::clarifai::api::MultiCollectorResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCollector : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCollector() {
      ::grpc::Service::MarkMethodStreamed(102,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::GetCollectorRequest, ::clarifai::api::SingleCollectorResponse>(std::bind(&WithStreamedUnaryMethod_GetCollector<BaseClass>::StreamedGetCollector, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetCollector() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCollector(::grpc::ServerContext* /*context*/, const ::clarifai::api::GetCollectorRequest* /*request*/, ::clarifai::api::SingleCollectorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCollector(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::GetCollectorRequest,::clarifai::api::SingleCollectorResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListCollectors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListCollectors() {
      ::grpc::Service::MarkMethodStreamed(103,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::ListCollectorsRequest, ::clarifai::api::MultiCollectorResponse>(std::bind(&WithStreamedUnaryMethod_ListCollectors<BaseClass>::StreamedListCollectors, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListCollectors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListCollectors(::grpc::ServerContext* /*context*/, const ::clarifai::api::ListCollectorsRequest* /*request*/, ::clarifai::api::MultiCollectorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListCollectors(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::ListCollectorsRequest,::clarifai::api::MultiCollectorResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PatchCollectors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PatchCollectors() {
      ::grpc::Service::MarkMethodStreamed(104,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PatchCollectorsRequest, ::clarifai::api::MultiCollectorResponse>(std::bind(&WithStreamedUnaryMethod_PatchCollectors<BaseClass>::StreamedPatchCollectors, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PatchCollectors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PatchCollectors(::grpc::ServerContext* /*context*/, const ::clarifai::api::PatchCollectorsRequest* /*request*/, ::clarifai::api::MultiCollectorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPatchCollectors(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PatchCollectorsRequest,::clarifai::api::MultiCollectorResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteCollectors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteCollectors() {
      ::grpc::Service::MarkMethodStreamed(105,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::DeleteCollectorsRequest, ::clarifai::api::status::BaseResponse>(std::bind(&WithStreamedUnaryMethod_DeleteCollectors<BaseClass>::StreamedDeleteCollectors, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteCollectors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteCollectors(::grpc::ServerContext* /*context*/, const ::clarifai::api::DeleteCollectorsRequest* /*request*/, ::clarifai::api::status::BaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteCollectors(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::DeleteCollectorsRequest,::clarifai::api::status::BaseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostStatValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostStatValues() {
      ::grpc::Service::MarkMethodStreamed(106,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostStatValuesRequest, ::clarifai::api::MultiStatValueResponse>(std::bind(&WithStreamedUnaryMethod_PostStatValues<BaseClass>::StreamedPostStatValues, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostStatValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostStatValues(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostStatValuesRequest* /*request*/, ::clarifai::api::MultiStatValueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostStatValues(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostStatValuesRequest,::clarifai::api::MultiStatValueResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostStatValuesAggregate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostStatValuesAggregate() {
      ::grpc::Service::MarkMethodStreamed(107,
        new ::grpc::internal::StreamedUnaryHandler< ::clarifai::api::PostStatValuesAggregateRequest, ::clarifai::api::MultiStatValueAggregateResponse>(std::bind(&WithStreamedUnaryMethod_PostStatValuesAggregate<BaseClass>::StreamedPostStatValuesAggregate, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PostStatValuesAggregate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostStatValuesAggregate(::grpc::ServerContext* /*context*/, const ::clarifai::api::PostStatValuesAggregateRequest* /*request*/, ::clarifai::api::MultiStatValueAggregateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostStatValuesAggregate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::clarifai::api::PostStatValuesAggregateRequest,::clarifai::api::MultiStatValueAggregateResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_ListConceptRelations<WithStreamedUnaryMethod_PostConceptRelations<WithStreamedUnaryMethod_DeleteConceptRelations<WithStreamedUnaryMethod_GetConceptCounts<WithStreamedUnaryMethod_GetConcept<WithStreamedUnaryMethod_ListConcepts<WithStreamedUnaryMethod_PostConceptsSearches<WithStreamedUnaryMethod_PostConcepts<WithStreamedUnaryMethod_PatchConcepts<WithStreamedUnaryMethod_GetConceptLanguage<WithStreamedUnaryMethod_ListConceptLanguages<WithStreamedUnaryMethod_PostConceptLanguages<WithStreamedUnaryMethod_PatchConceptLanguages<WithStreamedUnaryMethod_ListKnowledgeGraphs<WithStreamedUnaryMethod_PostKnowledgeGraphs<WithStreamedUnaryMethod_PostConceptMappingJobs<WithStreamedUnaryMethod_GetAnnotation<WithStreamedUnaryMethod_ListAnnotations<WithStreamedUnaryMethod_PostAnnotations<WithStreamedUnaryMethod_PatchAnnotations<WithStreamedUnaryMethod_PatchAnnotationsStatus<WithStreamedUnaryMethod_DeleteAnnotation<WithStreamedUnaryMethod_DeleteAnnotations<WithStreamedUnaryMethod_PostAnnotationsSearches<WithStreamedUnaryMethod_GetInputCount<WithStreamedUnaryMethod_StreamInputs<WithStreamedUnaryMethod_GetInputSamples<WithStreamedUnaryMethod_GetInput<WithStreamedUnaryMethod_ListInputs<WithStreamedUnaryMethod_PostInputs<WithStreamedUnaryMethod_PatchInputs<WithStreamedUnaryMethod_DeleteInput<WithStreamedUnaryMethod_DeleteInputs<WithStreamedUnaryMethod_PostInputsSearches<WithStreamedUnaryMethod_PostModelOutputs<WithStreamedUnaryMethod_GetModelType<WithStreamedUnaryMethod_ListModelTypes<WithStreamedUnaryMethod_GetModel<WithStreamedUnaryMethod_GetModelOutputInfo<WithStreamedUnaryMethod_ListModels<WithStreamedUnaryMethod_PostModelsSearches<WithStreamedUnaryMethod_PostModels<WithStreamedUnaryMethod_PatchModels<WithStreamedUnaryMethod_DeleteModel<WithStreamedUnaryMethod_DeleteModels<WithStreamedUnaryMethod_ListModelInputs<WithStreamedUnaryMethod_GetModelVersion<WithStreamedUnaryMethod_ListModelVersions<WithStreamedUnaryMethod_PostModelVersions<WithStreamedUnaryMethod_DeleteModelVersion<WithStreamedUnaryMethod_GetModelVersionMetrics<WithStreamedUnaryMethod_PostModelVersionMetrics<WithStreamedUnaryMethod_GetWorkflow<WithStreamedUnaryMethod_ListWorkflows<WithStreamedUnaryMethod_PostWorkflows<WithStreamedUnaryMethod_PatchWorkflows<WithStreamedUnaryMethod_DeleteWorkflow<WithStreamedUnaryMethod_DeleteWorkflows<WithStreamedUnaryMethod_PostWorkflowResults<WithStreamedUnaryMethod_PostWorkflowResultsSimilarity<WithStreamedUnaryMethod_GetKey<WithStreamedUnaryMethod_ListKeys<WithStreamedUnaryMethod_ListAppKeys<WithStreamedUnaryMethod_DeleteKey<WithStreamedUnaryMethod_PostKeys<WithStreamedUnaryMethod_PatchKeys<WithStreamedUnaryMethod_MyScopes<WithStreamedUnaryMethod_ListScopes<WithStreamedUnaryMethod_GetApp<WithStreamedUnaryMethod_ListApps<WithStreamedUnaryMethod_DeleteApp<WithStreamedUnaryMethod_PostApps<WithStreamedUnaryMethod_PatchApps<WithStreamedUnaryMethod_PostAppsSearches<WithStreamedUnaryMethod_PostValidatePassword<WithStreamedUnaryMethod_GetSearch<WithStreamedUnaryMethod_ListSearches<WithStreamedUnaryMethod_PostSearches<WithStreamedUnaryMethod_PostSearchesByID<WithStreamedUnaryMethod_PostAnnotationSearchMetrics<WithStreamedUnaryMethod_GetAnnotationSearchMetrics<WithStreamedUnaryMethod_ListAnnotationSearchMetrics<WithStreamedUnaryMethod_DeleteAnnotationSearchMetrics<WithStreamedUnaryMethod_DeleteSearch<WithStreamedUnaryMethod_ListStatusCodes<WithStreamedUnaryMethod_GetStatusCode<WithStreamedUnaryMethod_ListCollaborators<WithStreamedUnaryMethod_PostCollaborators<WithStreamedUnaryMethod_PatchCollaborators<WithStreamedUnaryMethod_DeleteCollaborators<WithStreamedUnaryMethod_ListCollaborations<WithStreamedUnaryMethod_PostAppDuplications<WithStreamedUnaryMethod_ListAppDuplications<WithStreamedUnaryMethod_GetAppDuplication<WithStreamedUnaryMethod_PostTasks<WithStreamedUnaryMethod_GetTaskAnnotationCount<WithStreamedUnaryMethod_GetTaskInputCount<WithStreamedUnaryMethod_GetTask<WithStreamedUnaryMethod_ListTasks<WithStreamedUnaryMethod_PatchTasks<WithStreamedUnaryMethod_DeleteTasks<WithStreamedUnaryMethod_PostCollectors<WithStreamedUnaryMethod_GetCollector<WithStreamedUnaryMethod_ListCollectors<WithStreamedUnaryMethod_PatchCollectors<WithStreamedUnaryMethod_DeleteCollectors<WithStreamedUnaryMethod_PostStatValues<WithStreamedUnaryMethod_PostStatValuesAggregate<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_ListConceptRelations<WithStreamedUnaryMethod_PostConceptRelations<WithStreamedUnaryMethod_DeleteConceptRelations<WithStreamedUnaryMethod_GetConceptCounts<WithStreamedUnaryMethod_GetConcept<WithStreamedUnaryMethod_ListConcepts<WithStreamedUnaryMethod_PostConceptsSearches<WithStreamedUnaryMethod_PostConcepts<WithStreamedUnaryMethod_PatchConcepts<WithStreamedUnaryMethod_GetConceptLanguage<WithStreamedUnaryMethod_ListConceptLanguages<WithStreamedUnaryMethod_PostConceptLanguages<WithStreamedUnaryMethod_PatchConceptLanguages<WithStreamedUnaryMethod_ListKnowledgeGraphs<WithStreamedUnaryMethod_PostKnowledgeGraphs<WithStreamedUnaryMethod_PostConceptMappingJobs<WithStreamedUnaryMethod_GetAnnotation<WithStreamedUnaryMethod_ListAnnotations<WithStreamedUnaryMethod_PostAnnotations<WithStreamedUnaryMethod_PatchAnnotations<WithStreamedUnaryMethod_PatchAnnotationsStatus<WithStreamedUnaryMethod_DeleteAnnotation<WithStreamedUnaryMethod_DeleteAnnotations<WithStreamedUnaryMethod_PostAnnotationsSearches<WithStreamedUnaryMethod_GetInputCount<WithStreamedUnaryMethod_StreamInputs<WithStreamedUnaryMethod_GetInputSamples<WithStreamedUnaryMethod_GetInput<WithStreamedUnaryMethod_ListInputs<WithStreamedUnaryMethod_PostInputs<WithStreamedUnaryMethod_PatchInputs<WithStreamedUnaryMethod_DeleteInput<WithStreamedUnaryMethod_DeleteInputs<WithStreamedUnaryMethod_PostInputsSearches<WithStreamedUnaryMethod_PostModelOutputs<WithStreamedUnaryMethod_GetModelType<WithStreamedUnaryMethod_ListModelTypes<WithStreamedUnaryMethod_GetModel<WithStreamedUnaryMethod_GetModelOutputInfo<WithStreamedUnaryMethod_ListModels<WithStreamedUnaryMethod_PostModelsSearches<WithStreamedUnaryMethod_PostModels<WithStreamedUnaryMethod_PatchModels<WithStreamedUnaryMethod_DeleteModel<WithStreamedUnaryMethod_DeleteModels<WithStreamedUnaryMethod_ListModelInputs<WithStreamedUnaryMethod_GetModelVersion<WithStreamedUnaryMethod_ListModelVersions<WithStreamedUnaryMethod_PostModelVersions<WithStreamedUnaryMethod_DeleteModelVersion<WithStreamedUnaryMethod_GetModelVersionMetrics<WithStreamedUnaryMethod_PostModelVersionMetrics<WithStreamedUnaryMethod_GetWorkflow<WithStreamedUnaryMethod_ListWorkflows<WithStreamedUnaryMethod_PostWorkflows<WithStreamedUnaryMethod_PatchWorkflows<WithStreamedUnaryMethod_DeleteWorkflow<WithStreamedUnaryMethod_DeleteWorkflows<WithStreamedUnaryMethod_PostWorkflowResults<WithStreamedUnaryMethod_PostWorkflowResultsSimilarity<WithStreamedUnaryMethod_GetKey<WithStreamedUnaryMethod_ListKeys<WithStreamedUnaryMethod_ListAppKeys<WithStreamedUnaryMethod_DeleteKey<WithStreamedUnaryMethod_PostKeys<WithStreamedUnaryMethod_PatchKeys<WithStreamedUnaryMethod_MyScopes<WithStreamedUnaryMethod_ListScopes<WithStreamedUnaryMethod_GetApp<WithStreamedUnaryMethod_ListApps<WithStreamedUnaryMethod_DeleteApp<WithStreamedUnaryMethod_PostApps<WithStreamedUnaryMethod_PatchApps<WithStreamedUnaryMethod_PostAppsSearches<WithStreamedUnaryMethod_PostValidatePassword<WithStreamedUnaryMethod_GetSearch<WithStreamedUnaryMethod_ListSearches<WithStreamedUnaryMethod_PostSearches<WithStreamedUnaryMethod_PostSearchesByID<WithStreamedUnaryMethod_PostAnnotationSearchMetrics<WithStreamedUnaryMethod_GetAnnotationSearchMetrics<WithStreamedUnaryMethod_ListAnnotationSearchMetrics<WithStreamedUnaryMethod_DeleteAnnotationSearchMetrics<WithStreamedUnaryMethod_DeleteSearch<WithStreamedUnaryMethod_ListStatusCodes<WithStreamedUnaryMethod_GetStatusCode<WithStreamedUnaryMethod_ListCollaborators<WithStreamedUnaryMethod_PostCollaborators<WithStreamedUnaryMethod_PatchCollaborators<WithStreamedUnaryMethod_DeleteCollaborators<WithStreamedUnaryMethod_ListCollaborations<WithStreamedUnaryMethod_PostAppDuplications<WithStreamedUnaryMethod_ListAppDuplications<WithStreamedUnaryMethod_GetAppDuplication<WithStreamedUnaryMethod_PostTasks<WithStreamedUnaryMethod_GetTaskAnnotationCount<WithStreamedUnaryMethod_GetTaskInputCount<WithStreamedUnaryMethod_GetTask<WithStreamedUnaryMethod_ListTasks<WithStreamedUnaryMethod_PatchTasks<WithStreamedUnaryMethod_DeleteTasks<WithStreamedUnaryMethod_PostCollectors<WithStreamedUnaryMethod_GetCollector<WithStreamedUnaryMethod_ListCollectors<WithStreamedUnaryMethod_PatchCollectors<WithStreamedUnaryMethod_DeleteCollectors<WithStreamedUnaryMethod_PostStatValues<WithStreamedUnaryMethod_PostStatValuesAggregate<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace api
}  // namespace clarifai


#endif  // GRPC_proto_2fclarifai_2fapi_2fservice_2eproto__INCLUDED
