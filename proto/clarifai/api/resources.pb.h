// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/clarifai/api/resources.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2fclarifai_2fapi_2fresources_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_proto_2fclarifai_2fapi_2fresources_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "proto/clarifai/api/status/status.pb.h"
#include "proto/clarifai/api/utils/extensions.pb.h"
#include "proto/clarifai/api/utils/matrix.pb.h"
#include "proto/clarifai/auth/util/extension.pb.h"
#include <google/protobuf/struct.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2fclarifai_2fapi_2fresources_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_proto_2fclarifai_2fapi_2fresources_2eproto;
namespace clarifai {
namespace api {
class APIPostModelOutputsCollectorSource;
struct APIPostModelOutputsCollectorSourceDefaultTypeInternal;
extern APIPostModelOutputsCollectorSourceDefaultTypeInternal _APIPostModelOutputsCollectorSource_default_instance_;
class AWSCreds;
struct AWSCredsDefaultTypeInternal;
extern AWSCredsDefaultTypeInternal _AWSCreds_default_instance_;
class AddConcepts;
struct AddConceptsDefaultTypeInternal;
extern AddConceptsDefaultTypeInternal _AddConcepts_default_instance_;
class AddMetadata;
struct AddMetadataDefaultTypeInternal;
extern AddMetadataDefaultTypeInternal _AddMetadata_default_instance_;
class AiAssistParameters;
struct AiAssistParametersDefaultTypeInternal;
extern AiAssistParametersDefaultTypeInternal _AiAssistParameters_default_instance_;
class And;
struct AndDefaultTypeInternal;
extern AndDefaultTypeInternal _And_default_instance_;
class Annotation;
struct AnnotationDefaultTypeInternal;
extern AnnotationDefaultTypeInternal _Annotation_default_instance_;
class AnnotationFilter;
struct AnnotationFilterDefaultTypeInternal;
extern AnnotationFilterDefaultTypeInternal _AnnotationFilter_default_instance_;
class AnnotationFilterConfig;
struct AnnotationFilterConfigDefaultTypeInternal;
extern AnnotationFilterConfigDefaultTypeInternal _AnnotationFilterConfig_default_instance_;
class AnnotationSearchMetrics;
struct AnnotationSearchMetricsDefaultTypeInternal;
extern AnnotationSearchMetricsDefaultTypeInternal _AnnotationSearchMetrics_default_instance_;
class App;
struct AppDefaultTypeInternal;
extern AppDefaultTypeInternal _App_default_instance_;
class AppCopyProgress;
struct AppCopyProgressDefaultTypeInternal;
extern AppCopyProgressDefaultTypeInternal _AppCopyProgress_default_instance_;
class AppDuplication;
struct AppDuplicationDefaultTypeInternal;
extern AppDuplicationDefaultTypeInternal _AppDuplication_default_instance_;
class AppDuplicationFilters;
struct AppDuplicationFiltersDefaultTypeInternal;
extern AppDuplicationFiltersDefaultTypeInternal _AppDuplicationFilters_default_instance_;
class AppQuery;
struct AppQueryDefaultTypeInternal;
extern AppQueryDefaultTypeInternal _AppQuery_default_instance_;
class Audio;
struct AudioDefaultTypeInternal;
extern AudioDefaultTypeInternal _Audio_default_instance_;
class AudioInfo;
struct AudioInfoDefaultTypeInternal;
extern AudioInfoDefaultTypeInternal _AudioInfo_default_instance_;
class BinaryMetrics;
struct BinaryMetricsDefaultTypeInternal;
extern BinaryMetricsDefaultTypeInternal _BinaryMetrics_default_instance_;
class BoundingBox;
struct BoundingBoxDefaultTypeInternal;
extern BoundingBoxDefaultTypeInternal _BoundingBox_default_instance_;
class BulkOperation;
struct BulkOperationDefaultTypeInternal;
extern BulkOperationDefaultTypeInternal _BulkOperation_default_instance_;
class Cluster;
struct ClusterDefaultTypeInternal;
extern ClusterDefaultTypeInternal _Cluster_default_instance_;
class Collaboration;
struct CollaborationDefaultTypeInternal;
extern CollaborationDefaultTypeInternal _Collaboration_default_instance_;
class Collaborator;
struct CollaboratorDefaultTypeInternal;
extern CollaboratorDefaultTypeInternal _Collaborator_default_instance_;
class Collector;
struct CollectorDefaultTypeInternal;
extern CollectorDefaultTypeInternal _Collector_default_instance_;
class CollectorSource;
struct CollectorSourceDefaultTypeInternal;
extern CollectorSourceDefaultTypeInternal _CollectorSource_default_instance_;
class Color;
struct ColorDefaultTypeInternal;
extern ColorDefaultTypeInternal _Color_default_instance_;
class Concept;
struct ConceptDefaultTypeInternal;
extern ConceptDefaultTypeInternal _Concept_default_instance_;
class ConceptCount;
struct ConceptCountDefaultTypeInternal;
extern ConceptCountDefaultTypeInternal _ConceptCount_default_instance_;
class ConceptLanguage;
struct ConceptLanguageDefaultTypeInternal;
extern ConceptLanguageDefaultTypeInternal _ConceptLanguage_default_instance_;
class ConceptMappingJob;
struct ConceptMappingJobDefaultTypeInternal;
extern ConceptMappingJobDefaultTypeInternal _ConceptMappingJob_default_instance_;
class ConceptQuery;
struct ConceptQueryDefaultTypeInternal;
extern ConceptQueryDefaultTypeInternal _ConceptQuery_default_instance_;
class ConceptRelation;
struct ConceptRelationDefaultTypeInternal;
extern ConceptRelationDefaultTypeInternal _ConceptRelation_default_instance_;
class ConceptTypeCount;
struct ConceptTypeCountDefaultTypeInternal;
extern ConceptTypeCountDefaultTypeInternal _ConceptTypeCount_default_instance_;
class ConfusionMatrix;
struct ConfusionMatrixDefaultTypeInternal;
extern ConfusionMatrixDefaultTypeInternal _ConfusionMatrix_default_instance_;
class ConfusionMatrixEntry;
struct ConfusionMatrixEntryDefaultTypeInternal;
extern ConfusionMatrixEntryDefaultTypeInternal _ConfusionMatrixEntry_default_instance_;
class CooccurrenceMatrix;
struct CooccurrenceMatrixDefaultTypeInternal;
extern CooccurrenceMatrixDefaultTypeInternal _CooccurrenceMatrix_default_instance_;
class CooccurrenceMatrixEntry;
struct CooccurrenceMatrixEntryDefaultTypeInternal;
extern CooccurrenceMatrixEntryDefaultTypeInternal _CooccurrenceMatrixEntry_default_instance_;
class Data;
struct DataDefaultTypeInternal;
extern DataDefaultTypeInternal _Data_default_instance_;
class DataSourceCredentials;
struct DataSourceCredentialsDefaultTypeInternal;
extern DataSourceCredentialsDefaultTypeInternal _DataSourceCredentials_default_instance_;
class DataSourceURL;
struct DataSourceURLDefaultTypeInternal;
extern DataSourceURLDefaultTypeInternal _DataSourceURL_default_instance_;
class Dataset;
struct DatasetDefaultTypeInternal;
extern DatasetDefaultTypeInternal _Dataset_default_instance_;
class DatasetInput;
struct DatasetInputDefaultTypeInternal;
extern DatasetInputDefaultTypeInternal _DatasetInput_default_instance_;
class DatasetInputsSearchAddJob;
struct DatasetInputsSearchAddJobDefaultTypeInternal;
extern DatasetInputsSearchAddJobDefaultTypeInternal _DatasetInputsSearchAddJob_default_instance_;
class DatasetVersion;
struct DatasetVersionDefaultTypeInternal;
extern DatasetVersionDefaultTypeInternal _DatasetVersion_default_instance_;
class DatasetVersionExport;
struct DatasetVersionExportDefaultTypeInternal;
extern DatasetVersionExportDefaultTypeInternal _DatasetVersionExport_default_instance_;
class DatasetVersionExportInfo;
struct DatasetVersionExportInfoDefaultTypeInternal;
extern DatasetVersionExportInfoDefaultTypeInternal _DatasetVersionExportInfo_default_instance_;
class DatasetVersionMetrics;
struct DatasetVersionMetricsDefaultTypeInternal;
extern DatasetVersionMetricsDefaultTypeInternal _DatasetVersionMetrics_default_instance_;
class DatasetVersionMetricsGroup;
struct DatasetVersionMetricsGroupDefaultTypeInternal;
extern DatasetVersionMetricsGroupDefaultTypeInternal _DatasetVersionMetricsGroup_default_instance_;
class DatasetVersion_MetricsEntry_DoNotUse;
struct DatasetVersion_MetricsEntry_DoNotUseDefaultTypeInternal;
extern DatasetVersion_MetricsEntry_DoNotUseDefaultTypeInternal _DatasetVersion_MetricsEntry_DoNotUse_default_instance_;
class DeleteConcepts;
struct DeleteConceptsDefaultTypeInternal;
extern DeleteConceptsDefaultTypeInternal _DeleteConcepts_default_instance_;
class DeleteGeo;
struct DeleteGeoDefaultTypeInternal;
extern DeleteGeoDefaultTypeInternal _DeleteGeo_default_instance_;
class DeleteMetadata;
struct DeleteMetadataDefaultTypeInternal;
extern DeleteMetadataDefaultTypeInternal _DeleteMetadata_default_instance_;
class DetailConceptCount;
struct DetailConceptCountDefaultTypeInternal;
extern DetailConceptCountDefaultTypeInternal _DetailConceptCount_default_instance_;
class EmailAddress;
struct EmailAddressDefaultTypeInternal;
extern EmailAddressDefaultTypeInternal _EmailAddress_default_instance_;
class Embedding;
struct EmbeddingDefaultTypeInternal;
extern EmbeddingDefaultTypeInternal _Embedding_default_instance_;
class EndpointDeps;
struct EndpointDepsDefaultTypeInternal;
extern EndpointDepsDefaultTypeInternal _EndpointDeps_default_instance_;
class EvalInfo;
struct EvalInfoDefaultTypeInternal;
extern EvalInfoDefaultTypeInternal _EvalInfo_default_instance_;
class EvalMetrics;
struct EvalMetricsDefaultTypeInternal;
extern EvalMetricsDefaultTypeInternal _EvalMetrics_default_instance_;
class EvalTestSetEntry;
struct EvalTestSetEntryDefaultTypeInternal;
extern EvalTestSetEntryDefaultTypeInternal _EvalTestSetEntry_default_instance_;
class FieldsValue;
struct FieldsValueDefaultTypeInternal;
extern FieldsValueDefaultTypeInternal _FieldsValue_default_instance_;
class Filter;
struct FilterDefaultTypeInternal;
extern FilterDefaultTypeInternal _Filter_default_instance_;
class Frame;
struct FrameDefaultTypeInternal;
extern FrameDefaultTypeInternal _Frame_default_instance_;
class FrameInfo;
struct FrameInfoDefaultTypeInternal;
extern FrameInfoDefaultTypeInternal _FrameInfo_default_instance_;
class FullTag;
struct FullTagDefaultTypeInternal;
extern FullTagDefaultTypeInternal _FullTag_default_instance_;
class Geo;
struct GeoDefaultTypeInternal;
extern GeoDefaultTypeInternal _Geo_default_instance_;
class GeoBoxedPoint;
struct GeoBoxedPointDefaultTypeInternal;
extern GeoBoxedPointDefaultTypeInternal _GeoBoxedPoint_default_instance_;
class GeoLimit;
struct GeoLimitDefaultTypeInternal;
extern GeoLimitDefaultTypeInternal _GeoLimit_default_instance_;
class GeoPoint;
struct GeoPointDefaultTypeInternal;
extern GeoPointDefaultTypeInternal _GeoPoint_default_instance_;
class Hit;
struct HitDefaultTypeInternal;
extern HitDefaultTypeInternal _Hit_default_instance_;
class HostedURL;
struct HostedURLDefaultTypeInternal;
extern HostedURLDefaultTypeInternal _HostedURL_default_instance_;
class Image;
struct ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class ImageInfo;
struct ImageInfoDefaultTypeInternal;
extern ImageInfoDefaultTypeInternal _ImageInfo_default_instance_;
class ImportInfo;
struct ImportInfoDefaultTypeInternal;
extern ImportInfoDefaultTypeInternal _ImportInfo_default_instance_;
class Input;
struct InputDefaultTypeInternal;
extern InputDefaultTypeInternal _Input_default_instance_;
class InputCount;
struct InputCountDefaultTypeInternal;
extern InputCountDefaultTypeInternal _InputCount_default_instance_;
class InputIDs;
struct InputIDsDefaultTypeInternal;
extern InputIDsDefaultTypeInternal _InputIDs_default_instance_;
class InputInfo;
struct InputInfoDefaultTypeInternal;
extern InputInfoDefaultTypeInternal _InputInfo_default_instance_;
class InputsAddJob;
struct InputsAddJobDefaultTypeInternal;
extern InputsAddJobDefaultTypeInternal _InputsAddJob_default_instance_;
class InputsAddJobProgress;
struct InputsAddJobProgressDefaultTypeInternal;
extern InputsAddJobProgressDefaultTypeInternal _InputsAddJobProgress_default_instance_;
class InputsDataSource;
struct InputsDataSourceDefaultTypeInternal;
extern InputsDataSourceDefaultTypeInternal _InputsDataSource_default_instance_;
class InputsExtractionJob;
struct InputsExtractionJobDefaultTypeInternal;
extern InputsExtractionJobDefaultTypeInternal _InputsExtractionJob_default_instance_;
class InputsExtractionJobProgress;
struct InputsExtractionJobProgressDefaultTypeInternal;
extern InputsExtractionJobProgressDefaultTypeInternal _InputsExtractionJobProgress_default_instance_;
class InstalledModuleVersion;
struct InstalledModuleVersionDefaultTypeInternal;
extern InstalledModuleVersionDefaultTypeInternal _InstalledModuleVersion_default_instance_;
class Key;
struct KeyDefaultTypeInternal;
extern KeyDefaultTypeInternal _Key_default_instance_;
class KeypointEdge;
struct KeypointEdgeDefaultTypeInternal;
extern KeypointEdgeDefaultTypeInternal _KeypointEdge_default_instance_;
class KeypointInfo;
struct KeypointInfoDefaultTypeInternal;
extern KeypointInfoDefaultTypeInternal _KeypointInfo_default_instance_;
class KnowledgeGraph;
struct KnowledgeGraphDefaultTypeInternal;
extern KnowledgeGraphDefaultTypeInternal _KnowledgeGraph_default_instance_;
class LOPQEvalResult;
struct LOPQEvalResultDefaultTypeInternal;
extern LOPQEvalResultDefaultTypeInternal _LOPQEvalResult_default_instance_;
class LabelCount;
struct LabelCountDefaultTypeInternal;
extern LabelCountDefaultTypeInternal _LabelCount_default_instance_;
class LabelDistribution;
struct LabelDistributionDefaultTypeInternal;
extern LabelDistributionDefaultTypeInternal _LabelDistribution_default_instance_;
class LabelOrder;
struct LabelOrderDefaultTypeInternal;
extern LabelOrderDefaultTypeInternal _LabelOrder_default_instance_;
class LayerShape;
struct LayerShapeDefaultTypeInternal;
extern LayerShapeDefaultTypeInternal _LayerShape_default_instance_;
class LossCurveEntry;
struct LossCurveEntryDefaultTypeInternal;
extern LossCurveEntryDefaultTypeInternal _LossCurveEntry_default_instance_;
class Mask;
struct MaskDefaultTypeInternal;
extern MaskDefaultTypeInternal _Mask_default_instance_;
class MetricsSummary;
struct MetricsSummaryDefaultTypeInternal;
extern MetricsSummaryDefaultTypeInternal _MetricsSummary_default_instance_;
class Model;
struct ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class ModelLayerInfo;
struct ModelLayerInfoDefaultTypeInternal;
extern ModelLayerInfoDefaultTypeInternal _ModelLayerInfo_default_instance_;
class ModelPredictConfig;
struct ModelPredictConfigDefaultTypeInternal;
extern ModelPredictConfigDefaultTypeInternal _ModelPredictConfig_default_instance_;
class ModelQuery;
struct ModelQueryDefaultTypeInternal;
extern ModelQueryDefaultTypeInternal _ModelQuery_default_instance_;
class ModelReference;
struct ModelReferenceDefaultTypeInternal;
extern ModelReferenceDefaultTypeInternal _ModelReference_default_instance_;
class ModelType;
struct ModelTypeDefaultTypeInternal;
extern ModelTypeDefaultTypeInternal _ModelType_default_instance_;
class ModelTypeEnumOption;
struct ModelTypeEnumOptionDefaultTypeInternal;
extern ModelTypeEnumOptionDefaultTypeInternal _ModelTypeEnumOption_default_instance_;
class ModelTypeEnumOptionAlias;
struct ModelTypeEnumOptionAliasDefaultTypeInternal;
extern ModelTypeEnumOptionAliasDefaultTypeInternal _ModelTypeEnumOptionAlias_default_instance_;
class ModelTypeField;
struct ModelTypeFieldDefaultTypeInternal;
extern ModelTypeFieldDefaultTypeInternal _ModelTypeField_default_instance_;
class ModelTypeRangeInfo;
struct ModelTypeRangeInfoDefaultTypeInternal;
extern ModelTypeRangeInfoDefaultTypeInternal _ModelTypeRangeInfo_default_instance_;
class ModelVersion;
struct ModelVersionDefaultTypeInternal;
extern ModelVersionDefaultTypeInternal _ModelVersion_default_instance_;
class ModelVersionInputExample;
struct ModelVersionInputExampleDefaultTypeInternal;
extern ModelVersionInputExampleDefaultTypeInternal _ModelVersionInputExample_default_instance_;
class Module;
struct ModuleDefaultTypeInternal;
extern ModuleDefaultTypeInternal _Module_default_instance_;
class ModuleVersion;
struct ModuleVersionDefaultTypeInternal;
extern ModuleVersionDefaultTypeInternal _ModuleVersion_default_instance_;
class ModuleVersion_ModuleNav;
struct ModuleVersion_ModuleNavDefaultTypeInternal;
extern ModuleVersion_ModuleNavDefaultTypeInternal _ModuleVersion_ModuleNav_default_instance_;
class ModuleVersion_ModuleSubNav;
struct ModuleVersion_ModuleSubNavDefaultTypeInternal;
extern ModuleVersion_ModuleSubNavDefaultTypeInternal _ModuleVersion_ModuleSubNav_default_instance_;
class NodeInput;
struct NodeInputDefaultTypeInternal;
extern NodeInputDefaultTypeInternal _NodeInput_default_instance_;
class Operation;
struct OperationDefaultTypeInternal;
extern OperationDefaultTypeInternal _Operation_default_instance_;
class Output;
struct OutputDefaultTypeInternal;
extern OutputDefaultTypeInternal _Output_default_instance_;
class OutputConfig;
struct OutputConfigDefaultTypeInternal;
extern OutputConfigDefaultTypeInternal _OutputConfig_default_instance_;
class OutputInfo;
struct OutputInfoDefaultTypeInternal;
extern OutputInfoDefaultTypeInternal _OutputInfo_default_instance_;
class OverwriteGeo;
struct OverwriteGeoDefaultTypeInternal;
extern OverwriteGeoDefaultTypeInternal _OverwriteGeo_default_instance_;
class Password;
struct PasswordDefaultTypeInternal;
extern PasswordDefaultTypeInternal _Password_default_instance_;
class PasswordViolations;
struct PasswordViolationsDefaultTypeInternal;
extern PasswordViolationsDefaultTypeInternal _PasswordViolations_default_instance_;
class PatchAction;
struct PatchActionDefaultTypeInternal;
extern PatchActionDefaultTypeInternal _PatchAction_default_instance_;
class Point;
struct PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class Polygon;
struct PolygonDefaultTypeInternal;
extern PolygonDefaultTypeInternal _Polygon_default_instance_;
class PrecisionRecallCurve;
struct PrecisionRecallCurveDefaultTypeInternal;
extern PrecisionRecallCurveDefaultTypeInternal _PrecisionRecallCurve_default_instance_;
class PretrainedModelConfig;
struct PretrainedModelConfigDefaultTypeInternal;
extern PretrainedModelConfigDefaultTypeInternal _PretrainedModelConfig_default_instance_;
class Progress;
struct ProgressDefaultTypeInternal;
extern ProgressDefaultTypeInternal _Progress_default_instance_;
class Query;
struct QueryDefaultTypeInternal;
extern QueryDefaultTypeInternal _Query_default_instance_;
class ROC;
struct ROCDefaultTypeInternal;
extern ROCDefaultTypeInternal _ROC_default_instance_;
class Rank;
struct RankDefaultTypeInternal;
extern RankDefaultTypeInternal _Rank_default_instance_;
class Region;
struct RegionDefaultTypeInternal;
extern RegionDefaultTypeInternal _Region_default_instance_;
class RegionInfo;
struct RegionInfoDefaultTypeInternal;
extern RegionInfoDefaultTypeInternal _RegionInfo_default_instance_;
class ScopeDeps;
struct ScopeDepsDefaultTypeInternal;
extern ScopeDepsDefaultTypeInternal _ScopeDeps_default_instance_;
class Search;
struct SearchDefaultTypeInternal;
extern SearchDefaultTypeInternal _Search_default_instance_;
class Span;
struct SpanDefaultTypeInternal;
extern SpanDefaultTypeInternal _Span_default_instance_;
class StatValue;
struct StatValueDefaultTypeInternal;
extern StatValueDefaultTypeInternal _StatValue_default_instance_;
class StatValueAggregate;
struct StatValueAggregateDefaultTypeInternal;
extern StatValueAggregateDefaultTypeInternal _StatValueAggregate_default_instance_;
class StatValueAggregateQuery;
struct StatValueAggregateQueryDefaultTypeInternal;
extern StatValueAggregateQueryDefaultTypeInternal _StatValueAggregateQuery_default_instance_;
class StatValueAggregateResult;
struct StatValueAggregateResultDefaultTypeInternal;
extern StatValueAggregateResultDefaultTypeInternal _StatValueAggregateResult_default_instance_;
class Task;
struct TaskDefaultTypeInternal;
extern TaskDefaultTypeInternal _Task_default_instance_;
class TaskAIAssistant;
struct TaskAIAssistantDefaultTypeInternal;
extern TaskAIAssistantDefaultTypeInternal _TaskAIAssistant_default_instance_;
class TaskInputSource;
struct TaskInputSourceDefaultTypeInternal;
extern TaskInputSourceDefaultTypeInternal _TaskInputSource_default_instance_;
class TaskReview;
struct TaskReviewDefaultTypeInternal;
extern TaskReviewDefaultTypeInternal _TaskReview_default_instance_;
class TaskReviewConsensusStrategyInfo;
struct TaskReviewConsensusStrategyInfoDefaultTypeInternal;
extern TaskReviewConsensusStrategyInfoDefaultTypeInternal _TaskReviewConsensusStrategyInfo_default_instance_;
class TaskReviewManualStrategyInfo;
struct TaskReviewManualStrategyInfoDefaultTypeInternal;
extern TaskReviewManualStrategyInfoDefaultTypeInternal _TaskReviewManualStrategyInfo_default_instance_;
class TaskStatusCountPerUser;
struct TaskStatusCountPerUserDefaultTypeInternal;
extern TaskStatusCountPerUserDefaultTypeInternal _TaskStatusCountPerUser_default_instance_;
class TaskWorker;
struct TaskWorkerDefaultTypeInternal;
extern TaskWorkerDefaultTypeInternal _TaskWorker_default_instance_;
class TaskWorkerPartitionedStrategyInfo;
struct TaskWorkerPartitionedStrategyInfoDefaultTypeInternal;
extern TaskWorkerPartitionedStrategyInfoDefaultTypeInternal _TaskWorkerPartitionedStrategyInfo_default_instance_;
class Text;
struct TextDefaultTypeInternal;
extern TextDefaultTypeInternal _Text_default_instance_;
class TextInfo;
struct TextInfoDefaultTypeInternal;
extern TextInfoDefaultTypeInternal _TextInfo_default_instance_;
class TimeInfo;
struct TimeInfoDefaultTypeInternal;
extern TimeInfoDefaultTypeInternal _TimeInfo_default_instance_;
class TimeRange;
struct TimeRangeDefaultTypeInternal;
extern TimeRangeDefaultTypeInternal _TimeRange_default_instance_;
class TimeSegment;
struct TimeSegmentDefaultTypeInternal;
extern TimeSegmentDefaultTypeInternal _TimeSegment_default_instance_;
class Token;
struct TokenDefaultTypeInternal;
extern TokenDefaultTypeInternal _Token_default_instance_;
class Track;
struct TrackDefaultTypeInternal;
extern TrackDefaultTypeInternal _Track_default_instance_;
class TrackerMetrics;
struct TrackerMetricsDefaultTypeInternal;
extern TrackerMetricsDefaultTypeInternal _TrackerMetrics_default_instance_;
class TrainInfo;
struct TrainInfoDefaultTypeInternal;
extern TrainInfoDefaultTypeInternal _TrainInfo_default_instance_;
class TrainStats;
struct TrainStatsDefaultTypeInternal;
extern TrainStatsDefaultTypeInternal _TrainStats_default_instance_;
class TrendingMetric;
struct TrendingMetricDefaultTypeInternal;
extern TrendingMetricDefaultTypeInternal _TrendingMetric_default_instance_;
class Upload;
struct UploadDefaultTypeInternal;
extern UploadDefaultTypeInternal _Upload_default_instance_;
class UploadContentPart;
struct UploadContentPartDefaultTypeInternal;
extern UploadContentPartDefaultTypeInternal _UploadContentPart_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
class UserAppIDSet;
struct UserAppIDSetDefaultTypeInternal;
extern UserAppIDSetDefaultTypeInternal _UserAppIDSet_default_instance_;
class UserDetail;
struct UserDetailDefaultTypeInternal;
extern UserDetailDefaultTypeInternal _UserDetail_default_instance_;
class Video;
struct VideoDefaultTypeInternal;
extern VideoDefaultTypeInternal _Video_default_instance_;
class VideoInfo;
struct VideoInfoDefaultTypeInternal;
extern VideoInfoDefaultTypeInternal _VideoInfo_default_instance_;
class Visibility;
struct VisibilityDefaultTypeInternal;
extern VisibilityDefaultTypeInternal _Visibility_default_instance_;
class W3C;
struct W3CDefaultTypeInternal;
extern W3CDefaultTypeInternal _W3C_default_instance_;
class Workflow;
struct WorkflowDefaultTypeInternal;
extern WorkflowDefaultTypeInternal _Workflow_default_instance_;
class WorkflowNode;
struct WorkflowNodeDefaultTypeInternal;
extern WorkflowNodeDefaultTypeInternal _WorkflowNode_default_instance_;
class WorkflowResult;
struct WorkflowResultDefaultTypeInternal;
extern WorkflowResultDefaultTypeInternal _WorkflowResult_default_instance_;
class WorkflowResultsSimilarity;
struct WorkflowResultsSimilarityDefaultTypeInternal;
extern WorkflowResultsSimilarityDefaultTypeInternal _WorkflowResultsSimilarity_default_instance_;
class WorkflowState;
struct WorkflowStateDefaultTypeInternal;
extern WorkflowStateDefaultTypeInternal _WorkflowState_default_instance_;
class WorkflowVersion;
struct WorkflowVersionDefaultTypeInternal;
extern WorkflowVersionDefaultTypeInternal _WorkflowVersion_default_instance_;
}  // namespace api
}  // namespace clarifai
PROTOBUF_NAMESPACE_OPEN
template<> ::clarifai::api::APIPostModelOutputsCollectorSource* Arena::CreateMaybeMessage<::clarifai::api::APIPostModelOutputsCollectorSource>(Arena*);
template<> ::clarifai::api::AWSCreds* Arena::CreateMaybeMessage<::clarifai::api::AWSCreds>(Arena*);
template<> ::clarifai::api::AddConcepts* Arena::CreateMaybeMessage<::clarifai::api::AddConcepts>(Arena*);
template<> ::clarifai::api::AddMetadata* Arena::CreateMaybeMessage<::clarifai::api::AddMetadata>(Arena*);
template<> ::clarifai::api::AiAssistParameters* Arena::CreateMaybeMessage<::clarifai::api::AiAssistParameters>(Arena*);
template<> ::clarifai::api::And* Arena::CreateMaybeMessage<::clarifai::api::And>(Arena*);
template<> ::clarifai::api::Annotation* Arena::CreateMaybeMessage<::clarifai::api::Annotation>(Arena*);
template<> ::clarifai::api::AnnotationFilter* Arena::CreateMaybeMessage<::clarifai::api::AnnotationFilter>(Arena*);
template<> ::clarifai::api::AnnotationFilterConfig* Arena::CreateMaybeMessage<::clarifai::api::AnnotationFilterConfig>(Arena*);
template<> ::clarifai::api::AnnotationSearchMetrics* Arena::CreateMaybeMessage<::clarifai::api::AnnotationSearchMetrics>(Arena*);
template<> ::clarifai::api::App* Arena::CreateMaybeMessage<::clarifai::api::App>(Arena*);
template<> ::clarifai::api::AppCopyProgress* Arena::CreateMaybeMessage<::clarifai::api::AppCopyProgress>(Arena*);
template<> ::clarifai::api::AppDuplication* Arena::CreateMaybeMessage<::clarifai::api::AppDuplication>(Arena*);
template<> ::clarifai::api::AppDuplicationFilters* Arena::CreateMaybeMessage<::clarifai::api::AppDuplicationFilters>(Arena*);
template<> ::clarifai::api::AppQuery* Arena::CreateMaybeMessage<::clarifai::api::AppQuery>(Arena*);
template<> ::clarifai::api::Audio* Arena::CreateMaybeMessage<::clarifai::api::Audio>(Arena*);
template<> ::clarifai::api::AudioInfo* Arena::CreateMaybeMessage<::clarifai::api::AudioInfo>(Arena*);
template<> ::clarifai::api::BinaryMetrics* Arena::CreateMaybeMessage<::clarifai::api::BinaryMetrics>(Arena*);
template<> ::clarifai::api::BoundingBox* Arena::CreateMaybeMessage<::clarifai::api::BoundingBox>(Arena*);
template<> ::clarifai::api::BulkOperation* Arena::CreateMaybeMessage<::clarifai::api::BulkOperation>(Arena*);
template<> ::clarifai::api::Cluster* Arena::CreateMaybeMessage<::clarifai::api::Cluster>(Arena*);
template<> ::clarifai::api::Collaboration* Arena::CreateMaybeMessage<::clarifai::api::Collaboration>(Arena*);
template<> ::clarifai::api::Collaborator* Arena::CreateMaybeMessage<::clarifai::api::Collaborator>(Arena*);
template<> ::clarifai::api::Collector* Arena::CreateMaybeMessage<::clarifai::api::Collector>(Arena*);
template<> ::clarifai::api::CollectorSource* Arena::CreateMaybeMessage<::clarifai::api::CollectorSource>(Arena*);
template<> ::clarifai::api::Color* Arena::CreateMaybeMessage<::clarifai::api::Color>(Arena*);
template<> ::clarifai::api::Concept* Arena::CreateMaybeMessage<::clarifai::api::Concept>(Arena*);
template<> ::clarifai::api::ConceptCount* Arena::CreateMaybeMessage<::clarifai::api::ConceptCount>(Arena*);
template<> ::clarifai::api::ConceptLanguage* Arena::CreateMaybeMessage<::clarifai::api::ConceptLanguage>(Arena*);
template<> ::clarifai::api::ConceptMappingJob* Arena::CreateMaybeMessage<::clarifai::api::ConceptMappingJob>(Arena*);
template<> ::clarifai::api::ConceptQuery* Arena::CreateMaybeMessage<::clarifai::api::ConceptQuery>(Arena*);
template<> ::clarifai::api::ConceptRelation* Arena::CreateMaybeMessage<::clarifai::api::ConceptRelation>(Arena*);
template<> ::clarifai::api::ConceptTypeCount* Arena::CreateMaybeMessage<::clarifai::api::ConceptTypeCount>(Arena*);
template<> ::clarifai::api::ConfusionMatrix* Arena::CreateMaybeMessage<::clarifai::api::ConfusionMatrix>(Arena*);
template<> ::clarifai::api::ConfusionMatrixEntry* Arena::CreateMaybeMessage<::clarifai::api::ConfusionMatrixEntry>(Arena*);
template<> ::clarifai::api::CooccurrenceMatrix* Arena::CreateMaybeMessage<::clarifai::api::CooccurrenceMatrix>(Arena*);
template<> ::clarifai::api::CooccurrenceMatrixEntry* Arena::CreateMaybeMessage<::clarifai::api::CooccurrenceMatrixEntry>(Arena*);
template<> ::clarifai::api::Data* Arena::CreateMaybeMessage<::clarifai::api::Data>(Arena*);
template<> ::clarifai::api::DataSourceCredentials* Arena::CreateMaybeMessage<::clarifai::api::DataSourceCredentials>(Arena*);
template<> ::clarifai::api::DataSourceURL* Arena::CreateMaybeMessage<::clarifai::api::DataSourceURL>(Arena*);
template<> ::clarifai::api::Dataset* Arena::CreateMaybeMessage<::clarifai::api::Dataset>(Arena*);
template<> ::clarifai::api::DatasetInput* Arena::CreateMaybeMessage<::clarifai::api::DatasetInput>(Arena*);
template<> ::clarifai::api::DatasetInputsSearchAddJob* Arena::CreateMaybeMessage<::clarifai::api::DatasetInputsSearchAddJob>(Arena*);
template<> ::clarifai::api::DatasetVersion* Arena::CreateMaybeMessage<::clarifai::api::DatasetVersion>(Arena*);
template<> ::clarifai::api::DatasetVersionExport* Arena::CreateMaybeMessage<::clarifai::api::DatasetVersionExport>(Arena*);
template<> ::clarifai::api::DatasetVersionExportInfo* Arena::CreateMaybeMessage<::clarifai::api::DatasetVersionExportInfo>(Arena*);
template<> ::clarifai::api::DatasetVersionMetrics* Arena::CreateMaybeMessage<::clarifai::api::DatasetVersionMetrics>(Arena*);
template<> ::clarifai::api::DatasetVersionMetricsGroup* Arena::CreateMaybeMessage<::clarifai::api::DatasetVersionMetricsGroup>(Arena*);
template<> ::clarifai::api::DatasetVersion_MetricsEntry_DoNotUse* Arena::CreateMaybeMessage<::clarifai::api::DatasetVersion_MetricsEntry_DoNotUse>(Arena*);
template<> ::clarifai::api::DeleteConcepts* Arena::CreateMaybeMessage<::clarifai::api::DeleteConcepts>(Arena*);
template<> ::clarifai::api::DeleteGeo* Arena::CreateMaybeMessage<::clarifai::api::DeleteGeo>(Arena*);
template<> ::clarifai::api::DeleteMetadata* Arena::CreateMaybeMessage<::clarifai::api::DeleteMetadata>(Arena*);
template<> ::clarifai::api::DetailConceptCount* Arena::CreateMaybeMessage<::clarifai::api::DetailConceptCount>(Arena*);
template<> ::clarifai::api::EmailAddress* Arena::CreateMaybeMessage<::clarifai::api::EmailAddress>(Arena*);
template<> ::clarifai::api::Embedding* Arena::CreateMaybeMessage<::clarifai::api::Embedding>(Arena*);
template<> ::clarifai::api::EndpointDeps* Arena::CreateMaybeMessage<::clarifai::api::EndpointDeps>(Arena*);
template<> ::clarifai::api::EvalInfo* Arena::CreateMaybeMessage<::clarifai::api::EvalInfo>(Arena*);
template<> ::clarifai::api::EvalMetrics* Arena::CreateMaybeMessage<::clarifai::api::EvalMetrics>(Arena*);
template<> ::clarifai::api::EvalTestSetEntry* Arena::CreateMaybeMessage<::clarifai::api::EvalTestSetEntry>(Arena*);
template<> ::clarifai::api::FieldsValue* Arena::CreateMaybeMessage<::clarifai::api::FieldsValue>(Arena*);
template<> ::clarifai::api::Filter* Arena::CreateMaybeMessage<::clarifai::api::Filter>(Arena*);
template<> ::clarifai::api::Frame* Arena::CreateMaybeMessage<::clarifai::api::Frame>(Arena*);
template<> ::clarifai::api::FrameInfo* Arena::CreateMaybeMessage<::clarifai::api::FrameInfo>(Arena*);
template<> ::clarifai::api::FullTag* Arena::CreateMaybeMessage<::clarifai::api::FullTag>(Arena*);
template<> ::clarifai::api::Geo* Arena::CreateMaybeMessage<::clarifai::api::Geo>(Arena*);
template<> ::clarifai::api::GeoBoxedPoint* Arena::CreateMaybeMessage<::clarifai::api::GeoBoxedPoint>(Arena*);
template<> ::clarifai::api::GeoLimit* Arena::CreateMaybeMessage<::clarifai::api::GeoLimit>(Arena*);
template<> ::clarifai::api::GeoPoint* Arena::CreateMaybeMessage<::clarifai::api::GeoPoint>(Arena*);
template<> ::clarifai::api::Hit* Arena::CreateMaybeMessage<::clarifai::api::Hit>(Arena*);
template<> ::clarifai::api::HostedURL* Arena::CreateMaybeMessage<::clarifai::api::HostedURL>(Arena*);
template<> ::clarifai::api::Image* Arena::CreateMaybeMessage<::clarifai::api::Image>(Arena*);
template<> ::clarifai::api::ImageInfo* Arena::CreateMaybeMessage<::clarifai::api::ImageInfo>(Arena*);
template<> ::clarifai::api::ImportInfo* Arena::CreateMaybeMessage<::clarifai::api::ImportInfo>(Arena*);
template<> ::clarifai::api::Input* Arena::CreateMaybeMessage<::clarifai::api::Input>(Arena*);
template<> ::clarifai::api::InputCount* Arena::CreateMaybeMessage<::clarifai::api::InputCount>(Arena*);
template<> ::clarifai::api::InputIDs* Arena::CreateMaybeMessage<::clarifai::api::InputIDs>(Arena*);
template<> ::clarifai::api::InputInfo* Arena::CreateMaybeMessage<::clarifai::api::InputInfo>(Arena*);
template<> ::clarifai::api::InputsAddJob* Arena::CreateMaybeMessage<::clarifai::api::InputsAddJob>(Arena*);
template<> ::clarifai::api::InputsAddJobProgress* Arena::CreateMaybeMessage<::clarifai::api::InputsAddJobProgress>(Arena*);
template<> ::clarifai::api::InputsDataSource* Arena::CreateMaybeMessage<::clarifai::api::InputsDataSource>(Arena*);
template<> ::clarifai::api::InputsExtractionJob* Arena::CreateMaybeMessage<::clarifai::api::InputsExtractionJob>(Arena*);
template<> ::clarifai::api::InputsExtractionJobProgress* Arena::CreateMaybeMessage<::clarifai::api::InputsExtractionJobProgress>(Arena*);
template<> ::clarifai::api::InstalledModuleVersion* Arena::CreateMaybeMessage<::clarifai::api::InstalledModuleVersion>(Arena*);
template<> ::clarifai::api::Key* Arena::CreateMaybeMessage<::clarifai::api::Key>(Arena*);
template<> ::clarifai::api::KeypointEdge* Arena::CreateMaybeMessage<::clarifai::api::KeypointEdge>(Arena*);
template<> ::clarifai::api::KeypointInfo* Arena::CreateMaybeMessage<::clarifai::api::KeypointInfo>(Arena*);
template<> ::clarifai::api::KnowledgeGraph* Arena::CreateMaybeMessage<::clarifai::api::KnowledgeGraph>(Arena*);
template<> ::clarifai::api::LOPQEvalResult* Arena::CreateMaybeMessage<::clarifai::api::LOPQEvalResult>(Arena*);
template<> ::clarifai::api::LabelCount* Arena::CreateMaybeMessage<::clarifai::api::LabelCount>(Arena*);
template<> ::clarifai::api::LabelDistribution* Arena::CreateMaybeMessage<::clarifai::api::LabelDistribution>(Arena*);
template<> ::clarifai::api::LabelOrder* Arena::CreateMaybeMessage<::clarifai::api::LabelOrder>(Arena*);
template<> ::clarifai::api::LayerShape* Arena::CreateMaybeMessage<::clarifai::api::LayerShape>(Arena*);
template<> ::clarifai::api::LossCurveEntry* Arena::CreateMaybeMessage<::clarifai::api::LossCurveEntry>(Arena*);
template<> ::clarifai::api::Mask* Arena::CreateMaybeMessage<::clarifai::api::Mask>(Arena*);
template<> ::clarifai::api::MetricsSummary* Arena::CreateMaybeMessage<::clarifai::api::MetricsSummary>(Arena*);
template<> ::clarifai::api::Model* Arena::CreateMaybeMessage<::clarifai::api::Model>(Arena*);
template<> ::clarifai::api::ModelLayerInfo* Arena::CreateMaybeMessage<::clarifai::api::ModelLayerInfo>(Arena*);
template<> ::clarifai::api::ModelPredictConfig* Arena::CreateMaybeMessage<::clarifai::api::ModelPredictConfig>(Arena*);
template<> ::clarifai::api::ModelQuery* Arena::CreateMaybeMessage<::clarifai::api::ModelQuery>(Arena*);
template<> ::clarifai::api::ModelReference* Arena::CreateMaybeMessage<::clarifai::api::ModelReference>(Arena*);
template<> ::clarifai::api::ModelType* Arena::CreateMaybeMessage<::clarifai::api::ModelType>(Arena*);
template<> ::clarifai::api::ModelTypeEnumOption* Arena::CreateMaybeMessage<::clarifai::api::ModelTypeEnumOption>(Arena*);
template<> ::clarifai::api::ModelTypeEnumOptionAlias* Arena::CreateMaybeMessage<::clarifai::api::ModelTypeEnumOptionAlias>(Arena*);
template<> ::clarifai::api::ModelTypeField* Arena::CreateMaybeMessage<::clarifai::api::ModelTypeField>(Arena*);
template<> ::clarifai::api::ModelTypeRangeInfo* Arena::CreateMaybeMessage<::clarifai::api::ModelTypeRangeInfo>(Arena*);
template<> ::clarifai::api::ModelVersion* Arena::CreateMaybeMessage<::clarifai::api::ModelVersion>(Arena*);
template<> ::clarifai::api::ModelVersionInputExample* Arena::CreateMaybeMessage<::clarifai::api::ModelVersionInputExample>(Arena*);
template<> ::clarifai::api::Module* Arena::CreateMaybeMessage<::clarifai::api::Module>(Arena*);
template<> ::clarifai::api::ModuleVersion* Arena::CreateMaybeMessage<::clarifai::api::ModuleVersion>(Arena*);
template<> ::clarifai::api::ModuleVersion_ModuleNav* Arena::CreateMaybeMessage<::clarifai::api::ModuleVersion_ModuleNav>(Arena*);
template<> ::clarifai::api::ModuleVersion_ModuleSubNav* Arena::CreateMaybeMessage<::clarifai::api::ModuleVersion_ModuleSubNav>(Arena*);
template<> ::clarifai::api::NodeInput* Arena::CreateMaybeMessage<::clarifai::api::NodeInput>(Arena*);
template<> ::clarifai::api::Operation* Arena::CreateMaybeMessage<::clarifai::api::Operation>(Arena*);
template<> ::clarifai::api::Output* Arena::CreateMaybeMessage<::clarifai::api::Output>(Arena*);
template<> ::clarifai::api::OutputConfig* Arena::CreateMaybeMessage<::clarifai::api::OutputConfig>(Arena*);
template<> ::clarifai::api::OutputInfo* Arena::CreateMaybeMessage<::clarifai::api::OutputInfo>(Arena*);
template<> ::clarifai::api::OverwriteGeo* Arena::CreateMaybeMessage<::clarifai::api::OverwriteGeo>(Arena*);
template<> ::clarifai::api::Password* Arena::CreateMaybeMessage<::clarifai::api::Password>(Arena*);
template<> ::clarifai::api::PasswordViolations* Arena::CreateMaybeMessage<::clarifai::api::PasswordViolations>(Arena*);
template<> ::clarifai::api::PatchAction* Arena::CreateMaybeMessage<::clarifai::api::PatchAction>(Arena*);
template<> ::clarifai::api::Point* Arena::CreateMaybeMessage<::clarifai::api::Point>(Arena*);
template<> ::clarifai::api::Polygon* Arena::CreateMaybeMessage<::clarifai::api::Polygon>(Arena*);
template<> ::clarifai::api::PrecisionRecallCurve* Arena::CreateMaybeMessage<::clarifai::api::PrecisionRecallCurve>(Arena*);
template<> ::clarifai::api::PretrainedModelConfig* Arena::CreateMaybeMessage<::clarifai::api::PretrainedModelConfig>(Arena*);
template<> ::clarifai::api::Progress* Arena::CreateMaybeMessage<::clarifai::api::Progress>(Arena*);
template<> ::clarifai::api::Query* Arena::CreateMaybeMessage<::clarifai::api::Query>(Arena*);
template<> ::clarifai::api::ROC* Arena::CreateMaybeMessage<::clarifai::api::ROC>(Arena*);
template<> ::clarifai::api::Rank* Arena::CreateMaybeMessage<::clarifai::api::Rank>(Arena*);
template<> ::clarifai::api::Region* Arena::CreateMaybeMessage<::clarifai::api::Region>(Arena*);
template<> ::clarifai::api::RegionInfo* Arena::CreateMaybeMessage<::clarifai::api::RegionInfo>(Arena*);
template<> ::clarifai::api::ScopeDeps* Arena::CreateMaybeMessage<::clarifai::api::ScopeDeps>(Arena*);
template<> ::clarifai::api::Search* Arena::CreateMaybeMessage<::clarifai::api::Search>(Arena*);
template<> ::clarifai::api::Span* Arena::CreateMaybeMessage<::clarifai::api::Span>(Arena*);
template<> ::clarifai::api::StatValue* Arena::CreateMaybeMessage<::clarifai::api::StatValue>(Arena*);
template<> ::clarifai::api::StatValueAggregate* Arena::CreateMaybeMessage<::clarifai::api::StatValueAggregate>(Arena*);
template<> ::clarifai::api::StatValueAggregateQuery* Arena::CreateMaybeMessage<::clarifai::api::StatValueAggregateQuery>(Arena*);
template<> ::clarifai::api::StatValueAggregateResult* Arena::CreateMaybeMessage<::clarifai::api::StatValueAggregateResult>(Arena*);
template<> ::clarifai::api::Task* Arena::CreateMaybeMessage<::clarifai::api::Task>(Arena*);
template<> ::clarifai::api::TaskAIAssistant* Arena::CreateMaybeMessage<::clarifai::api::TaskAIAssistant>(Arena*);
template<> ::clarifai::api::TaskInputSource* Arena::CreateMaybeMessage<::clarifai::api::TaskInputSource>(Arena*);
template<> ::clarifai::api::TaskReview* Arena::CreateMaybeMessage<::clarifai::api::TaskReview>(Arena*);
template<> ::clarifai::api::TaskReviewConsensusStrategyInfo* Arena::CreateMaybeMessage<::clarifai::api::TaskReviewConsensusStrategyInfo>(Arena*);
template<> ::clarifai::api::TaskReviewManualStrategyInfo* Arena::CreateMaybeMessage<::clarifai::api::TaskReviewManualStrategyInfo>(Arena*);
template<> ::clarifai::api::TaskStatusCountPerUser* Arena::CreateMaybeMessage<::clarifai::api::TaskStatusCountPerUser>(Arena*);
template<> ::clarifai::api::TaskWorker* Arena::CreateMaybeMessage<::clarifai::api::TaskWorker>(Arena*);
template<> ::clarifai::api::TaskWorkerPartitionedStrategyInfo* Arena::CreateMaybeMessage<::clarifai::api::TaskWorkerPartitionedStrategyInfo>(Arena*);
template<> ::clarifai::api::Text* Arena::CreateMaybeMessage<::clarifai::api::Text>(Arena*);
template<> ::clarifai::api::TextInfo* Arena::CreateMaybeMessage<::clarifai::api::TextInfo>(Arena*);
template<> ::clarifai::api::TimeInfo* Arena::CreateMaybeMessage<::clarifai::api::TimeInfo>(Arena*);
template<> ::clarifai::api::TimeRange* Arena::CreateMaybeMessage<::clarifai::api::TimeRange>(Arena*);
template<> ::clarifai::api::TimeSegment* Arena::CreateMaybeMessage<::clarifai::api::TimeSegment>(Arena*);
template<> ::clarifai::api::Token* Arena::CreateMaybeMessage<::clarifai::api::Token>(Arena*);
template<> ::clarifai::api::Track* Arena::CreateMaybeMessage<::clarifai::api::Track>(Arena*);
template<> ::clarifai::api::TrackerMetrics* Arena::CreateMaybeMessage<::clarifai::api::TrackerMetrics>(Arena*);
template<> ::clarifai::api::TrainInfo* Arena::CreateMaybeMessage<::clarifai::api::TrainInfo>(Arena*);
template<> ::clarifai::api::TrainStats* Arena::CreateMaybeMessage<::clarifai::api::TrainStats>(Arena*);
template<> ::clarifai::api::TrendingMetric* Arena::CreateMaybeMessage<::clarifai::api::TrendingMetric>(Arena*);
template<> ::clarifai::api::Upload* Arena::CreateMaybeMessage<::clarifai::api::Upload>(Arena*);
template<> ::clarifai::api::UploadContentPart* Arena::CreateMaybeMessage<::clarifai::api::UploadContentPart>(Arena*);
template<> ::clarifai::api::User* Arena::CreateMaybeMessage<::clarifai::api::User>(Arena*);
template<> ::clarifai::api::UserAppIDSet* Arena::CreateMaybeMessage<::clarifai::api::UserAppIDSet>(Arena*);
template<> ::clarifai::api::UserDetail* Arena::CreateMaybeMessage<::clarifai::api::UserDetail>(Arena*);
template<> ::clarifai::api::Video* Arena::CreateMaybeMessage<::clarifai::api::Video>(Arena*);
template<> ::clarifai::api::VideoInfo* Arena::CreateMaybeMessage<::clarifai::api::VideoInfo>(Arena*);
template<> ::clarifai::api::Visibility* Arena::CreateMaybeMessage<::clarifai::api::Visibility>(Arena*);
template<> ::clarifai::api::W3C* Arena::CreateMaybeMessage<::clarifai::api::W3C>(Arena*);
template<> ::clarifai::api::Workflow* Arena::CreateMaybeMessage<::clarifai::api::Workflow>(Arena*);
template<> ::clarifai::api::WorkflowNode* Arena::CreateMaybeMessage<::clarifai::api::WorkflowNode>(Arena*);
template<> ::clarifai::api::WorkflowResult* Arena::CreateMaybeMessage<::clarifai::api::WorkflowResult>(Arena*);
template<> ::clarifai::api::WorkflowResultsSimilarity* Arena::CreateMaybeMessage<::clarifai::api::WorkflowResultsSimilarity>(Arena*);
template<> ::clarifai::api::WorkflowState* Arena::CreateMaybeMessage<::clarifai::api::WorkflowState>(Arena*);
template<> ::clarifai::api::WorkflowVersion* Arena::CreateMaybeMessage<::clarifai::api::WorkflowVersion>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace clarifai {
namespace api {

enum Point_Visibility : int {
  Point_Visibility_NOT_SET = 0,
  Point_Visibility_VISIBLE = 1,
  Point_Visibility_NOT_VISIBLE = 2,
  Point_Visibility_NOT_PRESENT = 3,
  Point_Visibility_Point_Visibility_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Point_Visibility_Point_Visibility_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Point_Visibility_IsValid(int value);
constexpr Point_Visibility Point_Visibility_Visibility_MIN = Point_Visibility_NOT_SET;
constexpr Point_Visibility Point_Visibility_Visibility_MAX = Point_Visibility_NOT_PRESENT;
constexpr int Point_Visibility_Visibility_ARRAYSIZE = Point_Visibility_Visibility_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Point_Visibility_descriptor();
template<typename T>
inline const std::string& Point_Visibility_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Point_Visibility>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Point_Visibility_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Point_Visibility_descriptor(), enum_t_value);
}
inline bool Point_Visibility_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Point_Visibility* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Point_Visibility>(
    Point_Visibility_descriptor(), name, value);
}
enum ModelTypeField_ModelTypeFieldType : int {
  ModelTypeField_ModelTypeFieldType_INVALID_MODEL_TYPE_FIELD_TYPE = 0,
  ModelTypeField_ModelTypeFieldType_BOOLEAN = 1,
  ModelTypeField_ModelTypeFieldType_STRING = 2,
  ModelTypeField_ModelTypeFieldType_NUMBER = 3,
  ModelTypeField_ModelTypeFieldType_ARRAY_OF_CONCEPTS = 4,
  ModelTypeField_ModelTypeFieldType_ARRAY_OF_CONCEPTS_WITH_THRESHOLD = 5,
  ModelTypeField_ModelTypeFieldType_RANGE = 7,
  ModelTypeField_ModelTypeFieldType_ENUM = 8,
  ModelTypeField_ModelTypeFieldType_COLLABORATORS = 9,
  ModelTypeField_ModelTypeFieldType_JSON = 10,
  ModelTypeField_ModelTypeFieldType_ARRAY_OF_NUMBERS = 11,
  ModelTypeField_ModelTypeFieldType_WORKFLOW_EMBED_MODELS = 12,
  ModelTypeField_ModelTypeFieldType_ARRAY_OF_STRINGS = 13,
  ModelTypeField_ModelTypeFieldType_RECURSIVE_ENUM = 14,
  ModelTypeField_ModelTypeFieldType_PYTHON_CODE = 15,
  ModelTypeField_ModelTypeFieldType_DATASET_ID = 16,
  ModelTypeField_ModelTypeFieldType_DATASET_VERSION_ID = 17,
  ModelTypeField_ModelTypeFieldType_ModelTypeField_ModelTypeFieldType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ModelTypeField_ModelTypeFieldType_ModelTypeField_ModelTypeFieldType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ModelTypeField_ModelTypeFieldType_IsValid(int value);
constexpr ModelTypeField_ModelTypeFieldType ModelTypeField_ModelTypeFieldType_ModelTypeFieldType_MIN = ModelTypeField_ModelTypeFieldType_INVALID_MODEL_TYPE_FIELD_TYPE;
constexpr ModelTypeField_ModelTypeFieldType ModelTypeField_ModelTypeFieldType_ModelTypeFieldType_MAX = ModelTypeField_ModelTypeFieldType_DATASET_VERSION_ID;
constexpr int ModelTypeField_ModelTypeFieldType_ModelTypeFieldType_ARRAYSIZE = ModelTypeField_ModelTypeFieldType_ModelTypeFieldType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelTypeField_ModelTypeFieldType_descriptor();
template<typename T>
inline const std::string& ModelTypeField_ModelTypeFieldType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModelTypeField_ModelTypeFieldType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModelTypeField_ModelTypeFieldType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModelTypeField_ModelTypeFieldType_descriptor(), enum_t_value);
}
inline bool ModelTypeField_ModelTypeFieldType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModelTypeField_ModelTypeFieldType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModelTypeField_ModelTypeFieldType>(
    ModelTypeField_ModelTypeFieldType_descriptor(), name, value);
}
enum Task_TaskType : int {
  Task_TaskType_TYPE_NOT_SET = 0,
  Task_TaskType_CONCEPTS_CLASSIFICATION = 1,
  Task_TaskType_BOUNDING_BOX_DETECTION = 2,
  Task_TaskType_POLYGON_DETECTION = 3,
  Task_TaskType_Task_TaskType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Task_TaskType_Task_TaskType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Task_TaskType_IsValid(int value);
constexpr Task_TaskType Task_TaskType_TaskType_MIN = Task_TaskType_TYPE_NOT_SET;
constexpr Task_TaskType Task_TaskType_TaskType_MAX = Task_TaskType_POLYGON_DETECTION;
constexpr int Task_TaskType_TaskType_ARRAYSIZE = Task_TaskType_TaskType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Task_TaskType_descriptor();
template<typename T>
inline const std::string& Task_TaskType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Task_TaskType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Task_TaskType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Task_TaskType_descriptor(), enum_t_value);
}
inline bool Task_TaskType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Task_TaskType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Task_TaskType>(
    Task_TaskType_descriptor(), name, value);
}
enum TaskWorker_TaskWorkerStrategy : int {
  TaskWorker_TaskWorkerStrategy_WORKER_STRATEGY_NOT_SET = 0,
  TaskWorker_TaskWorkerStrategy_PARTITIONED = 2,
  TaskWorker_TaskWorkerStrategy_FULL = 3,
  TaskWorker_TaskWorkerStrategy_TaskWorker_TaskWorkerStrategy_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TaskWorker_TaskWorkerStrategy_TaskWorker_TaskWorkerStrategy_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TaskWorker_TaskWorkerStrategy_IsValid(int value);
constexpr TaskWorker_TaskWorkerStrategy TaskWorker_TaskWorkerStrategy_TaskWorkerStrategy_MIN = TaskWorker_TaskWorkerStrategy_WORKER_STRATEGY_NOT_SET;
constexpr TaskWorker_TaskWorkerStrategy TaskWorker_TaskWorkerStrategy_TaskWorkerStrategy_MAX = TaskWorker_TaskWorkerStrategy_FULL;
constexpr int TaskWorker_TaskWorkerStrategy_TaskWorkerStrategy_ARRAYSIZE = TaskWorker_TaskWorkerStrategy_TaskWorkerStrategy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaskWorker_TaskWorkerStrategy_descriptor();
template<typename T>
inline const std::string& TaskWorker_TaskWorkerStrategy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskWorker_TaskWorkerStrategy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskWorker_TaskWorkerStrategy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TaskWorker_TaskWorkerStrategy_descriptor(), enum_t_value);
}
inline bool TaskWorker_TaskWorkerStrategy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TaskWorker_TaskWorkerStrategy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TaskWorker_TaskWorkerStrategy>(
    TaskWorker_TaskWorkerStrategy_descriptor(), name, value);
}
enum TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy : int {
  TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_PARTITIONED_WORKER_STRATEGY_NOT_SET = 0,
  TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_EVENLY = 1,
  TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_WEIGHTED = 2,
  TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_IsValid(int value);
constexpr TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_TaskWorkerPartitionedStrategy_MIN = TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_PARTITIONED_WORKER_STRATEGY_NOT_SET;
constexpr TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_TaskWorkerPartitionedStrategy_MAX = TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_WEIGHTED;
constexpr int TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_TaskWorkerPartitionedStrategy_ARRAYSIZE = TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_TaskWorkerPartitionedStrategy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_descriptor();
template<typename T>
inline const std::string& TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_descriptor(), enum_t_value);
}
inline bool TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy>(
    TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_descriptor(), name, value);
}
enum TaskInputSource_TaskInputSourceType : int {
  TaskInputSource_TaskInputSourceType_INPUT_SOURCE_TYPE_NOT_SET = 0,
  TaskInputSource_TaskInputSourceType_ALL_INPUTS = 1,
  TaskInputSource_TaskInputSourceType_SAVED_SEARCH = 2,
  TaskInputSource_TaskInputSourceType_DATASET = 3,
  TaskInputSource_TaskInputSourceType_TaskInputSource_TaskInputSourceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TaskInputSource_TaskInputSourceType_TaskInputSource_TaskInputSourceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TaskInputSource_TaskInputSourceType_IsValid(int value);
constexpr TaskInputSource_TaskInputSourceType TaskInputSource_TaskInputSourceType_TaskInputSourceType_MIN = TaskInputSource_TaskInputSourceType_INPUT_SOURCE_TYPE_NOT_SET;
constexpr TaskInputSource_TaskInputSourceType TaskInputSource_TaskInputSourceType_TaskInputSourceType_MAX = TaskInputSource_TaskInputSourceType_DATASET;
constexpr int TaskInputSource_TaskInputSourceType_TaskInputSourceType_ARRAYSIZE = TaskInputSource_TaskInputSourceType_TaskInputSourceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaskInputSource_TaskInputSourceType_descriptor();
template<typename T>
inline const std::string& TaskInputSource_TaskInputSourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskInputSource_TaskInputSourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskInputSource_TaskInputSourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TaskInputSource_TaskInputSourceType_descriptor(), enum_t_value);
}
inline bool TaskInputSource_TaskInputSourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TaskInputSource_TaskInputSourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TaskInputSource_TaskInputSourceType>(
    TaskInputSource_TaskInputSourceType_descriptor(), name, value);
}
enum TaskReview_TaskReviewStrategy : int {
  TaskReview_TaskReviewStrategy_TASK_REVIEW_STRATEGY_NOT_SET = 0,
  TaskReview_TaskReviewStrategy_NONE = 1,
  TaskReview_TaskReviewStrategy_MANUAL = 2,
  TaskReview_TaskReviewStrategy_CONSENSUS = 3,
  TaskReview_TaskReviewStrategy_TaskReview_TaskReviewStrategy_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TaskReview_TaskReviewStrategy_TaskReview_TaskReviewStrategy_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TaskReview_TaskReviewStrategy_IsValid(int value);
constexpr TaskReview_TaskReviewStrategy TaskReview_TaskReviewStrategy_TaskReviewStrategy_MIN = TaskReview_TaskReviewStrategy_TASK_REVIEW_STRATEGY_NOT_SET;
constexpr TaskReview_TaskReviewStrategy TaskReview_TaskReviewStrategy_TaskReviewStrategy_MAX = TaskReview_TaskReviewStrategy_CONSENSUS;
constexpr int TaskReview_TaskReviewStrategy_TaskReviewStrategy_ARRAYSIZE = TaskReview_TaskReviewStrategy_TaskReviewStrategy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaskReview_TaskReviewStrategy_descriptor();
template<typename T>
inline const std::string& TaskReview_TaskReviewStrategy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskReview_TaskReviewStrategy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskReview_TaskReviewStrategy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TaskReview_TaskReviewStrategy_descriptor(), enum_t_value);
}
inline bool TaskReview_TaskReviewStrategy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TaskReview_TaskReviewStrategy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TaskReview_TaskReviewStrategy>(
    TaskReview_TaskReviewStrategy_descriptor(), name, value);
}
enum Visibility_Gettable : int {
  Visibility_Gettable_UNKNOWN_VISIBILITY = 0,
  Visibility_Gettable_PRIVATE = 10,
  Visibility_Gettable_ORG = 30,
  Visibility_Gettable_PUBLIC = 50,
  Visibility_Gettable_Visibility_Gettable_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Visibility_Gettable_Visibility_Gettable_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Visibility_Gettable_IsValid(int value);
constexpr Visibility_Gettable Visibility_Gettable_Gettable_MIN = Visibility_Gettable_UNKNOWN_VISIBILITY;
constexpr Visibility_Gettable Visibility_Gettable_Gettable_MAX = Visibility_Gettable_PUBLIC;
constexpr int Visibility_Gettable_Gettable_ARRAYSIZE = Visibility_Gettable_Gettable_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Visibility_Gettable_descriptor();
template<typename T>
inline const std::string& Visibility_Gettable_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Visibility_Gettable>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Visibility_Gettable_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Visibility_Gettable_descriptor(), enum_t_value);
}
inline bool Visibility_Gettable_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Visibility_Gettable* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Visibility_Gettable>(
    Visibility_Gettable_descriptor(), name, value);
}
enum DatasetVersionMetricsGroupType : int {
  DATASET_VERSION_METRICS_GROUP_TYPE_NOT_SET = 0,
  INPUT_TYPE = 2,
  CONCEPT_ID = 10,
  CONCEPTS_COUNT = 11,
  BOUNDING_BOXES_COUNT = 20,
  POLYGONS_COUNT = 21,
  POINTS_COUNT = 22,
  MASKS_COUNT = 23,
  PIXELS_COUNT = 30,
  ASPECT_RATIO = 31,
  DatasetVersionMetricsGroupType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DatasetVersionMetricsGroupType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DatasetVersionMetricsGroupType_IsValid(int value);
constexpr DatasetVersionMetricsGroupType DatasetVersionMetricsGroupType_MIN = DATASET_VERSION_METRICS_GROUP_TYPE_NOT_SET;
constexpr DatasetVersionMetricsGroupType DatasetVersionMetricsGroupType_MAX = ASPECT_RATIO;
constexpr int DatasetVersionMetricsGroupType_ARRAYSIZE = DatasetVersionMetricsGroupType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DatasetVersionMetricsGroupType_descriptor();
template<typename T>
inline const std::string& DatasetVersionMetricsGroupType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DatasetVersionMetricsGroupType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DatasetVersionMetricsGroupType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DatasetVersionMetricsGroupType_descriptor(), enum_t_value);
}
inline bool DatasetVersionMetricsGroupType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DatasetVersionMetricsGroupType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DatasetVersionMetricsGroupType>(
    DatasetVersionMetricsGroupType_descriptor(), name, value);
}
enum DatasetVersionExportFormat : int {
  DATASET_VERSION_EXPORT_FORMAT_NOT_SET = 0,
  CLARIFAI_DATA_PROTOBUF = 1,
  CLARIFAI_DATA_JSON = 3,
  COCO = 2,
  DatasetVersionExportFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DatasetVersionExportFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DatasetVersionExportFormat_IsValid(int value);
constexpr DatasetVersionExportFormat DatasetVersionExportFormat_MIN = DATASET_VERSION_EXPORT_FORMAT_NOT_SET;
constexpr DatasetVersionExportFormat DatasetVersionExportFormat_MAX = CLARIFAI_DATA_JSON;
constexpr int DatasetVersionExportFormat_ARRAYSIZE = DatasetVersionExportFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DatasetVersionExportFormat_descriptor();
template<typename T>
inline const std::string& DatasetVersionExportFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DatasetVersionExportFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DatasetVersionExportFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DatasetVersionExportFormat_descriptor(), enum_t_value);
}
inline bool DatasetVersionExportFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DatasetVersionExportFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DatasetVersionExportFormat>(
    DatasetVersionExportFormat_descriptor(), name, value);
}
enum ExpirationAction : int {
  EXPIRATION_ACTION_NOT_SET = 0,
  DELAY = 1,
  EXPIRY = 2,
  ExpirationAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ExpirationAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ExpirationAction_IsValid(int value);
constexpr ExpirationAction ExpirationAction_MIN = EXPIRATION_ACTION_NOT_SET;
constexpr ExpirationAction ExpirationAction_MAX = EXPIRY;
constexpr int ExpirationAction_ARRAYSIZE = ExpirationAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ExpirationAction_descriptor();
template<typename T>
inline const std::string& ExpirationAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExpirationAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExpirationAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ExpirationAction_descriptor(), enum_t_value);
}
inline bool ExpirationAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExpirationAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ExpirationAction>(
    ExpirationAction_descriptor(), name, value);
}
enum LicenseScope : int {
  LICENSE_SCOPE_NOT_SET = 0,
  PREDICT = 1,
  TRAIN = 2,
  SEARCH = 3,
  LicenseScope_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LicenseScope_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LicenseScope_IsValid(int value);
constexpr LicenseScope LicenseScope_MIN = LICENSE_SCOPE_NOT_SET;
constexpr LicenseScope LicenseScope_MAX = SEARCH;
constexpr int LicenseScope_ARRAYSIZE = LicenseScope_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LicenseScope_descriptor();
template<typename T>
inline const std::string& LicenseScope_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LicenseScope>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LicenseScope_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LicenseScope_descriptor(), enum_t_value);
}
inline bool LicenseScope_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LicenseScope* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LicenseScope>(
    LicenseScope_descriptor(), name, value);
}
enum DataType : int {
  UNDEFINED = 0,
  STRING = 1,
  UINT8 = 2,
  INT32 = 3,
  INT64 = 4,
  FP32 = 5,
  DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DataType_IsValid(int value);
constexpr DataType DataType_MIN = UNDEFINED;
constexpr DataType DataType_MAX = FP32;
constexpr int DataType_ARRAYSIZE = DataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataType_descriptor();
template<typename T>
inline const std::string& DataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataType_descriptor(), enum_t_value);
}
inline bool DataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataType>(
    DataType_descriptor(), name, value);
}
enum ValueComparator : int {
  CONCEPT_THRESHOLD_NOT_SET = 0,
  GREATER_THAN = 1,
  GREATER_THAN_OR_EQUAL = 2,
  LESS_THAN = 3,
  LESS_THAN_OR_EQUAL = 4,
  EQUAL = 5,
  ValueComparator_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ValueComparator_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ValueComparator_IsValid(int value);
constexpr ValueComparator ValueComparator_MIN = CONCEPT_THRESHOLD_NOT_SET;
constexpr ValueComparator ValueComparator_MAX = EQUAL;
constexpr int ValueComparator_ARRAYSIZE = ValueComparator_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ValueComparator_descriptor();
template<typename T>
inline const std::string& ValueComparator_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ValueComparator>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ValueComparator_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ValueComparator_descriptor(), enum_t_value);
}
inline bool ValueComparator_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ValueComparator* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ValueComparator>(
    ValueComparator_descriptor(), name, value);
}
enum EvaluationType : int {
  Undefined = 0,
  Classification = 1,
  Detection = 2,
  Segmentation = 3,
  Clustering = 4,
  Tracker = 5,
  EvaluationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EvaluationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EvaluationType_IsValid(int value);
constexpr EvaluationType EvaluationType_MIN = Undefined;
constexpr EvaluationType EvaluationType_MAX = Tracker;
constexpr int EvaluationType_ARRAYSIZE = EvaluationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EvaluationType_descriptor();
template<typename T>
inline const std::string& EvaluationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EvaluationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EvaluationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EvaluationType_descriptor(), enum_t_value);
}
inline bool EvaluationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EvaluationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EvaluationType>(
    EvaluationType_descriptor(), name, value);
}
enum APIEventType : int {
  API_EVENT_TYPE_NOT_SET = 0,
  ON_PREM_PREDICT = 1,
  ON_PREM_TRAIN = 2,
  ON_PREM_SEARCH = 3,
  APIEventType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  APIEventType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool APIEventType_IsValid(int value);
constexpr APIEventType APIEventType_MIN = API_EVENT_TYPE_NOT_SET;
constexpr APIEventType APIEventType_MAX = ON_PREM_SEARCH;
constexpr int APIEventType_ARRAYSIZE = APIEventType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* APIEventType_descriptor();
template<typename T>
inline const std::string& APIEventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, APIEventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function APIEventType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    APIEventType_descriptor(), enum_t_value);
}
inline bool APIEventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, APIEventType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<APIEventType>(
    APIEventType_descriptor(), name, value);
}
enum UsageIntervalType : int {
  undef = 0,
  day = 1,
  month = 2,
  year = 3,
  UsageIntervalType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UsageIntervalType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UsageIntervalType_IsValid(int value);
constexpr UsageIntervalType UsageIntervalType_MIN = undef;
constexpr UsageIntervalType UsageIntervalType_MAX = year;
constexpr int UsageIntervalType_ARRAYSIZE = UsageIntervalType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UsageIntervalType_descriptor();
template<typename T>
inline const std::string& UsageIntervalType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UsageIntervalType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UsageIntervalType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UsageIntervalType_descriptor(), enum_t_value);
}
inline bool UsageIntervalType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UsageIntervalType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UsageIntervalType>(
    UsageIntervalType_descriptor(), name, value);
}
enum RoleType : int {
  TEAM = 0,
  ORG = 1,
  RoleType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RoleType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RoleType_IsValid(int value);
constexpr RoleType RoleType_MIN = TEAM;
constexpr RoleType RoleType_MAX = ORG;
constexpr int RoleType_ARRAYSIZE = RoleType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RoleType_descriptor();
template<typename T>
inline const std::string& RoleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RoleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RoleType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RoleType_descriptor(), enum_t_value);
}
inline bool RoleType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RoleType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RoleType>(
    RoleType_descriptor(), name, value);
}
enum StatValueAggType : int {
  SUM = 0,
  AVG = 1,
  StatValueAggType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StatValueAggType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StatValueAggType_IsValid(int value);
constexpr StatValueAggType StatValueAggType_MIN = SUM;
constexpr StatValueAggType StatValueAggType_MAX = AVG;
constexpr int StatValueAggType_ARRAYSIZE = StatValueAggType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StatValueAggType_descriptor();
template<typename T>
inline const std::string& StatValueAggType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StatValueAggType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StatValueAggType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StatValueAggType_descriptor(), enum_t_value);
}
inline bool StatValueAggType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StatValueAggType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StatValueAggType>(
    StatValueAggType_descriptor(), name, value);
}
enum StatTimeAggType : int {
  NO_TIME_AGG = 0,
  YEAR = 1,
  MONTH = 2,
  WEEK = 3,
  DAY = 4,
  HOUR = 5,
  MINUTE = 6,
  StatTimeAggType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StatTimeAggType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StatTimeAggType_IsValid(int value);
constexpr StatTimeAggType StatTimeAggType_MIN = NO_TIME_AGG;
constexpr StatTimeAggType StatTimeAggType_MAX = MINUTE;
constexpr int StatTimeAggType_ARRAYSIZE = StatTimeAggType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StatTimeAggType_descriptor();
template<typename T>
inline const std::string& StatTimeAggType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StatTimeAggType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StatTimeAggType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StatTimeAggType_descriptor(), enum_t_value);
}
inline bool StatTimeAggType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StatTimeAggType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StatTimeAggType>(
    StatTimeAggType_descriptor(), name, value);
}
enum ValidationErrorType : int {
  VALIDATION_ERROR_TYPE_NOT_SET = 0,
  RESTRICTED = 1,
  DATABASE = 2,
  FORMAT = 3,
  ValidationErrorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ValidationErrorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ValidationErrorType_IsValid(int value);
constexpr ValidationErrorType ValidationErrorType_MIN = VALIDATION_ERROR_TYPE_NOT_SET;
constexpr ValidationErrorType ValidationErrorType_MAX = FORMAT;
constexpr int ValidationErrorType_ARRAYSIZE = ValidationErrorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ValidationErrorType_descriptor();
template<typename T>
inline const std::string& ValidationErrorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ValidationErrorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ValidationErrorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ValidationErrorType_descriptor(), enum_t_value);
}
inline bool ValidationErrorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ValidationErrorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ValidationErrorType>(
    ValidationErrorType_descriptor(), name, value);
}
// ===================================================================

class Annotation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Annotation) */ {
 public:
  inline Annotation() : Annotation(nullptr) {}
  ~Annotation() override;
  explicit PROTOBUF_CONSTEXPR Annotation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Annotation(const Annotation& from);
  Annotation(Annotation&& from) noexcept
    : Annotation() {
    *this = ::std::move(from);
  }

  inline Annotation& operator=(const Annotation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Annotation& operator=(Annotation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Annotation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Annotation* internal_default_instance() {
    return reinterpret_cast<const Annotation*>(
               &_Annotation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Annotation& a, Annotation& b) {
    a.Swap(&b);
  }
  inline void Swap(Annotation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Annotation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Annotation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Annotation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Annotation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Annotation& from) {
    Annotation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Annotation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Annotation";
  }
  protected:
  explicit Annotation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kInputIdFieldNumber = 2,
    kEmbedModelVersionIdFieldNumber = 14,
    kUserIdFieldNumber = 15,
    kModelVersionIdFieldNumber = 16,
    kTaskIdFieldNumber = 19,
    kDataFieldNumber = 3,
    kStatusFieldNumber = 7,
    kCreatedAtFieldNumber = 8,
    kModifiedAtFieldNumber = 9,
    kAnnotationInfoFieldNumber = 13,
    kConsensusInfoFieldNumber = 18,
    kTrustedFieldNumber = 10,
    kInputLevelFieldNumber = 17,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string input_id = 2;
  void clear_input_id();
  const std::string& input_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_input_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_input_id();
  PROTOBUF_NODISCARD std::string* release_input_id();
  void set_allocated_input_id(std::string* input_id);
  private:
  const std::string& _internal_input_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_input_id(const std::string& value);
  std::string* _internal_mutable_input_id();
  public:

  // string embed_model_version_id = 14 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_embed_model_version_id();
  PROTOBUF_DEPRECATED const std::string& embed_model_version_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_embed_model_version_id(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_embed_model_version_id();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_embed_model_version_id();
  PROTOBUF_DEPRECATED void set_allocated_embed_model_version_id(std::string* embed_model_version_id);
  private:
  const std::string& _internal_embed_model_version_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_embed_model_version_id(const std::string& value);
  std::string* _internal_mutable_embed_model_version_id();
  public:

  // string user_id = 15;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string model_version_id = 16;
  void clear_model_version_id();
  const std::string& model_version_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_version_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_version_id();
  PROTOBUF_NODISCARD std::string* release_model_version_id();
  void set_allocated_model_version_id(std::string* model_version_id);
  private:
  const std::string& _internal_model_version_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_version_id(const std::string& value);
  std::string* _internal_mutable_model_version_id();
  public:

  // string task_id = 19;
  void clear_task_id();
  const std::string& task_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_id();
  PROTOBUF_NODISCARD std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);
  private:
  const std::string& _internal_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(const std::string& value);
  std::string* _internal_mutable_task_id();
  public:

  // .clarifai.api.Data data = 3;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::clarifai::api::Data& data() const;
  PROTOBUF_NODISCARD ::clarifai::api::Data* release_data();
  ::clarifai::api::Data* mutable_data();
  void set_allocated_data(::clarifai::api::Data* data);
  private:
  const ::clarifai::api::Data& _internal_data() const;
  ::clarifai::api::Data* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::clarifai::api::Data* data);
  ::clarifai::api::Data* unsafe_arena_release_data();

  // .clarifai.api.status.Status status = 7;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::clarifai::api::status::Status& status() const;
  PROTOBUF_NODISCARD ::clarifai::api::status::Status* release_status();
  ::clarifai::api::status::Status* mutable_status();
  void set_allocated_status(::clarifai::api::status::Status* status);
  private:
  const ::clarifai::api::status::Status& _internal_status() const;
  ::clarifai::api::status::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::clarifai::api::status::Status* status);
  ::clarifai::api::status::Status* unsafe_arena_release_status();

  // .google.protobuf.Timestamp created_at = 8;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp modified_at = 9;
  bool has_modified_at() const;
  private:
  bool _internal_has_modified_at() const;
  public:
  void clear_modified_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& modified_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_modified_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_modified_at();
  void set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_modified_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_modified_at();
  public:
  void unsafe_arena_set_allocated_modified_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_modified_at();

  // .google.protobuf.Struct annotation_info = 13;
  bool has_annotation_info() const;
  private:
  bool _internal_has_annotation_info() const;
  public:
  void clear_annotation_info();
  const ::PROTOBUF_NAMESPACE_ID::Struct& annotation_info() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_annotation_info();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_annotation_info();
  void set_allocated_annotation_info(::PROTOBUF_NAMESPACE_ID::Struct* annotation_info);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_annotation_info() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_annotation_info();
  public:
  void unsafe_arena_set_allocated_annotation_info(
      ::PROTOBUF_NAMESPACE_ID::Struct* annotation_info);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_annotation_info();

  // .google.protobuf.Struct consensus_info = 18;
  bool has_consensus_info() const;
  private:
  bool _internal_has_consensus_info() const;
  public:
  void clear_consensus_info();
  const ::PROTOBUF_NAMESPACE_ID::Struct& consensus_info() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_consensus_info();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_consensus_info();
  void set_allocated_consensus_info(::PROTOBUF_NAMESPACE_ID::Struct* consensus_info);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_consensus_info() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_consensus_info();
  public:
  void unsafe_arena_set_allocated_consensus_info(
      ::PROTOBUF_NAMESPACE_ID::Struct* consensus_info);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_consensus_info();

  // bool trusted = 10 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_trusted();
  PROTOBUF_DEPRECATED bool trusted() const;
  PROTOBUF_DEPRECATED void set_trusted(bool value);
  private:
  bool _internal_trusted() const;
  void _internal_set_trusted(bool value);
  public:

  // bool input_level = 17;
  void clear_input_level();
  bool input_level() const;
  void set_input_level(bool value);
  private:
  bool _internal_input_level() const;
  void _internal_set_input_level(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.Annotation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr input_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr embed_model_version_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_version_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
    ::clarifai::api::Data* data_;
    ::clarifai::api::status::Status* status_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at_;
    ::PROTOBUF_NAMESPACE_ID::Struct* annotation_info_;
    ::PROTOBUF_NAMESPACE_ID::Struct* consensus_info_;
    bool trusted_;
    bool input_level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class App final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.App) */ {
 public:
  inline App() : App(nullptr) {}
  ~App() override;
  explicit PROTOBUF_CONSTEXPR App(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  App(const App& from);
  App(App&& from) noexcept
    : App() {
    *this = ::std::move(from);
  }

  inline App& operator=(const App& from) {
    CopyFrom(from);
    return *this;
  }
  inline App& operator=(App&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const App& default_instance() {
    return *internal_default_instance();
  }
  static inline const App* internal_default_instance() {
    return reinterpret_cast<const App*>(
               &_App_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(App& a, App& b) {
    a.Swap(&b);
  }
  inline void Swap(App* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(App* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  App* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<App>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const App& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const App& from) {
    App::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(App* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.App";
  }
  protected:
  explicit App(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kDefaultLanguageFieldNumber = 3,
    kDefaultWorkflowIdFieldNumber = 4,
    kUserIdFieldNumber = 5,
    kDescriptionFieldNumber = 14,
    kDataTierIdFieldNumber = 18,
    kNotesFieldNumber = 21,
    kCreatedAtFieldNumber = 6,
    kMetadataFieldNumber = 13,
    kVisibilityFieldNumber = 16,
    kModifiedAtFieldNumber = 17,
    kImageFieldNumber = 22,
    kLegalConsentStatusFieldNumber = 7,
    kSampleMsFieldNumber = 15,
    kIsStarredFieldNumber = 19,
    kStarCountFieldNumber = 20,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string default_language = 3;
  void clear_default_language();
  const std::string& default_language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_default_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_default_language();
  PROTOBUF_NODISCARD std::string* release_default_language();
  void set_allocated_default_language(std::string* default_language);
  private:
  const std::string& _internal_default_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_language(const std::string& value);
  std::string* _internal_mutable_default_language();
  public:

  // string default_workflow_id = 4;
  void clear_default_workflow_id();
  const std::string& default_workflow_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_default_workflow_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_default_workflow_id();
  PROTOBUF_NODISCARD std::string* release_default_workflow_id();
  void set_allocated_default_workflow_id(std::string* default_workflow_id);
  private:
  const std::string& _internal_default_workflow_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_workflow_id(const std::string& value);
  std::string* _internal_mutable_default_workflow_id();
  public:

  // string user_id = 5;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string description = 14;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string data_tier_id = 18;
  void clear_data_tier_id();
  const std::string& data_tier_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data_tier_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data_tier_id();
  PROTOBUF_NODISCARD std::string* release_data_tier_id();
  void set_allocated_data_tier_id(std::string* data_tier_id);
  private:
  const std::string& _internal_data_tier_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_tier_id(const std::string& value);
  std::string* _internal_mutable_data_tier_id();
  public:

  // string notes = 21;
  void clear_notes();
  const std::string& notes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_notes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_notes();
  PROTOBUF_NODISCARD std::string* release_notes();
  void set_allocated_notes(std::string* notes);
  private:
  const std::string& _internal_notes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_notes(const std::string& value);
  std::string* _internal_mutable_notes();
  public:

  // .google.protobuf.Timestamp created_at = 6;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Struct metadata = 13;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  void set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata();

  // .clarifai.api.Visibility visibility = 16;
  bool has_visibility() const;
  private:
  bool _internal_has_visibility() const;
  public:
  void clear_visibility();
  const ::clarifai::api::Visibility& visibility() const;
  PROTOBUF_NODISCARD ::clarifai::api::Visibility* release_visibility();
  ::clarifai::api::Visibility* mutable_visibility();
  void set_allocated_visibility(::clarifai::api::Visibility* visibility);
  private:
  const ::clarifai::api::Visibility& _internal_visibility() const;
  ::clarifai::api::Visibility* _internal_mutable_visibility();
  public:
  void unsafe_arena_set_allocated_visibility(
      ::clarifai::api::Visibility* visibility);
  ::clarifai::api::Visibility* unsafe_arena_release_visibility();

  // .google.protobuf.Timestamp modified_at = 17;
  bool has_modified_at() const;
  private:
  bool _internal_has_modified_at() const;
  public:
  void clear_modified_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& modified_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_modified_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_modified_at();
  void set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_modified_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_modified_at();
  public:
  void unsafe_arena_set_allocated_modified_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_modified_at();

  // .clarifai.api.Image image = 22;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::clarifai::api::Image& image() const;
  PROTOBUF_NODISCARD ::clarifai::api::Image* release_image();
  ::clarifai::api::Image* mutable_image();
  void set_allocated_image(::clarifai::api::Image* image);
  private:
  const ::clarifai::api::Image& _internal_image() const;
  ::clarifai::api::Image* _internal_mutable_image();
  public:
  void unsafe_arena_set_allocated_image(
      ::clarifai::api::Image* image);
  ::clarifai::api::Image* unsafe_arena_release_image();

  // uint32 legal_consent_status = 7;
  void clear_legal_consent_status();
  uint32_t legal_consent_status() const;
  void set_legal_consent_status(uint32_t value);
  private:
  uint32_t _internal_legal_consent_status() const;
  void _internal_set_legal_consent_status(uint32_t value);
  public:

  // uint32 sample_ms = 15;
  void clear_sample_ms();
  uint32_t sample_ms() const;
  void set_sample_ms(uint32_t value);
  private:
  uint32_t _internal_sample_ms() const;
  void _internal_set_sample_ms(uint32_t value);
  public:

  // bool is_starred = 19;
  void clear_is_starred();
  bool is_starred() const;
  void set_is_starred(bool value);
  private:
  bool _internal_is_starred() const;
  void _internal_set_is_starred(bool value);
  public:

  // int32 star_count = 20;
  void clear_star_count();
  int32_t star_count() const;
  void set_star_count(int32_t value);
  private:
  int32_t _internal_star_count() const;
  void _internal_set_star_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.App)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_language_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_workflow_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_tier_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr notes_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_;
    ::clarifai::api::Visibility* visibility_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at_;
    ::clarifai::api::Image* image_;
    uint32_t legal_consent_status_;
    uint32_t sample_ms_;
    bool is_starred_;
    int32_t star_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class AppQuery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.AppQuery) */ {
 public:
  inline AppQuery() : AppQuery(nullptr) {}
  ~AppQuery() override;
  explicit PROTOBUF_CONSTEXPR AppQuery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppQuery(const AppQuery& from);
  AppQuery(AppQuery&& from) noexcept
    : AppQuery() {
    *this = ::std::move(from);
  }

  inline AppQuery& operator=(const AppQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppQuery& operator=(AppQuery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppQuery& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppQuery* internal_default_instance() {
    return reinterpret_cast<const AppQuery*>(
               &_AppQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AppQuery& a, AppQuery& b) {
    a.Swap(&b);
  }
  inline void Swap(AppQuery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppQuery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppQuery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppQuery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppQuery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppQuery& from) {
    AppQuery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppQuery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.AppQuery";
  }
  protected:
  explicit AppQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.AppQuery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Collaborator final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Collaborator) */ {
 public:
  inline Collaborator() : Collaborator(nullptr) {}
  ~Collaborator() override;
  explicit PROTOBUF_CONSTEXPR Collaborator(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Collaborator(const Collaborator& from);
  Collaborator(Collaborator&& from) noexcept
    : Collaborator() {
    *this = ::std::move(from);
  }

  inline Collaborator& operator=(const Collaborator& from) {
    CopyFrom(from);
    return *this;
  }
  inline Collaborator& operator=(Collaborator&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Collaborator& default_instance() {
    return *internal_default_instance();
  }
  static inline const Collaborator* internal_default_instance() {
    return reinterpret_cast<const Collaborator*>(
               &_Collaborator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Collaborator& a, Collaborator& b) {
    a.Swap(&b);
  }
  inline void Swap(Collaborator* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Collaborator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Collaborator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Collaborator>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Collaborator& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Collaborator& from) {
    Collaborator::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Collaborator* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Collaborator";
  }
  protected:
  explicit Collaborator(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScopesFieldNumber = 4,
    kEndpointsFieldNumber = 5,
    kIdFieldNumber = 1,
    kAppFieldNumber = 2,
    kUserFieldNumber = 3,
    kCreatedAtFieldNumber = 6,
    kModifiedAtFieldNumber = 7,
    kDeletedAtFieldNumber = 8,
  };
  // repeated string scopes = 4;
  int scopes_size() const;
  private:
  int _internal_scopes_size() const;
  public:
  void clear_scopes();
  const std::string& scopes(int index) const;
  std::string* mutable_scopes(int index);
  void set_scopes(int index, const std::string& value);
  void set_scopes(int index, std::string&& value);
  void set_scopes(int index, const char* value);
  void set_scopes(int index, const char* value, size_t size);
  std::string* add_scopes();
  void add_scopes(const std::string& value);
  void add_scopes(std::string&& value);
  void add_scopes(const char* value);
  void add_scopes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& scopes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_scopes();
  private:
  const std::string& _internal_scopes(int index) const;
  std::string* _internal_add_scopes();
  public:

  // repeated string endpoints = 5;
  int endpoints_size() const;
  private:
  int _internal_endpoints_size() const;
  public:
  void clear_endpoints();
  const std::string& endpoints(int index) const;
  std::string* mutable_endpoints(int index);
  void set_endpoints(int index, const std::string& value);
  void set_endpoints(int index, std::string&& value);
  void set_endpoints(int index, const char* value);
  void set_endpoints(int index, const char* value, size_t size);
  std::string* add_endpoints();
  void add_endpoints(const std::string& value);
  void add_endpoints(std::string&& value);
  void add_endpoints(const char* value);
  void add_endpoints(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& endpoints() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_endpoints();
  private:
  const std::string& _internal_endpoints(int index) const;
  std::string* _internal_add_endpoints();
  public:

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .clarifai.api.App app = 2;
  bool has_app() const;
  private:
  bool _internal_has_app() const;
  public:
  void clear_app();
  const ::clarifai::api::App& app() const;
  PROTOBUF_NODISCARD ::clarifai::api::App* release_app();
  ::clarifai::api::App* mutable_app();
  void set_allocated_app(::clarifai::api::App* app);
  private:
  const ::clarifai::api::App& _internal_app() const;
  ::clarifai::api::App* _internal_mutable_app();
  public:
  void unsafe_arena_set_allocated_app(
      ::clarifai::api::App* app);
  ::clarifai::api::App* unsafe_arena_release_app();

  // .clarifai.api.User user = 3;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::clarifai::api::User& user() const;
  PROTOBUF_NODISCARD ::clarifai::api::User* release_user();
  ::clarifai::api::User* mutable_user();
  void set_allocated_user(::clarifai::api::User* user);
  private:
  const ::clarifai::api::User& _internal_user() const;
  ::clarifai::api::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::clarifai::api::User* user);
  ::clarifai::api::User* unsafe_arena_release_user();

  // .google.protobuf.Timestamp created_at = 6;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp modified_at = 7;
  bool has_modified_at() const;
  private:
  bool _internal_has_modified_at() const;
  public:
  void clear_modified_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& modified_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_modified_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_modified_at();
  void set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_modified_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_modified_at();
  public:
  void unsafe_arena_set_allocated_modified_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_modified_at();

  // .google.protobuf.Timestamp deleted_at = 8;
  bool has_deleted_at() const;
  private:
  bool _internal_has_deleted_at() const;
  public:
  void clear_deleted_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& deleted_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_deleted_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_deleted_at();
  void set_allocated_deleted_at(::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_deleted_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_deleted_at();
  public:
  void unsafe_arena_set_allocated_deleted_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_deleted_at();

  // @@protoc_insertion_point(class_scope:clarifai.api.Collaborator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> scopes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> endpoints_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::clarifai::api::App* app_;
    ::clarifai::api::User* user_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Collaboration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Collaboration) */ {
 public:
  inline Collaboration() : Collaboration(nullptr) {}
  ~Collaboration() override;
  explicit PROTOBUF_CONSTEXPR Collaboration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Collaboration(const Collaboration& from);
  Collaboration(Collaboration&& from) noexcept
    : Collaboration() {
    *this = ::std::move(from);
  }

  inline Collaboration& operator=(const Collaboration& from) {
    CopyFrom(from);
    return *this;
  }
  inline Collaboration& operator=(Collaboration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Collaboration& default_instance() {
    return *internal_default_instance();
  }
  static inline const Collaboration* internal_default_instance() {
    return reinterpret_cast<const Collaboration*>(
               &_Collaboration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Collaboration& a, Collaboration& b) {
    a.Swap(&b);
  }
  inline void Swap(Collaboration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Collaboration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Collaboration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Collaboration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Collaboration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Collaboration& from) {
    Collaboration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Collaboration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Collaboration";
  }
  protected:
  explicit Collaboration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScopesFieldNumber = 3,
    kEndpointsFieldNumber = 4,
    kAppFieldNumber = 1,
    kAppOwnerFieldNumber = 2,
    kCreatedAtFieldNumber = 5,
  };
  // repeated string scopes = 3;
  int scopes_size() const;
  private:
  int _internal_scopes_size() const;
  public:
  void clear_scopes();
  const std::string& scopes(int index) const;
  std::string* mutable_scopes(int index);
  void set_scopes(int index, const std::string& value);
  void set_scopes(int index, std::string&& value);
  void set_scopes(int index, const char* value);
  void set_scopes(int index, const char* value, size_t size);
  std::string* add_scopes();
  void add_scopes(const std::string& value);
  void add_scopes(std::string&& value);
  void add_scopes(const char* value);
  void add_scopes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& scopes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_scopes();
  private:
  const std::string& _internal_scopes(int index) const;
  std::string* _internal_add_scopes();
  public:

  // repeated string endpoints = 4;
  int endpoints_size() const;
  private:
  int _internal_endpoints_size() const;
  public:
  void clear_endpoints();
  const std::string& endpoints(int index) const;
  std::string* mutable_endpoints(int index);
  void set_endpoints(int index, const std::string& value);
  void set_endpoints(int index, std::string&& value);
  void set_endpoints(int index, const char* value);
  void set_endpoints(int index, const char* value, size_t size);
  std::string* add_endpoints();
  void add_endpoints(const std::string& value);
  void add_endpoints(std::string&& value);
  void add_endpoints(const char* value);
  void add_endpoints(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& endpoints() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_endpoints();
  private:
  const std::string& _internal_endpoints(int index) const;
  std::string* _internal_add_endpoints();
  public:

  // .clarifai.api.App app = 1;
  bool has_app() const;
  private:
  bool _internal_has_app() const;
  public:
  void clear_app();
  const ::clarifai::api::App& app() const;
  PROTOBUF_NODISCARD ::clarifai::api::App* release_app();
  ::clarifai::api::App* mutable_app();
  void set_allocated_app(::clarifai::api::App* app);
  private:
  const ::clarifai::api::App& _internal_app() const;
  ::clarifai::api::App* _internal_mutable_app();
  public:
  void unsafe_arena_set_allocated_app(
      ::clarifai::api::App* app);
  ::clarifai::api::App* unsafe_arena_release_app();

  // .clarifai.api.User app_owner = 2;
  bool has_app_owner() const;
  private:
  bool _internal_has_app_owner() const;
  public:
  void clear_app_owner();
  const ::clarifai::api::User& app_owner() const;
  PROTOBUF_NODISCARD ::clarifai::api::User* release_app_owner();
  ::clarifai::api::User* mutable_app_owner();
  void set_allocated_app_owner(::clarifai::api::User* app_owner);
  private:
  const ::clarifai::api::User& _internal_app_owner() const;
  ::clarifai::api::User* _internal_mutable_app_owner();
  public:
  void unsafe_arena_set_allocated_app_owner(
      ::clarifai::api::User* app_owner);
  ::clarifai::api::User* unsafe_arena_release_app_owner();

  // .google.protobuf.Timestamp created_at = 5;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // @@protoc_insertion_point(class_scope:clarifai.api.Collaboration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> scopes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> endpoints_;
    ::clarifai::api::App* app_;
    ::clarifai::api::User* app_owner_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Audio final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Audio) */ {
 public:
  inline Audio() : Audio(nullptr) {}
  ~Audio() override;
  explicit PROTOBUF_CONSTEXPR Audio(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Audio(const Audio& from);
  Audio(Audio&& from) noexcept
    : Audio() {
    *this = ::std::move(from);
  }

  inline Audio& operator=(const Audio& from) {
    CopyFrom(from);
    return *this;
  }
  inline Audio& operator=(Audio&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Audio& default_instance() {
    return *internal_default_instance();
  }
  static inline const Audio* internal_default_instance() {
    return reinterpret_cast<const Audio*>(
               &_Audio_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Audio& a, Audio& b) {
    a.Swap(&b);
  }
  inline void Swap(Audio* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Audio* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Audio* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Audio>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Audio& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Audio& from) {
    Audio::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Audio* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Audio";
  }
  protected:
  explicit Audio(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kBase64FieldNumber = 2,
    kHostedFieldNumber = 5,
    kAudioInfoFieldNumber = 6,
    kAllowDuplicateUrlFieldNumber = 4,
  };
  // string url = 1;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // bytes base64 = 2;
  void clear_base64();
  const std::string& base64() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_base64(ArgT0&& arg0, ArgT... args);
  std::string* mutable_base64();
  PROTOBUF_NODISCARD std::string* release_base64();
  void set_allocated_base64(std::string* base64);
  private:
  const std::string& _internal_base64() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base64(const std::string& value);
  std::string* _internal_mutable_base64();
  public:

  // .clarifai.api.HostedURL hosted = 5;
  bool has_hosted() const;
  private:
  bool _internal_has_hosted() const;
  public:
  void clear_hosted();
  const ::clarifai::api::HostedURL& hosted() const;
  PROTOBUF_NODISCARD ::clarifai::api::HostedURL* release_hosted();
  ::clarifai::api::HostedURL* mutable_hosted();
  void set_allocated_hosted(::clarifai::api::HostedURL* hosted);
  private:
  const ::clarifai::api::HostedURL& _internal_hosted() const;
  ::clarifai::api::HostedURL* _internal_mutable_hosted();
  public:
  void unsafe_arena_set_allocated_hosted(
      ::clarifai::api::HostedURL* hosted);
  ::clarifai::api::HostedURL* unsafe_arena_release_hosted();

  // .clarifai.api.AudioInfo audio_info = 6;
  bool has_audio_info() const;
  private:
  bool _internal_has_audio_info() const;
  public:
  void clear_audio_info();
  const ::clarifai::api::AudioInfo& audio_info() const;
  PROTOBUF_NODISCARD ::clarifai::api::AudioInfo* release_audio_info();
  ::clarifai::api::AudioInfo* mutable_audio_info();
  void set_allocated_audio_info(::clarifai::api::AudioInfo* audio_info);
  private:
  const ::clarifai::api::AudioInfo& _internal_audio_info() const;
  ::clarifai::api::AudioInfo* _internal_mutable_audio_info();
  public:
  void unsafe_arena_set_allocated_audio_info(
      ::clarifai::api::AudioInfo* audio_info);
  ::clarifai::api::AudioInfo* unsafe_arena_release_audio_info();

  // bool allow_duplicate_url = 4;
  void clear_allow_duplicate_url();
  bool allow_duplicate_url() const;
  void set_allow_duplicate_url(bool value);
  private:
  bool _internal_allow_duplicate_url() const;
  void _internal_set_allow_duplicate_url(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.Audio)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base64_;
    ::clarifai::api::HostedURL* hosted_;
    ::clarifai::api::AudioInfo* audio_info_;
    bool allow_duplicate_url_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class AudioInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.AudioInfo) */ {
 public:
  inline AudioInfo() : AudioInfo(nullptr) {}
  ~AudioInfo() override;
  explicit PROTOBUF_CONSTEXPR AudioInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioInfo(const AudioInfo& from);
  AudioInfo(AudioInfo&& from) noexcept
    : AudioInfo() {
    *this = ::std::move(from);
  }

  inline AudioInfo& operator=(const AudioInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioInfo& operator=(AudioInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioInfo* internal_default_instance() {
    return reinterpret_cast<const AudioInfo*>(
               &_AudioInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AudioInfo& a, AudioInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioInfo& from) {
    AudioInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.AudioInfo";
  }
  protected:
  explicit AudioInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioFormatFieldNumber = 1,
    kSampleRateFieldNumber = 2,
    kDurationSecondsFieldNumber = 3,
    kBitRateFieldNumber = 4,
  };
  // string audio_format = 1;
  void clear_audio_format();
  const std::string& audio_format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audio_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audio_format();
  PROTOBUF_NODISCARD std::string* release_audio_format();
  void set_allocated_audio_format(std::string* audio_format);
  private:
  const std::string& _internal_audio_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_format(const std::string& value);
  std::string* _internal_mutable_audio_format();
  public:

  // int32 sample_rate = 2;
  void clear_sample_rate();
  int32_t sample_rate() const;
  void set_sample_rate(int32_t value);
  private:
  int32_t _internal_sample_rate() const;
  void _internal_set_sample_rate(int32_t value);
  public:

  // float duration_seconds = 3;
  void clear_duration_seconds();
  float duration_seconds() const;
  void set_duration_seconds(float value);
  private:
  float _internal_duration_seconds() const;
  void _internal_set_duration_seconds(float value);
  public:

  // int32 bit_rate = 4;
  void clear_bit_rate();
  int32_t bit_rate() const;
  void set_bit_rate(int32_t value);
  private:
  int32_t _internal_bit_rate() const;
  void _internal_set_bit_rate(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.AudioInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_format_;
    int32_t sample_rate_;
    float duration_seconds_;
    int32_t bit_rate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Track final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Track) */ {
 public:
  inline Track() : Track(nullptr) {}
  ~Track() override;
  explicit PROTOBUF_CONSTEXPR Track(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Track(const Track& from);
  Track(Track&& from) noexcept
    : Track() {
    *this = ::std::move(from);
  }

  inline Track& operator=(const Track& from) {
    CopyFrom(from);
    return *this;
  }
  inline Track& operator=(Track&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Track& default_instance() {
    return *internal_default_instance();
  }
  static inline const Track* internal_default_instance() {
    return reinterpret_cast<const Track*>(
               &_Track_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Track& a, Track& b) {
    a.Swap(&b);
  }
  inline void Swap(Track* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Track* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Track* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Track>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Track& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Track& from) {
    Track::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Track* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Track";
  }
  protected:
  explicit Track(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kDataFieldNumber = 2,
    kTimeInfoFieldNumber = 4,
    kQualityFieldNumber = 5,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .clarifai.api.Data data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::clarifai::api::Data& data() const;
  PROTOBUF_NODISCARD ::clarifai::api::Data* release_data();
  ::clarifai::api::Data* mutable_data();
  void set_allocated_data(::clarifai::api::Data* data);
  private:
  const ::clarifai::api::Data& _internal_data() const;
  ::clarifai::api::Data* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::clarifai::api::Data* data);
  ::clarifai::api::Data* unsafe_arena_release_data();

  // .clarifai.api.TimeInfo time_info = 4;
  bool has_time_info() const;
  private:
  bool _internal_has_time_info() const;
  public:
  void clear_time_info();
  const ::clarifai::api::TimeInfo& time_info() const;
  PROTOBUF_NODISCARD ::clarifai::api::TimeInfo* release_time_info();
  ::clarifai::api::TimeInfo* mutable_time_info();
  void set_allocated_time_info(::clarifai::api::TimeInfo* time_info);
  private:
  const ::clarifai::api::TimeInfo& _internal_time_info() const;
  ::clarifai::api::TimeInfo* _internal_mutable_time_info();
  public:
  void unsafe_arena_set_allocated_time_info(
      ::clarifai::api::TimeInfo* time_info);
  ::clarifai::api::TimeInfo* unsafe_arena_release_time_info();

  // float quality = 5;
  void clear_quality();
  float quality() const;
  void set_quality(float value);
  private:
  float _internal_quality() const;
  void _internal_set_quality(float value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.Track)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::clarifai::api::Data* data_;
    ::clarifai::api::TimeInfo* time_info_;
    float quality_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Cluster final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Cluster) */ {
 public:
  inline Cluster() : Cluster(nullptr) {}
  ~Cluster() override;
  explicit PROTOBUF_CONSTEXPR Cluster(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Cluster(const Cluster& from);
  Cluster(Cluster&& from) noexcept
    : Cluster() {
    *this = ::std::move(from);
  }

  inline Cluster& operator=(const Cluster& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cluster& operator=(Cluster&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Cluster& default_instance() {
    return *internal_default_instance();
  }
  static inline const Cluster* internal_default_instance() {
    return reinterpret_cast<const Cluster*>(
               &_Cluster_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Cluster& a, Cluster& b) {
    a.Swap(&b);
  }
  inline void Swap(Cluster* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cluster* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Cluster* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Cluster>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Cluster& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Cluster& from) {
    Cluster::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cluster* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Cluster";
  }
  protected:
  explicit Cluster(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHitsFieldNumber = 4,
    kProjectionFieldNumber = 5,
    kIdFieldNumber = 1,
    kCountFieldNumber = 2,
    kScoreFieldNumber = 3,
  };
  // repeated .clarifai.api.Hit hits = 4;
  int hits_size() const;
  private:
  int _internal_hits_size() const;
  public:
  void clear_hits();
  ::clarifai::api::Hit* mutable_hits(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Hit >*
      mutable_hits();
  private:
  const ::clarifai::api::Hit& _internal_hits(int index) const;
  ::clarifai::api::Hit* _internal_add_hits();
  public:
  const ::clarifai::api::Hit& hits(int index) const;
  ::clarifai::api::Hit* add_hits();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Hit >&
      hits() const;

  // repeated float projection = 5;
  int projection_size() const;
  private:
  int _internal_projection_size() const;
  public:
  void clear_projection();
  private:
  float _internal_projection(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_projection() const;
  void _internal_add_projection(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_projection();
  public:
  float projection(int index) const;
  void set_projection(int index, float value);
  void add_projection(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      projection() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_projection();

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // uint32 count = 2;
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // float score = 3;
  void clear_score();
  float score() const;
  void set_score(float value);
  private:
  float _internal_score() const;
  void _internal_set_score(float value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.Cluster)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Hit > hits_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > projection_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    uint32_t count_;
    float score_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Color final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Color) */ {
 public:
  inline Color() : Color(nullptr) {}
  ~Color() override;
  explicit PROTOBUF_CONSTEXPR Color(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Color(const Color& from);
  Color(Color&& from) noexcept
    : Color() {
    *this = ::std::move(from);
  }

  inline Color& operator=(const Color& from) {
    CopyFrom(from);
    return *this;
  }
  inline Color& operator=(Color&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Color& default_instance() {
    return *internal_default_instance();
  }
  static inline const Color* internal_default_instance() {
    return reinterpret_cast<const Color*>(
               &_Color_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Color& a, Color& b) {
    a.Swap(&b);
  }
  inline void Swap(Color* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Color* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Color* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Color>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Color& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Color& from) {
    Color::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Color* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Color";
  }
  protected:
  explicit Color(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRawHexFieldNumber = 1,
    kW3CFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  // string raw_hex = 1;
  void clear_raw_hex();
  const std::string& raw_hex() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_raw_hex(ArgT0&& arg0, ArgT... args);
  std::string* mutable_raw_hex();
  PROTOBUF_NODISCARD std::string* release_raw_hex();
  void set_allocated_raw_hex(std::string* raw_hex);
  private:
  const std::string& _internal_raw_hex() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw_hex(const std::string& value);
  std::string* _internal_mutable_raw_hex();
  public:

  // .clarifai.api.W3C w3c = 2;
  bool has_w3c() const;
  private:
  bool _internal_has_w3c() const;
  public:
  void clear_w3c();
  const ::clarifai::api::W3C& w3c() const;
  PROTOBUF_NODISCARD ::clarifai::api::W3C* release_w3c();
  ::clarifai::api::W3C* mutable_w3c();
  void set_allocated_w3c(::clarifai::api::W3C* w3c);
  private:
  const ::clarifai::api::W3C& _internal_w3c() const;
  ::clarifai::api::W3C* _internal_mutable_w3c();
  public:
  void unsafe_arena_set_allocated_w3c(
      ::clarifai::api::W3C* w3c);
  ::clarifai::api::W3C* unsafe_arena_release_w3c();

  // float value = 3 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_value();
  float value() const;
  void set_value(float value);
  private:
  float _internal_value() const;
  void _internal_set_value(float value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.Color)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_hex_;
    ::clarifai::api::W3C* w3c_;
    float value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class W3C final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.W3C) */ {
 public:
  inline W3C() : W3C(nullptr) {}
  ~W3C() override;
  explicit PROTOBUF_CONSTEXPR W3C(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  W3C(const W3C& from);
  W3C(W3C&& from) noexcept
    : W3C() {
    *this = ::std::move(from);
  }

  inline W3C& operator=(const W3C& from) {
    CopyFrom(from);
    return *this;
  }
  inline W3C& operator=(W3C&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const W3C& default_instance() {
    return *internal_default_instance();
  }
  static inline const W3C* internal_default_instance() {
    return reinterpret_cast<const W3C*>(
               &_W3C_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(W3C& a, W3C& b) {
    a.Swap(&b);
  }
  inline void Swap(W3C* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(W3C* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  W3C* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<W3C>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const W3C& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const W3C& from) {
    W3C::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(W3C* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.W3C";
  }
  protected:
  explicit W3C(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHexFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string hex = 1;
  void clear_hex();
  const std::string& hex() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hex(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hex();
  PROTOBUF_NODISCARD std::string* release_hex();
  void set_allocated_hex(std::string* hex);
  private:
  const std::string& _internal_hex() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hex(const std::string& value);
  std::string* _internal_mutable_hex();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.W3C)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hex_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class UserAppIDSet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.UserAppIDSet) */ {
 public:
  inline UserAppIDSet() : UserAppIDSet(nullptr) {}
  ~UserAppIDSet() override;
  explicit PROTOBUF_CONSTEXPR UserAppIDSet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserAppIDSet(const UserAppIDSet& from);
  UserAppIDSet(UserAppIDSet&& from) noexcept
    : UserAppIDSet() {
    *this = ::std::move(from);
  }

  inline UserAppIDSet& operator=(const UserAppIDSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserAppIDSet& operator=(UserAppIDSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserAppIDSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserAppIDSet* internal_default_instance() {
    return reinterpret_cast<const UserAppIDSet*>(
               &_UserAppIDSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UserAppIDSet& a, UserAppIDSet& b) {
    a.Swap(&b);
  }
  inline void Swap(UserAppIDSet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserAppIDSet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserAppIDSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserAppIDSet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserAppIDSet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserAppIDSet& from) {
    UserAppIDSet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserAppIDSet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.UserAppIDSet";
  }
  protected:
  explicit UserAppIDSet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kAppIdFieldNumber = 2,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string app_id = 2;
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.UserAppIDSet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class PatchAction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.PatchAction) */ {
 public:
  inline PatchAction() : PatchAction(nullptr) {}
  ~PatchAction() override;
  explicit PROTOBUF_CONSTEXPR PatchAction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PatchAction(const PatchAction& from);
  PatchAction(PatchAction&& from) noexcept
    : PatchAction() {
    *this = ::std::move(from);
  }

  inline PatchAction& operator=(const PatchAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline PatchAction& operator=(PatchAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PatchAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const PatchAction* internal_default_instance() {
    return reinterpret_cast<const PatchAction*>(
               &_PatchAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(PatchAction& a, PatchAction& b) {
    a.Swap(&b);
  }
  inline void Swap(PatchAction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PatchAction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PatchAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PatchAction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PatchAction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PatchAction& from) {
    PatchAction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PatchAction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.PatchAction";
  }
  protected:
  explicit PatchAction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpFieldNumber = 1,
    kMergeConflictResolutionFieldNumber = 2,
    kPathFieldNumber = 3,
  };
  // string op = 1;
  void clear_op();
  const std::string& op() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_op(ArgT0&& arg0, ArgT... args);
  std::string* mutable_op();
  PROTOBUF_NODISCARD std::string* release_op();
  void set_allocated_op(std::string* op);
  private:
  const std::string& _internal_op() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_op(const std::string& value);
  std::string* _internal_mutable_op();
  public:

  // string merge_conflict_resolution = 2;
  void clear_merge_conflict_resolution();
  const std::string& merge_conflict_resolution() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_merge_conflict_resolution(ArgT0&& arg0, ArgT... args);
  std::string* mutable_merge_conflict_resolution();
  PROTOBUF_NODISCARD std::string* release_merge_conflict_resolution();
  void set_allocated_merge_conflict_resolution(std::string* merge_conflict_resolution);
  private:
  const std::string& _internal_merge_conflict_resolution() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_merge_conflict_resolution(const std::string& value);
  std::string* _internal_mutable_merge_conflict_resolution();
  public:

  // string path = 3;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.PatchAction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr op_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr merge_conflict_resolution_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Concept final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Concept) */ {
 public:
  inline Concept() : Concept(nullptr) {}
  ~Concept() override;
  explicit PROTOBUF_CONSTEXPR Concept(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Concept(const Concept& from);
  Concept(Concept&& from) noexcept
    : Concept() {
    *this = ::std::move(from);
  }

  inline Concept& operator=(const Concept& from) {
    CopyFrom(from);
    return *this;
  }
  inline Concept& operator=(Concept&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Concept& default_instance() {
    return *internal_default_instance();
  }
  static inline const Concept* internal_default_instance() {
    return reinterpret_cast<const Concept*>(
               &_Concept_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Concept& a, Concept& b) {
    a.Swap(&b);
  }
  inline void Swap(Concept* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Concept* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Concept* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Concept>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Concept& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Concept& from) {
    Concept::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Concept* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Concept";
  }
  protected:
  explicit Concept(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kLanguageFieldNumber = 5,
    kAppIdFieldNumber = 6,
    kDefinitionFieldNumber = 7,
    kVocabIdFieldNumber = 8,
    kUserIdFieldNumber = 10,
    kCreatedAtFieldNumber = 4,
    kVisibilityFieldNumber = 9,
    kKeypointInfoFieldNumber = 11,
    kValueFieldNumber = 3,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string language = 5;
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // string app_id = 6;
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // string definition = 7;
  void clear_definition();
  const std::string& definition() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_definition(ArgT0&& arg0, ArgT... args);
  std::string* mutable_definition();
  PROTOBUF_NODISCARD std::string* release_definition();
  void set_allocated_definition(std::string* definition);
  private:
  const std::string& _internal_definition() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_definition(const std::string& value);
  std::string* _internal_mutable_definition();
  public:

  // string vocab_id = 8;
  void clear_vocab_id();
  const std::string& vocab_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vocab_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vocab_id();
  PROTOBUF_NODISCARD std::string* release_vocab_id();
  void set_allocated_vocab_id(std::string* vocab_id);
  private:
  const std::string& _internal_vocab_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vocab_id(const std::string& value);
  std::string* _internal_mutable_vocab_id();
  public:

  // string user_id = 10;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // .google.protobuf.Timestamp created_at = 4;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .clarifai.api.Visibility visibility = 9;
  bool has_visibility() const;
  private:
  bool _internal_has_visibility() const;
  public:
  void clear_visibility();
  const ::clarifai::api::Visibility& visibility() const;
  PROTOBUF_NODISCARD ::clarifai::api::Visibility* release_visibility();
  ::clarifai::api::Visibility* mutable_visibility();
  void set_allocated_visibility(::clarifai::api::Visibility* visibility);
  private:
  const ::clarifai::api::Visibility& _internal_visibility() const;
  ::clarifai::api::Visibility* _internal_mutable_visibility();
  public:
  void unsafe_arena_set_allocated_visibility(
      ::clarifai::api::Visibility* visibility);
  ::clarifai::api::Visibility* unsafe_arena_release_visibility();

  // .clarifai.api.KeypointInfo keypoint_info = 11;
  bool has_keypoint_info() const;
  private:
  bool _internal_has_keypoint_info() const;
  public:
  void clear_keypoint_info();
  const ::clarifai::api::KeypointInfo& keypoint_info() const;
  PROTOBUF_NODISCARD ::clarifai::api::KeypointInfo* release_keypoint_info();
  ::clarifai::api::KeypointInfo* mutable_keypoint_info();
  void set_allocated_keypoint_info(::clarifai::api::KeypointInfo* keypoint_info);
  private:
  const ::clarifai::api::KeypointInfo& _internal_keypoint_info() const;
  ::clarifai::api::KeypointInfo* _internal_mutable_keypoint_info();
  public:
  void unsafe_arena_set_allocated_keypoint_info(
      ::clarifai::api::KeypointInfo* keypoint_info);
  ::clarifai::api::KeypointInfo* unsafe_arena_release_keypoint_info();

  // float value = 3 [(.clarifai.api.utils.cl_show_if_empty) = true, (.clarifai.api.utils.cl_default_float) = 1];
  void clear_value();
  float value() const;
  void set_value(float value);
  private:
  float _internal_value() const;
  void _internal_set_value(float value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.Concept)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr definition_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vocab_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::clarifai::api::Visibility* visibility_;
    ::clarifai::api::KeypointInfo* keypoint_info_;
    float value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class KeypointInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.KeypointInfo) */ {
 public:
  inline KeypointInfo() : KeypointInfo(nullptr) {}
  ~KeypointInfo() override;
  explicit PROTOBUF_CONSTEXPR KeypointInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeypointInfo(const KeypointInfo& from);
  KeypointInfo(KeypointInfo&& from) noexcept
    : KeypointInfo() {
    *this = ::std::move(from);
  }

  inline KeypointInfo& operator=(const KeypointInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeypointInfo& operator=(KeypointInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeypointInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeypointInfo* internal_default_instance() {
    return reinterpret_cast<const KeypointInfo*>(
               &_KeypointInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(KeypointInfo& a, KeypointInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(KeypointInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeypointInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeypointInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeypointInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeypointInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeypointInfo& from) {
    KeypointInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeypointInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.KeypointInfo";
  }
  protected:
  explicit KeypointInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeypointNamesFieldNumber = 1,
    kSkeletonFieldNumber = 2,
  };
  // repeated string keypoint_names = 1;
  int keypoint_names_size() const;
  private:
  int _internal_keypoint_names_size() const;
  public:
  void clear_keypoint_names();
  const std::string& keypoint_names(int index) const;
  std::string* mutable_keypoint_names(int index);
  void set_keypoint_names(int index, const std::string& value);
  void set_keypoint_names(int index, std::string&& value);
  void set_keypoint_names(int index, const char* value);
  void set_keypoint_names(int index, const char* value, size_t size);
  std::string* add_keypoint_names();
  void add_keypoint_names(const std::string& value);
  void add_keypoint_names(std::string&& value);
  void add_keypoint_names(const char* value);
  void add_keypoint_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keypoint_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keypoint_names();
  private:
  const std::string& _internal_keypoint_names(int index) const;
  std::string* _internal_add_keypoint_names();
  public:

  // repeated .clarifai.api.KeypointEdge skeleton = 2;
  int skeleton_size() const;
  private:
  int _internal_skeleton_size() const;
  public:
  void clear_skeleton();
  ::clarifai::api::KeypointEdge* mutable_skeleton(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::KeypointEdge >*
      mutable_skeleton();
  private:
  const ::clarifai::api::KeypointEdge& _internal_skeleton(int index) const;
  ::clarifai::api::KeypointEdge* _internal_add_skeleton();
  public:
  const ::clarifai::api::KeypointEdge& skeleton(int index) const;
  ::clarifai::api::KeypointEdge* add_skeleton();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::KeypointEdge >&
      skeleton() const;

  // @@protoc_insertion_point(class_scope:clarifai.api.KeypointInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keypoint_names_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::KeypointEdge > skeleton_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class KeypointEdge final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.KeypointEdge) */ {
 public:
  inline KeypointEdge() : KeypointEdge(nullptr) {}
  ~KeypointEdge() override;
  explicit PROTOBUF_CONSTEXPR KeypointEdge(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeypointEdge(const KeypointEdge& from);
  KeypointEdge(KeypointEdge&& from) noexcept
    : KeypointEdge() {
    *this = ::std::move(from);
  }

  inline KeypointEdge& operator=(const KeypointEdge& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeypointEdge& operator=(KeypointEdge&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeypointEdge& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeypointEdge* internal_default_instance() {
    return reinterpret_cast<const KeypointEdge*>(
               &_KeypointEdge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(KeypointEdge& a, KeypointEdge& b) {
    a.Swap(&b);
  }
  inline void Swap(KeypointEdge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeypointEdge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeypointEdge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeypointEdge>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeypointEdge& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeypointEdge& from) {
    KeypointEdge::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeypointEdge* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.KeypointEdge";
  }
  protected:
  explicit KeypointEdge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kK1FieldNumber = 1,
    kK2FieldNumber = 2,
  };
  // uint32 k1 = 1;
  void clear_k1();
  uint32_t k1() const;
  void set_k1(uint32_t value);
  private:
  uint32_t _internal_k1() const;
  void _internal_set_k1(uint32_t value);
  public:

  // uint32 k2 = 2;
  void clear_k2();
  uint32_t k2() const;
  void set_k2(uint32_t value);
  private:
  uint32_t _internal_k2() const;
  void _internal_set_k2(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.KeypointEdge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t k1_;
    uint32_t k2_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ConceptCount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.ConceptCount) */ {
 public:
  inline ConceptCount() : ConceptCount(nullptr) {}
  ~ConceptCount() override;
  explicit PROTOBUF_CONSTEXPR ConceptCount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConceptCount(const ConceptCount& from);
  ConceptCount(ConceptCount&& from) noexcept
    : ConceptCount() {
    *this = ::std::move(from);
  }

  inline ConceptCount& operator=(const ConceptCount& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConceptCount& operator=(ConceptCount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConceptCount& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConceptCount* internal_default_instance() {
    return reinterpret_cast<const ConceptCount*>(
               &_ConceptCount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ConceptCount& a, ConceptCount& b) {
    a.Swap(&b);
  }
  inline void Swap(ConceptCount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConceptCount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConceptCount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConceptCount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConceptCount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConceptCount& from) {
    ConceptCount::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConceptCount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.ConceptCount";
  }
  protected:
  explicit ConceptCount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kConceptTypeCountFieldNumber = 3,
    kDetailConceptCountFieldNumber = 4,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .clarifai.api.ConceptTypeCount concept_type_count = 3;
  bool has_concept_type_count() const;
  private:
  bool _internal_has_concept_type_count() const;
  public:
  void clear_concept_type_count();
  const ::clarifai::api::ConceptTypeCount& concept_type_count() const;
  PROTOBUF_NODISCARD ::clarifai::api::ConceptTypeCount* release_concept_type_count();
  ::clarifai::api::ConceptTypeCount* mutable_concept_type_count();
  void set_allocated_concept_type_count(::clarifai::api::ConceptTypeCount* concept_type_count);
  private:
  const ::clarifai::api::ConceptTypeCount& _internal_concept_type_count() const;
  ::clarifai::api::ConceptTypeCount* _internal_mutable_concept_type_count();
  public:
  void unsafe_arena_set_allocated_concept_type_count(
      ::clarifai::api::ConceptTypeCount* concept_type_count);
  ::clarifai::api::ConceptTypeCount* unsafe_arena_release_concept_type_count();

  // .clarifai.api.DetailConceptCount detail_concept_count = 4;
  bool has_detail_concept_count() const;
  private:
  bool _internal_has_detail_concept_count() const;
  public:
  void clear_detail_concept_count();
  const ::clarifai::api::DetailConceptCount& detail_concept_count() const;
  PROTOBUF_NODISCARD ::clarifai::api::DetailConceptCount* release_detail_concept_count();
  ::clarifai::api::DetailConceptCount* mutable_detail_concept_count();
  void set_allocated_detail_concept_count(::clarifai::api::DetailConceptCount* detail_concept_count);
  private:
  const ::clarifai::api::DetailConceptCount& _internal_detail_concept_count() const;
  ::clarifai::api::DetailConceptCount* _internal_mutable_detail_concept_count();
  public:
  void unsafe_arena_set_allocated_detail_concept_count(
      ::clarifai::api::DetailConceptCount* detail_concept_count);
  ::clarifai::api::DetailConceptCount* unsafe_arena_release_detail_concept_count();

  // @@protoc_insertion_point(class_scope:clarifai.api.ConceptCount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::clarifai::api::ConceptTypeCount* concept_type_count_;
    ::clarifai::api::DetailConceptCount* detail_concept_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ConceptTypeCount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.ConceptTypeCount) */ {
 public:
  inline ConceptTypeCount() : ConceptTypeCount(nullptr) {}
  ~ConceptTypeCount() override;
  explicit PROTOBUF_CONSTEXPR ConceptTypeCount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConceptTypeCount(const ConceptTypeCount& from);
  ConceptTypeCount(ConceptTypeCount&& from) noexcept
    : ConceptTypeCount() {
    *this = ::std::move(from);
  }

  inline ConceptTypeCount& operator=(const ConceptTypeCount& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConceptTypeCount& operator=(ConceptTypeCount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConceptTypeCount& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConceptTypeCount* internal_default_instance() {
    return reinterpret_cast<const ConceptTypeCount*>(
               &_ConceptTypeCount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ConceptTypeCount& a, ConceptTypeCount& b) {
    a.Swap(&b);
  }
  inline void Swap(ConceptTypeCount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConceptTypeCount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConceptTypeCount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConceptTypeCount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConceptTypeCount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConceptTypeCount& from) {
    ConceptTypeCount::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConceptTypeCount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.ConceptTypeCount";
  }
  protected:
  explicit ConceptTypeCount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositiveFieldNumber = 1,
    kNegativeFieldNumber = 2,
  };
  // uint32 positive = 1 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_positive();
  uint32_t positive() const;
  void set_positive(uint32_t value);
  private:
  uint32_t _internal_positive() const;
  void _internal_set_positive(uint32_t value);
  public:

  // uint32 negative = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_negative();
  uint32_t negative() const;
  void set_negative(uint32_t value);
  private:
  uint32_t _internal_negative() const;
  void _internal_set_negative(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.ConceptTypeCount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t positive_;
    uint32_t negative_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class DetailConceptCount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.DetailConceptCount) */ {
 public:
  inline DetailConceptCount() : DetailConceptCount(nullptr) {}
  ~DetailConceptCount() override;
  explicit PROTOBUF_CONSTEXPR DetailConceptCount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DetailConceptCount(const DetailConceptCount& from);
  DetailConceptCount(DetailConceptCount&& from) noexcept
    : DetailConceptCount() {
    *this = ::std::move(from);
  }

  inline DetailConceptCount& operator=(const DetailConceptCount& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetailConceptCount& operator=(DetailConceptCount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DetailConceptCount& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetailConceptCount* internal_default_instance() {
    return reinterpret_cast<const DetailConceptCount*>(
               &_DetailConceptCount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(DetailConceptCount& a, DetailConceptCount& b) {
    a.Swap(&b);
  }
  inline void Swap(DetailConceptCount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetailConceptCount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DetailConceptCount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DetailConceptCount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DetailConceptCount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DetailConceptCount& from) {
    DetailConceptCount::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetailConceptCount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.DetailConceptCount";
  }
  protected:
  explicit DetailConceptCount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessedFieldNumber = 1,
    kToProcessFieldNumber = 2,
    kErrorsFieldNumber = 3,
    kProcessingFieldNumber = 4,
  };
  // .clarifai.api.ConceptTypeCount processed = 1;
  bool has_processed() const;
  private:
  bool _internal_has_processed() const;
  public:
  void clear_processed();
  const ::clarifai::api::ConceptTypeCount& processed() const;
  PROTOBUF_NODISCARD ::clarifai::api::ConceptTypeCount* release_processed();
  ::clarifai::api::ConceptTypeCount* mutable_processed();
  void set_allocated_processed(::clarifai::api::ConceptTypeCount* processed);
  private:
  const ::clarifai::api::ConceptTypeCount& _internal_processed() const;
  ::clarifai::api::ConceptTypeCount* _internal_mutable_processed();
  public:
  void unsafe_arena_set_allocated_processed(
      ::clarifai::api::ConceptTypeCount* processed);
  ::clarifai::api::ConceptTypeCount* unsafe_arena_release_processed();

  // .clarifai.api.ConceptTypeCount to_process = 2;
  bool has_to_process() const;
  private:
  bool _internal_has_to_process() const;
  public:
  void clear_to_process();
  const ::clarifai::api::ConceptTypeCount& to_process() const;
  PROTOBUF_NODISCARD ::clarifai::api::ConceptTypeCount* release_to_process();
  ::clarifai::api::ConceptTypeCount* mutable_to_process();
  void set_allocated_to_process(::clarifai::api::ConceptTypeCount* to_process);
  private:
  const ::clarifai::api::ConceptTypeCount& _internal_to_process() const;
  ::clarifai::api::ConceptTypeCount* _internal_mutable_to_process();
  public:
  void unsafe_arena_set_allocated_to_process(
      ::clarifai::api::ConceptTypeCount* to_process);
  ::clarifai::api::ConceptTypeCount* unsafe_arena_release_to_process();

  // .clarifai.api.ConceptTypeCount errors = 3;
  bool has_errors() const;
  private:
  bool _internal_has_errors() const;
  public:
  void clear_errors();
  const ::clarifai::api::ConceptTypeCount& errors() const;
  PROTOBUF_NODISCARD ::clarifai::api::ConceptTypeCount* release_errors();
  ::clarifai::api::ConceptTypeCount* mutable_errors();
  void set_allocated_errors(::clarifai::api::ConceptTypeCount* errors);
  private:
  const ::clarifai::api::ConceptTypeCount& _internal_errors() const;
  ::clarifai::api::ConceptTypeCount* _internal_mutable_errors();
  public:
  void unsafe_arena_set_allocated_errors(
      ::clarifai::api::ConceptTypeCount* errors);
  ::clarifai::api::ConceptTypeCount* unsafe_arena_release_errors();

  // .clarifai.api.ConceptTypeCount processing = 4;
  bool has_processing() const;
  private:
  bool _internal_has_processing() const;
  public:
  void clear_processing();
  const ::clarifai::api::ConceptTypeCount& processing() const;
  PROTOBUF_NODISCARD ::clarifai::api::ConceptTypeCount* release_processing();
  ::clarifai::api::ConceptTypeCount* mutable_processing();
  void set_allocated_processing(::clarifai::api::ConceptTypeCount* processing);
  private:
  const ::clarifai::api::ConceptTypeCount& _internal_processing() const;
  ::clarifai::api::ConceptTypeCount* _internal_mutable_processing();
  public:
  void unsafe_arena_set_allocated_processing(
      ::clarifai::api::ConceptTypeCount* processing);
  ::clarifai::api::ConceptTypeCount* unsafe_arena_release_processing();

  // @@protoc_insertion_point(class_scope:clarifai.api.DetailConceptCount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::clarifai::api::ConceptTypeCount* processed_;
    ::clarifai::api::ConceptTypeCount* to_process_;
    ::clarifai::api::ConceptTypeCount* errors_;
    ::clarifai::api::ConceptTypeCount* processing_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ConceptQuery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.ConceptQuery) */ {
 public:
  inline ConceptQuery() : ConceptQuery(nullptr) {}
  ~ConceptQuery() override;
  explicit PROTOBUF_CONSTEXPR ConceptQuery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConceptQuery(const ConceptQuery& from);
  ConceptQuery(ConceptQuery&& from) noexcept
    : ConceptQuery() {
    *this = ::std::move(from);
  }

  inline ConceptQuery& operator=(const ConceptQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConceptQuery& operator=(ConceptQuery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConceptQuery& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConceptQuery* internal_default_instance() {
    return reinterpret_cast<const ConceptQuery*>(
               &_ConceptQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ConceptQuery& a, ConceptQuery& b) {
    a.Swap(&b);
  }
  inline void Swap(ConceptQuery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConceptQuery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConceptQuery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConceptQuery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConceptQuery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConceptQuery& from) {
    ConceptQuery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConceptQuery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.ConceptQuery";
  }
  protected:
  explicit ConceptQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kLanguageFieldNumber = 2,
    kWorkflowIdFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string language = 2;
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // string workflow_id = 3;
  void clear_workflow_id();
  const std::string& workflow_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_workflow_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_workflow_id();
  PROTOBUF_NODISCARD std::string* release_workflow_id();
  void set_allocated_workflow_id(std::string* workflow_id);
  private:
  const std::string& _internal_workflow_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_workflow_id(const std::string& value);
  std::string* _internal_mutable_workflow_id();
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.ConceptQuery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr workflow_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ConceptRelation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.ConceptRelation) */ {
 public:
  inline ConceptRelation() : ConceptRelation(nullptr) {}
  ~ConceptRelation() override;
  explicit PROTOBUF_CONSTEXPR ConceptRelation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConceptRelation(const ConceptRelation& from);
  ConceptRelation(ConceptRelation&& from) noexcept
    : ConceptRelation() {
    *this = ::std::move(from);
  }

  inline ConceptRelation& operator=(const ConceptRelation& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConceptRelation& operator=(ConceptRelation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConceptRelation& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConceptRelation* internal_default_instance() {
    return reinterpret_cast<const ConceptRelation*>(
               &_ConceptRelation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ConceptRelation& a, ConceptRelation& b) {
    a.Swap(&b);
  }
  inline void Swap(ConceptRelation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConceptRelation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConceptRelation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConceptRelation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConceptRelation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConceptRelation& from) {
    ConceptRelation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConceptRelation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.ConceptRelation";
  }
  protected:
  explicit ConceptRelation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPredicateFieldNumber = 4,
    kKnowledgeGraphIdFieldNumber = 5,
    kSubjectConceptFieldNumber = 2,
    kObjectConceptFieldNumber = 3,
    kVisibilityFieldNumber = 6,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string predicate = 4;
  void clear_predicate();
  const std::string& predicate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_predicate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_predicate();
  PROTOBUF_NODISCARD std::string* release_predicate();
  void set_allocated_predicate(std::string* predicate);
  private:
  const std::string& _internal_predicate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_predicate(const std::string& value);
  std::string* _internal_mutable_predicate();
  public:

  // string knowledge_graph_id = 5;
  void clear_knowledge_graph_id();
  const std::string& knowledge_graph_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_knowledge_graph_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_knowledge_graph_id();
  PROTOBUF_NODISCARD std::string* release_knowledge_graph_id();
  void set_allocated_knowledge_graph_id(std::string* knowledge_graph_id);
  private:
  const std::string& _internal_knowledge_graph_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_knowledge_graph_id(const std::string& value);
  std::string* _internal_mutable_knowledge_graph_id();
  public:

  // .clarifai.api.Concept subject_concept = 2;
  bool has_subject_concept() const;
  private:
  bool _internal_has_subject_concept() const;
  public:
  void clear_subject_concept();
  const ::clarifai::api::Concept& subject_concept() const;
  PROTOBUF_NODISCARD ::clarifai::api::Concept* release_subject_concept();
  ::clarifai::api::Concept* mutable_subject_concept();
  void set_allocated_subject_concept(::clarifai::api::Concept* subject_concept);
  private:
  const ::clarifai::api::Concept& _internal_subject_concept() const;
  ::clarifai::api::Concept* _internal_mutable_subject_concept();
  public:
  void unsafe_arena_set_allocated_subject_concept(
      ::clarifai::api::Concept* subject_concept);
  ::clarifai::api::Concept* unsafe_arena_release_subject_concept();

  // .clarifai.api.Concept object_concept = 3;
  bool has_object_concept() const;
  private:
  bool _internal_has_object_concept() const;
  public:
  void clear_object_concept();
  const ::clarifai::api::Concept& object_concept() const;
  PROTOBUF_NODISCARD ::clarifai::api::Concept* release_object_concept();
  ::clarifai::api::Concept* mutable_object_concept();
  void set_allocated_object_concept(::clarifai::api::Concept* object_concept);
  private:
  const ::clarifai::api::Concept& _internal_object_concept() const;
  ::clarifai::api::Concept* _internal_mutable_object_concept();
  public:
  void unsafe_arena_set_allocated_object_concept(
      ::clarifai::api::Concept* object_concept);
  ::clarifai::api::Concept* unsafe_arena_release_object_concept();

  // .clarifai.api.Visibility visibility = 6;
  bool has_visibility() const;
  private:
  bool _internal_has_visibility() const;
  public:
  void clear_visibility();
  const ::clarifai::api::Visibility& visibility() const;
  PROTOBUF_NODISCARD ::clarifai::api::Visibility* release_visibility();
  ::clarifai::api::Visibility* mutable_visibility();
  void set_allocated_visibility(::clarifai::api::Visibility* visibility);
  private:
  const ::clarifai::api::Visibility& _internal_visibility() const;
  ::clarifai::api::Visibility* _internal_mutable_visibility();
  public:
  void unsafe_arena_set_allocated_visibility(
      ::clarifai::api::Visibility* visibility);
  ::clarifai::api::Visibility* unsafe_arena_release_visibility();

  // @@protoc_insertion_point(class_scope:clarifai.api.ConceptRelation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr predicate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr knowledge_graph_id_;
    ::clarifai::api::Concept* subject_concept_;
    ::clarifai::api::Concept* object_concept_;
    ::clarifai::api::Visibility* visibility_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class KnowledgeGraph final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.KnowledgeGraph) */ {
 public:
  inline KnowledgeGraph() : KnowledgeGraph(nullptr) {}
  ~KnowledgeGraph() override;
  explicit PROTOBUF_CONSTEXPR KnowledgeGraph(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KnowledgeGraph(const KnowledgeGraph& from);
  KnowledgeGraph(KnowledgeGraph&& from) noexcept
    : KnowledgeGraph() {
    *this = ::std::move(from);
  }

  inline KnowledgeGraph& operator=(const KnowledgeGraph& from) {
    CopyFrom(from);
    return *this;
  }
  inline KnowledgeGraph& operator=(KnowledgeGraph&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KnowledgeGraph& default_instance() {
    return *internal_default_instance();
  }
  static inline const KnowledgeGraph* internal_default_instance() {
    return reinterpret_cast<const KnowledgeGraph*>(
               &_KnowledgeGraph_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(KnowledgeGraph& a, KnowledgeGraph& b) {
    a.Swap(&b);
  }
  inline void Swap(KnowledgeGraph* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KnowledgeGraph* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KnowledgeGraph* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KnowledgeGraph>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KnowledgeGraph& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KnowledgeGraph& from) {
    KnowledgeGraph::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KnowledgeGraph* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.KnowledgeGraph";
  }
  protected:
  explicit KnowledgeGraph(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kExamplesAppIdFieldNumber = 4,
    kSampledExamplesAppIdFieldNumber = 5,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string examples_app_id = 4;
  void clear_examples_app_id();
  const std::string& examples_app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_examples_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_examples_app_id();
  PROTOBUF_NODISCARD std::string* release_examples_app_id();
  void set_allocated_examples_app_id(std::string* examples_app_id);
  private:
  const std::string& _internal_examples_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_examples_app_id(const std::string& value);
  std::string* _internal_mutable_examples_app_id();
  public:

  // string sampled_examples_app_id = 5;
  void clear_sampled_examples_app_id();
  const std::string& sampled_examples_app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sampled_examples_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sampled_examples_app_id();
  PROTOBUF_NODISCARD std::string* release_sampled_examples_app_id();
  void set_allocated_sampled_examples_app_id(std::string* sampled_examples_app_id);
  private:
  const std::string& _internal_sampled_examples_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sampled_examples_app_id(const std::string& value);
  std::string* _internal_mutable_sampled_examples_app_id();
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.KnowledgeGraph)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr examples_app_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sampled_examples_app_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ConceptMappingJob final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.ConceptMappingJob) */ {
 public:
  inline ConceptMappingJob() : ConceptMappingJob(nullptr) {}
  ~ConceptMappingJob() override;
  explicit PROTOBUF_CONSTEXPR ConceptMappingJob(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConceptMappingJob(const ConceptMappingJob& from);
  ConceptMappingJob(ConceptMappingJob&& from) noexcept
    : ConceptMappingJob() {
    *this = ::std::move(from);
  }

  inline ConceptMappingJob& operator=(const ConceptMappingJob& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConceptMappingJob& operator=(ConceptMappingJob&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConceptMappingJob& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConceptMappingJob* internal_default_instance() {
    return reinterpret_cast<const ConceptMappingJob*>(
               &_ConceptMappingJob_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ConceptMappingJob& a, ConceptMappingJob& b) {
    a.Swap(&b);
  }
  inline void Swap(ConceptMappingJob* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConceptMappingJob* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConceptMappingJob* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConceptMappingJob>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConceptMappingJob& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConceptMappingJob& from) {
    ConceptMappingJob::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConceptMappingJob* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.ConceptMappingJob";
  }
  protected:
  explicit ConceptMappingJob(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConceptIdsFieldNumber = 2,
    kKnowledgeGraphIdFieldNumber = 1,
  };
  // repeated string concept_ids = 2;
  int concept_ids_size() const;
  private:
  int _internal_concept_ids_size() const;
  public:
  void clear_concept_ids();
  const std::string& concept_ids(int index) const;
  std::string* mutable_concept_ids(int index);
  void set_concept_ids(int index, const std::string& value);
  void set_concept_ids(int index, std::string&& value);
  void set_concept_ids(int index, const char* value);
  void set_concept_ids(int index, const char* value, size_t size);
  std::string* add_concept_ids();
  void add_concept_ids(const std::string& value);
  void add_concept_ids(std::string&& value);
  void add_concept_ids(const char* value);
  void add_concept_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& concept_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_concept_ids();
  private:
  const std::string& _internal_concept_ids(int index) const;
  std::string* _internal_add_concept_ids();
  public:

  // string knowledge_graph_id = 1;
  void clear_knowledge_graph_id();
  const std::string& knowledge_graph_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_knowledge_graph_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_knowledge_graph_id();
  PROTOBUF_NODISCARD std::string* release_knowledge_graph_id();
  void set_allocated_knowledge_graph_id(std::string* knowledge_graph_id);
  private:
  const std::string& _internal_knowledge_graph_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_knowledge_graph_id(const std::string& value);
  std::string* _internal_mutable_knowledge_graph_id();
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.ConceptMappingJob)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> concept_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr knowledge_graph_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ConceptLanguage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.ConceptLanguage) */ {
 public:
  inline ConceptLanguage() : ConceptLanguage(nullptr) {}
  ~ConceptLanguage() override;
  explicit PROTOBUF_CONSTEXPR ConceptLanguage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConceptLanguage(const ConceptLanguage& from);
  ConceptLanguage(ConceptLanguage&& from) noexcept
    : ConceptLanguage() {
    *this = ::std::move(from);
  }

  inline ConceptLanguage& operator=(const ConceptLanguage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConceptLanguage& operator=(ConceptLanguage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConceptLanguage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConceptLanguage* internal_default_instance() {
    return reinterpret_cast<const ConceptLanguage*>(
               &_ConceptLanguage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ConceptLanguage& a, ConceptLanguage& b) {
    a.Swap(&b);
  }
  inline void Swap(ConceptLanguage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConceptLanguage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConceptLanguage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConceptLanguage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConceptLanguage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConceptLanguage& from) {
    ConceptLanguage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConceptLanguage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.ConceptLanguage";
  }
  protected:
  explicit ConceptLanguage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kDefinitionFieldNumber = 3,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string definition = 3;
  void clear_definition();
  const std::string& definition() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_definition(ArgT0&& arg0, ArgT... args);
  std::string* mutable_definition();
  PROTOBUF_NODISCARD std::string* release_definition();
  void set_allocated_definition(std::string* definition);
  private:
  const std::string& _internal_definition() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_definition(const std::string& value);
  std::string* _internal_mutable_definition();
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.ConceptLanguage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr definition_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Data final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Data) */ {
 public:
  inline Data() : Data(nullptr) {}
  ~Data() override;
  explicit PROTOBUF_CONSTEXPR Data(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Data(const Data& from);
  Data(Data&& from) noexcept
    : Data() {
    *this = ::std::move(from);
  }

  inline Data& operator=(const Data& from) {
    CopyFrom(from);
    return *this;
  }
  inline Data& operator=(Data&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Data& default_instance() {
    return *internal_default_instance();
  }
  static inline const Data* internal_default_instance() {
    return reinterpret_cast<const Data*>(
               &_Data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Data& a, Data& b) {
    a.Swap(&b);
  }
  inline void Swap(Data* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Data* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Data* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Data>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Data& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Data& from) {
    Data::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Data* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Data";
  }
  protected:
  explicit Data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConceptsFieldNumber = 3,
    kColorsFieldNumber = 7,
    kClustersFieldNumber = 8,
    kEmbeddingsFieldNumber = 9,
    kRegionsFieldNumber = 11,
    kFramesFieldNumber = 12,
    kTracksFieldNumber = 15,
    kTimeSegmentsFieldNumber = 16,
    kHitsFieldNumber = 17,
    kHeatmapsFieldNumber = 18,
    kImageFieldNumber = 1,
    kVideoFieldNumber = 2,
    kMetadataFieldNumber = 5,
    kGeoFieldNumber = 6,
    kTextFieldNumber = 13,
    kAudioFieldNumber = 14,
  };
  // repeated .clarifai.api.Concept concepts = 3;
  int concepts_size() const;
  private:
  int _internal_concepts_size() const;
  public:
  void clear_concepts();
  ::clarifai::api::Concept* mutable_concepts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept >*
      mutable_concepts();
  private:
  const ::clarifai::api::Concept& _internal_concepts(int index) const;
  ::clarifai::api::Concept* _internal_add_concepts();
  public:
  const ::clarifai::api::Concept& concepts(int index) const;
  ::clarifai::api::Concept* add_concepts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept >&
      concepts() const;

  // repeated .clarifai.api.Color colors = 7;
  int colors_size() const;
  private:
  int _internal_colors_size() const;
  public:
  void clear_colors();
  ::clarifai::api::Color* mutable_colors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Color >*
      mutable_colors();
  private:
  const ::clarifai::api::Color& _internal_colors(int index) const;
  ::clarifai::api::Color* _internal_add_colors();
  public:
  const ::clarifai::api::Color& colors(int index) const;
  ::clarifai::api::Color* add_colors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Color >&
      colors() const;

  // repeated .clarifai.api.Cluster clusters = 8;
  int clusters_size() const;
  private:
  int _internal_clusters_size() const;
  public:
  void clear_clusters();
  ::clarifai::api::Cluster* mutable_clusters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Cluster >*
      mutable_clusters();
  private:
  const ::clarifai::api::Cluster& _internal_clusters(int index) const;
  ::clarifai::api::Cluster* _internal_add_clusters();
  public:
  const ::clarifai::api::Cluster& clusters(int index) const;
  ::clarifai::api::Cluster* add_clusters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Cluster >&
      clusters() const;

  // repeated .clarifai.api.Embedding embeddings = 9;
  int embeddings_size() const;
  private:
  int _internal_embeddings_size() const;
  public:
  void clear_embeddings();
  ::clarifai::api::Embedding* mutable_embeddings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Embedding >*
      mutable_embeddings();
  private:
  const ::clarifai::api::Embedding& _internal_embeddings(int index) const;
  ::clarifai::api::Embedding* _internal_add_embeddings();
  public:
  const ::clarifai::api::Embedding& embeddings(int index) const;
  ::clarifai::api::Embedding* add_embeddings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Embedding >&
      embeddings() const;

  // repeated .clarifai.api.Region regions = 11;
  int regions_size() const;
  private:
  int _internal_regions_size() const;
  public:
  void clear_regions();
  ::clarifai::api::Region* mutable_regions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Region >*
      mutable_regions();
  private:
  const ::clarifai::api::Region& _internal_regions(int index) const;
  ::clarifai::api::Region* _internal_add_regions();
  public:
  const ::clarifai::api::Region& regions(int index) const;
  ::clarifai::api::Region* add_regions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Region >&
      regions() const;

  // repeated .clarifai.api.Frame frames = 12;
  int frames_size() const;
  private:
  int _internal_frames_size() const;
  public:
  void clear_frames();
  ::clarifai::api::Frame* mutable_frames(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Frame >*
      mutable_frames();
  private:
  const ::clarifai::api::Frame& _internal_frames(int index) const;
  ::clarifai::api::Frame* _internal_add_frames();
  public:
  const ::clarifai::api::Frame& frames(int index) const;
  ::clarifai::api::Frame* add_frames();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Frame >&
      frames() const;

  // repeated .clarifai.api.Track tracks = 15;
  int tracks_size() const;
  private:
  int _internal_tracks_size() const;
  public:
  void clear_tracks();
  ::clarifai::api::Track* mutable_tracks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Track >*
      mutable_tracks();
  private:
  const ::clarifai::api::Track& _internal_tracks(int index) const;
  ::clarifai::api::Track* _internal_add_tracks();
  public:
  const ::clarifai::api::Track& tracks(int index) const;
  ::clarifai::api::Track* add_tracks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Track >&
      tracks() const;

  // repeated .clarifai.api.TimeSegment time_segments = 16;
  int time_segments_size() const;
  private:
  int _internal_time_segments_size() const;
  public:
  void clear_time_segments();
  ::clarifai::api::TimeSegment* mutable_time_segments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::TimeSegment >*
      mutable_time_segments();
  private:
  const ::clarifai::api::TimeSegment& _internal_time_segments(int index) const;
  ::clarifai::api::TimeSegment* _internal_add_time_segments();
  public:
  const ::clarifai::api::TimeSegment& time_segments(int index) const;
  ::clarifai::api::TimeSegment* add_time_segments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::TimeSegment >&
      time_segments() const;

  // repeated .clarifai.api.Hit hits = 17;
  int hits_size() const;
  private:
  int _internal_hits_size() const;
  public:
  void clear_hits();
  ::clarifai::api::Hit* mutable_hits(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Hit >*
      mutable_hits();
  private:
  const ::clarifai::api::Hit& _internal_hits(int index) const;
  ::clarifai::api::Hit* _internal_add_hits();
  public:
  const ::clarifai::api::Hit& hits(int index) const;
  ::clarifai::api::Hit* add_hits();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Hit >&
      hits() const;

  // repeated .clarifai.api.Image heatmaps = 18;
  int heatmaps_size() const;
  private:
  int _internal_heatmaps_size() const;
  public:
  void clear_heatmaps();
  ::clarifai::api::Image* mutable_heatmaps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Image >*
      mutable_heatmaps();
  private:
  const ::clarifai::api::Image& _internal_heatmaps(int index) const;
  ::clarifai::api::Image* _internal_add_heatmaps();
  public:
  const ::clarifai::api::Image& heatmaps(int index) const;
  ::clarifai::api::Image* add_heatmaps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Image >&
      heatmaps() const;

  // .clarifai.api.Image image = 1;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::clarifai::api::Image& image() const;
  PROTOBUF_NODISCARD ::clarifai::api::Image* release_image();
  ::clarifai::api::Image* mutable_image();
  void set_allocated_image(::clarifai::api::Image* image);
  private:
  const ::clarifai::api::Image& _internal_image() const;
  ::clarifai::api::Image* _internal_mutable_image();
  public:
  void unsafe_arena_set_allocated_image(
      ::clarifai::api::Image* image);
  ::clarifai::api::Image* unsafe_arena_release_image();

  // .clarifai.api.Video video = 2;
  bool has_video() const;
  private:
  bool _internal_has_video() const;
  public:
  void clear_video();
  const ::clarifai::api::Video& video() const;
  PROTOBUF_NODISCARD ::clarifai::api::Video* release_video();
  ::clarifai::api::Video* mutable_video();
  void set_allocated_video(::clarifai::api::Video* video);
  private:
  const ::clarifai::api::Video& _internal_video() const;
  ::clarifai::api::Video* _internal_mutable_video();
  public:
  void unsafe_arena_set_allocated_video(
      ::clarifai::api::Video* video);
  ::clarifai::api::Video* unsafe_arena_release_video();

  // .google.protobuf.Struct metadata = 5;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  void set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata();

  // .clarifai.api.Geo geo = 6;
  bool has_geo() const;
  private:
  bool _internal_has_geo() const;
  public:
  void clear_geo();
  const ::clarifai::api::Geo& geo() const;
  PROTOBUF_NODISCARD ::clarifai::api::Geo* release_geo();
  ::clarifai::api::Geo* mutable_geo();
  void set_allocated_geo(::clarifai::api::Geo* geo);
  private:
  const ::clarifai::api::Geo& _internal_geo() const;
  ::clarifai::api::Geo* _internal_mutable_geo();
  public:
  void unsafe_arena_set_allocated_geo(
      ::clarifai::api::Geo* geo);
  ::clarifai::api::Geo* unsafe_arena_release_geo();

  // .clarifai.api.Text text = 13;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const ::clarifai::api::Text& text() const;
  PROTOBUF_NODISCARD ::clarifai::api::Text* release_text();
  ::clarifai::api::Text* mutable_text();
  void set_allocated_text(::clarifai::api::Text* text);
  private:
  const ::clarifai::api::Text& _internal_text() const;
  ::clarifai::api::Text* _internal_mutable_text();
  public:
  void unsafe_arena_set_allocated_text(
      ::clarifai::api::Text* text);
  ::clarifai::api::Text* unsafe_arena_release_text();

  // .clarifai.api.Audio audio = 14;
  bool has_audio() const;
  private:
  bool _internal_has_audio() const;
  public:
  void clear_audio();
  const ::clarifai::api::Audio& audio() const;
  PROTOBUF_NODISCARD ::clarifai::api::Audio* release_audio();
  ::clarifai::api::Audio* mutable_audio();
  void set_allocated_audio(::clarifai::api::Audio* audio);
  private:
  const ::clarifai::api::Audio& _internal_audio() const;
  ::clarifai::api::Audio* _internal_mutable_audio();
  public:
  void unsafe_arena_set_allocated_audio(
      ::clarifai::api::Audio* audio);
  ::clarifai::api::Audio* unsafe_arena_release_audio();

  // @@protoc_insertion_point(class_scope:clarifai.api.Data)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept > concepts_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Color > colors_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Cluster > clusters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Embedding > embeddings_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Region > regions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Frame > frames_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Track > tracks_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::TimeSegment > time_segments_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Hit > hits_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Image > heatmaps_;
    ::clarifai::api::Image* image_;
    ::clarifai::api::Video* video_;
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_;
    ::clarifai::api::Geo* geo_;
    ::clarifai::api::Text* text_;
    ::clarifai::api::Audio* audio_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Region final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Region) */ {
 public:
  inline Region() : Region(nullptr) {}
  ~Region() override;
  explicit PROTOBUF_CONSTEXPR Region(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Region(const Region& from);
  Region(Region&& from) noexcept
    : Region() {
    *this = ::std::move(from);
  }

  inline Region& operator=(const Region& from) {
    CopyFrom(from);
    return *this;
  }
  inline Region& operator=(Region&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Region& default_instance() {
    return *internal_default_instance();
  }
  static inline const Region* internal_default_instance() {
    return reinterpret_cast<const Region*>(
               &_Region_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Region& a, Region& b) {
    a.Swap(&b);
  }
  inline void Swap(Region* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Region* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Region* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Region>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Region& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Region& from) {
    Region::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Region* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Region";
  }
  protected:
  explicit Region(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTrackIdFieldNumber = 5,
    kRegionInfoFieldNumber = 2,
    kDataFieldNumber = 3,
    kValueFieldNumber = 4,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string track_id = 5;
  void clear_track_id();
  const std::string& track_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_id();
  PROTOBUF_NODISCARD std::string* release_track_id();
  void set_allocated_track_id(std::string* track_id);
  private:
  const std::string& _internal_track_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_id(const std::string& value);
  std::string* _internal_mutable_track_id();
  public:

  // .clarifai.api.RegionInfo region_info = 2;
  bool has_region_info() const;
  private:
  bool _internal_has_region_info() const;
  public:
  void clear_region_info();
  const ::clarifai::api::RegionInfo& region_info() const;
  PROTOBUF_NODISCARD ::clarifai::api::RegionInfo* release_region_info();
  ::clarifai::api::RegionInfo* mutable_region_info();
  void set_allocated_region_info(::clarifai::api::RegionInfo* region_info);
  private:
  const ::clarifai::api::RegionInfo& _internal_region_info() const;
  ::clarifai::api::RegionInfo* _internal_mutable_region_info();
  public:
  void unsafe_arena_set_allocated_region_info(
      ::clarifai::api::RegionInfo* region_info);
  ::clarifai::api::RegionInfo* unsafe_arena_release_region_info();

  // .clarifai.api.Data data = 3;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::clarifai::api::Data& data() const;
  PROTOBUF_NODISCARD ::clarifai::api::Data* release_data();
  ::clarifai::api::Data* mutable_data();
  void set_allocated_data(::clarifai::api::Data* data);
  private:
  const ::clarifai::api::Data& _internal_data() const;
  ::clarifai::api::Data* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::clarifai::api::Data* data);
  ::clarifai::api::Data* unsafe_arena_release_data();

  // float value = 4;
  void clear_value();
  float value() const;
  void set_value(float value);
  private:
  float _internal_value() const;
  void _internal_set_value(float value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.Region)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_id_;
    ::clarifai::api::RegionInfo* region_info_;
    ::clarifai::api::Data* data_;
    float value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class RegionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.RegionInfo) */ {
 public:
  inline RegionInfo() : RegionInfo(nullptr) {}
  ~RegionInfo() override;
  explicit PROTOBUF_CONSTEXPR RegionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionInfo(const RegionInfo& from);
  RegionInfo(RegionInfo&& from) noexcept
    : RegionInfo() {
    *this = ::std::move(from);
  }

  inline RegionInfo& operator=(const RegionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionInfo& operator=(RegionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionInfo* internal_default_instance() {
    return reinterpret_cast<const RegionInfo*>(
               &_RegionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(RegionInfo& a, RegionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegionInfo& from) {
    RegionInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.RegionInfo";
  }
  protected:
  explicit RegionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeypointLocationsFieldNumber = 9,
    kBoundingBoxFieldNumber = 1,
    kMaskFieldNumber = 4,
    kPolygonFieldNumber = 5,
    kPointFieldNumber = 6,
    kSpanFieldNumber = 7,
    kTokenFieldNumber = 8,
  };
  // repeated .clarifai.api.Point keypoint_locations = 9;
  int keypoint_locations_size() const;
  private:
  int _internal_keypoint_locations_size() const;
  public:
  void clear_keypoint_locations();
  ::clarifai::api::Point* mutable_keypoint_locations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Point >*
      mutable_keypoint_locations();
  private:
  const ::clarifai::api::Point& _internal_keypoint_locations(int index) const;
  ::clarifai::api::Point* _internal_add_keypoint_locations();
  public:
  const ::clarifai::api::Point& keypoint_locations(int index) const;
  ::clarifai::api::Point* add_keypoint_locations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Point >&
      keypoint_locations() const;

  // .clarifai.api.BoundingBox bounding_box = 1;
  bool has_bounding_box() const;
  private:
  bool _internal_has_bounding_box() const;
  public:
  void clear_bounding_box();
  const ::clarifai::api::BoundingBox& bounding_box() const;
  PROTOBUF_NODISCARD ::clarifai::api::BoundingBox* release_bounding_box();
  ::clarifai::api::BoundingBox* mutable_bounding_box();
  void set_allocated_bounding_box(::clarifai::api::BoundingBox* bounding_box);
  private:
  const ::clarifai::api::BoundingBox& _internal_bounding_box() const;
  ::clarifai::api::BoundingBox* _internal_mutable_bounding_box();
  public:
  void unsafe_arena_set_allocated_bounding_box(
      ::clarifai::api::BoundingBox* bounding_box);
  ::clarifai::api::BoundingBox* unsafe_arena_release_bounding_box();

  // .clarifai.api.Mask mask = 4;
  bool has_mask() const;
  private:
  bool _internal_has_mask() const;
  public:
  void clear_mask();
  const ::clarifai::api::Mask& mask() const;
  PROTOBUF_NODISCARD ::clarifai::api::Mask* release_mask();
  ::clarifai::api::Mask* mutable_mask();
  void set_allocated_mask(::clarifai::api::Mask* mask);
  private:
  const ::clarifai::api::Mask& _internal_mask() const;
  ::clarifai::api::Mask* _internal_mutable_mask();
  public:
  void unsafe_arena_set_allocated_mask(
      ::clarifai::api::Mask* mask);
  ::clarifai::api::Mask* unsafe_arena_release_mask();

  // .clarifai.api.Polygon polygon = 5;
  bool has_polygon() const;
  private:
  bool _internal_has_polygon() const;
  public:
  void clear_polygon();
  const ::clarifai::api::Polygon& polygon() const;
  PROTOBUF_NODISCARD ::clarifai::api::Polygon* release_polygon();
  ::clarifai::api::Polygon* mutable_polygon();
  void set_allocated_polygon(::clarifai::api::Polygon* polygon);
  private:
  const ::clarifai::api::Polygon& _internal_polygon() const;
  ::clarifai::api::Polygon* _internal_mutable_polygon();
  public:
  void unsafe_arena_set_allocated_polygon(
      ::clarifai::api::Polygon* polygon);
  ::clarifai::api::Polygon* unsafe_arena_release_polygon();

  // .clarifai.api.Point point = 6;
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  const ::clarifai::api::Point& point() const;
  PROTOBUF_NODISCARD ::clarifai::api::Point* release_point();
  ::clarifai::api::Point* mutable_point();
  void set_allocated_point(::clarifai::api::Point* point);
  private:
  const ::clarifai::api::Point& _internal_point() const;
  ::clarifai::api::Point* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::clarifai::api::Point* point);
  ::clarifai::api::Point* unsafe_arena_release_point();

  // .clarifai.api.Span span = 7;
  bool has_span() const;
  private:
  bool _internal_has_span() const;
  public:
  void clear_span();
  const ::clarifai::api::Span& span() const;
  PROTOBUF_NODISCARD ::clarifai::api::Span* release_span();
  ::clarifai::api::Span* mutable_span();
  void set_allocated_span(::clarifai::api::Span* span);
  private:
  const ::clarifai::api::Span& _internal_span() const;
  ::clarifai::api::Span* _internal_mutable_span();
  public:
  void unsafe_arena_set_allocated_span(
      ::clarifai::api::Span* span);
  ::clarifai::api::Span* unsafe_arena_release_span();

  // .clarifai.api.Token token = 8;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const ::clarifai::api::Token& token() const;
  PROTOBUF_NODISCARD ::clarifai::api::Token* release_token();
  ::clarifai::api::Token* mutable_token();
  void set_allocated_token(::clarifai::api::Token* token);
  private:
  const ::clarifai::api::Token& _internal_token() const;
  ::clarifai::api::Token* _internal_mutable_token();
  public:
  void unsafe_arena_set_allocated_token(
      ::clarifai::api::Token* token);
  ::clarifai::api::Token* unsafe_arena_release_token();

  // @@protoc_insertion_point(class_scope:clarifai.api.RegionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Point > keypoint_locations_;
    ::clarifai::api::BoundingBox* bounding_box_;
    ::clarifai::api::Mask* mask_;
    ::clarifai::api::Polygon* polygon_;
    ::clarifai::api::Point* point_;
    ::clarifai::api::Span* span_;
    ::clarifai::api::Token* token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class BoundingBox final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.BoundingBox) */ {
 public:
  inline BoundingBox() : BoundingBox(nullptr) {}
  ~BoundingBox() override;
  explicit PROTOBUF_CONSTEXPR BoundingBox(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BoundingBox(const BoundingBox& from);
  BoundingBox(BoundingBox&& from) noexcept
    : BoundingBox() {
    *this = ::std::move(from);
  }

  inline BoundingBox& operator=(const BoundingBox& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoundingBox& operator=(BoundingBox&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoundingBox& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoundingBox* internal_default_instance() {
    return reinterpret_cast<const BoundingBox*>(
               &_BoundingBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(BoundingBox& a, BoundingBox& b) {
    a.Swap(&b);
  }
  inline void Swap(BoundingBox* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoundingBox* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoundingBox* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoundingBox>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BoundingBox& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BoundingBox& from) {
    BoundingBox::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoundingBox* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.BoundingBox";
  }
  protected:
  explicit BoundingBox(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopRowFieldNumber = 1,
    kLeftColFieldNumber = 2,
    kBottomRowFieldNumber = 3,
    kRightColFieldNumber = 4,
  };
  // float top_row = 1 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_top_row();
  float top_row() const;
  void set_top_row(float value);
  private:
  float _internal_top_row() const;
  void _internal_set_top_row(float value);
  public:

  // float left_col = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_left_col();
  float left_col() const;
  void set_left_col(float value);
  private:
  float _internal_left_col() const;
  void _internal_set_left_col(float value);
  public:

  // float bottom_row = 3 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_bottom_row();
  float bottom_row() const;
  void set_bottom_row(float value);
  private:
  float _internal_bottom_row() const;
  void _internal_set_bottom_row(float value);
  public:

  // float right_col = 4 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_right_col();
  float right_col() const;
  void set_right_col(float value);
  private:
  float _internal_right_col() const;
  void _internal_set_right_col(float value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.BoundingBox)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float top_row_;
    float left_col_;
    float bottom_row_;
    float right_col_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class FrameInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.FrameInfo) */ {
 public:
  inline FrameInfo() : FrameInfo(nullptr) {}
  ~FrameInfo() override;
  explicit PROTOBUF_CONSTEXPR FrameInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FrameInfo(const FrameInfo& from);
  FrameInfo(FrameInfo&& from) noexcept
    : FrameInfo() {
    *this = ::std::move(from);
  }

  inline FrameInfo& operator=(const FrameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameInfo& operator=(FrameInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrameInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrameInfo* internal_default_instance() {
    return reinterpret_cast<const FrameInfo*>(
               &_FrameInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(FrameInfo& a, FrameInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrameInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FrameInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FrameInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FrameInfo& from) {
    FrameInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrameInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.FrameInfo";
  }
  protected:
  explicit FrameInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
    kTimeFieldNumber = 2,
  };
  // uint32 index = 1 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // uint32 time = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_time();
  uint32_t time() const;
  void set_time(uint32_t value);
  private:
  uint32_t _internal_time() const;
  void _internal_set_time(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.FrameInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t index_;
    uint32_t time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Frame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Frame) */ {
 public:
  inline Frame() : Frame(nullptr) {}
  ~Frame() override;
  explicit PROTOBUF_CONSTEXPR Frame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Frame(const Frame& from);
  Frame(Frame&& from) noexcept
    : Frame() {
    *this = ::std::move(from);
  }

  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }
  inline Frame& operator=(Frame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Frame& default_instance() {
    return *internal_default_instance();
  }
  static inline const Frame* internal_default_instance() {
    return reinterpret_cast<const Frame*>(
               &_Frame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(Frame& a, Frame& b) {
    a.Swap(&b);
  }
  inline void Swap(Frame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Frame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Frame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Frame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Frame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Frame& from) {
    Frame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Frame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Frame";
  }
  protected:
  explicit Frame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 3,
    kFrameInfoFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // string id = 3;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .clarifai.api.FrameInfo frame_info = 1;
  bool has_frame_info() const;
  private:
  bool _internal_has_frame_info() const;
  public:
  void clear_frame_info();
  const ::clarifai::api::FrameInfo& frame_info() const;
  PROTOBUF_NODISCARD ::clarifai::api::FrameInfo* release_frame_info();
  ::clarifai::api::FrameInfo* mutable_frame_info();
  void set_allocated_frame_info(::clarifai::api::FrameInfo* frame_info);
  private:
  const ::clarifai::api::FrameInfo& _internal_frame_info() const;
  ::clarifai::api::FrameInfo* _internal_mutable_frame_info();
  public:
  void unsafe_arena_set_allocated_frame_info(
      ::clarifai::api::FrameInfo* frame_info);
  ::clarifai::api::FrameInfo* unsafe_arena_release_frame_info();

  // .clarifai.api.Data data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::clarifai::api::Data& data() const;
  PROTOBUF_NODISCARD ::clarifai::api::Data* release_data();
  ::clarifai::api::Data* mutable_data();
  void set_allocated_data(::clarifai::api::Data* data);
  private:
  const ::clarifai::api::Data& _internal_data() const;
  ::clarifai::api::Data* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::clarifai::api::Data* data);
  ::clarifai::api::Data* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:clarifai.api.Frame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::clarifai::api::FrameInfo* frame_info_;
    ::clarifai::api::Data* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Mask final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Mask) */ {
 public:
  inline Mask() : Mask(nullptr) {}
  ~Mask() override;
  explicit PROTOBUF_CONSTEXPR Mask(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mask(const Mask& from);
  Mask(Mask&& from) noexcept
    : Mask() {
    *this = ::std::move(from);
  }

  inline Mask& operator=(const Mask& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mask& operator=(Mask&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mask& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mask* internal_default_instance() {
    return reinterpret_cast<const Mask*>(
               &_Mask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(Mask& a, Mask& b) {
    a.Swap(&b);
  }
  inline void Swap(Mask* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mask* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mask>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Mask& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Mask& from) {
    Mask::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mask* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Mask";
  }
  protected:
  explicit Mask(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageFieldNumber = 2,
  };
  // .clarifai.api.Image image = 2;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::clarifai::api::Image& image() const;
  PROTOBUF_NODISCARD ::clarifai::api::Image* release_image();
  ::clarifai::api::Image* mutable_image();
  void set_allocated_image(::clarifai::api::Image* image);
  private:
  const ::clarifai::api::Image& _internal_image() const;
  ::clarifai::api::Image* _internal_mutable_image();
  public:
  void unsafe_arena_set_allocated_image(
      ::clarifai::api::Image* image);
  ::clarifai::api::Image* unsafe_arena_release_image();

  // @@protoc_insertion_point(class_scope:clarifai.api.Mask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::clarifai::api::Image* image_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Polygon final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Polygon) */ {
 public:
  inline Polygon() : Polygon(nullptr) {}
  ~Polygon() override;
  explicit PROTOBUF_CONSTEXPR Polygon(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Polygon(const Polygon& from);
  Polygon(Polygon&& from) noexcept
    : Polygon() {
    *this = ::std::move(from);
  }

  inline Polygon& operator=(const Polygon& from) {
    CopyFrom(from);
    return *this;
  }
  inline Polygon& operator=(Polygon&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Polygon& default_instance() {
    return *internal_default_instance();
  }
  static inline const Polygon* internal_default_instance() {
    return reinterpret_cast<const Polygon*>(
               &_Polygon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(Polygon& a, Polygon& b) {
    a.Swap(&b);
  }
  inline void Swap(Polygon* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Polygon* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Polygon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Polygon>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Polygon& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Polygon& from) {
    Polygon::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Polygon* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Polygon";
  }
  protected:
  explicit Polygon(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 1,
  };
  // repeated .clarifai.api.Point points = 1;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::clarifai::api::Point* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Point >*
      mutable_points();
  private:
  const ::clarifai::api::Point& _internal_points(int index) const;
  ::clarifai::api::Point* _internal_add_points();
  public:
  const ::clarifai::api::Point& points(int index) const;
  ::clarifai::api::Point* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Point >&
      points() const;

  // @@protoc_insertion_point(class_scope:clarifai.api.Polygon)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Point > points_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Point final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Point) */ {
 public:
  inline Point() : Point(nullptr) {}
  ~Point() override;
  explicit PROTOBUF_CONSTEXPR Point(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Point(const Point& from);
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point& operator=(Point&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Point& default_instance() {
    return *internal_default_instance();
  }
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }
  inline void Swap(Point* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Point* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Point>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Point& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Point& from) {
    Point::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Point";
  }
  protected:
  explicit Point(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Point_Visibility Visibility;
  static constexpr Visibility NOT_SET =
    Point_Visibility_NOT_SET;
  static constexpr Visibility VISIBLE =
    Point_Visibility_VISIBLE;
  static constexpr Visibility NOT_VISIBLE =
    Point_Visibility_NOT_VISIBLE;
  static constexpr Visibility NOT_PRESENT =
    Point_Visibility_NOT_PRESENT;
  static inline bool Visibility_IsValid(int value) {
    return Point_Visibility_IsValid(value);
  }
  static constexpr Visibility Visibility_MIN =
    Point_Visibility_Visibility_MIN;
  static constexpr Visibility Visibility_MAX =
    Point_Visibility_Visibility_MAX;
  static constexpr int Visibility_ARRAYSIZE =
    Point_Visibility_Visibility_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Visibility_descriptor() {
    return Point_Visibility_descriptor();
  }
  template<typename T>
  static inline const std::string& Visibility_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Visibility>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Visibility_Name.");
    return Point_Visibility_Name(enum_t_value);
  }
  static inline bool Visibility_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Visibility* value) {
    return Point_Visibility_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRowFieldNumber = 1,
    kColFieldNumber = 2,
    kZFieldNumber = 3,
    kVisibilityFieldNumber = 4,
  };
  // float row = 1 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_row();
  float row() const;
  void set_row(float value);
  private:
  float _internal_row() const;
  void _internal_set_row(float value);
  public:

  // float col = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_col();
  float col() const;
  void set_col(float value);
  private:
  float _internal_col() const;
  void _internal_set_col(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // .clarifai.api.Point.Visibility visibility = 4;
  void clear_visibility();
  ::clarifai::api::Point_Visibility visibility() const;
  void set_visibility(::clarifai::api::Point_Visibility value);
  private:
  ::clarifai::api::Point_Visibility _internal_visibility() const;
  void _internal_set_visibility(::clarifai::api::Point_Visibility value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.Point)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float row_;
    float col_;
    float z_;
    int visibility_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Span final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Span) */ {
 public:
  inline Span() : Span(nullptr) {}
  ~Span() override;
  explicit PROTOBUF_CONSTEXPR Span(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Span(const Span& from);
  Span(Span&& from) noexcept
    : Span() {
    *this = ::std::move(from);
  }

  inline Span& operator=(const Span& from) {
    CopyFrom(from);
    return *this;
  }
  inline Span& operator=(Span&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Span& default_instance() {
    return *internal_default_instance();
  }
  static inline const Span* internal_default_instance() {
    return reinterpret_cast<const Span*>(
               &_Span_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(Span& a, Span& b) {
    a.Swap(&b);
  }
  inline void Swap(Span* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Span* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Span* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Span>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Span& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Span& from) {
    Span::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Span* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Span";
  }
  protected:
  explicit Span(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRawTextFieldNumber = 3,
    kCharStartFieldNumber = 1,
    kCharEndFieldNumber = 2,
  };
  // string raw_text = 3;
  void clear_raw_text();
  const std::string& raw_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_raw_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_raw_text();
  PROTOBUF_NODISCARD std::string* release_raw_text();
  void set_allocated_raw_text(std::string* raw_text);
  private:
  const std::string& _internal_raw_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw_text(const std::string& value);
  std::string* _internal_mutable_raw_text();
  public:

  // uint32 char_start = 1 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_char_start();
  uint32_t char_start() const;
  void set_char_start(uint32_t value);
  private:
  uint32_t _internal_char_start() const;
  void _internal_set_char_start(uint32_t value);
  public:

  // uint32 char_end = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_char_end();
  uint32_t char_end() const;
  void set_char_end(uint32_t value);
  private:
  uint32_t _internal_char_end() const;
  void _internal_set_char_end(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.Span)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_text_;
    uint32_t char_start_;
    uint32_t char_end_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Token final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Token) */ {
 public:
  inline Token() : Token(nullptr) {}
  ~Token() override;
  explicit PROTOBUF_CONSTEXPR Token(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Token(const Token& from);
  Token(Token&& from) noexcept
    : Token() {
    *this = ::std::move(from);
  }

  inline Token& operator=(const Token& from) {
    CopyFrom(from);
    return *this;
  }
  inline Token& operator=(Token&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Token& default_instance() {
    return *internal_default_instance();
  }
  static inline const Token* internal_default_instance() {
    return reinterpret_cast<const Token*>(
               &_Token_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(Token& a, Token& b) {
    a.Swap(&b);
  }
  inline void Swap(Token* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Token* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Token* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Token>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Token& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Token& from) {
    Token::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Token* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Token";
  }
  protected:
  explicit Token(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRawTextFieldNumber = 3,
    kCharStartFieldNumber = 1,
    kCharEndFieldNumber = 2,
  };
  // string raw_text = 3;
  void clear_raw_text();
  const std::string& raw_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_raw_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_raw_text();
  PROTOBUF_NODISCARD std::string* release_raw_text();
  void set_allocated_raw_text(std::string* raw_text);
  private:
  const std::string& _internal_raw_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw_text(const std::string& value);
  std::string* _internal_mutable_raw_text();
  public:

  // uint32 char_start = 1 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_char_start();
  uint32_t char_start() const;
  void set_char_start(uint32_t value);
  private:
  uint32_t _internal_char_start() const;
  void _internal_set_char_start(uint32_t value);
  public:

  // uint32 char_end = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_char_end();
  uint32_t char_end() const;
  void set_char_end(uint32_t value);
  private:
  uint32_t _internal_char_end() const;
  void _internal_set_char_end(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.Token)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_text_;
    uint32_t char_start_;
    uint32_t char_end_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Embedding final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Embedding) */ {
 public:
  inline Embedding() : Embedding(nullptr) {}
  ~Embedding() override;
  explicit PROTOBUF_CONSTEXPR Embedding(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Embedding(const Embedding& from);
  Embedding(Embedding&& from) noexcept
    : Embedding() {
    *this = ::std::move(from);
  }

  inline Embedding& operator=(const Embedding& from) {
    CopyFrom(from);
    return *this;
  }
  inline Embedding& operator=(Embedding&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Embedding& default_instance() {
    return *internal_default_instance();
  }
  static inline const Embedding* internal_default_instance() {
    return reinterpret_cast<const Embedding*>(
               &_Embedding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(Embedding& a, Embedding& b) {
    a.Swap(&b);
  }
  inline void Swap(Embedding* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Embedding* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Embedding* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Embedding>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Embedding& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Embedding& from) {
    Embedding::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Embedding* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Embedding";
  }
  protected:
  explicit Embedding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVectorFieldNumber = 1,
    kNumDimensionsFieldNumber = 2,
  };
  // repeated float vector = 1 [packed = true];
  int vector_size() const;
  private:
  int _internal_vector_size() const;
  public:
  void clear_vector();
  private:
  float _internal_vector(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_vector() const;
  void _internal_add_vector(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_vector();
  public:
  float vector(int index) const;
  void set_vector(int index, float value);
  void add_vector(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      vector() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_vector();

  // uint32 num_dimensions = 2;
  void clear_num_dimensions();
  uint32_t num_dimensions() const;
  void set_num_dimensions(uint32_t value);
  private:
  uint32_t _internal_num_dimensions() const;
  void _internal_set_num_dimensions(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.Embedding)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > vector_;
    uint32_t num_dimensions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class GeoPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.GeoPoint) */ {
 public:
  inline GeoPoint() : GeoPoint(nullptr) {}
  ~GeoPoint() override;
  explicit PROTOBUF_CONSTEXPR GeoPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GeoPoint(const GeoPoint& from);
  GeoPoint(GeoPoint&& from) noexcept
    : GeoPoint() {
    *this = ::std::move(from);
  }

  inline GeoPoint& operator=(const GeoPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoPoint& operator=(GeoPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeoPoint* internal_default_instance() {
    return reinterpret_cast<const GeoPoint*>(
               &_GeoPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(GeoPoint& a, GeoPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(GeoPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GeoPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GeoPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GeoPoint& from) {
    GeoPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeoPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.GeoPoint";
  }
  protected:
  explicit GeoPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLongitudeFieldNumber = 1,
    kLatitudeFieldNumber = 2,
  };
  // float longitude = 1 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_longitude();
  float longitude() const;
  void set_longitude(float value);
  private:
  float _internal_longitude() const;
  void _internal_set_longitude(float value);
  public:

  // float latitude = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_latitude();
  float latitude() const;
  void set_latitude(float value);
  private:
  float _internal_latitude() const;
  void _internal_set_latitude(float value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.GeoPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float longitude_;
    float latitude_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class GeoLimit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.GeoLimit) */ {
 public:
  inline GeoLimit() : GeoLimit(nullptr) {}
  ~GeoLimit() override;
  explicit PROTOBUF_CONSTEXPR GeoLimit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GeoLimit(const GeoLimit& from);
  GeoLimit(GeoLimit&& from) noexcept
    : GeoLimit() {
    *this = ::std::move(from);
  }

  inline GeoLimit& operator=(const GeoLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoLimit& operator=(GeoLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeoLimit* internal_default_instance() {
    return reinterpret_cast<const GeoLimit*>(
               &_GeoLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(GeoLimit& a, GeoLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(GeoLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoLimit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GeoLimit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GeoLimit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GeoLimit& from) {
    GeoLimit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeoLimit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.GeoLimit";
  }
  protected:
  explicit GeoLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // float value = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_value();
  float value() const;
  void set_value(float value);
  private:
  float _internal_value() const;
  void _internal_set_value(float value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.GeoLimit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    float value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class GeoBoxedPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.GeoBoxedPoint) */ {
 public:
  inline GeoBoxedPoint() : GeoBoxedPoint(nullptr) {}
  ~GeoBoxedPoint() override;
  explicit PROTOBUF_CONSTEXPR GeoBoxedPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GeoBoxedPoint(const GeoBoxedPoint& from);
  GeoBoxedPoint(GeoBoxedPoint&& from) noexcept
    : GeoBoxedPoint() {
    *this = ::std::move(from);
  }

  inline GeoBoxedPoint& operator=(const GeoBoxedPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoBoxedPoint& operator=(GeoBoxedPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoBoxedPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeoBoxedPoint* internal_default_instance() {
    return reinterpret_cast<const GeoBoxedPoint*>(
               &_GeoBoxedPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(GeoBoxedPoint& a, GeoBoxedPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(GeoBoxedPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoBoxedPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoBoxedPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GeoBoxedPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GeoBoxedPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GeoBoxedPoint& from) {
    GeoBoxedPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeoBoxedPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.GeoBoxedPoint";
  }
  protected:
  explicit GeoBoxedPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGeoPointFieldNumber = 1,
  };
  // .clarifai.api.GeoPoint geo_point = 1;
  bool has_geo_point() const;
  private:
  bool _internal_has_geo_point() const;
  public:
  void clear_geo_point();
  const ::clarifai::api::GeoPoint& geo_point() const;
  PROTOBUF_NODISCARD ::clarifai::api::GeoPoint* release_geo_point();
  ::clarifai::api::GeoPoint* mutable_geo_point();
  void set_allocated_geo_point(::clarifai::api::GeoPoint* geo_point);
  private:
  const ::clarifai::api::GeoPoint& _internal_geo_point() const;
  ::clarifai::api::GeoPoint* _internal_mutable_geo_point();
  public:
  void unsafe_arena_set_allocated_geo_point(
      ::clarifai::api::GeoPoint* geo_point);
  ::clarifai::api::GeoPoint* unsafe_arena_release_geo_point();

  // @@protoc_insertion_point(class_scope:clarifai.api.GeoBoxedPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::clarifai::api::GeoPoint* geo_point_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Geo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Geo) */ {
 public:
  inline Geo() : Geo(nullptr) {}
  ~Geo() override;
  explicit PROTOBUF_CONSTEXPR Geo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Geo(const Geo& from);
  Geo(Geo&& from) noexcept
    : Geo() {
    *this = ::std::move(from);
  }

  inline Geo& operator=(const Geo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Geo& operator=(Geo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Geo& default_instance() {
    return *internal_default_instance();
  }
  static inline const Geo* internal_default_instance() {
    return reinterpret_cast<const Geo*>(
               &_Geo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(Geo& a, Geo& b) {
    a.Swap(&b);
  }
  inline void Swap(Geo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Geo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Geo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Geo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Geo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Geo& from) {
    Geo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Geo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Geo";
  }
  protected:
  explicit Geo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGeoBoxFieldNumber = 3,
    kGeoPointFieldNumber = 1,
    kGeoLimitFieldNumber = 2,
  };
  // repeated .clarifai.api.GeoBoxedPoint geo_box = 3;
  int geo_box_size() const;
  private:
  int _internal_geo_box_size() const;
  public:
  void clear_geo_box();
  ::clarifai::api::GeoBoxedPoint* mutable_geo_box(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::GeoBoxedPoint >*
      mutable_geo_box();
  private:
  const ::clarifai::api::GeoBoxedPoint& _internal_geo_box(int index) const;
  ::clarifai::api::GeoBoxedPoint* _internal_add_geo_box();
  public:
  const ::clarifai::api::GeoBoxedPoint& geo_box(int index) const;
  ::clarifai::api::GeoBoxedPoint* add_geo_box();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::GeoBoxedPoint >&
      geo_box() const;

  // .clarifai.api.GeoPoint geo_point = 1;
  bool has_geo_point() const;
  private:
  bool _internal_has_geo_point() const;
  public:
  void clear_geo_point();
  const ::clarifai::api::GeoPoint& geo_point() const;
  PROTOBUF_NODISCARD ::clarifai::api::GeoPoint* release_geo_point();
  ::clarifai::api::GeoPoint* mutable_geo_point();
  void set_allocated_geo_point(::clarifai::api::GeoPoint* geo_point);
  private:
  const ::clarifai::api::GeoPoint& _internal_geo_point() const;
  ::clarifai::api::GeoPoint* _internal_mutable_geo_point();
  public:
  void unsafe_arena_set_allocated_geo_point(
      ::clarifai::api::GeoPoint* geo_point);
  ::clarifai::api::GeoPoint* unsafe_arena_release_geo_point();

  // .clarifai.api.GeoLimit geo_limit = 2;
  bool has_geo_limit() const;
  private:
  bool _internal_has_geo_limit() const;
  public:
  void clear_geo_limit();
  const ::clarifai::api::GeoLimit& geo_limit() const;
  PROTOBUF_NODISCARD ::clarifai::api::GeoLimit* release_geo_limit();
  ::clarifai::api::GeoLimit* mutable_geo_limit();
  void set_allocated_geo_limit(::clarifai::api::GeoLimit* geo_limit);
  private:
  const ::clarifai::api::GeoLimit& _internal_geo_limit() const;
  ::clarifai::api::GeoLimit* _internal_mutable_geo_limit();
  public:
  void unsafe_arena_set_allocated_geo_limit(
      ::clarifai::api::GeoLimit* geo_limit);
  ::clarifai::api::GeoLimit* unsafe_arena_release_geo_limit();

  // @@protoc_insertion_point(class_scope:clarifai.api.Geo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::GeoBoxedPoint > geo_box_;
    ::clarifai::api::GeoPoint* geo_point_;
    ::clarifai::api::GeoLimit* geo_limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Image final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Image) */ {
 public:
  inline Image() : Image(nullptr) {}
  ~Image() override;
  explicit PROTOBUF_CONSTEXPR Image(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Image(const Image& from);
  Image(Image&& from) noexcept
    : Image() {
    *this = ::std::move(from);
  }

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  inline Image& operator=(Image&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Image& default_instance() {
    return *internal_default_instance();
  }
  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
               &_Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(Image& a, Image& b) {
    a.Swap(&b);
  }
  inline void Swap(Image* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Image* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Image* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Image>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Image& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Image& from) {
    Image::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Image* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Image";
  }
  protected:
  explicit Image(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kBase64FieldNumber = 2,
    kHostedFieldNumber = 5,
    kImageInfoFieldNumber = 6,
    kAllowDuplicateUrlFieldNumber = 4,
  };
  // string url = 1;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // bytes base64 = 2;
  void clear_base64();
  const std::string& base64() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_base64(ArgT0&& arg0, ArgT... args);
  std::string* mutable_base64();
  PROTOBUF_NODISCARD std::string* release_base64();
  void set_allocated_base64(std::string* base64);
  private:
  const std::string& _internal_base64() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base64(const std::string& value);
  std::string* _internal_mutable_base64();
  public:

  // .clarifai.api.HostedURL hosted = 5;
  bool has_hosted() const;
  private:
  bool _internal_has_hosted() const;
  public:
  void clear_hosted();
  const ::clarifai::api::HostedURL& hosted() const;
  PROTOBUF_NODISCARD ::clarifai::api::HostedURL* release_hosted();
  ::clarifai::api::HostedURL* mutable_hosted();
  void set_allocated_hosted(::clarifai::api::HostedURL* hosted);
  private:
  const ::clarifai::api::HostedURL& _internal_hosted() const;
  ::clarifai::api::HostedURL* _internal_mutable_hosted();
  public:
  void unsafe_arena_set_allocated_hosted(
      ::clarifai::api::HostedURL* hosted);
  ::clarifai::api::HostedURL* unsafe_arena_release_hosted();

  // .clarifai.api.ImageInfo image_info = 6;
  bool has_image_info() const;
  private:
  bool _internal_has_image_info() const;
  public:
  void clear_image_info();
  const ::clarifai::api::ImageInfo& image_info() const;
  PROTOBUF_NODISCARD ::clarifai::api::ImageInfo* release_image_info();
  ::clarifai::api::ImageInfo* mutable_image_info();
  void set_allocated_image_info(::clarifai::api::ImageInfo* image_info);
  private:
  const ::clarifai::api::ImageInfo& _internal_image_info() const;
  ::clarifai::api::ImageInfo* _internal_mutable_image_info();
  public:
  void unsafe_arena_set_allocated_image_info(
      ::clarifai::api::ImageInfo* image_info);
  ::clarifai::api::ImageInfo* unsafe_arena_release_image_info();

  // bool allow_duplicate_url = 4;
  void clear_allow_duplicate_url();
  bool allow_duplicate_url() const;
  void set_allow_duplicate_url(bool value);
  private:
  bool _internal_allow_duplicate_url() const;
  void _internal_set_allow_duplicate_url(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.Image)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base64_;
    ::clarifai::api::HostedURL* hosted_;
    ::clarifai::api::ImageInfo* image_info_;
    bool allow_duplicate_url_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ImageInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.ImageInfo) */ {
 public:
  inline ImageInfo() : ImageInfo(nullptr) {}
  ~ImageInfo() override;
  explicit PROTOBUF_CONSTEXPR ImageInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageInfo(const ImageInfo& from);
  ImageInfo(ImageInfo&& from) noexcept
    : ImageInfo() {
    *this = ::std::move(from);
  }

  inline ImageInfo& operator=(const ImageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageInfo& operator=(ImageInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageInfo* internal_default_instance() {
    return reinterpret_cast<const ImageInfo*>(
               &_ImageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(ImageInfo& a, ImageInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImageInfo& from) {
    ImageInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.ImageInfo";
  }
  protected:
  explicit ImageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFormatFieldNumber = 3,
    kColorModeFieldNumber = 4,
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // string format = 3;
  void clear_format();
  const std::string& format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_format();
  PROTOBUF_NODISCARD std::string* release_format();
  void set_allocated_format(std::string* format);
  private:
  const std::string& _internal_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_format(const std::string& value);
  std::string* _internal_mutable_format();
  public:

  // string color_mode = 4;
  void clear_color_mode();
  const std::string& color_mode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_color_mode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_color_mode();
  PROTOBUF_NODISCARD std::string* release_color_mode();
  void set_allocated_color_mode(std::string* color_mode);
  private:
  const std::string& _internal_color_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color_mode(const std::string& value);
  std::string* _internal_mutable_color_mode();
  public:

  // int32 width = 1;
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // int32 height = 2;
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.ImageInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr format_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_mode_;
    int32_t width_;
    int32_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class HostedURL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.HostedURL) */ {
 public:
  inline HostedURL() : HostedURL(nullptr) {}
  ~HostedURL() override;
  explicit PROTOBUF_CONSTEXPR HostedURL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HostedURL(const HostedURL& from);
  HostedURL(HostedURL&& from) noexcept
    : HostedURL() {
    *this = ::std::move(from);
  }

  inline HostedURL& operator=(const HostedURL& from) {
    CopyFrom(from);
    return *this;
  }
  inline HostedURL& operator=(HostedURL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HostedURL& default_instance() {
    return *internal_default_instance();
  }
  static inline const HostedURL* internal_default_instance() {
    return reinterpret_cast<const HostedURL*>(
               &_HostedURL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(HostedURL& a, HostedURL& b) {
    a.Swap(&b);
  }
  inline void Swap(HostedURL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HostedURL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HostedURL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HostedURL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HostedURL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HostedURL& from) {
    HostedURL::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HostedURL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.HostedURL";
  }
  protected:
  explicit HostedURL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizesFieldNumber = 3,
    kPrefixFieldNumber = 1,
    kSuffixFieldNumber = 2,
    kCrossoriginFieldNumber = 4,
  };
  // repeated string sizes = 3;
  int sizes_size() const;
  private:
  int _internal_sizes_size() const;
  public:
  void clear_sizes();
  const std::string& sizes(int index) const;
  std::string* mutable_sizes(int index);
  void set_sizes(int index, const std::string& value);
  void set_sizes(int index, std::string&& value);
  void set_sizes(int index, const char* value);
  void set_sizes(int index, const char* value, size_t size);
  std::string* add_sizes();
  void add_sizes(const std::string& value);
  void add_sizes(std::string&& value);
  void add_sizes(const char* value);
  void add_sizes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& sizes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_sizes();
  private:
  const std::string& _internal_sizes(int index) const;
  std::string* _internal_add_sizes();
  public:

  // string prefix = 1;
  void clear_prefix();
  const std::string& prefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prefix();
  PROTOBUF_NODISCARD std::string* release_prefix();
  void set_allocated_prefix(std::string* prefix);
  private:
  const std::string& _internal_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prefix(const std::string& value);
  std::string* _internal_mutable_prefix();
  public:

  // string suffix = 2;
  void clear_suffix();
  const std::string& suffix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_suffix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_suffix();
  PROTOBUF_NODISCARD std::string* release_suffix();
  void set_allocated_suffix(std::string* suffix);
  private:
  const std::string& _internal_suffix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_suffix(const std::string& value);
  std::string* _internal_mutable_suffix();
  public:

  // string crossorigin = 4;
  void clear_crossorigin();
  const std::string& crossorigin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_crossorigin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_crossorigin();
  PROTOBUF_NODISCARD std::string* release_crossorigin();
  void set_allocated_crossorigin(std::string* crossorigin);
  private:
  const std::string& _internal_crossorigin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_crossorigin(const std::string& value);
  std::string* _internal_mutable_crossorigin();
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.HostedURL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> sizes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prefix_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr suffix_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr crossorigin_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Input final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Input) */ {
 public:
  inline Input() : Input(nullptr) {}
  ~Input() override;
  explicit PROTOBUF_CONSTEXPR Input(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Input(const Input& from);
  Input(Input&& from) noexcept
    : Input() {
    *this = ::std::move(from);
  }

  inline Input& operator=(const Input& from) {
    CopyFrom(from);
    return *this;
  }
  inline Input& operator=(Input&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Input& default_instance() {
    return *internal_default_instance();
  }
  static inline const Input* internal_default_instance() {
    return reinterpret_cast<const Input*>(
               &_Input_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(Input& a, Input& b) {
    a.Swap(&b);
  }
  inline void Swap(Input* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Input* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Input* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Input>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Input& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Input& from) {
    Input::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Input* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Input";
  }
  protected:
  explicit Input(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatasetIdsFieldNumber = 7,
    kIdFieldNumber = 1,
    kDataFieldNumber = 2,
    kCreatedAtFieldNumber = 4,
    kModifiedAtFieldNumber = 5,
    kStatusFieldNumber = 6,
  };
  // repeated string dataset_ids = 7;
  int dataset_ids_size() const;
  private:
  int _internal_dataset_ids_size() const;
  public:
  void clear_dataset_ids();
  const std::string& dataset_ids(int index) const;
  std::string* mutable_dataset_ids(int index);
  void set_dataset_ids(int index, const std::string& value);
  void set_dataset_ids(int index, std::string&& value);
  void set_dataset_ids(int index, const char* value);
  void set_dataset_ids(int index, const char* value, size_t size);
  std::string* add_dataset_ids();
  void add_dataset_ids(const std::string& value);
  void add_dataset_ids(std::string&& value);
  void add_dataset_ids(const char* value);
  void add_dataset_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& dataset_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_dataset_ids();
  private:
  const std::string& _internal_dataset_ids(int index) const;
  std::string* _internal_add_dataset_ids();
  public:

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .clarifai.api.Data data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::clarifai::api::Data& data() const;
  PROTOBUF_NODISCARD ::clarifai::api::Data* release_data();
  ::clarifai::api::Data* mutable_data();
  void set_allocated_data(::clarifai::api::Data* data);
  private:
  const ::clarifai::api::Data& _internal_data() const;
  ::clarifai::api::Data* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::clarifai::api::Data* data);
  ::clarifai::api::Data* unsafe_arena_release_data();

  // .google.protobuf.Timestamp created_at = 4;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp modified_at = 5;
  bool has_modified_at() const;
  private:
  bool _internal_has_modified_at() const;
  public:
  void clear_modified_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& modified_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_modified_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_modified_at();
  void set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_modified_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_modified_at();
  public:
  void unsafe_arena_set_allocated_modified_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_modified_at();

  // .clarifai.api.status.Status status = 6;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::clarifai::api::status::Status& status() const;
  PROTOBUF_NODISCARD ::clarifai::api::status::Status* release_status();
  ::clarifai::api::status::Status* mutable_status();
  void set_allocated_status(::clarifai::api::status::Status* status);
  private:
  const ::clarifai::api::status::Status& _internal_status() const;
  ::clarifai::api::status::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::clarifai::api::status::Status* status);
  ::clarifai::api::status::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:clarifai.api.Input)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> dataset_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::clarifai::api::Data* data_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at_;
    ::clarifai::api::status::Status* status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class InputCount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.InputCount) */ {
 public:
  inline InputCount() : InputCount(nullptr) {}
  ~InputCount() override;
  explicit PROTOBUF_CONSTEXPR InputCount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InputCount(const InputCount& from);
  InputCount(InputCount&& from) noexcept
    : InputCount() {
    *this = ::std::move(from);
  }

  inline InputCount& operator=(const InputCount& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputCount& operator=(InputCount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputCount& default_instance() {
    return *internal_default_instance();
  }
  static inline const InputCount* internal_default_instance() {
    return reinterpret_cast<const InputCount*>(
               &_InputCount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(InputCount& a, InputCount& b) {
    a.Swap(&b);
  }
  inline void Swap(InputCount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputCount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputCount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InputCount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InputCount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InputCount& from) {
    InputCount::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputCount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.InputCount";
  }
  protected:
  explicit InputCount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessedFieldNumber = 1,
    kToProcessFieldNumber = 2,
    kErrorsFieldNumber = 3,
    kProcessingFieldNumber = 4,
    kReindexedFieldNumber = 5,
    kToReindexFieldNumber = 6,
    kReindexErrorsFieldNumber = 7,
    kReindexingFieldNumber = 8,
  };
  // uint32 processed = 1 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_processed();
  uint32_t processed() const;
  void set_processed(uint32_t value);
  private:
  uint32_t _internal_processed() const;
  void _internal_set_processed(uint32_t value);
  public:

  // uint32 to_process = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_to_process();
  uint32_t to_process() const;
  void set_to_process(uint32_t value);
  private:
  uint32_t _internal_to_process() const;
  void _internal_set_to_process(uint32_t value);
  public:

  // uint32 errors = 3 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_errors();
  uint32_t errors() const;
  void set_errors(uint32_t value);
  private:
  uint32_t _internal_errors() const;
  void _internal_set_errors(uint32_t value);
  public:

  // uint32 processing = 4 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_processing();
  uint32_t processing() const;
  void set_processing(uint32_t value);
  private:
  uint32_t _internal_processing() const;
  void _internal_set_processing(uint32_t value);
  public:

  // uint32 reindexed = 5 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_reindexed();
  uint32_t reindexed() const;
  void set_reindexed(uint32_t value);
  private:
  uint32_t _internal_reindexed() const;
  void _internal_set_reindexed(uint32_t value);
  public:

  // uint32 to_reindex = 6 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_to_reindex();
  uint32_t to_reindex() const;
  void set_to_reindex(uint32_t value);
  private:
  uint32_t _internal_to_reindex() const;
  void _internal_set_to_reindex(uint32_t value);
  public:

  // uint32 reindex_errors = 7 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_reindex_errors();
  uint32_t reindex_errors() const;
  void set_reindex_errors(uint32_t value);
  private:
  uint32_t _internal_reindex_errors() const;
  void _internal_set_reindex_errors(uint32_t value);
  public:

  // uint32 reindexing = 8 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_reindexing();
  uint32_t reindexing() const;
  void set_reindexing(uint32_t value);
  private:
  uint32_t _internal_reindexing() const;
  void _internal_set_reindexing(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.InputCount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t processed_;
    uint32_t to_process_;
    uint32_t errors_;
    uint32_t processing_;
    uint32_t reindexed_;
    uint32_t to_reindex_;
    uint32_t reindex_errors_;
    uint32_t reindexing_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Dataset final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Dataset) */ {
 public:
  inline Dataset() : Dataset(nullptr) {}
  ~Dataset() override;
  explicit PROTOBUF_CONSTEXPR Dataset(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Dataset(const Dataset& from);
  Dataset(Dataset&& from) noexcept
    : Dataset() {
    *this = ::std::move(from);
  }

  inline Dataset& operator=(const Dataset& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dataset& operator=(Dataset&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dataset& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dataset* internal_default_instance() {
    return reinterpret_cast<const Dataset*>(
               &_Dataset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(Dataset& a, Dataset& b) {
    a.Swap(&b);
  }
  inline void Swap(Dataset* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dataset* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dataset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dataset>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Dataset& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Dataset& from) {
    Dataset::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dataset* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Dataset";
  }
  protected:
  explicit Dataset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kAppIdFieldNumber = 4,
    kUserIdFieldNumber = 5,
    kDescriptionFieldNumber = 7,
    kNotesFieldNumber = 11,
    kCreatedAtFieldNumber = 2,
    kModifiedAtFieldNumber = 3,
    kMetadataFieldNumber = 8,
    kVisibilityFieldNumber = 9,
    kDefaultAnnotationFilterFieldNumber = 12,
    kVersionFieldNumber = 13,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string app_id = 4;
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // string user_id = 5;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string description = 7;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string notes = 11;
  void clear_notes();
  const std::string& notes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_notes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_notes();
  PROTOBUF_NODISCARD std::string* release_notes();
  void set_allocated_notes(std::string* notes);
  private:
  const std::string& _internal_notes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_notes(const std::string& value);
  std::string* _internal_mutable_notes();
  public:

  // .google.protobuf.Timestamp created_at = 2;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp modified_at = 3;
  bool has_modified_at() const;
  private:
  bool _internal_has_modified_at() const;
  public:
  void clear_modified_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& modified_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_modified_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_modified_at();
  void set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_modified_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_modified_at();
  public:
  void unsafe_arena_set_allocated_modified_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_modified_at();

  // .google.protobuf.Struct metadata = 8;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  void set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata();

  // .clarifai.api.Visibility visibility = 9;
  bool has_visibility() const;
  private:
  bool _internal_has_visibility() const;
  public:
  void clear_visibility();
  const ::clarifai::api::Visibility& visibility() const;
  PROTOBUF_NODISCARD ::clarifai::api::Visibility* release_visibility();
  ::clarifai::api::Visibility* mutable_visibility();
  void set_allocated_visibility(::clarifai::api::Visibility* visibility);
  private:
  const ::clarifai::api::Visibility& _internal_visibility() const;
  ::clarifai::api::Visibility* _internal_mutable_visibility();
  public:
  void unsafe_arena_set_allocated_visibility(
      ::clarifai::api::Visibility* visibility);
  ::clarifai::api::Visibility* unsafe_arena_release_visibility();

  // .clarifai.api.AnnotationFilter default_annotation_filter = 12;
  bool has_default_annotation_filter() const;
  private:
  bool _internal_has_default_annotation_filter() const;
  public:
  void clear_default_annotation_filter();
  const ::clarifai::api::AnnotationFilter& default_annotation_filter() const;
  PROTOBUF_NODISCARD ::clarifai::api::AnnotationFilter* release_default_annotation_filter();
  ::clarifai::api::AnnotationFilter* mutable_default_annotation_filter();
  void set_allocated_default_annotation_filter(::clarifai::api::AnnotationFilter* default_annotation_filter);
  private:
  const ::clarifai::api::AnnotationFilter& _internal_default_annotation_filter() const;
  ::clarifai::api::AnnotationFilter* _internal_mutable_default_annotation_filter();
  public:
  void unsafe_arena_set_allocated_default_annotation_filter(
      ::clarifai::api::AnnotationFilter* default_annotation_filter);
  ::clarifai::api::AnnotationFilter* unsafe_arena_release_default_annotation_filter();

  // .clarifai.api.DatasetVersion version = 13;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const ::clarifai::api::DatasetVersion& version() const;
  PROTOBUF_NODISCARD ::clarifai::api::DatasetVersion* release_version();
  ::clarifai::api::DatasetVersion* mutable_version();
  void set_allocated_version(::clarifai::api::DatasetVersion* version);
  private:
  const ::clarifai::api::DatasetVersion& _internal_version() const;
  ::clarifai::api::DatasetVersion* _internal_mutable_version();
  public:
  void unsafe_arena_set_allocated_version(
      ::clarifai::api::DatasetVersion* version);
  ::clarifai::api::DatasetVersion* unsafe_arena_release_version();

  // @@protoc_insertion_point(class_scope:clarifai.api.Dataset)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr notes_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at_;
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_;
    ::clarifai::api::Visibility* visibility_;
    ::clarifai::api::AnnotationFilter* default_annotation_filter_;
    ::clarifai::api::DatasetVersion* version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class AnnotationFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.AnnotationFilter) */ {
 public:
  inline AnnotationFilter() : AnnotationFilter(nullptr) {}
  ~AnnotationFilter() override;
  explicit PROTOBUF_CONSTEXPR AnnotationFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnnotationFilter(const AnnotationFilter& from);
  AnnotationFilter(AnnotationFilter&& from) noexcept
    : AnnotationFilter() {
    *this = ::std::move(from);
  }

  inline AnnotationFilter& operator=(const AnnotationFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnnotationFilter& operator=(AnnotationFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnnotationFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnnotationFilter* internal_default_instance() {
    return reinterpret_cast<const AnnotationFilter*>(
               &_AnnotationFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(AnnotationFilter& a, AnnotationFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(AnnotationFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnnotationFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnnotationFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnnotationFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnnotationFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnnotationFilter& from) {
    AnnotationFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnnotationFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.AnnotationFilter";
  }
  protected:
  explicit AnnotationFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kUserIdFieldNumber = 4,
    kAppIdFieldNumber = 5,
    kCreatedAtFieldNumber = 2,
    kModifiedAtFieldNumber = 3,
    kSavedSearchFieldNumber = 8,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string user_id = 4;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string app_id = 5;
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // .google.protobuf.Timestamp created_at = 2;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp modified_at = 3;
  bool has_modified_at() const;
  private:
  bool _internal_has_modified_at() const;
  public:
  void clear_modified_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& modified_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_modified_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_modified_at();
  void set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_modified_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_modified_at();
  public:
  void unsafe_arena_set_allocated_modified_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_modified_at();

  // .clarifai.api.Search saved_search = 8;
  bool has_saved_search() const;
  private:
  bool _internal_has_saved_search() const;
  public:
  void clear_saved_search();
  const ::clarifai::api::Search& saved_search() const;
  PROTOBUF_NODISCARD ::clarifai::api::Search* release_saved_search();
  ::clarifai::api::Search* mutable_saved_search();
  void set_allocated_saved_search(::clarifai::api::Search* saved_search);
  private:
  const ::clarifai::api::Search& _internal_saved_search() const;
  ::clarifai::api::Search* _internal_mutable_saved_search();
  public:
  void unsafe_arena_set_allocated_saved_search(
      ::clarifai::api::Search* saved_search);
  ::clarifai::api::Search* unsafe_arena_release_saved_search();

  // @@protoc_insertion_point(class_scope:clarifai.api.AnnotationFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at_;
    ::clarifai::api::Search* saved_search_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class DatasetInput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.DatasetInput) */ {
 public:
  inline DatasetInput() : DatasetInput(nullptr) {}
  ~DatasetInput() override;
  explicit PROTOBUF_CONSTEXPR DatasetInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DatasetInput(const DatasetInput& from);
  DatasetInput(DatasetInput&& from) noexcept
    : DatasetInput() {
    *this = ::std::move(from);
  }

  inline DatasetInput& operator=(const DatasetInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatasetInput& operator=(DatasetInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatasetInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const DatasetInput* internal_default_instance() {
    return reinterpret_cast<const DatasetInput*>(
               &_DatasetInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(DatasetInput& a, DatasetInput& b) {
    a.Swap(&b);
  }
  inline void Swap(DatasetInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatasetInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatasetInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatasetInput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DatasetInput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DatasetInput& from) {
    DatasetInput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatasetInput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.DatasetInput";
  }
  protected:
  explicit DatasetInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreatedAtFieldNumber = 1,
    kInputFieldNumber = 2,
  };
  // .google.protobuf.Timestamp created_at = 1;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .clarifai.api.Input input = 2;
  bool has_input() const;
  private:
  bool _internal_has_input() const;
  public:
  void clear_input();
  const ::clarifai::api::Input& input() const;
  PROTOBUF_NODISCARD ::clarifai::api::Input* release_input();
  ::clarifai::api::Input* mutable_input();
  void set_allocated_input(::clarifai::api::Input* input);
  private:
  const ::clarifai::api::Input& _internal_input() const;
  ::clarifai::api::Input* _internal_mutable_input();
  public:
  void unsafe_arena_set_allocated_input(
      ::clarifai::api::Input* input);
  ::clarifai::api::Input* unsafe_arena_release_input();

  // @@protoc_insertion_point(class_scope:clarifai.api.DatasetInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::clarifai::api::Input* input_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class DatasetVersion_MetricsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DatasetVersion_MetricsEntry_DoNotUse, 
    std::string, ::clarifai::api::DatasetVersionMetrics,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DatasetVersion_MetricsEntry_DoNotUse, 
    std::string, ::clarifai::api::DatasetVersionMetrics,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  DatasetVersion_MetricsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR DatasetVersion_MetricsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit DatasetVersion_MetricsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const DatasetVersion_MetricsEntry_DoNotUse& other);
  static const DatasetVersion_MetricsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DatasetVersion_MetricsEntry_DoNotUse*>(&_DatasetVersion_MetricsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "clarifai.api.DatasetVersion.MetricsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};

// -------------------------------------------------------------------

class DatasetVersion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.DatasetVersion) */ {
 public:
  inline DatasetVersion() : DatasetVersion(nullptr) {}
  ~DatasetVersion() override;
  explicit PROTOBUF_CONSTEXPR DatasetVersion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DatasetVersion(const DatasetVersion& from);
  DatasetVersion(DatasetVersion&& from) noexcept
    : DatasetVersion() {
    *this = ::std::move(from);
  }

  inline DatasetVersion& operator=(const DatasetVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatasetVersion& operator=(DatasetVersion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatasetVersion& default_instance() {
    return *internal_default_instance();
  }
  enum DataConfigCase {
    kAnnotationFilterConfig = 15,
    kModelPredictConfig = 18,
    DATA_CONFIG_NOT_SET = 0,
  };

  static inline const DatasetVersion* internal_default_instance() {
    return reinterpret_cast<const DatasetVersion*>(
               &_DatasetVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(DatasetVersion& a, DatasetVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(DatasetVersion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatasetVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatasetVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatasetVersion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DatasetVersion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DatasetVersion& from) {
    DatasetVersion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatasetVersion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.DatasetVersion";
  }
  protected:
  explicit DatasetVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kEmbedModelVersionIdsFieldNumber = 14,
    kMetricsFieldNumber = 16,
    kIdFieldNumber = 1,
    kAppIdFieldNumber = 4,
    kUserIdFieldNumber = 5,
    kDatasetIdFieldNumber = 6,
    kDescriptionFieldNumber = 10,
    kCreatedAtFieldNumber = 2,
    kModifiedAtFieldNumber = 3,
    kStatusFieldNumber = 8,
    kMetadataFieldNumber = 12,
    kVisibilityFieldNumber = 13,
    kExportInfoFieldNumber = 17,
    kAnnotationFilterConfigFieldNumber = 15,
    kModelPredictConfigFieldNumber = 18,
  };
  // repeated string embed_model_version_ids = 14;
  int embed_model_version_ids_size() const;
  private:
  int _internal_embed_model_version_ids_size() const;
  public:
  void clear_embed_model_version_ids();
  const std::string& embed_model_version_ids(int index) const;
  std::string* mutable_embed_model_version_ids(int index);
  void set_embed_model_version_ids(int index, const std::string& value);
  void set_embed_model_version_ids(int index, std::string&& value);
  void set_embed_model_version_ids(int index, const char* value);
  void set_embed_model_version_ids(int index, const char* value, size_t size);
  std::string* add_embed_model_version_ids();
  void add_embed_model_version_ids(const std::string& value);
  void add_embed_model_version_ids(std::string&& value);
  void add_embed_model_version_ids(const char* value);
  void add_embed_model_version_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& embed_model_version_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_embed_model_version_ids();
  private:
  const std::string& _internal_embed_model_version_ids(int index) const;
  std::string* _internal_add_embed_model_version_ids();
  public:

  // map<string, .clarifai.api.DatasetVersionMetrics> metrics = 16;
  int metrics_size() const;
  private:
  int _internal_metrics_size() const;
  public:
  void clear_metrics();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::clarifai::api::DatasetVersionMetrics >&
      _internal_metrics() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::clarifai::api::DatasetVersionMetrics >*
      _internal_mutable_metrics();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::clarifai::api::DatasetVersionMetrics >&
      metrics() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::clarifai::api::DatasetVersionMetrics >*
      mutable_metrics();

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string app_id = 4;
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // string user_id = 5;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string dataset_id = 6;
  void clear_dataset_id();
  const std::string& dataset_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dataset_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dataset_id();
  PROTOBUF_NODISCARD std::string* release_dataset_id();
  void set_allocated_dataset_id(std::string* dataset_id);
  private:
  const std::string& _internal_dataset_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dataset_id(const std::string& value);
  std::string* _internal_mutable_dataset_id();
  public:

  // string description = 10;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .google.protobuf.Timestamp created_at = 2;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp modified_at = 3;
  bool has_modified_at() const;
  private:
  bool _internal_has_modified_at() const;
  public:
  void clear_modified_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& modified_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_modified_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_modified_at();
  void set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_modified_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_modified_at();
  public:
  void unsafe_arena_set_allocated_modified_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_modified_at();

  // .clarifai.api.status.Status status = 8;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::clarifai::api::status::Status& status() const;
  PROTOBUF_NODISCARD ::clarifai::api::status::Status* release_status();
  ::clarifai::api::status::Status* mutable_status();
  void set_allocated_status(::clarifai::api::status::Status* status);
  private:
  const ::clarifai::api::status::Status& _internal_status() const;
  ::clarifai::api::status::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::clarifai::api::status::Status* status);
  ::clarifai::api::status::Status* unsafe_arena_release_status();

  // .google.protobuf.Struct metadata = 12;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  void set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata();

  // .clarifai.api.Visibility visibility = 13;
  bool has_visibility() const;
  private:
  bool _internal_has_visibility() const;
  public:
  void clear_visibility();
  const ::clarifai::api::Visibility& visibility() const;
  PROTOBUF_NODISCARD ::clarifai::api::Visibility* release_visibility();
  ::clarifai::api::Visibility* mutable_visibility();
  void set_allocated_visibility(::clarifai::api::Visibility* visibility);
  private:
  const ::clarifai::api::Visibility& _internal_visibility() const;
  ::clarifai::api::Visibility* _internal_mutable_visibility();
  public:
  void unsafe_arena_set_allocated_visibility(
      ::clarifai::api::Visibility* visibility);
  ::clarifai::api::Visibility* unsafe_arena_release_visibility();

  // .clarifai.api.DatasetVersionExportInfo export_info = 17;
  bool has_export_info() const;
  private:
  bool _internal_has_export_info() const;
  public:
  void clear_export_info();
  const ::clarifai::api::DatasetVersionExportInfo& export_info() const;
  PROTOBUF_NODISCARD ::clarifai::api::DatasetVersionExportInfo* release_export_info();
  ::clarifai::api::DatasetVersionExportInfo* mutable_export_info();
  void set_allocated_export_info(::clarifai::api::DatasetVersionExportInfo* export_info);
  private:
  const ::clarifai::api::DatasetVersionExportInfo& _internal_export_info() const;
  ::clarifai::api::DatasetVersionExportInfo* _internal_mutable_export_info();
  public:
  void unsafe_arena_set_allocated_export_info(
      ::clarifai::api::DatasetVersionExportInfo* export_info);
  ::clarifai::api::DatasetVersionExportInfo* unsafe_arena_release_export_info();

  // .clarifai.api.AnnotationFilterConfig annotation_filter_config = 15;
  bool has_annotation_filter_config() const;
  private:
  bool _internal_has_annotation_filter_config() const;
  public:
  void clear_annotation_filter_config();
  const ::clarifai::api::AnnotationFilterConfig& annotation_filter_config() const;
  PROTOBUF_NODISCARD ::clarifai::api::AnnotationFilterConfig* release_annotation_filter_config();
  ::clarifai::api::AnnotationFilterConfig* mutable_annotation_filter_config();
  void set_allocated_annotation_filter_config(::clarifai::api::AnnotationFilterConfig* annotation_filter_config);
  private:
  const ::clarifai::api::AnnotationFilterConfig& _internal_annotation_filter_config() const;
  ::clarifai::api::AnnotationFilterConfig* _internal_mutable_annotation_filter_config();
  public:
  void unsafe_arena_set_allocated_annotation_filter_config(
      ::clarifai::api::AnnotationFilterConfig* annotation_filter_config);
  ::clarifai::api::AnnotationFilterConfig* unsafe_arena_release_annotation_filter_config();

  // .clarifai.api.ModelPredictConfig model_predict_config = 18;
  bool has_model_predict_config() const;
  private:
  bool _internal_has_model_predict_config() const;
  public:
  void clear_model_predict_config();
  const ::clarifai::api::ModelPredictConfig& model_predict_config() const;
  PROTOBUF_NODISCARD ::clarifai::api::ModelPredictConfig* release_model_predict_config();
  ::clarifai::api::ModelPredictConfig* mutable_model_predict_config();
  void set_allocated_model_predict_config(::clarifai::api::ModelPredictConfig* model_predict_config);
  private:
  const ::clarifai::api::ModelPredictConfig& _internal_model_predict_config() const;
  ::clarifai::api::ModelPredictConfig* _internal_mutable_model_predict_config();
  public:
  void unsafe_arena_set_allocated_model_predict_config(
      ::clarifai::api::ModelPredictConfig* model_predict_config);
  ::clarifai::api::ModelPredictConfig* unsafe_arena_release_model_predict_config();

  void clear_data_config();
  DataConfigCase data_config_case() const;
  // @@protoc_insertion_point(class_scope:clarifai.api.DatasetVersion)
 private:
  class _Internal;
  void set_has_annotation_filter_config();
  void set_has_model_predict_config();

  inline bool has_data_config() const;
  inline void clear_has_data_config();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> embed_model_version_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        DatasetVersion_MetricsEntry_DoNotUse,
        std::string, ::clarifai::api::DatasetVersionMetrics,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> metrics_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dataset_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at_;
    ::clarifai::api::status::Status* status_;
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_;
    ::clarifai::api::Visibility* visibility_;
    ::clarifai::api::DatasetVersionExportInfo* export_info_;
    union DataConfigUnion {
      constexpr DataConfigUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::clarifai::api::AnnotationFilterConfig* annotation_filter_config_;
      ::clarifai::api::ModelPredictConfig* model_predict_config_;
    } data_config_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class AnnotationFilterConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.AnnotationFilterConfig) */ {
 public:
  inline AnnotationFilterConfig() : AnnotationFilterConfig(nullptr) {}
  ~AnnotationFilterConfig() override;
  explicit PROTOBUF_CONSTEXPR AnnotationFilterConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnnotationFilterConfig(const AnnotationFilterConfig& from);
  AnnotationFilterConfig(AnnotationFilterConfig&& from) noexcept
    : AnnotationFilterConfig() {
    *this = ::std::move(from);
  }

  inline AnnotationFilterConfig& operator=(const AnnotationFilterConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnnotationFilterConfig& operator=(AnnotationFilterConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnnotationFilterConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnnotationFilterConfig* internal_default_instance() {
    return reinterpret_cast<const AnnotationFilterConfig*>(
               &_AnnotationFilterConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(AnnotationFilterConfig& a, AnnotationFilterConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(AnnotationFilterConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnnotationFilterConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnnotationFilterConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnnotationFilterConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnnotationFilterConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnnotationFilterConfig& from) {
    AnnotationFilterConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnnotationFilterConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.AnnotationFilterConfig";
  }
  protected:
  explicit AnnotationFilterConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnnotationFilterFieldNumber = 1,
    kIgnoreEmptyInputsFieldNumber = 2,
  };
  // .clarifai.api.AnnotationFilter annotation_filter = 1;
  bool has_annotation_filter() const;
  private:
  bool _internal_has_annotation_filter() const;
  public:
  void clear_annotation_filter();
  const ::clarifai::api::AnnotationFilter& annotation_filter() const;
  PROTOBUF_NODISCARD ::clarifai::api::AnnotationFilter* release_annotation_filter();
  ::clarifai::api::AnnotationFilter* mutable_annotation_filter();
  void set_allocated_annotation_filter(::clarifai::api::AnnotationFilter* annotation_filter);
  private:
  const ::clarifai::api::AnnotationFilter& _internal_annotation_filter() const;
  ::clarifai::api::AnnotationFilter* _internal_mutable_annotation_filter();
  public:
  void unsafe_arena_set_allocated_annotation_filter(
      ::clarifai::api::AnnotationFilter* annotation_filter);
  ::clarifai::api::AnnotationFilter* unsafe_arena_release_annotation_filter();

  // bool ignore_empty_inputs = 2;
  void clear_ignore_empty_inputs();
  bool ignore_empty_inputs() const;
  void set_ignore_empty_inputs(bool value);
  private:
  bool _internal_ignore_empty_inputs() const;
  void _internal_set_ignore_empty_inputs(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.AnnotationFilterConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::clarifai::api::AnnotationFilter* annotation_filter_;
    bool ignore_empty_inputs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ModelPredictConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.ModelPredictConfig) */ {
 public:
  inline ModelPredictConfig() : ModelPredictConfig(nullptr) {}
  ~ModelPredictConfig() override;
  explicit PROTOBUF_CONSTEXPR ModelPredictConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelPredictConfig(const ModelPredictConfig& from);
  ModelPredictConfig(ModelPredictConfig&& from) noexcept
    : ModelPredictConfig() {
    *this = ::std::move(from);
  }

  inline ModelPredictConfig& operator=(const ModelPredictConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelPredictConfig& operator=(ModelPredictConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelPredictConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelPredictConfig* internal_default_instance() {
    return reinterpret_cast<const ModelPredictConfig*>(
               &_ModelPredictConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(ModelPredictConfig& a, ModelPredictConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelPredictConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelPredictConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelPredictConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelPredictConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelPredictConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelPredictConfig& from) {
    ModelPredictConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelPredictConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.ModelPredictConfig";
  }
  protected:
  explicit ModelPredictConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelFieldNumber = 1,
  };
  // .clarifai.api.Model model = 1;
  bool has_model() const;
  private:
  bool _internal_has_model() const;
  public:
  void clear_model();
  const ::clarifai::api::Model& model() const;
  PROTOBUF_NODISCARD ::clarifai::api::Model* release_model();
  ::clarifai::api::Model* mutable_model();
  void set_allocated_model(::clarifai::api::Model* model);
  private:
  const ::clarifai::api::Model& _internal_model() const;
  ::clarifai::api::Model* _internal_mutable_model();
  public:
  void unsafe_arena_set_allocated_model(
      ::clarifai::api::Model* model);
  ::clarifai::api::Model* unsafe_arena_release_model();

  // @@protoc_insertion_point(class_scope:clarifai.api.ModelPredictConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::clarifai::api::Model* model_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class DatasetVersionMetrics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.DatasetVersionMetrics) */ {
 public:
  inline DatasetVersionMetrics() : DatasetVersionMetrics(nullptr) {}
  ~DatasetVersionMetrics() override;
  explicit PROTOBUF_CONSTEXPR DatasetVersionMetrics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DatasetVersionMetrics(const DatasetVersionMetrics& from);
  DatasetVersionMetrics(DatasetVersionMetrics&& from) noexcept
    : DatasetVersionMetrics() {
    *this = ::std::move(from);
  }

  inline DatasetVersionMetrics& operator=(const DatasetVersionMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatasetVersionMetrics& operator=(DatasetVersionMetrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatasetVersionMetrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const DatasetVersionMetrics* internal_default_instance() {
    return reinterpret_cast<const DatasetVersionMetrics*>(
               &_DatasetVersionMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(DatasetVersionMetrics& a, DatasetVersionMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(DatasetVersionMetrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatasetVersionMetrics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatasetVersionMetrics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatasetVersionMetrics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DatasetVersionMetrics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DatasetVersionMetrics& from) {
    DatasetVersionMetrics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatasetVersionMetrics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.DatasetVersionMetrics";
  }
  protected:
  explicit DatasetVersionMetrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputsCountFieldNumber = 1,
    kUnlabeledInputsCountFieldNumber = 6,
    kInputsWithMetadataCountFieldNumber = 8,
    kInputsWithGeoCountFieldNumber = 9,
    kRegionsCountFieldNumber = 20,
    kRegionLocationMatrixFieldNumber = 21,
    kBoundingBoxesCountFieldNumber = 22,
    kPolygonsCountFieldNumber = 23,
    kPointsCountFieldNumber = 24,
    kMasksCountFieldNumber = 25,
    kFramesCountFieldNumber = 30,
    kEmbeddingsCountFieldNumber = 40,
    kPositiveInputTagsCountFieldNumber = 50,
    kPositiveRegionTagsCountFieldNumber = 51,
    kPositiveFrameTagsCountFieldNumber = 52,
    kRegionInputsCountFieldNumber = 60,
    kRegionFramesCountFieldNumber = 61,
    kFrameInputsCountFieldNumber = 70,
  };
  // .google.protobuf.UInt64Value inputs_count = 1;
  bool has_inputs_count() const;
  private:
  bool _internal_has_inputs_count() const;
  public:
  void clear_inputs_count();
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& inputs_count() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::UInt64Value* release_inputs_count();
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* mutable_inputs_count();
  void set_allocated_inputs_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* inputs_count);
  private:
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& _internal_inputs_count() const;
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _internal_mutable_inputs_count();
  public:
  void unsafe_arena_set_allocated_inputs_count(
      ::PROTOBUF_NAMESPACE_ID::UInt64Value* inputs_count);
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* unsafe_arena_release_inputs_count();

  // .google.protobuf.UInt64Value unlabeled_inputs_count = 6;
  bool has_unlabeled_inputs_count() const;
  private:
  bool _internal_has_unlabeled_inputs_count() const;
  public:
  void clear_unlabeled_inputs_count();
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& unlabeled_inputs_count() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::UInt64Value* release_unlabeled_inputs_count();
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* mutable_unlabeled_inputs_count();
  void set_allocated_unlabeled_inputs_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* unlabeled_inputs_count);
  private:
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& _internal_unlabeled_inputs_count() const;
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _internal_mutable_unlabeled_inputs_count();
  public:
  void unsafe_arena_set_allocated_unlabeled_inputs_count(
      ::PROTOBUF_NAMESPACE_ID::UInt64Value* unlabeled_inputs_count);
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* unsafe_arena_release_unlabeled_inputs_count();

  // .google.protobuf.UInt64Value inputs_with_metadata_count = 8;
  bool has_inputs_with_metadata_count() const;
  private:
  bool _internal_has_inputs_with_metadata_count() const;
  public:
  void clear_inputs_with_metadata_count();
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& inputs_with_metadata_count() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::UInt64Value* release_inputs_with_metadata_count();
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* mutable_inputs_with_metadata_count();
  void set_allocated_inputs_with_metadata_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* inputs_with_metadata_count);
  private:
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& _internal_inputs_with_metadata_count() const;
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _internal_mutable_inputs_with_metadata_count();
  public:
  void unsafe_arena_set_allocated_inputs_with_metadata_count(
      ::PROTOBUF_NAMESPACE_ID::UInt64Value* inputs_with_metadata_count);
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* unsafe_arena_release_inputs_with_metadata_count();

  // .google.protobuf.UInt64Value inputs_with_geo_count = 9;
  bool has_inputs_with_geo_count() const;
  private:
  bool _internal_has_inputs_with_geo_count() const;
  public:
  void clear_inputs_with_geo_count();
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& inputs_with_geo_count() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::UInt64Value* release_inputs_with_geo_count();
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* mutable_inputs_with_geo_count();
  void set_allocated_inputs_with_geo_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* inputs_with_geo_count);
  private:
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& _internal_inputs_with_geo_count() const;
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _internal_mutable_inputs_with_geo_count();
  public:
  void unsafe_arena_set_allocated_inputs_with_geo_count(
      ::PROTOBUF_NAMESPACE_ID::UInt64Value* inputs_with_geo_count);
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* unsafe_arena_release_inputs_with_geo_count();

  // .google.protobuf.UInt64Value regions_count = 20;
  bool has_regions_count() const;
  private:
  bool _internal_has_regions_count() const;
  public:
  void clear_regions_count();
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& regions_count() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::UInt64Value* release_regions_count();
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* mutable_regions_count();
  void set_allocated_regions_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* regions_count);
  private:
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& _internal_regions_count() const;
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _internal_mutable_regions_count();
  public:
  void unsafe_arena_set_allocated_regions_count(
      ::PROTOBUF_NAMESPACE_ID::UInt64Value* regions_count);
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* unsafe_arena_release_regions_count();

  // .MatrixUint64 region_location_matrix = 21;
  bool has_region_location_matrix() const;
  private:
  bool _internal_has_region_location_matrix() const;
  public:
  void clear_region_location_matrix();
  const ::MatrixUint64& region_location_matrix() const;
  PROTOBUF_NODISCARD ::MatrixUint64* release_region_location_matrix();
  ::MatrixUint64* mutable_region_location_matrix();
  void set_allocated_region_location_matrix(::MatrixUint64* region_location_matrix);
  private:
  const ::MatrixUint64& _internal_region_location_matrix() const;
  ::MatrixUint64* _internal_mutable_region_location_matrix();
  public:
  void unsafe_arena_set_allocated_region_location_matrix(
      ::MatrixUint64* region_location_matrix);
  ::MatrixUint64* unsafe_arena_release_region_location_matrix();

  // .google.protobuf.UInt64Value bounding_boxes_count = 22;
  bool has_bounding_boxes_count() const;
  private:
  bool _internal_has_bounding_boxes_count() const;
  public:
  void clear_bounding_boxes_count();
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& bounding_boxes_count() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::UInt64Value* release_bounding_boxes_count();
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* mutable_bounding_boxes_count();
  void set_allocated_bounding_boxes_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* bounding_boxes_count);
  private:
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& _internal_bounding_boxes_count() const;
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _internal_mutable_bounding_boxes_count();
  public:
  void unsafe_arena_set_allocated_bounding_boxes_count(
      ::PROTOBUF_NAMESPACE_ID::UInt64Value* bounding_boxes_count);
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* unsafe_arena_release_bounding_boxes_count();

  // .google.protobuf.UInt64Value polygons_count = 23;
  bool has_polygons_count() const;
  private:
  bool _internal_has_polygons_count() const;
  public:
  void clear_polygons_count();
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& polygons_count() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::UInt64Value* release_polygons_count();
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* mutable_polygons_count();
  void set_allocated_polygons_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* polygons_count);
  private:
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& _internal_polygons_count() const;
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _internal_mutable_polygons_count();
  public:
  void unsafe_arena_set_allocated_polygons_count(
      ::PROTOBUF_NAMESPACE_ID::UInt64Value* polygons_count);
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* unsafe_arena_release_polygons_count();

  // .google.protobuf.UInt64Value points_count = 24;
  bool has_points_count() const;
  private:
  bool _internal_has_points_count() const;
  public:
  void clear_points_count();
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& points_count() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::UInt64Value* release_points_count();
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* mutable_points_count();
  void set_allocated_points_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* points_count);
  private:
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& _internal_points_count() const;
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _internal_mutable_points_count();
  public:
  void unsafe_arena_set_allocated_points_count(
      ::PROTOBUF_NAMESPACE_ID::UInt64Value* points_count);
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* unsafe_arena_release_points_count();

  // .google.protobuf.UInt64Value masks_count = 25;
  bool has_masks_count() const;
  private:
  bool _internal_has_masks_count() const;
  public:
  void clear_masks_count();
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& masks_count() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::UInt64Value* release_masks_count();
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* mutable_masks_count();
  void set_allocated_masks_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* masks_count);
  private:
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& _internal_masks_count() const;
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _internal_mutable_masks_count();
  public:
  void unsafe_arena_set_allocated_masks_count(
      ::PROTOBUF_NAMESPACE_ID::UInt64Value* masks_count);
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* unsafe_arena_release_masks_count();

  // .google.protobuf.UInt64Value frames_count = 30;
  bool has_frames_count() const;
  private:
  bool _internal_has_frames_count() const;
  public:
  void clear_frames_count();
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& frames_count() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::UInt64Value* release_frames_count();
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* mutable_frames_count();
  void set_allocated_frames_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* frames_count);
  private:
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& _internal_frames_count() const;
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _internal_mutable_frames_count();
  public:
  void unsafe_arena_set_allocated_frames_count(
      ::PROTOBUF_NAMESPACE_ID::UInt64Value* frames_count);
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* unsafe_arena_release_frames_count();

  // .google.protobuf.UInt64Value embeddings_count = 40;
  bool has_embeddings_count() const;
  private:
  bool _internal_has_embeddings_count() const;
  public:
  void clear_embeddings_count();
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& embeddings_count() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::UInt64Value* release_embeddings_count();
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* mutable_embeddings_count();
  void set_allocated_embeddings_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* embeddings_count);
  private:
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& _internal_embeddings_count() const;
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _internal_mutable_embeddings_count();
  public:
  void unsafe_arena_set_allocated_embeddings_count(
      ::PROTOBUF_NAMESPACE_ID::UInt64Value* embeddings_count);
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* unsafe_arena_release_embeddings_count();

  // .google.protobuf.UInt64Value positive_input_tags_count = 50;
  bool has_positive_input_tags_count() const;
  private:
  bool _internal_has_positive_input_tags_count() const;
  public:
  void clear_positive_input_tags_count();
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& positive_input_tags_count() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::UInt64Value* release_positive_input_tags_count();
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* mutable_positive_input_tags_count();
  void set_allocated_positive_input_tags_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* positive_input_tags_count);
  private:
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& _internal_positive_input_tags_count() const;
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _internal_mutable_positive_input_tags_count();
  public:
  void unsafe_arena_set_allocated_positive_input_tags_count(
      ::PROTOBUF_NAMESPACE_ID::UInt64Value* positive_input_tags_count);
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* unsafe_arena_release_positive_input_tags_count();

  // .google.protobuf.UInt64Value positive_region_tags_count = 51;
  bool has_positive_region_tags_count() const;
  private:
  bool _internal_has_positive_region_tags_count() const;
  public:
  void clear_positive_region_tags_count();
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& positive_region_tags_count() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::UInt64Value* release_positive_region_tags_count();
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* mutable_positive_region_tags_count();
  void set_allocated_positive_region_tags_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* positive_region_tags_count);
  private:
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& _internal_positive_region_tags_count() const;
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _internal_mutable_positive_region_tags_count();
  public:
  void unsafe_arena_set_allocated_positive_region_tags_count(
      ::PROTOBUF_NAMESPACE_ID::UInt64Value* positive_region_tags_count);
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* unsafe_arena_release_positive_region_tags_count();

  // .google.protobuf.UInt64Value positive_frame_tags_count = 52;
  bool has_positive_frame_tags_count() const;
  private:
  bool _internal_has_positive_frame_tags_count() const;
  public:
  void clear_positive_frame_tags_count();
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& positive_frame_tags_count() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::UInt64Value* release_positive_frame_tags_count();
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* mutable_positive_frame_tags_count();
  void set_allocated_positive_frame_tags_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* positive_frame_tags_count);
  private:
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& _internal_positive_frame_tags_count() const;
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _internal_mutable_positive_frame_tags_count();
  public:
  void unsafe_arena_set_allocated_positive_frame_tags_count(
      ::PROTOBUF_NAMESPACE_ID::UInt64Value* positive_frame_tags_count);
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* unsafe_arena_release_positive_frame_tags_count();

  // .google.protobuf.UInt64Value region_inputs_count = 60;
  bool has_region_inputs_count() const;
  private:
  bool _internal_has_region_inputs_count() const;
  public:
  void clear_region_inputs_count();
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& region_inputs_count() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::UInt64Value* release_region_inputs_count();
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* mutable_region_inputs_count();
  void set_allocated_region_inputs_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* region_inputs_count);
  private:
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& _internal_region_inputs_count() const;
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _internal_mutable_region_inputs_count();
  public:
  void unsafe_arena_set_allocated_region_inputs_count(
      ::PROTOBUF_NAMESPACE_ID::UInt64Value* region_inputs_count);
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* unsafe_arena_release_region_inputs_count();

  // .google.protobuf.UInt64Value region_frames_count = 61;
  bool has_region_frames_count() const;
  private:
  bool _internal_has_region_frames_count() const;
  public:
  void clear_region_frames_count();
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& region_frames_count() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::UInt64Value* release_region_frames_count();
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* mutable_region_frames_count();
  void set_allocated_region_frames_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* region_frames_count);
  private:
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& _internal_region_frames_count() const;
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _internal_mutable_region_frames_count();
  public:
  void unsafe_arena_set_allocated_region_frames_count(
      ::PROTOBUF_NAMESPACE_ID::UInt64Value* region_frames_count);
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* unsafe_arena_release_region_frames_count();

  // .google.protobuf.UInt64Value frame_inputs_count = 70;
  bool has_frame_inputs_count() const;
  private:
  bool _internal_has_frame_inputs_count() const;
  public:
  void clear_frame_inputs_count();
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& frame_inputs_count() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::UInt64Value* release_frame_inputs_count();
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* mutable_frame_inputs_count();
  void set_allocated_frame_inputs_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* frame_inputs_count);
  private:
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value& _internal_frame_inputs_count() const;
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _internal_mutable_frame_inputs_count();
  public:
  void unsafe_arena_set_allocated_frame_inputs_count(
      ::PROTOBUF_NAMESPACE_ID::UInt64Value* frame_inputs_count);
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* unsafe_arena_release_frame_inputs_count();

  // @@protoc_insertion_point(class_scope:clarifai.api.DatasetVersionMetrics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* inputs_count_;
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* unlabeled_inputs_count_;
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* inputs_with_metadata_count_;
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* inputs_with_geo_count_;
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* regions_count_;
    ::MatrixUint64* region_location_matrix_;
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* bounding_boxes_count_;
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* polygons_count_;
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* points_count_;
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* masks_count_;
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* frames_count_;
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* embeddings_count_;
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* positive_input_tags_count_;
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* positive_region_tags_count_;
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* positive_frame_tags_count_;
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* region_inputs_count_;
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* region_frames_count_;
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* frame_inputs_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class DatasetVersionMetricsGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.DatasetVersionMetricsGroup) */ {
 public:
  inline DatasetVersionMetricsGroup() : DatasetVersionMetricsGroup(nullptr) {}
  ~DatasetVersionMetricsGroup() override;
  explicit PROTOBUF_CONSTEXPR DatasetVersionMetricsGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DatasetVersionMetricsGroup(const DatasetVersionMetricsGroup& from);
  DatasetVersionMetricsGroup(DatasetVersionMetricsGroup&& from) noexcept
    : DatasetVersionMetricsGroup() {
    *this = ::std::move(from);
  }

  inline DatasetVersionMetricsGroup& operator=(const DatasetVersionMetricsGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatasetVersionMetricsGroup& operator=(DatasetVersionMetricsGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatasetVersionMetricsGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const DatasetVersionMetricsGroup* internal_default_instance() {
    return reinterpret_cast<const DatasetVersionMetricsGroup*>(
               &_DatasetVersionMetricsGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(DatasetVersionMetricsGroup& a, DatasetVersionMetricsGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(DatasetVersionMetricsGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatasetVersionMetricsGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatasetVersionMetricsGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatasetVersionMetricsGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DatasetVersionMetricsGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DatasetVersionMetricsGroup& from) {
    DatasetVersionMetricsGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatasetVersionMetricsGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.DatasetVersionMetricsGroup";
  }
  protected:
  explicit DatasetVersionMetricsGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentPathFieldNumber = 1,
    kValueFieldNumber = 3,
    kMetricsFieldNumber = 4,
    kTypeFieldNumber = 2,
  };
  // string parent_path = 1;
  void clear_parent_path();
  const std::string& parent_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_path();
  PROTOBUF_NODISCARD std::string* release_parent_path();
  void set_allocated_parent_path(std::string* parent_path);
  private:
  const std::string& _internal_parent_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_path(const std::string& value);
  std::string* _internal_mutable_parent_path();
  public:

  // .google.protobuf.Value value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::PROTOBUF_NAMESPACE_ID::Value& value() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Value* release_value();
  ::PROTOBUF_NAMESPACE_ID::Value* mutable_value();
  void set_allocated_value(::PROTOBUF_NAMESPACE_ID::Value* value);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Value& _internal_value() const;
  ::PROTOBUF_NAMESPACE_ID::Value* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::PROTOBUF_NAMESPACE_ID::Value* value);
  ::PROTOBUF_NAMESPACE_ID::Value* unsafe_arena_release_value();

  // .clarifai.api.DatasetVersionMetrics metrics = 4;
  bool has_metrics() const;
  private:
  bool _internal_has_metrics() const;
  public:
  void clear_metrics();
  const ::clarifai::api::DatasetVersionMetrics& metrics() const;
  PROTOBUF_NODISCARD ::clarifai::api::DatasetVersionMetrics* release_metrics();
  ::clarifai::api::DatasetVersionMetrics* mutable_metrics();
  void set_allocated_metrics(::clarifai::api::DatasetVersionMetrics* metrics);
  private:
  const ::clarifai::api::DatasetVersionMetrics& _internal_metrics() const;
  ::clarifai::api::DatasetVersionMetrics* _internal_mutable_metrics();
  public:
  void unsafe_arena_set_allocated_metrics(
      ::clarifai::api::DatasetVersionMetrics* metrics);
  ::clarifai::api::DatasetVersionMetrics* unsafe_arena_release_metrics();

  // .clarifai.api.DatasetVersionMetricsGroupType type = 2;
  void clear_type();
  ::clarifai::api::DatasetVersionMetricsGroupType type() const;
  void set_type(::clarifai::api::DatasetVersionMetricsGroupType value);
  private:
  ::clarifai::api::DatasetVersionMetricsGroupType _internal_type() const;
  void _internal_set_type(::clarifai::api::DatasetVersionMetricsGroupType value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.DatasetVersionMetricsGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_path_;
    ::PROTOBUF_NAMESPACE_ID::Value* value_;
    ::clarifai::api::DatasetVersionMetrics* metrics_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class DatasetVersionExportInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.DatasetVersionExportInfo) */ {
 public:
  inline DatasetVersionExportInfo() : DatasetVersionExportInfo(nullptr) {}
  ~DatasetVersionExportInfo() override;
  explicit PROTOBUF_CONSTEXPR DatasetVersionExportInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DatasetVersionExportInfo(const DatasetVersionExportInfo& from);
  DatasetVersionExportInfo(DatasetVersionExportInfo&& from) noexcept
    : DatasetVersionExportInfo() {
    *this = ::std::move(from);
  }

  inline DatasetVersionExportInfo& operator=(const DatasetVersionExportInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatasetVersionExportInfo& operator=(DatasetVersionExportInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatasetVersionExportInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DatasetVersionExportInfo* internal_default_instance() {
    return reinterpret_cast<const DatasetVersionExportInfo*>(
               &_DatasetVersionExportInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(DatasetVersionExportInfo& a, DatasetVersionExportInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DatasetVersionExportInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatasetVersionExportInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatasetVersionExportInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatasetVersionExportInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DatasetVersionExportInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DatasetVersionExportInfo& from) {
    DatasetVersionExportInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatasetVersionExportInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.DatasetVersionExportInfo";
  }
  protected:
  explicit DatasetVersionExportInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClarifaiDataProtobufFieldNumber = 1,
    kCocoFieldNumber = 2,
    kClarifaiDataJsonFieldNumber = 3,
  };
  // .clarifai.api.DatasetVersionExport clarifai_data_protobuf = 1;
  bool has_clarifai_data_protobuf() const;
  private:
  bool _internal_has_clarifai_data_protobuf() const;
  public:
  void clear_clarifai_data_protobuf();
  const ::clarifai::api::DatasetVersionExport& clarifai_data_protobuf() const;
  PROTOBUF_NODISCARD ::clarifai::api::DatasetVersionExport* release_clarifai_data_protobuf();
  ::clarifai::api::DatasetVersionExport* mutable_clarifai_data_protobuf();
  void set_allocated_clarifai_data_protobuf(::clarifai::api::DatasetVersionExport* clarifai_data_protobuf);
  private:
  const ::clarifai::api::DatasetVersionExport& _internal_clarifai_data_protobuf() const;
  ::clarifai::api::DatasetVersionExport* _internal_mutable_clarifai_data_protobuf();
  public:
  void unsafe_arena_set_allocated_clarifai_data_protobuf(
      ::clarifai::api::DatasetVersionExport* clarifai_data_protobuf);
  ::clarifai::api::DatasetVersionExport* unsafe_arena_release_clarifai_data_protobuf();

  // .clarifai.api.DatasetVersionExport coco = 2;
  bool has_coco() const;
  private:
  bool _internal_has_coco() const;
  public:
  void clear_coco();
  const ::clarifai::api::DatasetVersionExport& coco() const;
  PROTOBUF_NODISCARD ::clarifai::api::DatasetVersionExport* release_coco();
  ::clarifai::api::DatasetVersionExport* mutable_coco();
  void set_allocated_coco(::clarifai::api::DatasetVersionExport* coco);
  private:
  const ::clarifai::api::DatasetVersionExport& _internal_coco() const;
  ::clarifai::api::DatasetVersionExport* _internal_mutable_coco();
  public:
  void unsafe_arena_set_allocated_coco(
      ::clarifai::api::DatasetVersionExport* coco);
  ::clarifai::api::DatasetVersionExport* unsafe_arena_release_coco();

  // .clarifai.api.DatasetVersionExport clarifai_data_json = 3;
  bool has_clarifai_data_json() const;
  private:
  bool _internal_has_clarifai_data_json() const;
  public:
  void clear_clarifai_data_json();
  const ::clarifai::api::DatasetVersionExport& clarifai_data_json() const;
  PROTOBUF_NODISCARD ::clarifai::api::DatasetVersionExport* release_clarifai_data_json();
  ::clarifai::api::DatasetVersionExport* mutable_clarifai_data_json();
  void set_allocated_clarifai_data_json(::clarifai::api::DatasetVersionExport* clarifai_data_json);
  private:
  const ::clarifai::api::DatasetVersionExport& _internal_clarifai_data_json() const;
  ::clarifai::api::DatasetVersionExport* _internal_mutable_clarifai_data_json();
  public:
  void unsafe_arena_set_allocated_clarifai_data_json(
      ::clarifai::api::DatasetVersionExport* clarifai_data_json);
  ::clarifai::api::DatasetVersionExport* unsafe_arena_release_clarifai_data_json();

  // @@protoc_insertion_point(class_scope:clarifai.api.DatasetVersionExportInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::clarifai::api::DatasetVersionExport* clarifai_data_protobuf_;
    ::clarifai::api::DatasetVersionExport* coco_;
    ::clarifai::api::DatasetVersionExport* clarifai_data_json_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class DatasetVersionExport final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.DatasetVersionExport) */ {
 public:
  inline DatasetVersionExport() : DatasetVersionExport(nullptr) {}
  ~DatasetVersionExport() override;
  explicit PROTOBUF_CONSTEXPR DatasetVersionExport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DatasetVersionExport(const DatasetVersionExport& from);
  DatasetVersionExport(DatasetVersionExport&& from) noexcept
    : DatasetVersionExport() {
    *this = ::std::move(from);
  }

  inline DatasetVersionExport& operator=(const DatasetVersionExport& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatasetVersionExport& operator=(DatasetVersionExport&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatasetVersionExport& default_instance() {
    return *internal_default_instance();
  }
  static inline const DatasetVersionExport* internal_default_instance() {
    return reinterpret_cast<const DatasetVersionExport*>(
               &_DatasetVersionExport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(DatasetVersionExport& a, DatasetVersionExport& b) {
    a.Swap(&b);
  }
  inline void Swap(DatasetVersionExport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatasetVersionExport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatasetVersionExport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatasetVersionExport>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DatasetVersionExport& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DatasetVersionExport& from) {
    DatasetVersionExport::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatasetVersionExport* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.DatasetVersionExport";
  }
  protected:
  explicit DatasetVersionExport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 3,
    kStatusFieldNumber = 2,
    kSizeFieldNumber = 4,
    kFormatFieldNumber = 1,
  };
  // string url = 3;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // .clarifai.api.status.Status status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::clarifai::api::status::Status& status() const;
  PROTOBUF_NODISCARD ::clarifai::api::status::Status* release_status();
  ::clarifai::api::status::Status* mutable_status();
  void set_allocated_status(::clarifai::api::status::Status* status);
  private:
  const ::clarifai::api::status::Status& _internal_status() const;
  ::clarifai::api::status::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::clarifai::api::status::Status* status);
  ::clarifai::api::status::Status* unsafe_arena_release_status();

  // uint64 size = 4;
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // .clarifai.api.DatasetVersionExportFormat format = 1;
  void clear_format();
  ::clarifai::api::DatasetVersionExportFormat format() const;
  void set_format(::clarifai::api::DatasetVersionExportFormat value);
  private:
  ::clarifai::api::DatasetVersionExportFormat _internal_format() const;
  void _internal_set_format(::clarifai::api::DatasetVersionExportFormat value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.DatasetVersionExport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::clarifai::api::status::Status* status_;
    uint64_t size_;
    int format_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class WorkflowResultsSimilarity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.WorkflowResultsSimilarity) */ {
 public:
  inline WorkflowResultsSimilarity() : WorkflowResultsSimilarity(nullptr) {}
  ~WorkflowResultsSimilarity() override;
  explicit PROTOBUF_CONSTEXPR WorkflowResultsSimilarity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkflowResultsSimilarity(const WorkflowResultsSimilarity& from);
  WorkflowResultsSimilarity(WorkflowResultsSimilarity&& from) noexcept
    : WorkflowResultsSimilarity() {
    *this = ::std::move(from);
  }

  inline WorkflowResultsSimilarity& operator=(const WorkflowResultsSimilarity& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkflowResultsSimilarity& operator=(WorkflowResultsSimilarity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkflowResultsSimilarity& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkflowResultsSimilarity* internal_default_instance() {
    return reinterpret_cast<const WorkflowResultsSimilarity*>(
               &_WorkflowResultsSimilarity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(WorkflowResultsSimilarity& a, WorkflowResultsSimilarity& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkflowResultsSimilarity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkflowResultsSimilarity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkflowResultsSimilarity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkflowResultsSimilarity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkflowResultsSimilarity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkflowResultsSimilarity& from) {
    WorkflowResultsSimilarity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowResultsSimilarity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.WorkflowResultsSimilarity";
  }
  protected:
  explicit WorkflowResultsSimilarity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoolResultsFieldNumber = 2,
    kProbeInputFieldNumber = 1,
  };
  // repeated .clarifai.api.Hit pool_results = 2;
  int pool_results_size() const;
  private:
  int _internal_pool_results_size() const;
  public:
  void clear_pool_results();
  ::clarifai::api::Hit* mutable_pool_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Hit >*
      mutable_pool_results();
  private:
  const ::clarifai::api::Hit& _internal_pool_results(int index) const;
  ::clarifai::api::Hit* _internal_add_pool_results();
  public:
  const ::clarifai::api::Hit& pool_results(int index) const;
  ::clarifai::api::Hit* add_pool_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Hit >&
      pool_results() const;

  // .clarifai.api.Input probe_input = 1;
  bool has_probe_input() const;
  private:
  bool _internal_has_probe_input() const;
  public:
  void clear_probe_input();
  const ::clarifai::api::Input& probe_input() const;
  PROTOBUF_NODISCARD ::clarifai::api::Input* release_probe_input();
  ::clarifai::api::Input* mutable_probe_input();
  void set_allocated_probe_input(::clarifai::api::Input* probe_input);
  private:
  const ::clarifai::api::Input& _internal_probe_input() const;
  ::clarifai::api::Input* _internal_mutable_probe_input();
  public:
  void unsafe_arena_set_allocated_probe_input(
      ::clarifai::api::Input* probe_input);
  ::clarifai::api::Input* unsafe_arena_release_probe_input();

  // @@protoc_insertion_point(class_scope:clarifai.api.WorkflowResultsSimilarity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Hit > pool_results_;
    ::clarifai::api::Input* probe_input_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Key final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Key) */ {
 public:
  inline Key() : Key(nullptr) {}
  ~Key() override;
  explicit PROTOBUF_CONSTEXPR Key(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Key(const Key& from);
  Key(Key&& from) noexcept
    : Key() {
    *this = ::std::move(from);
  }

  inline Key& operator=(const Key& from) {
    CopyFrom(from);
    return *this;
  }
  inline Key& operator=(Key&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Key& default_instance() {
    return *internal_default_instance();
  }
  static inline const Key* internal_default_instance() {
    return reinterpret_cast<const Key*>(
               &_Key_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(Key& a, Key& b) {
    a.Swap(&b);
  }
  inline void Swap(Key* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Key* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Key* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Key>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Key& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Key& from) {
    Key::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Key* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Key";
  }
  protected:
  explicit Key(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScopesFieldNumber = 3,
    kAppsFieldNumber = 4,
    kEndpointsFieldNumber = 7,
    kAuthorizedIdpIdsFieldNumber = 9,
    kIdFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kTypeFieldNumber = 8,
    kCreatedAtFieldNumber = 5,
    kExpiresAtFieldNumber = 6,
  };
  // repeated string scopes = 3;
  int scopes_size() const;
  private:
  int _internal_scopes_size() const;
  public:
  void clear_scopes();
  const std::string& scopes(int index) const;
  std::string* mutable_scopes(int index);
  void set_scopes(int index, const std::string& value);
  void set_scopes(int index, std::string&& value);
  void set_scopes(int index, const char* value);
  void set_scopes(int index, const char* value, size_t size);
  std::string* add_scopes();
  void add_scopes(const std::string& value);
  void add_scopes(std::string&& value);
  void add_scopes(const char* value);
  void add_scopes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& scopes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_scopes();
  private:
  const std::string& _internal_scopes(int index) const;
  std::string* _internal_add_scopes();
  public:

  // repeated .clarifai.api.App apps = 4;
  int apps_size() const;
  private:
  int _internal_apps_size() const;
  public:
  void clear_apps();
  ::clarifai::api::App* mutable_apps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::App >*
      mutable_apps();
  private:
  const ::clarifai::api::App& _internal_apps(int index) const;
  ::clarifai::api::App* _internal_add_apps();
  public:
  const ::clarifai::api::App& apps(int index) const;
  ::clarifai::api::App* add_apps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::App >&
      apps() const;

  // repeated string endpoints = 7;
  int endpoints_size() const;
  private:
  int _internal_endpoints_size() const;
  public:
  void clear_endpoints();
  const std::string& endpoints(int index) const;
  std::string* mutable_endpoints(int index);
  void set_endpoints(int index, const std::string& value);
  void set_endpoints(int index, std::string&& value);
  void set_endpoints(int index, const char* value);
  void set_endpoints(int index, const char* value, size_t size);
  std::string* add_endpoints();
  void add_endpoints(const std::string& value);
  void add_endpoints(std::string&& value);
  void add_endpoints(const char* value);
  void add_endpoints(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& endpoints() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_endpoints();
  private:
  const std::string& _internal_endpoints(int index) const;
  std::string* _internal_add_endpoints();
  public:

  // repeated string authorized_idp_ids = 9;
  int authorized_idp_ids_size() const;
  private:
  int _internal_authorized_idp_ids_size() const;
  public:
  void clear_authorized_idp_ids();
  const std::string& authorized_idp_ids(int index) const;
  std::string* mutable_authorized_idp_ids(int index);
  void set_authorized_idp_ids(int index, const std::string& value);
  void set_authorized_idp_ids(int index, std::string&& value);
  void set_authorized_idp_ids(int index, const char* value);
  void set_authorized_idp_ids(int index, const char* value, size_t size);
  std::string* add_authorized_idp_ids();
  void add_authorized_idp_ids(const std::string& value);
  void add_authorized_idp_ids(std::string&& value);
  void add_authorized_idp_ids(const char* value);
  void add_authorized_idp_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& authorized_idp_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_authorized_idp_ids();
  private:
  const std::string& _internal_authorized_idp_ids(int index) const;
  std::string* _internal_add_authorized_idp_ids();
  public:

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string type = 8;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // .google.protobuf.Timestamp created_at = 5;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp expires_at = 6;
  bool has_expires_at() const;
  private:
  bool _internal_has_expires_at() const;
  public:
  void clear_expires_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& expires_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_expires_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_expires_at();
  void set_allocated_expires_at(::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_expires_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_expires_at();
  public:
  void unsafe_arena_set_allocated_expires_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_expires_at();

  // @@protoc_insertion_point(class_scope:clarifai.api.Key)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> scopes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::App > apps_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> endpoints_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> authorized_idp_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Model final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Model) */ {
 public:
  inline Model() : Model(nullptr) {}
  ~Model() override;
  explicit PROTOBUF_CONSTEXPR Model(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Model(const Model& from);
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  inline Model& operator=(Model&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Model& default_instance() {
    return *internal_default_instance();
  }
  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }
  inline void Swap(Model* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Model* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Model* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Model>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Model& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Model& from) {
    Model::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Model* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Model";
  }
  protected:
  explicit Model(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToolkitsFieldNumber = 20,
    kUseCasesFieldNumber = 21,
    kLanguagesFieldNumber = 25,
    kLanguagesFullFieldNumber = 31,
    kCheckConsentsFieldNumber = 32,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kAppIdFieldNumber = 4,
    kDisplayNameFieldNumber = 7,
    kUserIdFieldNumber = 9,
    kModelTypeIdFieldNumber = 14,
    kDescriptionFieldNumber = 16,
    kNotesFieldNumber = 18,
    kTaskFieldNumber = 26,
    kCreatedAtFieldNumber = 3,
    kOutputInfoFieldNumber = 5,
    kModelVersionFieldNumber = 6,
    kInputInfoFieldNumber = 12,
    kTrainInfoFieldNumber = 13,
    kVisibilityFieldNumber = 15,
    kMetadataFieldNumber = 17,
    kModifiedAtFieldNumber = 19,
    kImportInfoFieldNumber = 24,
    kPresetsFieldNumber = 27,
    kWorkflowRecommendedFieldNumber = 29,
    kDefaultEvalInfoFieldNumber = 30,
    kIsStarredFieldNumber = 22,
    kStarCountFieldNumber = 23,
  };
  // repeated string toolkits = 20 [(.clarifai.api.utils.cl_show_if_empty) = true];
  int toolkits_size() const;
  private:
  int _internal_toolkits_size() const;
  public:
  void clear_toolkits();
  const std::string& toolkits(int index) const;
  std::string* mutable_toolkits(int index);
  void set_toolkits(int index, const std::string& value);
  void set_toolkits(int index, std::string&& value);
  void set_toolkits(int index, const char* value);
  void set_toolkits(int index, const char* value, size_t size);
  std::string* add_toolkits();
  void add_toolkits(const std::string& value);
  void add_toolkits(std::string&& value);
  void add_toolkits(const char* value);
  void add_toolkits(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& toolkits() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_toolkits();
  private:
  const std::string& _internal_toolkits(int index) const;
  std::string* _internal_add_toolkits();
  public:

  // repeated string use_cases = 21 [(.clarifai.api.utils.cl_show_if_empty) = true];
  int use_cases_size() const;
  private:
  int _internal_use_cases_size() const;
  public:
  void clear_use_cases();
  const std::string& use_cases(int index) const;
  std::string* mutable_use_cases(int index);
  void set_use_cases(int index, const std::string& value);
  void set_use_cases(int index, std::string&& value);
  void set_use_cases(int index, const char* value);
  void set_use_cases(int index, const char* value, size_t size);
  std::string* add_use_cases();
  void add_use_cases(const std::string& value);
  void add_use_cases(std::string&& value);
  void add_use_cases(const char* value);
  void add_use_cases(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& use_cases() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_use_cases();
  private:
  const std::string& _internal_use_cases(int index) const;
  std::string* _internal_add_use_cases();
  public:

  // repeated string languages = 25 [(.clarifai.api.utils.cl_show_if_empty) = true];
  int languages_size() const;
  private:
  int _internal_languages_size() const;
  public:
  void clear_languages();
  const std::string& languages(int index) const;
  std::string* mutable_languages(int index);
  void set_languages(int index, const std::string& value);
  void set_languages(int index, std::string&& value);
  void set_languages(int index, const char* value);
  void set_languages(int index, const char* value, size_t size);
  std::string* add_languages();
  void add_languages(const std::string& value);
  void add_languages(std::string&& value);
  void add_languages(const char* value);
  void add_languages(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& languages() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_languages();
  private:
  const std::string& _internal_languages(int index) const;
  std::string* _internal_add_languages();
  public:

  // repeated .clarifai.api.FullTag languages_full = 31 [(.clarifai.api.utils.cl_show_if_empty) = true];
  int languages_full_size() const;
  private:
  int _internal_languages_full_size() const;
  public:
  void clear_languages_full();
  ::clarifai::api::FullTag* mutable_languages_full(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::FullTag >*
      mutable_languages_full();
  private:
  const ::clarifai::api::FullTag& _internal_languages_full(int index) const;
  ::clarifai::api::FullTag* _internal_add_languages_full();
  public:
  const ::clarifai::api::FullTag& languages_full(int index) const;
  ::clarifai::api::FullTag* add_languages_full();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::FullTag >&
      languages_full() const;

  // repeated string check_consents = 32 [(.clarifai.api.utils.cl_show_if_empty) = true];
  int check_consents_size() const;
  private:
  int _internal_check_consents_size() const;
  public:
  void clear_check_consents();
  const std::string& check_consents(int index) const;
  std::string* mutable_check_consents(int index);
  void set_check_consents(int index, const std::string& value);
  void set_check_consents(int index, std::string&& value);
  void set_check_consents(int index, const char* value);
  void set_check_consents(int index, const char* value, size_t size);
  std::string* add_check_consents();
  void add_check_consents(const std::string& value);
  void add_check_consents(std::string&& value);
  void add_check_consents(const char* value);
  void add_check_consents(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& check_consents() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_check_consents();
  private:
  const std::string& _internal_check_consents(int index) const;
  std::string* _internal_add_check_consents();
  public:

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_name();
  PROTOBUF_DEPRECATED const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_name(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_name();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_name();
  PROTOBUF_DEPRECATED void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string app_id = 4 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // string display_name = 7 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_display_name();
  PROTOBUF_DEPRECATED const std::string& display_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_display_name(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_display_name();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_display_name();
  PROTOBUF_DEPRECATED void set_allocated_display_name(std::string* display_name);
  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
  std::string* _internal_mutable_display_name();
  public:

  // string user_id = 9;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string model_type_id = 14;
  void clear_model_type_id();
  const std::string& model_type_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_type_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_type_id();
  PROTOBUF_NODISCARD std::string* release_model_type_id();
  void set_allocated_model_type_id(std::string* model_type_id);
  private:
  const std::string& _internal_model_type_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_type_id(const std::string& value);
  std::string* _internal_mutable_model_type_id();
  public:

  // string description = 16;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string notes = 18;
  void clear_notes();
  const std::string& notes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_notes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_notes();
  PROTOBUF_NODISCARD std::string* release_notes();
  void set_allocated_notes(std::string* notes);
  private:
  const std::string& _internal_notes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_notes(const std::string& value);
  std::string* _internal_mutable_notes();
  public:

  // string task = 26;
  void clear_task();
  const std::string& task() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task();
  PROTOBUF_NODISCARD std::string* release_task();
  void set_allocated_task(std::string* task);
  private:
  const std::string& _internal_task() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task(const std::string& value);
  std::string* _internal_mutable_task();
  public:

  // .google.protobuf.Timestamp created_at = 3;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .clarifai.api.OutputInfo output_info = 5 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_output_info() const;
  private:
  bool _internal_has_output_info() const;
  public:
  PROTOBUF_DEPRECATED void clear_output_info();
  PROTOBUF_DEPRECATED const ::clarifai::api::OutputInfo& output_info() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::clarifai::api::OutputInfo* release_output_info();
  PROTOBUF_DEPRECATED ::clarifai::api::OutputInfo* mutable_output_info();
  PROTOBUF_DEPRECATED void set_allocated_output_info(::clarifai::api::OutputInfo* output_info);
  private:
  const ::clarifai::api::OutputInfo& _internal_output_info() const;
  ::clarifai::api::OutputInfo* _internal_mutable_output_info();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_output_info(
      ::clarifai::api::OutputInfo* output_info);
  PROTOBUF_DEPRECATED ::clarifai::api::OutputInfo* unsafe_arena_release_output_info();

  // .clarifai.api.ModelVersion model_version = 6;
  bool has_model_version() const;
  private:
  bool _internal_has_model_version() const;
  public:
  void clear_model_version();
  const ::clarifai::api::ModelVersion& model_version() const;
  PROTOBUF_NODISCARD ::clarifai::api::ModelVersion* release_model_version();
  ::clarifai::api::ModelVersion* mutable_model_version();
  void set_allocated_model_version(::clarifai::api::ModelVersion* model_version);
  private:
  const ::clarifai::api::ModelVersion& _internal_model_version() const;
  ::clarifai::api::ModelVersion* _internal_mutable_model_version();
  public:
  void unsafe_arena_set_allocated_model_version(
      ::clarifai::api::ModelVersion* model_version);
  ::clarifai::api::ModelVersion* unsafe_arena_release_model_version();

  // .clarifai.api.InputInfo input_info = 12 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_input_info() const;
  private:
  bool _internal_has_input_info() const;
  public:
  PROTOBUF_DEPRECATED void clear_input_info();
  PROTOBUF_DEPRECATED const ::clarifai::api::InputInfo& input_info() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::clarifai::api::InputInfo* release_input_info();
  PROTOBUF_DEPRECATED ::clarifai::api::InputInfo* mutable_input_info();
  PROTOBUF_DEPRECATED void set_allocated_input_info(::clarifai::api::InputInfo* input_info);
  private:
  const ::clarifai::api::InputInfo& _internal_input_info() const;
  ::clarifai::api::InputInfo* _internal_mutable_input_info();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_input_info(
      ::clarifai::api::InputInfo* input_info);
  PROTOBUF_DEPRECATED ::clarifai::api::InputInfo* unsafe_arena_release_input_info();

  // .clarifai.api.TrainInfo train_info = 13 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_train_info() const;
  private:
  bool _internal_has_train_info() const;
  public:
  PROTOBUF_DEPRECATED void clear_train_info();
  PROTOBUF_DEPRECATED const ::clarifai::api::TrainInfo& train_info() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::clarifai::api::TrainInfo* release_train_info();
  PROTOBUF_DEPRECATED ::clarifai::api::TrainInfo* mutable_train_info();
  PROTOBUF_DEPRECATED void set_allocated_train_info(::clarifai::api::TrainInfo* train_info);
  private:
  const ::clarifai::api::TrainInfo& _internal_train_info() const;
  ::clarifai::api::TrainInfo* _internal_mutable_train_info();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_train_info(
      ::clarifai::api::TrainInfo* train_info);
  PROTOBUF_DEPRECATED ::clarifai::api::TrainInfo* unsafe_arena_release_train_info();

  // .clarifai.api.Visibility visibility = 15;
  bool has_visibility() const;
  private:
  bool _internal_has_visibility() const;
  public:
  void clear_visibility();
  const ::clarifai::api::Visibility& visibility() const;
  PROTOBUF_NODISCARD ::clarifai::api::Visibility* release_visibility();
  ::clarifai::api::Visibility* mutable_visibility();
  void set_allocated_visibility(::clarifai::api::Visibility* visibility);
  private:
  const ::clarifai::api::Visibility& _internal_visibility() const;
  ::clarifai::api::Visibility* _internal_mutable_visibility();
  public:
  void unsafe_arena_set_allocated_visibility(
      ::clarifai::api::Visibility* visibility);
  ::clarifai::api::Visibility* unsafe_arena_release_visibility();

  // .google.protobuf.Struct metadata = 17;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  void set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata();

  // .google.protobuf.Timestamp modified_at = 19;
  bool has_modified_at() const;
  private:
  bool _internal_has_modified_at() const;
  public:
  void clear_modified_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& modified_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_modified_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_modified_at();
  void set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_modified_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_modified_at();
  public:
  void unsafe_arena_set_allocated_modified_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_modified_at();

  // .clarifai.api.ImportInfo import_info = 24 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_import_info() const;
  private:
  bool _internal_has_import_info() const;
  public:
  PROTOBUF_DEPRECATED void clear_import_info();
  PROTOBUF_DEPRECATED const ::clarifai::api::ImportInfo& import_info() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::clarifai::api::ImportInfo* release_import_info();
  PROTOBUF_DEPRECATED ::clarifai::api::ImportInfo* mutable_import_info();
  PROTOBUF_DEPRECATED void set_allocated_import_info(::clarifai::api::ImportInfo* import_info);
  private:
  const ::clarifai::api::ImportInfo& _internal_import_info() const;
  ::clarifai::api::ImportInfo* _internal_mutable_import_info();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_import_info(
      ::clarifai::api::ImportInfo* import_info);
  PROTOBUF_DEPRECATED ::clarifai::api::ImportInfo* unsafe_arena_release_import_info();

  // .google.protobuf.Struct presets = 27;
  bool has_presets() const;
  private:
  bool _internal_has_presets() const;
  public:
  void clear_presets();
  const ::PROTOBUF_NAMESPACE_ID::Struct& presets() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_presets();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_presets();
  void set_allocated_presets(::PROTOBUF_NAMESPACE_ID::Struct* presets);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_presets() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_presets();
  public:
  void unsafe_arena_set_allocated_presets(
      ::PROTOBUF_NAMESPACE_ID::Struct* presets);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_presets();

  // .google.protobuf.BoolValue workflow_recommended = 29;
  bool has_workflow_recommended() const;
  private:
  bool _internal_has_workflow_recommended() const;
  public:
  void clear_workflow_recommended();
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& workflow_recommended() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_workflow_recommended();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_workflow_recommended();
  void set_allocated_workflow_recommended(::PROTOBUF_NAMESPACE_ID::BoolValue* workflow_recommended);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_workflow_recommended() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_workflow_recommended();
  public:
  void unsafe_arena_set_allocated_workflow_recommended(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* workflow_recommended);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_workflow_recommended();

  // .clarifai.api.EvalInfo default_eval_info = 30;
  bool has_default_eval_info() const;
  private:
  bool _internal_has_default_eval_info() const;
  public:
  void clear_default_eval_info();
  const ::clarifai::api::EvalInfo& default_eval_info() const;
  PROTOBUF_NODISCARD ::clarifai::api::EvalInfo* release_default_eval_info();
  ::clarifai::api::EvalInfo* mutable_default_eval_info();
  void set_allocated_default_eval_info(::clarifai::api::EvalInfo* default_eval_info);
  private:
  const ::clarifai::api::EvalInfo& _internal_default_eval_info() const;
  ::clarifai::api::EvalInfo* _internal_mutable_default_eval_info();
  public:
  void unsafe_arena_set_allocated_default_eval_info(
      ::clarifai::api::EvalInfo* default_eval_info);
  ::clarifai::api::EvalInfo* unsafe_arena_release_default_eval_info();

  // bool is_starred = 22;
  void clear_is_starred();
  bool is_starred() const;
  void set_is_starred(bool value);
  private:
  bool _internal_is_starred() const;
  void _internal_set_is_starred(bool value);
  public:

  // int32 star_count = 23;
  void clear_star_count();
  int32_t star_count() const;
  void set_star_count(int32_t value);
  private:
  int32_t _internal_star_count() const;
  void _internal_set_star_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.Model)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> toolkits_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> use_cases_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> languages_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::FullTag > languages_full_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> check_consents_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_type_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr notes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::clarifai::api::OutputInfo* output_info_;
    ::clarifai::api::ModelVersion* model_version_;
    ::clarifai::api::InputInfo* input_info_;
    ::clarifai::api::TrainInfo* train_info_;
    ::clarifai::api::Visibility* visibility_;
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at_;
    ::clarifai::api::ImportInfo* import_info_;
    ::PROTOBUF_NAMESPACE_ID::Struct* presets_;
    ::PROTOBUF_NAMESPACE_ID::BoolValue* workflow_recommended_;
    ::clarifai::api::EvalInfo* default_eval_info_;
    bool is_starred_;
    int32_t star_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ModelReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.ModelReference) */ {
 public:
  inline ModelReference() : ModelReference(nullptr) {}
  ~ModelReference() override;
  explicit PROTOBUF_CONSTEXPR ModelReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelReference(const ModelReference& from);
  ModelReference(ModelReference&& from) noexcept
    : ModelReference() {
    *this = ::std::move(from);
  }

  inline ModelReference& operator=(const ModelReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelReference& operator=(ModelReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelReference* internal_default_instance() {
    return reinterpret_cast<const ModelReference*>(
               &_ModelReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(ModelReference& a, ModelReference& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelReference& from) {
    ModelReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.ModelReference";
  }
  protected:
  explicit ModelReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kModelIdFieldNumber = 2,
    kUrlFieldNumber = 3,
    kNameFieldNumber = 4,
    kMetadataFieldNumber = 5,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string model_id = 2;
  void clear_model_id();
  const std::string& model_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_id();
  PROTOBUF_NODISCARD std::string* release_model_id();
  void set_allocated_model_id(std::string* model_id);
  private:
  const std::string& _internal_model_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_id(const std::string& value);
  std::string* _internal_mutable_model_id();
  public:

  // string url = 3;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string name = 4;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Struct metadata = 5;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  void set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:clarifai.api.ModelReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ModelVersionInputExample final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.ModelVersionInputExample) */ {
 public:
  inline ModelVersionInputExample() : ModelVersionInputExample(nullptr) {}
  ~ModelVersionInputExample() override;
  explicit PROTOBUF_CONSTEXPR ModelVersionInputExample(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelVersionInputExample(const ModelVersionInputExample& from);
  ModelVersionInputExample(ModelVersionInputExample&& from) noexcept
    : ModelVersionInputExample() {
    *this = ::std::move(from);
  }

  inline ModelVersionInputExample& operator=(const ModelVersionInputExample& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelVersionInputExample& operator=(ModelVersionInputExample&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelVersionInputExample& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelVersionInputExample* internal_default_instance() {
    return reinterpret_cast<const ModelVersionInputExample*>(
               &_ModelVersionInputExample_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(ModelVersionInputExample& a, ModelVersionInputExample& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelVersionInputExample* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelVersionInputExample* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelVersionInputExample* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelVersionInputExample>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelVersionInputExample& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelVersionInputExample& from) {
    ModelVersionInputExample::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelVersionInputExample* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.ModelVersionInputExample";
  }
  protected:
  explicit ModelVersionInputExample(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kModelIdFieldNumber = 2,
    kModelVersionIdFieldNumber = 3,
    kNameFieldNumber = 5,
    kDescriptionFieldNumber = 6,
    kDataFieldNumber = 4,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string model_id = 2;
  void clear_model_id();
  const std::string& model_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_id();
  PROTOBUF_NODISCARD std::string* release_model_id();
  void set_allocated_model_id(std::string* model_id);
  private:
  const std::string& _internal_model_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_id(const std::string& value);
  std::string* _internal_mutable_model_id();
  public:

  // string model_version_id = 3;
  void clear_model_version_id();
  const std::string& model_version_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_version_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_version_id();
  PROTOBUF_NODISCARD std::string* release_model_version_id();
  void set_allocated_model_version_id(std::string* model_version_id);
  private:
  const std::string& _internal_model_version_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_version_id(const std::string& value);
  std::string* _internal_mutable_model_version_id();
  public:

  // string name = 5;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 6;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .clarifai.api.Data data = 4;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::clarifai::api::Data& data() const;
  PROTOBUF_NODISCARD ::clarifai::api::Data* release_data();
  ::clarifai::api::Data* mutable_data();
  void set_allocated_data(::clarifai::api::Data* data);
  private:
  const ::clarifai::api::Data& _internal_data() const;
  ::clarifai::api::Data* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::clarifai::api::Data* data);
  ::clarifai::api::Data* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:clarifai.api.ModelVersionInputExample)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_version_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::clarifai::api::Data* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class OutputInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.OutputInfo) */ {
 public:
  inline OutputInfo() : OutputInfo(nullptr) {}
  ~OutputInfo() override;
  explicit PROTOBUF_CONSTEXPR OutputInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OutputInfo(const OutputInfo& from);
  OutputInfo(OutputInfo&& from) noexcept
    : OutputInfo() {
    *this = ::std::move(from);
  }

  inline OutputInfo& operator=(const OutputInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutputInfo& operator=(OutputInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OutputInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const OutputInfo* internal_default_instance() {
    return reinterpret_cast<const OutputInfo*>(
               &_OutputInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(OutputInfo& a, OutputInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(OutputInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OutputInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OutputInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OutputInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OutputInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OutputInfo& from) {
    OutputInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OutputInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.OutputInfo";
  }
  protected:
  explicit OutputInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kDataFieldNumber = 1,
    kOutputConfigFieldNumber = 2,
    kFieldsMapFieldNumber = 6,
    kParamsFieldNumber = 7,
  };
  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .clarifai.api.Data data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::clarifai::api::Data& data() const;
  PROTOBUF_NODISCARD ::clarifai::api::Data* release_data();
  ::clarifai::api::Data* mutable_data();
  void set_allocated_data(::clarifai::api::Data* data);
  private:
  const ::clarifai::api::Data& _internal_data() const;
  ::clarifai::api::Data* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::clarifai::api::Data* data);
  ::clarifai::api::Data* unsafe_arena_release_data();

  // .clarifai.api.OutputConfig output_config = 2;
  bool has_output_config() const;
  private:
  bool _internal_has_output_config() const;
  public:
  void clear_output_config();
  const ::clarifai::api::OutputConfig& output_config() const;
  PROTOBUF_NODISCARD ::clarifai::api::OutputConfig* release_output_config();
  ::clarifai::api::OutputConfig* mutable_output_config();
  void set_allocated_output_config(::clarifai::api::OutputConfig* output_config);
  private:
  const ::clarifai::api::OutputConfig& _internal_output_config() const;
  ::clarifai::api::OutputConfig* _internal_mutable_output_config();
  public:
  void unsafe_arena_set_allocated_output_config(
      ::clarifai::api::OutputConfig* output_config);
  ::clarifai::api::OutputConfig* unsafe_arena_release_output_config();

  // .google.protobuf.Struct fields_map = 6;
  bool has_fields_map() const;
  private:
  bool _internal_has_fields_map() const;
  public:
  void clear_fields_map();
  const ::PROTOBUF_NAMESPACE_ID::Struct& fields_map() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_fields_map();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_fields_map();
  void set_allocated_fields_map(::PROTOBUF_NAMESPACE_ID::Struct* fields_map);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_fields_map() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_fields_map();
  public:
  void unsafe_arena_set_allocated_fields_map(
      ::PROTOBUF_NAMESPACE_ID::Struct* fields_map);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_fields_map();

  // .google.protobuf.Struct params = 7;
  bool has_params() const;
  private:
  bool _internal_has_params() const;
  public:
  void clear_params();
  const ::PROTOBUF_NAMESPACE_ID::Struct& params() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_params();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_params();
  void set_allocated_params(::PROTOBUF_NAMESPACE_ID::Struct* params);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_params() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_params();
  public:
  void unsafe_arena_set_allocated_params(
      ::PROTOBUF_NAMESPACE_ID::Struct* params);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_params();

  // @@protoc_insertion_point(class_scope:clarifai.api.OutputInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::clarifai::api::Data* data_;
    ::clarifai::api::OutputConfig* output_config_;
    ::PROTOBUF_NAMESPACE_ID::Struct* fields_map_;
    ::PROTOBUF_NAMESPACE_ID::Struct* params_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class InputInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.InputInfo) */ {
 public:
  inline InputInfo() : InputInfo(nullptr) {}
  ~InputInfo() override;
  explicit PROTOBUF_CONSTEXPR InputInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InputInfo(const InputInfo& from);
  InputInfo(InputInfo&& from) noexcept
    : InputInfo() {
    *this = ::std::move(from);
  }

  inline InputInfo& operator=(const InputInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputInfo& operator=(InputInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const InputInfo* internal_default_instance() {
    return reinterpret_cast<const InputInfo*>(
               &_InputInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(InputInfo& a, InputInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(InputInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InputInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InputInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InputInfo& from) {
    InputInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.InputInfo";
  }
  protected:
  explicit InputInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsMapFieldNumber = 1,
    kParamsFieldNumber = 2,
  };
  // .google.protobuf.Struct fields_map = 1;
  bool has_fields_map() const;
  private:
  bool _internal_has_fields_map() const;
  public:
  void clear_fields_map();
  const ::PROTOBUF_NAMESPACE_ID::Struct& fields_map() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_fields_map();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_fields_map();
  void set_allocated_fields_map(::PROTOBUF_NAMESPACE_ID::Struct* fields_map);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_fields_map() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_fields_map();
  public:
  void unsafe_arena_set_allocated_fields_map(
      ::PROTOBUF_NAMESPACE_ID::Struct* fields_map);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_fields_map();

  // .google.protobuf.Struct params = 2;
  bool has_params() const;
  private:
  bool _internal_has_params() const;
  public:
  void clear_params();
  const ::PROTOBUF_NAMESPACE_ID::Struct& params() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_params();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_params();
  void set_allocated_params(::PROTOBUF_NAMESPACE_ID::Struct* params);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_params() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_params();
  public:
  void unsafe_arena_set_allocated_params(
      ::PROTOBUF_NAMESPACE_ID::Struct* params);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_params();

  // @@protoc_insertion_point(class_scope:clarifai.api.InputInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Struct* fields_map_;
    ::PROTOBUF_NAMESPACE_ID::Struct* params_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class TrainInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.TrainInfo) */ {
 public:
  inline TrainInfo() : TrainInfo(nullptr) {}
  ~TrainInfo() override;
  explicit PROTOBUF_CONSTEXPR TrainInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrainInfo(const TrainInfo& from);
  TrainInfo(TrainInfo&& from) noexcept
    : TrainInfo() {
    *this = ::std::move(from);
  }

  inline TrainInfo& operator=(const TrainInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrainInfo& operator=(TrainInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrainInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrainInfo* internal_default_instance() {
    return reinterpret_cast<const TrainInfo*>(
               &_TrainInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(TrainInfo& a, TrainInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TrainInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrainInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrainInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrainInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrainInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrainInfo& from) {
    TrainInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrainInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.TrainInfo";
  }
  protected:
  explicit TrainInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 1,
  };
  // .google.protobuf.Struct params = 1;
  bool has_params() const;
  private:
  bool _internal_has_params() const;
  public:
  void clear_params();
  const ::PROTOBUF_NAMESPACE_ID::Struct& params() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_params();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_params();
  void set_allocated_params(::PROTOBUF_NAMESPACE_ID::Struct* params);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_params() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_params();
  public:
  void unsafe_arena_set_allocated_params(
      ::PROTOBUF_NAMESPACE_ID::Struct* params);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_params();

  // @@protoc_insertion_point(class_scope:clarifai.api.TrainInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Struct* params_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class EvalInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.EvalInfo) */ {
 public:
  inline EvalInfo() : EvalInfo(nullptr) {}
  ~EvalInfo() override;
  explicit PROTOBUF_CONSTEXPR EvalInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EvalInfo(const EvalInfo& from);
  EvalInfo(EvalInfo&& from) noexcept
    : EvalInfo() {
    *this = ::std::move(from);
  }

  inline EvalInfo& operator=(const EvalInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline EvalInfo& operator=(EvalInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EvalInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const EvalInfo* internal_default_instance() {
    return reinterpret_cast<const EvalInfo*>(
               &_EvalInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(EvalInfo& a, EvalInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(EvalInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EvalInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EvalInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EvalInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EvalInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EvalInfo& from) {
    EvalInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EvalInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.EvalInfo";
  }
  protected:
  explicit EvalInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 1,
  };
  // .google.protobuf.Struct params = 1;
  bool has_params() const;
  private:
  bool _internal_has_params() const;
  public:
  void clear_params();
  const ::PROTOBUF_NAMESPACE_ID::Struct& params() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_params();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_params();
  void set_allocated_params(::PROTOBUF_NAMESPACE_ID::Struct* params);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_params() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_params();
  public:
  void unsafe_arena_set_allocated_params(
      ::PROTOBUF_NAMESPACE_ID::Struct* params);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_params();

  // @@protoc_insertion_point(class_scope:clarifai.api.EvalInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Struct* params_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ImportInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.ImportInfo) */ {
 public:
  inline ImportInfo() : ImportInfo(nullptr) {}
  ~ImportInfo() override;
  explicit PROTOBUF_CONSTEXPR ImportInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImportInfo(const ImportInfo& from);
  ImportInfo(ImportInfo&& from) noexcept
    : ImportInfo() {
    *this = ::std::move(from);
  }

  inline ImportInfo& operator=(const ImportInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImportInfo& operator=(ImportInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImportInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImportInfo* internal_default_instance() {
    return reinterpret_cast<const ImportInfo*>(
               &_ImportInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(ImportInfo& a, ImportInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ImportInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImportInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImportInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImportInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImportInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImportInfo& from) {
    ImportInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImportInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.ImportInfo";
  }
  protected:
  explicit ImportInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 1,
  };
  // .google.protobuf.Struct params = 1;
  bool has_params() const;
  private:
  bool _internal_has_params() const;
  public:
  void clear_params();
  const ::PROTOBUF_NAMESPACE_ID::Struct& params() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_params();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_params();
  void set_allocated_params(::PROTOBUF_NAMESPACE_ID::Struct* params);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_params() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_params();
  public:
  void unsafe_arena_set_allocated_params(
      ::PROTOBUF_NAMESPACE_ID::Struct* params);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_params();

  // @@protoc_insertion_point(class_scope:clarifai.api.ImportInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Struct* params_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class OutputConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.OutputConfig) */ {
 public:
  inline OutputConfig() : OutputConfig(nullptr) {}
  ~OutputConfig() override;
  explicit PROTOBUF_CONSTEXPR OutputConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OutputConfig(const OutputConfig& from);
  OutputConfig(OutputConfig&& from) noexcept
    : OutputConfig() {
    *this = ::std::move(from);
  }

  inline OutputConfig& operator=(const OutputConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutputConfig& operator=(OutputConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OutputConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const OutputConfig* internal_default_instance() {
    return reinterpret_cast<const OutputConfig*>(
               &_OutputConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(OutputConfig& a, OutputConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(OutputConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OutputConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OutputConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OutputConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OutputConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OutputConfig& from) {
    OutputConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OutputConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.OutputConfig";
  }
  protected:
  explicit OutputConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSelectConceptsFieldNumber = 8,
    kExistingModelIdFieldNumber = 3,
    kLanguageFieldNumber = 4,
    kHyperParametersFieldNumber = 5,
    kEmbedModelVersionIdFieldNumber = 14,
    kHyperParamsFieldNumber = 13,
    kModelMetadataFieldNumber = 17,
    kMaxConceptsFieldNumber = 6,
    kConceptsMutuallyExclusiveFieldNumber = 1,
    kClosedEnvironmentFieldNumber = 2,
    kFailOnMissingPositiveExamplesFieldNumber = 15,
    kMinValueFieldNumber = 7,
    kTrainingTimeoutFieldNumber = 9,
    kSampleMsFieldNumber = 10,
  };
  // repeated .clarifai.api.Concept select_concepts = 8;
  int select_concepts_size() const;
  private:
  int _internal_select_concepts_size() const;
  public:
  void clear_select_concepts();
  ::clarifai::api::Concept* mutable_select_concepts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept >*
      mutable_select_concepts();
  private:
  const ::clarifai::api::Concept& _internal_select_concepts(int index) const;
  ::clarifai::api::Concept* _internal_add_select_concepts();
  public:
  const ::clarifai::api::Concept& select_concepts(int index) const;
  ::clarifai::api::Concept* add_select_concepts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept >&
      select_concepts() const;

  // string existing_model_id = 3 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_existing_model_id();
  PROTOBUF_DEPRECATED const std::string& existing_model_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_existing_model_id(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_existing_model_id();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_existing_model_id();
  PROTOBUF_DEPRECATED void set_allocated_existing_model_id(std::string* existing_model_id);
  private:
  const std::string& _internal_existing_model_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_existing_model_id(const std::string& value);
  std::string* _internal_mutable_existing_model_id();
  public:

  // string language = 4;
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // string hyper_parameters = 5 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_hyper_parameters();
  PROTOBUF_DEPRECATED const std::string& hyper_parameters() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_hyper_parameters(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_hyper_parameters();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_hyper_parameters();
  PROTOBUF_DEPRECATED void set_allocated_hyper_parameters(std::string* hyper_parameters);
  private:
  const std::string& _internal_hyper_parameters() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hyper_parameters(const std::string& value);
  std::string* _internal_mutable_hyper_parameters();
  public:

  // string embed_model_version_id = 14;
  void clear_embed_model_version_id();
  const std::string& embed_model_version_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_embed_model_version_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_embed_model_version_id();
  PROTOBUF_NODISCARD std::string* release_embed_model_version_id();
  void set_allocated_embed_model_version_id(std::string* embed_model_version_id);
  private:
  const std::string& _internal_embed_model_version_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_embed_model_version_id(const std::string& value);
  std::string* _internal_mutable_embed_model_version_id();
  public:

  // .google.protobuf.Struct hyper_params = 13;
  bool has_hyper_params() const;
  private:
  bool _internal_has_hyper_params() const;
  public:
  void clear_hyper_params();
  const ::PROTOBUF_NAMESPACE_ID::Struct& hyper_params() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_hyper_params();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_hyper_params();
  void set_allocated_hyper_params(::PROTOBUF_NAMESPACE_ID::Struct* hyper_params);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_hyper_params() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_hyper_params();
  public:
  void unsafe_arena_set_allocated_hyper_params(
      ::PROTOBUF_NAMESPACE_ID::Struct* hyper_params);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_hyper_params();

  // .google.protobuf.Struct model_metadata = 17 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_model_metadata() const;
  private:
  bool _internal_has_model_metadata() const;
  public:
  PROTOBUF_DEPRECATED void clear_model_metadata();
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::Struct& model_metadata() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::Struct* release_model_metadata();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::Struct* mutable_model_metadata();
  PROTOBUF_DEPRECATED void set_allocated_model_metadata(::PROTOBUF_NAMESPACE_ID::Struct* model_metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_model_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_model_metadata();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_model_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* model_metadata);
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_model_metadata();

  // uint32 max_concepts = 6 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_max_concepts();
  uint32_t max_concepts() const;
  void set_max_concepts(uint32_t value);
  private:
  uint32_t _internal_max_concepts() const;
  void _internal_set_max_concepts(uint32_t value);
  public:

  // bool concepts_mutually_exclusive = 1 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_concepts_mutually_exclusive();
  PROTOBUF_DEPRECATED bool concepts_mutually_exclusive() const;
  PROTOBUF_DEPRECATED void set_concepts_mutually_exclusive(bool value);
  private:
  bool _internal_concepts_mutually_exclusive() const;
  void _internal_set_concepts_mutually_exclusive(bool value);
  public:

  // bool closed_environment = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_closed_environment();
  bool closed_environment() const;
  void set_closed_environment(bool value);
  private:
  bool _internal_closed_environment() const;
  void _internal_set_closed_environment(bool value);
  public:

  // bool fail_on_missing_positive_examples = 15;
  void clear_fail_on_missing_positive_examples();
  bool fail_on_missing_positive_examples() const;
  void set_fail_on_missing_positive_examples(bool value);
  private:
  bool _internal_fail_on_missing_positive_examples() const;
  void _internal_set_fail_on_missing_positive_examples(bool value);
  public:

  // float min_value = 7 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_min_value();
  float min_value() const;
  void set_min_value(float value);
  private:
  float _internal_min_value() const;
  void _internal_set_min_value(float value);
  public:

  // uint32 training_timeout = 9;
  void clear_training_timeout();
  uint32_t training_timeout() const;
  void set_training_timeout(uint32_t value);
  private:
  uint32_t _internal_training_timeout() const;
  void _internal_set_training_timeout(uint32_t value);
  public:

  // uint32 sample_ms = 10;
  void clear_sample_ms();
  uint32_t sample_ms() const;
  void set_sample_ms(uint32_t value);
  private:
  uint32_t _internal_sample_ms() const;
  void _internal_set_sample_ms(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.OutputConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept > select_concepts_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr existing_model_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hyper_parameters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr embed_model_version_id_;
    ::PROTOBUF_NAMESPACE_ID::Struct* hyper_params_;
    ::PROTOBUF_NAMESPACE_ID::Struct* model_metadata_;
    uint32_t max_concepts_;
    bool concepts_mutually_exclusive_;
    bool closed_environment_;
    bool fail_on_missing_positive_examples_;
    float min_value_;
    uint32_t training_timeout_;
    uint32_t sample_ms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ModelType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.ModelType) */ {
 public:
  inline ModelType() : ModelType(nullptr) {}
  ~ModelType() override;
  explicit PROTOBUF_CONSTEXPR ModelType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelType(const ModelType& from);
  ModelType(ModelType&& from) noexcept
    : ModelType() {
    *this = ::std::move(from);
  }

  inline ModelType& operator=(const ModelType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelType& operator=(ModelType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelType& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelType* internal_default_instance() {
    return reinterpret_cast<const ModelType*>(
               &_ModelType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(ModelType& a, ModelType& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelType& from) {
    ModelType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.ModelType";
  }
  protected:
  explicit ModelType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputFieldsFieldNumber = 5,
    kOutputFieldsFieldNumber = 6,
    kModelTypeFieldsFieldNumber = 11,
    kExpectedInputLayersFieldNumber = 16,
    kExpectedOutputLayersFieldNumber = 17,
    kIdFieldNumber = 1,
    kTitleFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kTrainableFieldNumber = 8,
    kCreatableFieldNumber = 9,
    kInternalOnlyFieldNumber = 10,
    kRequiresSequentialFramesFieldNumber = 12,
    kEvaluationTypeFieldNumber = 18,
  };
  // repeated string input_fields = 5;
  int input_fields_size() const;
  private:
  int _internal_input_fields_size() const;
  public:
  void clear_input_fields();
  const std::string& input_fields(int index) const;
  std::string* mutable_input_fields(int index);
  void set_input_fields(int index, const std::string& value);
  void set_input_fields(int index, std::string&& value);
  void set_input_fields(int index, const char* value);
  void set_input_fields(int index, const char* value, size_t size);
  std::string* add_input_fields();
  void add_input_fields(const std::string& value);
  void add_input_fields(std::string&& value);
  void add_input_fields(const char* value);
  void add_input_fields(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& input_fields() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_input_fields();
  private:
  const std::string& _internal_input_fields(int index) const;
  std::string* _internal_add_input_fields();
  public:

  // repeated string output_fields = 6;
  int output_fields_size() const;
  private:
  int _internal_output_fields_size() const;
  public:
  void clear_output_fields();
  const std::string& output_fields(int index) const;
  std::string* mutable_output_fields(int index);
  void set_output_fields(int index, const std::string& value);
  void set_output_fields(int index, std::string&& value);
  void set_output_fields(int index, const char* value);
  void set_output_fields(int index, const char* value, size_t size);
  std::string* add_output_fields();
  void add_output_fields(const std::string& value);
  void add_output_fields(std::string&& value);
  void add_output_fields(const char* value);
  void add_output_fields(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& output_fields() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_output_fields();
  private:
  const std::string& _internal_output_fields(int index) const;
  std::string* _internal_add_output_fields();
  public:

  // repeated .clarifai.api.ModelTypeField model_type_fields = 11;
  int model_type_fields_size() const;
  private:
  int _internal_model_type_fields_size() const;
  public:
  void clear_model_type_fields();
  ::clarifai::api::ModelTypeField* mutable_model_type_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelTypeField >*
      mutable_model_type_fields();
  private:
  const ::clarifai::api::ModelTypeField& _internal_model_type_fields(int index) const;
  ::clarifai::api::ModelTypeField* _internal_add_model_type_fields();
  public:
  const ::clarifai::api::ModelTypeField& model_type_fields(int index) const;
  ::clarifai::api::ModelTypeField* add_model_type_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelTypeField >&
      model_type_fields() const;

  // repeated .clarifai.api.ModelLayerInfo expected_input_layers = 16;
  int expected_input_layers_size() const;
  private:
  int _internal_expected_input_layers_size() const;
  public:
  void clear_expected_input_layers();
  ::clarifai::api::ModelLayerInfo* mutable_expected_input_layers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelLayerInfo >*
      mutable_expected_input_layers();
  private:
  const ::clarifai::api::ModelLayerInfo& _internal_expected_input_layers(int index) const;
  ::clarifai::api::ModelLayerInfo* _internal_add_expected_input_layers();
  public:
  const ::clarifai::api::ModelLayerInfo& expected_input_layers(int index) const;
  ::clarifai::api::ModelLayerInfo* add_expected_input_layers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelLayerInfo >&
      expected_input_layers() const;

  // repeated .clarifai.api.ModelLayerInfo expected_output_layers = 17;
  int expected_output_layers_size() const;
  private:
  int _internal_expected_output_layers_size() const;
  public:
  void clear_expected_output_layers();
  ::clarifai::api::ModelLayerInfo* mutable_expected_output_layers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelLayerInfo >*
      mutable_expected_output_layers();
  private:
  const ::clarifai::api::ModelLayerInfo& _internal_expected_output_layers(int index) const;
  ::clarifai::api::ModelLayerInfo* _internal_add_expected_output_layers();
  public:
  const ::clarifai::api::ModelLayerInfo& expected_output_layers(int index) const;
  ::clarifai::api::ModelLayerInfo* add_expected_output_layers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelLayerInfo >&
      expected_output_layers() const;

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string title = 2;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // bool trainable = 8;
  void clear_trainable();
  bool trainable() const;
  void set_trainable(bool value);
  private:
  bool _internal_trainable() const;
  void _internal_set_trainable(bool value);
  public:

  // bool creatable = 9;
  void clear_creatable();
  bool creatable() const;
  void set_creatable(bool value);
  private:
  bool _internal_creatable() const;
  void _internal_set_creatable(bool value);
  public:

  // bool internal_only = 10;
  void clear_internal_only();
  bool internal_only() const;
  void set_internal_only(bool value);
  private:
  bool _internal_internal_only() const;
  void _internal_set_internal_only(bool value);
  public:

  // bool requires_sequential_frames = 12;
  void clear_requires_sequential_frames();
  bool requires_sequential_frames() const;
  void set_requires_sequential_frames(bool value);
  private:
  bool _internal_requires_sequential_frames() const;
  void _internal_set_requires_sequential_frames(bool value);
  public:

  // .clarifai.api.EvaluationType evaluation_type = 18;
  void clear_evaluation_type();
  ::clarifai::api::EvaluationType evaluation_type() const;
  void set_evaluation_type(::clarifai::api::EvaluationType value);
  private:
  ::clarifai::api::EvaluationType _internal_evaluation_type() const;
  void _internal_set_evaluation_type(::clarifai::api::EvaluationType value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.ModelType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> input_fields_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> output_fields_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelTypeField > model_type_fields_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelLayerInfo > expected_input_layers_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelLayerInfo > expected_output_layers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    bool trainable_;
    bool creatable_;
    bool internal_only_;
    bool requires_sequential_frames_;
    int evaluation_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ModelLayerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.ModelLayerInfo) */ {
 public:
  inline ModelLayerInfo() : ModelLayerInfo(nullptr) {}
  ~ModelLayerInfo() override;
  explicit PROTOBUF_CONSTEXPR ModelLayerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelLayerInfo(const ModelLayerInfo& from);
  ModelLayerInfo(ModelLayerInfo&& from) noexcept
    : ModelLayerInfo() {
    *this = ::std::move(from);
  }

  inline ModelLayerInfo& operator=(const ModelLayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelLayerInfo& operator=(ModelLayerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelLayerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelLayerInfo* internal_default_instance() {
    return reinterpret_cast<const ModelLayerInfo*>(
               &_ModelLayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(ModelLayerInfo& a, ModelLayerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelLayerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelLayerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelLayerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelLayerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelLayerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelLayerInfo& from) {
    ModelLayerInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelLayerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.ModelLayerInfo";
  }
  protected:
  explicit ModelLayerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapesFieldNumber = 2,
    kDataFieldNameFieldNumber = 1,
    kDescriptionFieldNumber = 3,
    kRequiresLabelFilenameFieldNumber = 4,
  };
  // repeated .clarifai.api.LayerShape shapes = 2;
  int shapes_size() const;
  private:
  int _internal_shapes_size() const;
  public:
  void clear_shapes();
  ::clarifai::api::LayerShape* mutable_shapes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::LayerShape >*
      mutable_shapes();
  private:
  const ::clarifai::api::LayerShape& _internal_shapes(int index) const;
  ::clarifai::api::LayerShape* _internal_add_shapes();
  public:
  const ::clarifai::api::LayerShape& shapes(int index) const;
  ::clarifai::api::LayerShape* add_shapes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::LayerShape >&
      shapes() const;

  // string data_field_name = 1;
  void clear_data_field_name();
  const std::string& data_field_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data_field_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data_field_name();
  PROTOBUF_NODISCARD std::string* release_data_field_name();
  void set_allocated_data_field_name(std::string* data_field_name);
  private:
  const std::string& _internal_data_field_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_field_name(const std::string& value);
  std::string* _internal_mutable_data_field_name();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // bool requires_label_filename = 4;
  void clear_requires_label_filename();
  bool requires_label_filename() const;
  void set_requires_label_filename(bool value);
  private:
  bool _internal_requires_label_filename() const;
  void _internal_set_requires_label_filename(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.ModelLayerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::LayerShape > shapes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_field_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    bool requires_label_filename_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class LayerShape final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.LayerShape) */ {
 public:
  inline LayerShape() : LayerShape(nullptr) {}
  ~LayerShape() override;
  explicit PROTOBUF_CONSTEXPR LayerShape(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LayerShape(const LayerShape& from);
  LayerShape(LayerShape&& from) noexcept
    : LayerShape() {
    *this = ::std::move(from);
  }

  inline LayerShape& operator=(const LayerShape& from) {
    CopyFrom(from);
    return *this;
  }
  inline LayerShape& operator=(LayerShape&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LayerShape& default_instance() {
    return *internal_default_instance();
  }
  static inline const LayerShape* internal_default_instance() {
    return reinterpret_cast<const LayerShape*>(
               &_LayerShape_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(LayerShape& a, LayerShape& b) {
    a.Swap(&b);
  }
  inline void Swap(LayerShape* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LayerShape* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LayerShape* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LayerShape>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LayerShape& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LayerShape& from) {
    LayerShape::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LayerShape* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.LayerShape";
  }
  protected:
  explicit LayerShape(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimsFieldNumber = 1,
    kMaxDimsFieldNumber = 2,
    kDescriptionFieldNumber = 4,
    kDataTypeFieldNumber = 3,
  };
  // repeated int32 dims = 1;
  int dims_size() const;
  private:
  int _internal_dims_size() const;
  public:
  void clear_dims();
  private:
  int32_t _internal_dims(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_dims() const;
  void _internal_add_dims(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_dims();
  public:
  int32_t dims(int index) const;
  void set_dims(int index, int32_t value);
  void add_dims(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      dims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_dims();

  // repeated int32 max_dims = 2;
  int max_dims_size() const;
  private:
  int _internal_max_dims_size() const;
  public:
  void clear_max_dims();
  private:
  int32_t _internal_max_dims(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_max_dims() const;
  void _internal_add_max_dims(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_max_dims();
  public:
  int32_t max_dims(int index) const;
  void set_max_dims(int index, int32_t value);
  void add_max_dims(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      max_dims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_max_dims();

  // string description = 4;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .clarifai.api.DataType data_type = 3;
  void clear_data_type();
  ::clarifai::api::DataType data_type() const;
  void set_data_type(::clarifai::api::DataType value);
  private:
  ::clarifai::api::DataType _internal_data_type() const;
  void _internal_set_data_type(::clarifai::api::DataType value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.LayerShape)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > dims_;
    mutable std::atomic<int> _dims_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > max_dims_;
    mutable std::atomic<int> _max_dims_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    int data_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ModelTypeField final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.ModelTypeField) */ {
 public:
  inline ModelTypeField() : ModelTypeField(nullptr) {}
  ~ModelTypeField() override;
  explicit PROTOBUF_CONSTEXPR ModelTypeField(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelTypeField(const ModelTypeField& from);
  ModelTypeField(ModelTypeField&& from) noexcept
    : ModelTypeField() {
    *this = ::std::move(from);
  }

  inline ModelTypeField& operator=(const ModelTypeField& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelTypeField& operator=(ModelTypeField&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelTypeField& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelTypeField* internal_default_instance() {
    return reinterpret_cast<const ModelTypeField*>(
               &_ModelTypeField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(ModelTypeField& a, ModelTypeField& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelTypeField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelTypeField* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelTypeField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelTypeField>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelTypeField& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelTypeField& from) {
    ModelTypeField::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelTypeField* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.ModelTypeField";
  }
  protected:
  explicit ModelTypeField(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModelTypeField_ModelTypeFieldType ModelTypeFieldType;
  static constexpr ModelTypeFieldType INVALID_MODEL_TYPE_FIELD_TYPE =
    ModelTypeField_ModelTypeFieldType_INVALID_MODEL_TYPE_FIELD_TYPE;
  static constexpr ModelTypeFieldType BOOLEAN =
    ModelTypeField_ModelTypeFieldType_BOOLEAN;
  static constexpr ModelTypeFieldType STRING =
    ModelTypeField_ModelTypeFieldType_STRING;
  static constexpr ModelTypeFieldType NUMBER =
    ModelTypeField_ModelTypeFieldType_NUMBER;
  static constexpr ModelTypeFieldType ARRAY_OF_CONCEPTS =
    ModelTypeField_ModelTypeFieldType_ARRAY_OF_CONCEPTS;
  static constexpr ModelTypeFieldType ARRAY_OF_CONCEPTS_WITH_THRESHOLD =
    ModelTypeField_ModelTypeFieldType_ARRAY_OF_CONCEPTS_WITH_THRESHOLD;
  static constexpr ModelTypeFieldType RANGE =
    ModelTypeField_ModelTypeFieldType_RANGE;
  static constexpr ModelTypeFieldType ENUM =
    ModelTypeField_ModelTypeFieldType_ENUM;
  static constexpr ModelTypeFieldType COLLABORATORS =
    ModelTypeField_ModelTypeFieldType_COLLABORATORS;
  static constexpr ModelTypeFieldType JSON =
    ModelTypeField_ModelTypeFieldType_JSON;
  static constexpr ModelTypeFieldType ARRAY_OF_NUMBERS =
    ModelTypeField_ModelTypeFieldType_ARRAY_OF_NUMBERS;
  static constexpr ModelTypeFieldType WORKFLOW_EMBED_MODELS =
    ModelTypeField_ModelTypeFieldType_WORKFLOW_EMBED_MODELS;
  static constexpr ModelTypeFieldType ARRAY_OF_STRINGS =
    ModelTypeField_ModelTypeFieldType_ARRAY_OF_STRINGS;
  static constexpr ModelTypeFieldType RECURSIVE_ENUM =
    ModelTypeField_ModelTypeFieldType_RECURSIVE_ENUM;
  static constexpr ModelTypeFieldType PYTHON_CODE =
    ModelTypeField_ModelTypeFieldType_PYTHON_CODE;
  static constexpr ModelTypeFieldType DATASET_ID =
    ModelTypeField_ModelTypeFieldType_DATASET_ID;
  static constexpr ModelTypeFieldType DATASET_VERSION_ID =
    ModelTypeField_ModelTypeFieldType_DATASET_VERSION_ID;
  static inline bool ModelTypeFieldType_IsValid(int value) {
    return ModelTypeField_ModelTypeFieldType_IsValid(value);
  }
  static constexpr ModelTypeFieldType ModelTypeFieldType_MIN =
    ModelTypeField_ModelTypeFieldType_ModelTypeFieldType_MIN;
  static constexpr ModelTypeFieldType ModelTypeFieldType_MAX =
    ModelTypeField_ModelTypeFieldType_ModelTypeFieldType_MAX;
  static constexpr int ModelTypeFieldType_ARRAYSIZE =
    ModelTypeField_ModelTypeFieldType_ModelTypeFieldType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ModelTypeFieldType_descriptor() {
    return ModelTypeField_ModelTypeFieldType_descriptor();
  }
  template<typename T>
  static inline const std::string& ModelTypeFieldType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ModelTypeFieldType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ModelTypeFieldType_Name.");
    return ModelTypeField_ModelTypeFieldType_Name(enum_t_value);
  }
  static inline bool ModelTypeFieldType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ModelTypeFieldType* value) {
    return ModelTypeField_ModelTypeFieldType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kModelTypeEnumOptionsFieldNumber = 6,
    kPathFieldNumber = 1,
    kDescriptionFieldNumber = 4,
    kPlaceholderFieldNumber = 5,
    kDefaultValueFieldNumber = 3,
    kModelTypeRangeInfoFieldNumber = 9,
    kFieldTypeFieldNumber = 2,
    kInternalOnlyFieldNumber = 7,
    kRequiredFieldNumber = 8,
  };
  // repeated .clarifai.api.ModelTypeEnumOption model_type_enum_options = 6;
  int model_type_enum_options_size() const;
  private:
  int _internal_model_type_enum_options_size() const;
  public:
  void clear_model_type_enum_options();
  ::clarifai::api::ModelTypeEnumOption* mutable_model_type_enum_options(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelTypeEnumOption >*
      mutable_model_type_enum_options();
  private:
  const ::clarifai::api::ModelTypeEnumOption& _internal_model_type_enum_options(int index) const;
  ::clarifai::api::ModelTypeEnumOption* _internal_add_model_type_enum_options();
  public:
  const ::clarifai::api::ModelTypeEnumOption& model_type_enum_options(int index) const;
  ::clarifai::api::ModelTypeEnumOption* add_model_type_enum_options();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelTypeEnumOption >&
      model_type_enum_options() const;

  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string description = 4;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string placeholder = 5;
  void clear_placeholder();
  const std::string& placeholder() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_placeholder(ArgT0&& arg0, ArgT... args);
  std::string* mutable_placeholder();
  PROTOBUF_NODISCARD std::string* release_placeholder();
  void set_allocated_placeholder(std::string* placeholder);
  private:
  const std::string& _internal_placeholder() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_placeholder(const std::string& value);
  std::string* _internal_mutable_placeholder();
  public:

  // .google.protobuf.Value default_value = 3;
  bool has_default_value() const;
  private:
  bool _internal_has_default_value() const;
  public:
  void clear_default_value();
  const ::PROTOBUF_NAMESPACE_ID::Value& default_value() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Value* release_default_value();
  ::PROTOBUF_NAMESPACE_ID::Value* mutable_default_value();
  void set_allocated_default_value(::PROTOBUF_NAMESPACE_ID::Value* default_value);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Value& _internal_default_value() const;
  ::PROTOBUF_NAMESPACE_ID::Value* _internal_mutable_default_value();
  public:
  void unsafe_arena_set_allocated_default_value(
      ::PROTOBUF_NAMESPACE_ID::Value* default_value);
  ::PROTOBUF_NAMESPACE_ID::Value* unsafe_arena_release_default_value();

  // .clarifai.api.ModelTypeRangeInfo model_type_range_info = 9;
  bool has_model_type_range_info() const;
  private:
  bool _internal_has_model_type_range_info() const;
  public:
  void clear_model_type_range_info();
  const ::clarifai::api::ModelTypeRangeInfo& model_type_range_info() const;
  PROTOBUF_NODISCARD ::clarifai::api::ModelTypeRangeInfo* release_model_type_range_info();
  ::clarifai::api::ModelTypeRangeInfo* mutable_model_type_range_info();
  void set_allocated_model_type_range_info(::clarifai::api::ModelTypeRangeInfo* model_type_range_info);
  private:
  const ::clarifai::api::ModelTypeRangeInfo& _internal_model_type_range_info() const;
  ::clarifai::api::ModelTypeRangeInfo* _internal_mutable_model_type_range_info();
  public:
  void unsafe_arena_set_allocated_model_type_range_info(
      ::clarifai::api::ModelTypeRangeInfo* model_type_range_info);
  ::clarifai::api::ModelTypeRangeInfo* unsafe_arena_release_model_type_range_info();

  // .clarifai.api.ModelTypeField.ModelTypeFieldType field_type = 2;
  void clear_field_type();
  ::clarifai::api::ModelTypeField_ModelTypeFieldType field_type() const;
  void set_field_type(::clarifai::api::ModelTypeField_ModelTypeFieldType value);
  private:
  ::clarifai::api::ModelTypeField_ModelTypeFieldType _internal_field_type() const;
  void _internal_set_field_type(::clarifai::api::ModelTypeField_ModelTypeFieldType value);
  public:

  // bool internal_only = 7;
  void clear_internal_only();
  bool internal_only() const;
  void set_internal_only(bool value);
  private:
  bool _internal_internal_only() const;
  void _internal_set_internal_only(bool value);
  public:

  // bool required = 8;
  void clear_required();
  bool required() const;
  void set_required(bool value);
  private:
  bool _internal_required() const;
  void _internal_set_required(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.ModelTypeField)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelTypeEnumOption > model_type_enum_options_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr placeholder_;
    ::PROTOBUF_NAMESPACE_ID::Value* default_value_;
    ::clarifai::api::ModelTypeRangeInfo* model_type_range_info_;
    int field_type_;
    bool internal_only_;
    bool required_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ModelTypeRangeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.ModelTypeRangeInfo) */ {
 public:
  inline ModelTypeRangeInfo() : ModelTypeRangeInfo(nullptr) {}
  ~ModelTypeRangeInfo() override;
  explicit PROTOBUF_CONSTEXPR ModelTypeRangeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelTypeRangeInfo(const ModelTypeRangeInfo& from);
  ModelTypeRangeInfo(ModelTypeRangeInfo&& from) noexcept
    : ModelTypeRangeInfo() {
    *this = ::std::move(from);
  }

  inline ModelTypeRangeInfo& operator=(const ModelTypeRangeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelTypeRangeInfo& operator=(ModelTypeRangeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelTypeRangeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelTypeRangeInfo* internal_default_instance() {
    return reinterpret_cast<const ModelTypeRangeInfo*>(
               &_ModelTypeRangeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(ModelTypeRangeInfo& a, ModelTypeRangeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelTypeRangeInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelTypeRangeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelTypeRangeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelTypeRangeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelTypeRangeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelTypeRangeInfo& from) {
    ModelTypeRangeInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelTypeRangeInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.ModelTypeRangeInfo";
  }
  protected:
  explicit ModelTypeRangeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinFieldNumber = 1,
    kMaxFieldNumber = 2,
    kStepFieldNumber = 3,
  };
  // float min = 1;
  void clear_min();
  float min() const;
  void set_min(float value);
  private:
  float _internal_min() const;
  void _internal_set_min(float value);
  public:

  // float max = 2;
  void clear_max();
  float max() const;
  void set_max(float value);
  private:
  float _internal_max() const;
  void _internal_set_max(float value);
  public:

  // float step = 3;
  void clear_step();
  float step() const;
  void set_step(float value);
  private:
  float _internal_step() const;
  void _internal_set_step(float value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.ModelTypeRangeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float min_;
    float max_;
    float step_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ModelTypeEnumOption final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.ModelTypeEnumOption) */ {
 public:
  inline ModelTypeEnumOption() : ModelTypeEnumOption(nullptr) {}
  ~ModelTypeEnumOption() override;
  explicit PROTOBUF_CONSTEXPR ModelTypeEnumOption(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelTypeEnumOption(const ModelTypeEnumOption& from);
  ModelTypeEnumOption(ModelTypeEnumOption&& from) noexcept
    : ModelTypeEnumOption() {
    *this = ::std::move(from);
  }

  inline ModelTypeEnumOption& operator=(const ModelTypeEnumOption& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelTypeEnumOption& operator=(ModelTypeEnumOption&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelTypeEnumOption& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelTypeEnumOption* internal_default_instance() {
    return reinterpret_cast<const ModelTypeEnumOption*>(
               &_ModelTypeEnumOption_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(ModelTypeEnumOption& a, ModelTypeEnumOption& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelTypeEnumOption* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelTypeEnumOption* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelTypeEnumOption* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelTypeEnumOption>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelTypeEnumOption& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelTypeEnumOption& from) {
    ModelTypeEnumOption::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelTypeEnumOption* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.ModelTypeEnumOption";
  }
  protected:
  explicit ModelTypeEnumOption(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelTypeFieldsFieldNumber = 3,
    kAliasesFieldNumber = 5,
    kIdFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kInternalOnlyFieldNumber = 4,
    kRecommendedFieldNumber = 6,
  };
  // repeated .clarifai.api.ModelTypeField model_type_fields = 3;
  int model_type_fields_size() const;
  private:
  int _internal_model_type_fields_size() const;
  public:
  void clear_model_type_fields();
  ::clarifai::api::ModelTypeField* mutable_model_type_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelTypeField >*
      mutable_model_type_fields();
  private:
  const ::clarifai::api::ModelTypeField& _internal_model_type_fields(int index) const;
  ::clarifai::api::ModelTypeField* _internal_add_model_type_fields();
  public:
  const ::clarifai::api::ModelTypeField& model_type_fields(int index) const;
  ::clarifai::api::ModelTypeField* add_model_type_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelTypeField >&
      model_type_fields() const;

  // repeated .clarifai.api.ModelTypeEnumOptionAlias aliases = 5;
  int aliases_size() const;
  private:
  int _internal_aliases_size() const;
  public:
  void clear_aliases();
  ::clarifai::api::ModelTypeEnumOptionAlias* mutable_aliases(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelTypeEnumOptionAlias >*
      mutable_aliases();
  private:
  const ::clarifai::api::ModelTypeEnumOptionAlias& _internal_aliases(int index) const;
  ::clarifai::api::ModelTypeEnumOptionAlias* _internal_add_aliases();
  public:
  const ::clarifai::api::ModelTypeEnumOptionAlias& aliases(int index) const;
  ::clarifai::api::ModelTypeEnumOptionAlias* add_aliases();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelTypeEnumOptionAlias >&
      aliases() const;

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // bool internal_only = 4;
  void clear_internal_only();
  bool internal_only() const;
  void set_internal_only(bool value);
  private:
  bool _internal_internal_only() const;
  void _internal_set_internal_only(bool value);
  public:

  // bool recommended = 6;
  void clear_recommended();
  bool recommended() const;
  void set_recommended(bool value);
  private:
  bool _internal_recommended() const;
  void _internal_set_recommended(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.ModelTypeEnumOption)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelTypeField > model_type_fields_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelTypeEnumOptionAlias > aliases_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    bool internal_only_;
    bool recommended_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ModelTypeEnumOptionAlias final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.ModelTypeEnumOptionAlias) */ {
 public:
  inline ModelTypeEnumOptionAlias() : ModelTypeEnumOptionAlias(nullptr) {}
  ~ModelTypeEnumOptionAlias() override;
  explicit PROTOBUF_CONSTEXPR ModelTypeEnumOptionAlias(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelTypeEnumOptionAlias(const ModelTypeEnumOptionAlias& from);
  ModelTypeEnumOptionAlias(ModelTypeEnumOptionAlias&& from) noexcept
    : ModelTypeEnumOptionAlias() {
    *this = ::std::move(from);
  }

  inline ModelTypeEnumOptionAlias& operator=(const ModelTypeEnumOptionAlias& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelTypeEnumOptionAlias& operator=(ModelTypeEnumOptionAlias&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelTypeEnumOptionAlias& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelTypeEnumOptionAlias* internal_default_instance() {
    return reinterpret_cast<const ModelTypeEnumOptionAlias*>(
               &_ModelTypeEnumOptionAlias_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(ModelTypeEnumOptionAlias& a, ModelTypeEnumOptionAlias& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelTypeEnumOptionAlias* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelTypeEnumOptionAlias* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelTypeEnumOptionAlias* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelTypeEnumOptionAlias>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelTypeEnumOptionAlias& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelTypeEnumOptionAlias& from) {
    ModelTypeEnumOptionAlias::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelTypeEnumOptionAlias* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.ModelTypeEnumOptionAlias";
  }
  protected:
  explicit ModelTypeEnumOptionAlias(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWildcardStringFieldNumber = 2,
    kIdIntFieldNumber = 1,
  };
  // string wildcard_string = 2;
  void clear_wildcard_string();
  const std::string& wildcard_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_wildcard_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_wildcard_string();
  PROTOBUF_NODISCARD std::string* release_wildcard_string();
  void set_allocated_wildcard_string(std::string* wildcard_string);
  private:
  const std::string& _internal_wildcard_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wildcard_string(const std::string& value);
  std::string* _internal_mutable_wildcard_string();
  public:

  // int64 id_int = 1;
  void clear_id_int();
  int64_t id_int() const;
  void set_id_int(int64_t value);
  private:
  int64_t _internal_id_int() const;
  void _internal_set_id_int(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.ModelTypeEnumOptionAlias)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wildcard_string_;
    int64_t id_int_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ModelQuery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.ModelQuery) */ {
 public:
  inline ModelQuery() : ModelQuery(nullptr) {}
  ~ModelQuery() override;
  explicit PROTOBUF_CONSTEXPR ModelQuery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelQuery(const ModelQuery& from);
  ModelQuery(ModelQuery&& from) noexcept
    : ModelQuery() {
    *this = ::std::move(from);
  }

  inline ModelQuery& operator=(const ModelQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelQuery& operator=(ModelQuery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelQuery& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelQuery* internal_default_instance() {
    return reinterpret_cast<const ModelQuery*>(
               &_ModelQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(ModelQuery& a, ModelQuery& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelQuery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelQuery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelQuery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelQuery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelQuery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelQuery& from) {
    ModelQuery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelQuery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.ModelQuery";
  }
  protected:
  explicit ModelQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kModelTypeIdFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string model_type_id = 3;
  void clear_model_type_id();
  const std::string& model_type_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_type_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_type_id();
  PROTOBUF_NODISCARD std::string* release_model_type_id();
  void set_allocated_model_type_id(std::string* model_type_id);
  private:
  const std::string& _internal_model_type_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_type_id(const std::string& value);
  std::string* _internal_mutable_model_type_id();
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.ModelQuery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_type_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ModelVersion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.ModelVersion) */ {
 public:
  inline ModelVersion() : ModelVersion(nullptr) {}
  ~ModelVersion() override;
  explicit PROTOBUF_CONSTEXPR ModelVersion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelVersion(const ModelVersion& from);
  ModelVersion(ModelVersion&& from) noexcept
    : ModelVersion() {
    *this = ::std::move(from);
  }

  inline ModelVersion& operator=(const ModelVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelVersion& operator=(ModelVersion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelVersion& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelVersion* internal_default_instance() {
    return reinterpret_cast<const ModelVersion*>(
               &_ModelVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(ModelVersion& a, ModelVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelVersion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelVersion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelVersion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelVersion& from) {
    ModelVersion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelVersion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.ModelVersion";
  }
  protected:
  explicit ModelVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kDescriptionFieldNumber = 11,
    kAppIdFieldNumber = 13,
    kUserIdFieldNumber = 14,
    kLicenseFieldNumber = 17,
    kCreatedAtFieldNumber = 2,
    kStatusFieldNumber = 3,
    kMetricsFieldNumber = 5,
    kPretrainedModelConfigFieldNumber = 7,
    kCompletedAtFieldNumber = 10,
    kVisibilityFieldNumber = 12,
    kModifiedAtFieldNumber = 15,
    kMetadataFieldNumber = 16,
    kDatasetVersionFieldNumber = 18,
    kOutputInfoFieldNumber = 19,
    kInputInfoFieldNumber = 20,
    kTrainInfoFieldNumber = 21,
    kImportInfoFieldNumber = 22,
    kActiveConceptCountFieldNumber = 4,
    kTotalInputCountFieldNumber = 6,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string description = 11;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string app_id = 13;
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // string user_id = 14;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string license = 17;
  void clear_license();
  const std::string& license() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_license(ArgT0&& arg0, ArgT... args);
  std::string* mutable_license();
  PROTOBUF_NODISCARD std::string* release_license();
  void set_allocated_license(std::string* license);
  private:
  const std::string& _internal_license() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_license(const std::string& value);
  std::string* _internal_mutable_license();
  public:

  // .google.protobuf.Timestamp created_at = 2;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .clarifai.api.status.Status status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::clarifai::api::status::Status& status() const;
  PROTOBUF_NODISCARD ::clarifai::api::status::Status* release_status();
  ::clarifai::api::status::Status* mutable_status();
  void set_allocated_status(::clarifai::api::status::Status* status);
  private:
  const ::clarifai::api::status::Status& _internal_status() const;
  ::clarifai::api::status::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::clarifai::api::status::Status* status);
  ::clarifai::api::status::Status* unsafe_arena_release_status();

  // .clarifai.api.EvalMetrics metrics = 5;
  bool has_metrics() const;
  private:
  bool _internal_has_metrics() const;
  public:
  void clear_metrics();
  const ::clarifai::api::EvalMetrics& metrics() const;
  PROTOBUF_NODISCARD ::clarifai::api::EvalMetrics* release_metrics();
  ::clarifai::api::EvalMetrics* mutable_metrics();
  void set_allocated_metrics(::clarifai::api::EvalMetrics* metrics);
  private:
  const ::clarifai::api::EvalMetrics& _internal_metrics() const;
  ::clarifai::api::EvalMetrics* _internal_mutable_metrics();
  public:
  void unsafe_arena_set_allocated_metrics(
      ::clarifai::api::EvalMetrics* metrics);
  ::clarifai::api::EvalMetrics* unsafe_arena_release_metrics();

  // .clarifai.api.PretrainedModelConfig pretrained_model_config = 7;
  bool has_pretrained_model_config() const;
  private:
  bool _internal_has_pretrained_model_config() const;
  public:
  void clear_pretrained_model_config();
  const ::clarifai::api::PretrainedModelConfig& pretrained_model_config() const;
  PROTOBUF_NODISCARD ::clarifai::api::PretrainedModelConfig* release_pretrained_model_config();
  ::clarifai::api::PretrainedModelConfig* mutable_pretrained_model_config();
  void set_allocated_pretrained_model_config(::clarifai::api::PretrainedModelConfig* pretrained_model_config);
  private:
  const ::clarifai::api::PretrainedModelConfig& _internal_pretrained_model_config() const;
  ::clarifai::api::PretrainedModelConfig* _internal_mutable_pretrained_model_config();
  public:
  void unsafe_arena_set_allocated_pretrained_model_config(
      ::clarifai::api::PretrainedModelConfig* pretrained_model_config);
  ::clarifai::api::PretrainedModelConfig* unsafe_arena_release_pretrained_model_config();

  // .google.protobuf.Timestamp completed_at = 10;
  bool has_completed_at() const;
  private:
  bool _internal_has_completed_at() const;
  public:
  void clear_completed_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& completed_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_completed_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_completed_at();
  void set_allocated_completed_at(::PROTOBUF_NAMESPACE_ID::Timestamp* completed_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_completed_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_completed_at();
  public:
  void unsafe_arena_set_allocated_completed_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* completed_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_completed_at();

  // .clarifai.api.Visibility visibility = 12;
  bool has_visibility() const;
  private:
  bool _internal_has_visibility() const;
  public:
  void clear_visibility();
  const ::clarifai::api::Visibility& visibility() const;
  PROTOBUF_NODISCARD ::clarifai::api::Visibility* release_visibility();
  ::clarifai::api::Visibility* mutable_visibility();
  void set_allocated_visibility(::clarifai::api::Visibility* visibility);
  private:
  const ::clarifai::api::Visibility& _internal_visibility() const;
  ::clarifai::api::Visibility* _internal_mutable_visibility();
  public:
  void unsafe_arena_set_allocated_visibility(
      ::clarifai::api::Visibility* visibility);
  ::clarifai::api::Visibility* unsafe_arena_release_visibility();

  // .google.protobuf.Timestamp modified_at = 15;
  bool has_modified_at() const;
  private:
  bool _internal_has_modified_at() const;
  public:
  void clear_modified_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& modified_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_modified_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_modified_at();
  void set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_modified_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_modified_at();
  public:
  void unsafe_arena_set_allocated_modified_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_modified_at();

  // .google.protobuf.Struct metadata = 16;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  void set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata();

  // .clarifai.api.DatasetVersion dataset_version = 18;
  bool has_dataset_version() const;
  private:
  bool _internal_has_dataset_version() const;
  public:
  void clear_dataset_version();
  const ::clarifai::api::DatasetVersion& dataset_version() const;
  PROTOBUF_NODISCARD ::clarifai::api::DatasetVersion* release_dataset_version();
  ::clarifai::api::DatasetVersion* mutable_dataset_version();
  void set_allocated_dataset_version(::clarifai::api::DatasetVersion* dataset_version);
  private:
  const ::clarifai::api::DatasetVersion& _internal_dataset_version() const;
  ::clarifai::api::DatasetVersion* _internal_mutable_dataset_version();
  public:
  void unsafe_arena_set_allocated_dataset_version(
      ::clarifai::api::DatasetVersion* dataset_version);
  ::clarifai::api::DatasetVersion* unsafe_arena_release_dataset_version();

  // .clarifai.api.OutputInfo output_info = 19;
  bool has_output_info() const;
  private:
  bool _internal_has_output_info() const;
  public:
  void clear_output_info();
  const ::clarifai::api::OutputInfo& output_info() const;
  PROTOBUF_NODISCARD ::clarifai::api::OutputInfo* release_output_info();
  ::clarifai::api::OutputInfo* mutable_output_info();
  void set_allocated_output_info(::clarifai::api::OutputInfo* output_info);
  private:
  const ::clarifai::api::OutputInfo& _internal_output_info() const;
  ::clarifai::api::OutputInfo* _internal_mutable_output_info();
  public:
  void unsafe_arena_set_allocated_output_info(
      ::clarifai::api::OutputInfo* output_info);
  ::clarifai::api::OutputInfo* unsafe_arena_release_output_info();

  // .clarifai.api.InputInfo input_info = 20;
  bool has_input_info() const;
  private:
  bool _internal_has_input_info() const;
  public:
  void clear_input_info();
  const ::clarifai::api::InputInfo& input_info() const;
  PROTOBUF_NODISCARD ::clarifai::api::InputInfo* release_input_info();
  ::clarifai::api::InputInfo* mutable_input_info();
  void set_allocated_input_info(::clarifai::api::InputInfo* input_info);
  private:
  const ::clarifai::api::InputInfo& _internal_input_info() const;
  ::clarifai::api::InputInfo* _internal_mutable_input_info();
  public:
  void unsafe_arena_set_allocated_input_info(
      ::clarifai::api::InputInfo* input_info);
  ::clarifai::api::InputInfo* unsafe_arena_release_input_info();

  // .clarifai.api.TrainInfo train_info = 21;
  bool has_train_info() const;
  private:
  bool _internal_has_train_info() const;
  public:
  void clear_train_info();
  const ::clarifai::api::TrainInfo& train_info() const;
  PROTOBUF_NODISCARD ::clarifai::api::TrainInfo* release_train_info();
  ::clarifai::api::TrainInfo* mutable_train_info();
  void set_allocated_train_info(::clarifai::api::TrainInfo* train_info);
  private:
  const ::clarifai::api::TrainInfo& _internal_train_info() const;
  ::clarifai::api::TrainInfo* _internal_mutable_train_info();
  public:
  void unsafe_arena_set_allocated_train_info(
      ::clarifai::api::TrainInfo* train_info);
  ::clarifai::api::TrainInfo* unsafe_arena_release_train_info();

  // .clarifai.api.ImportInfo import_info = 22;
  bool has_import_info() const;
  private:
  bool _internal_has_import_info() const;
  public:
  void clear_import_info();
  const ::clarifai::api::ImportInfo& import_info() const;
  PROTOBUF_NODISCARD ::clarifai::api::ImportInfo* release_import_info();
  ::clarifai::api::ImportInfo* mutable_import_info();
  void set_allocated_import_info(::clarifai::api::ImportInfo* import_info);
  private:
  const ::clarifai::api::ImportInfo& _internal_import_info() const;
  ::clarifai::api::ImportInfo* _internal_mutable_import_info();
  public:
  void unsafe_arena_set_allocated_import_info(
      ::clarifai::api::ImportInfo* import_info);
  ::clarifai::api::ImportInfo* unsafe_arena_release_import_info();

  // uint32 active_concept_count = 4;
  void clear_active_concept_count();
  uint32_t active_concept_count() const;
  void set_active_concept_count(uint32_t value);
  private:
  uint32_t _internal_active_concept_count() const;
  void _internal_set_active_concept_count(uint32_t value);
  public:

  // uint32 total_input_count = 6;
  void clear_total_input_count();
  uint32_t total_input_count() const;
  void set_total_input_count(uint32_t value);
  private:
  uint32_t _internal_total_input_count() const;
  void _internal_set_total_input_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.ModelVersion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr license_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::clarifai::api::status::Status* status_;
    ::clarifai::api::EvalMetrics* metrics_;
    ::clarifai::api::PretrainedModelConfig* pretrained_model_config_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* completed_at_;
    ::clarifai::api::Visibility* visibility_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at_;
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_;
    ::clarifai::api::DatasetVersion* dataset_version_;
    ::clarifai::api::OutputInfo* output_info_;
    ::clarifai::api::InputInfo* input_info_;
    ::clarifai::api::TrainInfo* train_info_;
    ::clarifai::api::ImportInfo* import_info_;
    uint32_t active_concept_count_;
    uint32_t total_input_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class PretrainedModelConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.PretrainedModelConfig) */ {
 public:
  inline PretrainedModelConfig() : PretrainedModelConfig(nullptr) {}
  ~PretrainedModelConfig() override;
  explicit PROTOBUF_CONSTEXPR PretrainedModelConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PretrainedModelConfig(const PretrainedModelConfig& from);
  PretrainedModelConfig(PretrainedModelConfig&& from) noexcept
    : PretrainedModelConfig() {
    *this = ::std::move(from);
  }

  inline PretrainedModelConfig& operator=(const PretrainedModelConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline PretrainedModelConfig& operator=(PretrainedModelConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PretrainedModelConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const PretrainedModelConfig* internal_default_instance() {
    return reinterpret_cast<const PretrainedModelConfig*>(
               &_PretrainedModelConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(PretrainedModelConfig& a, PretrainedModelConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(PretrainedModelConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PretrainedModelConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PretrainedModelConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PretrainedModelConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PretrainedModelConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PretrainedModelConfig& from) {
    PretrainedModelConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PretrainedModelConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.PretrainedModelConfig";
  }
  protected:
  explicit PretrainedModelConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelZipUrlFieldNumber = 6,
    kInputFieldsMapFieldNumber = 3,
    kOutputFieldsMapFieldNumber = 4,
  };
  // string model_zip_url = 6;
  void clear_model_zip_url();
  const std::string& model_zip_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_zip_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_zip_url();
  PROTOBUF_NODISCARD std::string* release_model_zip_url();
  void set_allocated_model_zip_url(std::string* model_zip_url);
  private:
  const std::string& _internal_model_zip_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_zip_url(const std::string& value);
  std::string* _internal_mutable_model_zip_url();
  public:

  // .google.protobuf.Struct input_fields_map = 3;
  bool has_input_fields_map() const;
  private:
  bool _internal_has_input_fields_map() const;
  public:
  void clear_input_fields_map();
  const ::PROTOBUF_NAMESPACE_ID::Struct& input_fields_map() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_input_fields_map();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_input_fields_map();
  void set_allocated_input_fields_map(::PROTOBUF_NAMESPACE_ID::Struct* input_fields_map);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_input_fields_map() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_input_fields_map();
  public:
  void unsafe_arena_set_allocated_input_fields_map(
      ::PROTOBUF_NAMESPACE_ID::Struct* input_fields_map);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_input_fields_map();

  // .google.protobuf.Struct output_fields_map = 4;
  bool has_output_fields_map() const;
  private:
  bool _internal_has_output_fields_map() const;
  public:
  void clear_output_fields_map();
  const ::PROTOBUF_NAMESPACE_ID::Struct& output_fields_map() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_output_fields_map();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_output_fields_map();
  void set_allocated_output_fields_map(::PROTOBUF_NAMESPACE_ID::Struct* output_fields_map);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_output_fields_map() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_output_fields_map();
  public:
  void unsafe_arena_set_allocated_output_fields_map(
      ::PROTOBUF_NAMESPACE_ID::Struct* output_fields_map);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_output_fields_map();

  // @@protoc_insertion_point(class_scope:clarifai.api.PretrainedModelConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_zip_url_;
    ::PROTOBUF_NAMESPACE_ID::Struct* input_fields_map_;
    ::PROTOBUF_NAMESPACE_ID::Struct* output_fields_map_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class TrainStats final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.TrainStats) */ {
 public:
  inline TrainStats() : TrainStats(nullptr) {}
  ~TrainStats() override;
  explicit PROTOBUF_CONSTEXPR TrainStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrainStats(const TrainStats& from);
  TrainStats(TrainStats&& from) noexcept
    : TrainStats() {
    *this = ::std::move(from);
  }

  inline TrainStats& operator=(const TrainStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrainStats& operator=(TrainStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrainStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrainStats* internal_default_instance() {
    return reinterpret_cast<const TrainStats*>(
               &_TrainStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(TrainStats& a, TrainStats& b) {
    a.Swap(&b);
  }
  inline void Swap(TrainStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrainStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrainStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrainStats>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrainStats& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrainStats& from) {
    TrainStats::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrainStats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.TrainStats";
  }
  protected:
  explicit TrainStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLossCurveFieldNumber = 1,
  };
  // repeated .clarifai.api.LossCurveEntry loss_curve = 1;
  int loss_curve_size() const;
  private:
  int _internal_loss_curve_size() const;
  public:
  void clear_loss_curve();
  ::clarifai::api::LossCurveEntry* mutable_loss_curve(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::LossCurveEntry >*
      mutable_loss_curve();
  private:
  const ::clarifai::api::LossCurveEntry& _internal_loss_curve(int index) const;
  ::clarifai::api::LossCurveEntry* _internal_add_loss_curve();
  public:
  const ::clarifai::api::LossCurveEntry& loss_curve(int index) const;
  ::clarifai::api::LossCurveEntry* add_loss_curve();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::LossCurveEntry >&
      loss_curve() const;

  // @@protoc_insertion_point(class_scope:clarifai.api.TrainStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::LossCurveEntry > loss_curve_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class LossCurveEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.LossCurveEntry) */ {
 public:
  inline LossCurveEntry() : LossCurveEntry(nullptr) {}
  ~LossCurveEntry() override;
  explicit PROTOBUF_CONSTEXPR LossCurveEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LossCurveEntry(const LossCurveEntry& from);
  LossCurveEntry(LossCurveEntry&& from) noexcept
    : LossCurveEntry() {
    *this = ::std::move(from);
  }

  inline LossCurveEntry& operator=(const LossCurveEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline LossCurveEntry& operator=(LossCurveEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LossCurveEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const LossCurveEntry* internal_default_instance() {
    return reinterpret_cast<const LossCurveEntry*>(
               &_LossCurveEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(LossCurveEntry& a, LossCurveEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(LossCurveEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LossCurveEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LossCurveEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LossCurveEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LossCurveEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LossCurveEntry& from) {
    LossCurveEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LossCurveEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.LossCurveEntry";
  }
  protected:
  explicit LossCurveEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEpochFieldNumber = 1,
    kGlobalStepFieldNumber = 2,
    kCostFieldNumber = 3,
  };
  // uint32 epoch = 1;
  void clear_epoch();
  uint32_t epoch() const;
  void set_epoch(uint32_t value);
  private:
  uint32_t _internal_epoch() const;
  void _internal_set_epoch(uint32_t value);
  public:

  // uint32 global_step = 2;
  void clear_global_step();
  uint32_t global_step() const;
  void set_global_step(uint32_t value);
  private:
  uint32_t _internal_global_step() const;
  void _internal_set_global_step(uint32_t value);
  public:

  // float cost = 3;
  void clear_cost();
  float cost() const;
  void set_cost(float value);
  private:
  float _internal_cost() const;
  void _internal_set_cost(float value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.LossCurveEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t epoch_;
    uint32_t global_step_;
    float cost_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class LabelCount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.LabelCount) */ {
 public:
  inline LabelCount() : LabelCount(nullptr) {}
  ~LabelCount() override;
  explicit PROTOBUF_CONSTEXPR LabelCount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LabelCount(const LabelCount& from);
  LabelCount(LabelCount&& from) noexcept
    : LabelCount() {
    *this = ::std::move(from);
  }

  inline LabelCount& operator=(const LabelCount& from) {
    CopyFrom(from);
    return *this;
  }
  inline LabelCount& operator=(LabelCount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LabelCount& default_instance() {
    return *internal_default_instance();
  }
  static inline const LabelCount* internal_default_instance() {
    return reinterpret_cast<const LabelCount*>(
               &_LabelCount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(LabelCount& a, LabelCount& b) {
    a.Swap(&b);
  }
  inline void Swap(LabelCount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LabelCount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LabelCount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LabelCount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LabelCount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LabelCount& from) {
    LabelCount::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LabelCount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.LabelCount";
  }
  protected:
  explicit LabelCount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConceptNameFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // string concept_name = 1;
  void clear_concept_name();
  const std::string& concept_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_concept_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_concept_name();
  PROTOBUF_NODISCARD std::string* release_concept_name();
  void set_allocated_concept_name(std::string* concept_name);
  private:
  const std::string& _internal_concept_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_concept_name(const std::string& value);
  std::string* _internal_mutable_concept_name();
  public:

  // uint32 count = 2;
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.LabelCount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr concept_name_;
    uint32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class LabelDistribution final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.LabelDistribution) */ {
 public:
  inline LabelDistribution() : LabelDistribution(nullptr) {}
  ~LabelDistribution() override;
  explicit PROTOBUF_CONSTEXPR LabelDistribution(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LabelDistribution(const LabelDistribution& from);
  LabelDistribution(LabelDistribution&& from) noexcept
    : LabelDistribution() {
    *this = ::std::move(from);
  }

  inline LabelDistribution& operator=(const LabelDistribution& from) {
    CopyFrom(from);
    return *this;
  }
  inline LabelDistribution& operator=(LabelDistribution&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LabelDistribution& default_instance() {
    return *internal_default_instance();
  }
  static inline const LabelDistribution* internal_default_instance() {
    return reinterpret_cast<const LabelDistribution*>(
               &_LabelDistribution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(LabelDistribution& a, LabelDistribution& b) {
    a.Swap(&b);
  }
  inline void Swap(LabelDistribution* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LabelDistribution* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LabelDistribution* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LabelDistribution>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LabelDistribution& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LabelDistribution& from) {
    LabelDistribution::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LabelDistribution* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.LabelDistribution";
  }
  protected:
  explicit LabelDistribution(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositiveLabelCountsFieldNumber = 1,
  };
  // repeated .clarifai.api.LabelCount positive_label_counts = 1;
  int positive_label_counts_size() const;
  private:
  int _internal_positive_label_counts_size() const;
  public:
  void clear_positive_label_counts();
  ::clarifai::api::LabelCount* mutable_positive_label_counts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::LabelCount >*
      mutable_positive_label_counts();
  private:
  const ::clarifai::api::LabelCount& _internal_positive_label_counts(int index) const;
  ::clarifai::api::LabelCount* _internal_add_positive_label_counts();
  public:
  const ::clarifai::api::LabelCount& positive_label_counts(int index) const;
  ::clarifai::api::LabelCount* add_positive_label_counts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::LabelCount >&
      positive_label_counts() const;

  // @@protoc_insertion_point(class_scope:clarifai.api.LabelDistribution)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::LabelCount > positive_label_counts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class CooccurrenceMatrixEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.CooccurrenceMatrixEntry) */ {
 public:
  inline CooccurrenceMatrixEntry() : CooccurrenceMatrixEntry(nullptr) {}
  ~CooccurrenceMatrixEntry() override;
  explicit PROTOBUF_CONSTEXPR CooccurrenceMatrixEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CooccurrenceMatrixEntry(const CooccurrenceMatrixEntry& from);
  CooccurrenceMatrixEntry(CooccurrenceMatrixEntry&& from) noexcept
    : CooccurrenceMatrixEntry() {
    *this = ::std::move(from);
  }

  inline CooccurrenceMatrixEntry& operator=(const CooccurrenceMatrixEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline CooccurrenceMatrixEntry& operator=(CooccurrenceMatrixEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CooccurrenceMatrixEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const CooccurrenceMatrixEntry* internal_default_instance() {
    return reinterpret_cast<const CooccurrenceMatrixEntry*>(
               &_CooccurrenceMatrixEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(CooccurrenceMatrixEntry& a, CooccurrenceMatrixEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(CooccurrenceMatrixEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CooccurrenceMatrixEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CooccurrenceMatrixEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CooccurrenceMatrixEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CooccurrenceMatrixEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CooccurrenceMatrixEntry& from) {
    CooccurrenceMatrixEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CooccurrenceMatrixEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.CooccurrenceMatrixEntry";
  }
  protected:
  explicit CooccurrenceMatrixEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowFieldNumber = 1,
    kColFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // string row = 1;
  void clear_row();
  const std::string& row() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_row(ArgT0&& arg0, ArgT... args);
  std::string* mutable_row();
  PROTOBUF_NODISCARD std::string* release_row();
  void set_allocated_row(std::string* row);
  private:
  const std::string& _internal_row() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_row(const std::string& value);
  std::string* _internal_mutable_row();
  public:

  // string col = 2;
  void clear_col();
  const std::string& col() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_col(ArgT0&& arg0, ArgT... args);
  std::string* mutable_col();
  PROTOBUF_NODISCARD std::string* release_col();
  void set_allocated_col(std::string* col);
  private:
  const std::string& _internal_col() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_col(const std::string& value);
  std::string* _internal_mutable_col();
  public:

  // uint32 count = 3;
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.CooccurrenceMatrixEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr row_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr col_;
    uint32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class CooccurrenceMatrix final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.CooccurrenceMatrix) */ {
 public:
  inline CooccurrenceMatrix() : CooccurrenceMatrix(nullptr) {}
  ~CooccurrenceMatrix() override;
  explicit PROTOBUF_CONSTEXPR CooccurrenceMatrix(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CooccurrenceMatrix(const CooccurrenceMatrix& from);
  CooccurrenceMatrix(CooccurrenceMatrix&& from) noexcept
    : CooccurrenceMatrix() {
    *this = ::std::move(from);
  }

  inline CooccurrenceMatrix& operator=(const CooccurrenceMatrix& from) {
    CopyFrom(from);
    return *this;
  }
  inline CooccurrenceMatrix& operator=(CooccurrenceMatrix&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CooccurrenceMatrix& default_instance() {
    return *internal_default_instance();
  }
  static inline const CooccurrenceMatrix* internal_default_instance() {
    return reinterpret_cast<const CooccurrenceMatrix*>(
               &_CooccurrenceMatrix_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(CooccurrenceMatrix& a, CooccurrenceMatrix& b) {
    a.Swap(&b);
  }
  inline void Swap(CooccurrenceMatrix* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CooccurrenceMatrix* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CooccurrenceMatrix* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CooccurrenceMatrix>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CooccurrenceMatrix& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CooccurrenceMatrix& from) {
    CooccurrenceMatrix::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CooccurrenceMatrix* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.CooccurrenceMatrix";
  }
  protected:
  explicit CooccurrenceMatrix(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatrixFieldNumber = 1,
    kConceptIdsFieldNumber = 2,
  };
  // repeated .clarifai.api.CooccurrenceMatrixEntry matrix = 1;
  int matrix_size() const;
  private:
  int _internal_matrix_size() const;
  public:
  void clear_matrix();
  ::clarifai::api::CooccurrenceMatrixEntry* mutable_matrix(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::CooccurrenceMatrixEntry >*
      mutable_matrix();
  private:
  const ::clarifai::api::CooccurrenceMatrixEntry& _internal_matrix(int index) const;
  ::clarifai::api::CooccurrenceMatrixEntry* _internal_add_matrix();
  public:
  const ::clarifai::api::CooccurrenceMatrixEntry& matrix(int index) const;
  ::clarifai::api::CooccurrenceMatrixEntry* add_matrix();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::CooccurrenceMatrixEntry >&
      matrix() const;

  // repeated string concept_ids = 2;
  int concept_ids_size() const;
  private:
  int _internal_concept_ids_size() const;
  public:
  void clear_concept_ids();
  const std::string& concept_ids(int index) const;
  std::string* mutable_concept_ids(int index);
  void set_concept_ids(int index, const std::string& value);
  void set_concept_ids(int index, std::string&& value);
  void set_concept_ids(int index, const char* value);
  void set_concept_ids(int index, const char* value, size_t size);
  std::string* add_concept_ids();
  void add_concept_ids(const std::string& value);
  void add_concept_ids(std::string&& value);
  void add_concept_ids(const char* value);
  void add_concept_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& concept_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_concept_ids();
  private:
  const std::string& _internal_concept_ids(int index) const;
  std::string* _internal_add_concept_ids();
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.CooccurrenceMatrix)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::CooccurrenceMatrixEntry > matrix_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> concept_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ConfusionMatrixEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.ConfusionMatrixEntry) */ {
 public:
  inline ConfusionMatrixEntry() : ConfusionMatrixEntry(nullptr) {}
  ~ConfusionMatrixEntry() override;
  explicit PROTOBUF_CONSTEXPR ConfusionMatrixEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfusionMatrixEntry(const ConfusionMatrixEntry& from);
  ConfusionMatrixEntry(ConfusionMatrixEntry&& from) noexcept
    : ConfusionMatrixEntry() {
    *this = ::std::move(from);
  }

  inline ConfusionMatrixEntry& operator=(const ConfusionMatrixEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfusionMatrixEntry& operator=(ConfusionMatrixEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfusionMatrixEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfusionMatrixEntry* internal_default_instance() {
    return reinterpret_cast<const ConfusionMatrixEntry*>(
               &_ConfusionMatrixEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(ConfusionMatrixEntry& a, ConfusionMatrixEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfusionMatrixEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfusionMatrixEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfusionMatrixEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfusionMatrixEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfusionMatrixEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConfusionMatrixEntry& from) {
    ConfusionMatrixEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfusionMatrixEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.ConfusionMatrixEntry";
  }
  protected:
  explicit ConfusionMatrixEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPredictedFieldNumber = 1,
    kActualFieldNumber = 2,
    kValueFieldNumber = 4,
  };
  // string predicted = 1;
  void clear_predicted();
  const std::string& predicted() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_predicted(ArgT0&& arg0, ArgT... args);
  std::string* mutable_predicted();
  PROTOBUF_NODISCARD std::string* release_predicted();
  void set_allocated_predicted(std::string* predicted);
  private:
  const std::string& _internal_predicted() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_predicted(const std::string& value);
  std::string* _internal_mutable_predicted();
  public:

  // string actual = 2;
  void clear_actual();
  const std::string& actual() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_actual(ArgT0&& arg0, ArgT... args);
  std::string* mutable_actual();
  PROTOBUF_NODISCARD std::string* release_actual();
  void set_allocated_actual(std::string* actual);
  private:
  const std::string& _internal_actual() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_actual(const std::string& value);
  std::string* _internal_mutable_actual();
  public:

  // float value = 4 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_value();
  float value() const;
  void set_value(float value);
  private:
  float _internal_value() const;
  void _internal_set_value(float value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.ConfusionMatrixEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr predicted_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr actual_;
    float value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ConfusionMatrix final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.ConfusionMatrix) */ {
 public:
  inline ConfusionMatrix() : ConfusionMatrix(nullptr) {}
  ~ConfusionMatrix() override;
  explicit PROTOBUF_CONSTEXPR ConfusionMatrix(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfusionMatrix(const ConfusionMatrix& from);
  ConfusionMatrix(ConfusionMatrix&& from) noexcept
    : ConfusionMatrix() {
    *this = ::std::move(from);
  }

  inline ConfusionMatrix& operator=(const ConfusionMatrix& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfusionMatrix& operator=(ConfusionMatrix&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfusionMatrix& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfusionMatrix* internal_default_instance() {
    return reinterpret_cast<const ConfusionMatrix*>(
               &_ConfusionMatrix_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(ConfusionMatrix& a, ConfusionMatrix& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfusionMatrix* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfusionMatrix* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfusionMatrix* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfusionMatrix>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfusionMatrix& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConfusionMatrix& from) {
    ConfusionMatrix::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfusionMatrix* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.ConfusionMatrix";
  }
  protected:
  explicit ConfusionMatrix(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatrixFieldNumber = 1,
    kConceptIdsFieldNumber = 2,
  };
  // repeated .clarifai.api.ConfusionMatrixEntry matrix = 1;
  int matrix_size() const;
  private:
  int _internal_matrix_size() const;
  public:
  void clear_matrix();
  ::clarifai::api::ConfusionMatrixEntry* mutable_matrix(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ConfusionMatrixEntry >*
      mutable_matrix();
  private:
  const ::clarifai::api::ConfusionMatrixEntry& _internal_matrix(int index) const;
  ::clarifai::api::ConfusionMatrixEntry* _internal_add_matrix();
  public:
  const ::clarifai::api::ConfusionMatrixEntry& matrix(int index) const;
  ::clarifai::api::ConfusionMatrixEntry* add_matrix();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ConfusionMatrixEntry >&
      matrix() const;

  // repeated string concept_ids = 2;
  int concept_ids_size() const;
  private:
  int _internal_concept_ids_size() const;
  public:
  void clear_concept_ids();
  const std::string& concept_ids(int index) const;
  std::string* mutable_concept_ids(int index);
  void set_concept_ids(int index, const std::string& value);
  void set_concept_ids(int index, std::string&& value);
  void set_concept_ids(int index, const char* value);
  void set_concept_ids(int index, const char* value, size_t size);
  std::string* add_concept_ids();
  void add_concept_ids(const std::string& value);
  void add_concept_ids(std::string&& value);
  void add_concept_ids(const char* value);
  void add_concept_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& concept_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_concept_ids();
  private:
  const std::string& _internal_concept_ids(int index) const;
  std::string* _internal_add_concept_ids();
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.ConfusionMatrix)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ConfusionMatrixEntry > matrix_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> concept_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ROC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.ROC) */ {
 public:
  inline ROC() : ROC(nullptr) {}
  ~ROC() override;
  explicit PROTOBUF_CONSTEXPR ROC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ROC(const ROC& from);
  ROC(ROC&& from) noexcept
    : ROC() {
    *this = ::std::move(from);
  }

  inline ROC& operator=(const ROC& from) {
    CopyFrom(from);
    return *this;
  }
  inline ROC& operator=(ROC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ROC& default_instance() {
    return *internal_default_instance();
  }
  static inline const ROC* internal_default_instance() {
    return reinterpret_cast<const ROC*>(
               &_ROC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(ROC& a, ROC& b) {
    a.Swap(&b);
  }
  inline void Swap(ROC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ROC* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ROC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ROC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ROC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ROC& from) {
    ROC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ROC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.ROC";
  }
  protected:
  explicit ROC(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFprFieldNumber = 1,
    kTprFieldNumber = 2,
    kThresholdsFieldNumber = 3,
    kFprPerImageFieldNumber = 4,
    kFprPerObjectFieldNumber = 5,
  };
  // repeated float fpr = 1 [(.clarifai.api.utils.cl_show_if_empty) = true];
  int fpr_size() const;
  private:
  int _internal_fpr_size() const;
  public:
  void clear_fpr();
  private:
  float _internal_fpr(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_fpr() const;
  void _internal_add_fpr(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_fpr();
  public:
  float fpr(int index) const;
  void set_fpr(int index, float value);
  void add_fpr(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      fpr() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_fpr();

  // repeated float tpr = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
  int tpr_size() const;
  private:
  int _internal_tpr_size() const;
  public:
  void clear_tpr();
  private:
  float _internal_tpr(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_tpr() const;
  void _internal_add_tpr(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_tpr();
  public:
  float tpr(int index) const;
  void set_tpr(int index, float value);
  void add_tpr(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      tpr() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_tpr();

  // repeated float thresholds = 3 [(.clarifai.api.utils.cl_show_if_empty) = true];
  int thresholds_size() const;
  private:
  int _internal_thresholds_size() const;
  public:
  void clear_thresholds();
  private:
  float _internal_thresholds(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_thresholds() const;
  void _internal_add_thresholds(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_thresholds();
  public:
  float thresholds(int index) const;
  void set_thresholds(int index, float value);
  void add_thresholds(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      thresholds() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_thresholds();

  // repeated float fpr_per_image = 4;
  int fpr_per_image_size() const;
  private:
  int _internal_fpr_per_image_size() const;
  public:
  void clear_fpr_per_image();
  private:
  float _internal_fpr_per_image(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_fpr_per_image() const;
  void _internal_add_fpr_per_image(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_fpr_per_image();
  public:
  float fpr_per_image(int index) const;
  void set_fpr_per_image(int index, float value);
  void add_fpr_per_image(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      fpr_per_image() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_fpr_per_image();

  // repeated float fpr_per_object = 5;
  int fpr_per_object_size() const;
  private:
  int _internal_fpr_per_object_size() const;
  public:
  void clear_fpr_per_object();
  private:
  float _internal_fpr_per_object(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_fpr_per_object() const;
  void _internal_add_fpr_per_object(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_fpr_per_object();
  public:
  float fpr_per_object(int index) const;
  void set_fpr_per_object(int index, float value);
  void add_fpr_per_object(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      fpr_per_object() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_fpr_per_object();

  // @@protoc_insertion_point(class_scope:clarifai.api.ROC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > fpr_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > tpr_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > thresholds_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > fpr_per_image_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > fpr_per_object_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class PrecisionRecallCurve final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.PrecisionRecallCurve) */ {
 public:
  inline PrecisionRecallCurve() : PrecisionRecallCurve(nullptr) {}
  ~PrecisionRecallCurve() override;
  explicit PROTOBUF_CONSTEXPR PrecisionRecallCurve(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrecisionRecallCurve(const PrecisionRecallCurve& from);
  PrecisionRecallCurve(PrecisionRecallCurve&& from) noexcept
    : PrecisionRecallCurve() {
    *this = ::std::move(from);
  }

  inline PrecisionRecallCurve& operator=(const PrecisionRecallCurve& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrecisionRecallCurve& operator=(PrecisionRecallCurve&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrecisionRecallCurve& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrecisionRecallCurve* internal_default_instance() {
    return reinterpret_cast<const PrecisionRecallCurve*>(
               &_PrecisionRecallCurve_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(PrecisionRecallCurve& a, PrecisionRecallCurve& b) {
    a.Swap(&b);
  }
  inline void Swap(PrecisionRecallCurve* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrecisionRecallCurve* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrecisionRecallCurve* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrecisionRecallCurve>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrecisionRecallCurve& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PrecisionRecallCurve& from) {
    PrecisionRecallCurve::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrecisionRecallCurve* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.PrecisionRecallCurve";
  }
  protected:
  explicit PrecisionRecallCurve(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecallFieldNumber = 1,
    kPrecisionFieldNumber = 2,
    kThresholdsFieldNumber = 3,
  };
  // repeated float recall = 1 [(.clarifai.api.utils.cl_show_if_empty) = true];
  int recall_size() const;
  private:
  int _internal_recall_size() const;
  public:
  void clear_recall();
  private:
  float _internal_recall(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_recall() const;
  void _internal_add_recall(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_recall();
  public:
  float recall(int index) const;
  void set_recall(int index, float value);
  void add_recall(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      recall() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_recall();

  // repeated float precision = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
  int precision_size() const;
  private:
  int _internal_precision_size() const;
  public:
  void clear_precision();
  private:
  float _internal_precision(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_precision() const;
  void _internal_add_precision(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_precision();
  public:
  float precision(int index) const;
  void set_precision(int index, float value);
  void add_precision(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      precision() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_precision();

  // repeated float thresholds = 3 [(.clarifai.api.utils.cl_show_if_empty) = true];
  int thresholds_size() const;
  private:
  int _internal_thresholds_size() const;
  public:
  void clear_thresholds();
  private:
  float _internal_thresholds(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_thresholds() const;
  void _internal_add_thresholds(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_thresholds();
  public:
  float thresholds(int index) const;
  void set_thresholds(int index, float value);
  void add_thresholds(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      thresholds() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_thresholds();

  // @@protoc_insertion_point(class_scope:clarifai.api.PrecisionRecallCurve)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > recall_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > precision_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > thresholds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class BinaryMetrics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.BinaryMetrics) */ {
 public:
  inline BinaryMetrics() : BinaryMetrics(nullptr) {}
  ~BinaryMetrics() override;
  explicit PROTOBUF_CONSTEXPR BinaryMetrics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BinaryMetrics(const BinaryMetrics& from);
  BinaryMetrics(BinaryMetrics&& from) noexcept
    : BinaryMetrics() {
    *this = ::std::move(from);
  }

  inline BinaryMetrics& operator=(const BinaryMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryMetrics& operator=(BinaryMetrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BinaryMetrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const BinaryMetrics* internal_default_instance() {
    return reinterpret_cast<const BinaryMetrics*>(
               &_BinaryMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(BinaryMetrics& a, BinaryMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(BinaryMetrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinaryMetrics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BinaryMetrics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BinaryMetrics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BinaryMetrics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BinaryMetrics& from) {
    BinaryMetrics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinaryMetrics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.BinaryMetrics";
  }
  protected:
  explicit BinaryMetrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAreaNameFieldNumber = 10,
    kConceptFieldNumber = 6,
    kRocCurveFieldNumber = 7,
    kPrecisionRecallCurveFieldNumber = 8,
    kNumPosFieldNumber = 1,
    kNumNegFieldNumber = 2,
    kNumTotFieldNumber = 3,
    kRocAucFieldNumber = 4,
    kF1FieldNumber = 5,
    kAvgPrecisionFieldNumber = 9,
    kAreaMinFieldNumber = 11,
    kAreaMaxFieldNumber = 12,
    kIouFieldNumber = 13,
  };
  // string area_name = 10;
  void clear_area_name();
  const std::string& area_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_area_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_area_name();
  PROTOBUF_NODISCARD std::string* release_area_name();
  void set_allocated_area_name(std::string* area_name);
  private:
  const std::string& _internal_area_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_area_name(const std::string& value);
  std::string* _internal_mutable_area_name();
  public:

  // .clarifai.api.Concept concept = 6;
  bool has_concept() const;
  private:
  bool _internal_has_concept() const;
  public:
  void clear_concept();
  const ::clarifai::api::Concept& concept() const;
  PROTOBUF_NODISCARD ::clarifai::api::Concept* release_concept();
  ::clarifai::api::Concept* mutable_concept();
  void set_allocated_concept(::clarifai::api::Concept* concept);
  private:
  const ::clarifai::api::Concept& _internal_concept() const;
  ::clarifai::api::Concept* _internal_mutable_concept();
  public:
  void unsafe_arena_set_allocated_concept(
      ::clarifai::api::Concept* concept);
  ::clarifai::api::Concept* unsafe_arena_release_concept();

  // .clarifai.api.ROC roc_curve = 7;
  bool has_roc_curve() const;
  private:
  bool _internal_has_roc_curve() const;
  public:
  void clear_roc_curve();
  const ::clarifai::api::ROC& roc_curve() const;
  PROTOBUF_NODISCARD ::clarifai::api::ROC* release_roc_curve();
  ::clarifai::api::ROC* mutable_roc_curve();
  void set_allocated_roc_curve(::clarifai::api::ROC* roc_curve);
  private:
  const ::clarifai::api::ROC& _internal_roc_curve() const;
  ::clarifai::api::ROC* _internal_mutable_roc_curve();
  public:
  void unsafe_arena_set_allocated_roc_curve(
      ::clarifai::api::ROC* roc_curve);
  ::clarifai::api::ROC* unsafe_arena_release_roc_curve();

  // .clarifai.api.PrecisionRecallCurve precision_recall_curve = 8;
  bool has_precision_recall_curve() const;
  private:
  bool _internal_has_precision_recall_curve() const;
  public:
  void clear_precision_recall_curve();
  const ::clarifai::api::PrecisionRecallCurve& precision_recall_curve() const;
  PROTOBUF_NODISCARD ::clarifai::api::PrecisionRecallCurve* release_precision_recall_curve();
  ::clarifai::api::PrecisionRecallCurve* mutable_precision_recall_curve();
  void set_allocated_precision_recall_curve(::clarifai::api::PrecisionRecallCurve* precision_recall_curve);
  private:
  const ::clarifai::api::PrecisionRecallCurve& _internal_precision_recall_curve() const;
  ::clarifai::api::PrecisionRecallCurve* _internal_mutable_precision_recall_curve();
  public:
  void unsafe_arena_set_allocated_precision_recall_curve(
      ::clarifai::api::PrecisionRecallCurve* precision_recall_curve);
  ::clarifai::api::PrecisionRecallCurve* unsafe_arena_release_precision_recall_curve();

  // uint32 num_pos = 1 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_num_pos();
  uint32_t num_pos() const;
  void set_num_pos(uint32_t value);
  private:
  uint32_t _internal_num_pos() const;
  void _internal_set_num_pos(uint32_t value);
  public:

  // uint32 num_neg = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_num_neg();
  uint32_t num_neg() const;
  void set_num_neg(uint32_t value);
  private:
  uint32_t _internal_num_neg() const;
  void _internal_set_num_neg(uint32_t value);
  public:

  // uint32 num_tot = 3 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_num_tot();
  uint32_t num_tot() const;
  void set_num_tot(uint32_t value);
  private:
  uint32_t _internal_num_tot() const;
  void _internal_set_num_tot(uint32_t value);
  public:

  // float roc_auc = 4 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_roc_auc();
  float roc_auc() const;
  void set_roc_auc(float value);
  private:
  float _internal_roc_auc() const;
  void _internal_set_roc_auc(float value);
  public:

  // float f1 = 5 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_f1();
  float f1() const;
  void set_f1(float value);
  private:
  float _internal_f1() const;
  void _internal_set_f1(float value);
  public:

  // float avg_precision = 9;
  void clear_avg_precision();
  float avg_precision() const;
  void set_avg_precision(float value);
  private:
  float _internal_avg_precision() const;
  void _internal_set_avg_precision(float value);
  public:

  // double area_min = 11;
  void clear_area_min();
  double area_min() const;
  void set_area_min(double value);
  private:
  double _internal_area_min() const;
  void _internal_set_area_min(double value);
  public:

  // double area_max = 12;
  void clear_area_max();
  double area_max() const;
  void set_area_max(double value);
  private:
  double _internal_area_max() const;
  void _internal_set_area_max(double value);
  public:

  // float iou = 13;
  void clear_iou();
  float iou() const;
  void set_iou(float value);
  private:
  float _internal_iou() const;
  void _internal_set_iou(float value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.BinaryMetrics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr area_name_;
    ::clarifai::api::Concept* concept_;
    ::clarifai::api::ROC* roc_curve_;
    ::clarifai::api::PrecisionRecallCurve* precision_recall_curve_;
    uint32_t num_pos_;
    uint32_t num_neg_;
    uint32_t num_tot_;
    float roc_auc_;
    float f1_;
    float avg_precision_;
    double area_min_;
    double area_max_;
    float iou_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class TrackerMetrics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.TrackerMetrics) */ {
 public:
  inline TrackerMetrics() : TrackerMetrics(nullptr) {}
  ~TrackerMetrics() override;
  explicit PROTOBUF_CONSTEXPR TrackerMetrics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackerMetrics(const TrackerMetrics& from);
  TrackerMetrics(TrackerMetrics&& from) noexcept
    : TrackerMetrics() {
    *this = ::std::move(from);
  }

  inline TrackerMetrics& operator=(const TrackerMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackerMetrics& operator=(TrackerMetrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackerMetrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackerMetrics* internal_default_instance() {
    return reinterpret_cast<const TrackerMetrics*>(
               &_TrackerMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(TrackerMetrics& a, TrackerMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackerMetrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackerMetrics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackerMetrics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackerMetrics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackerMetrics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackerMetrics& from) {
    TrackerMetrics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackerMetrics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.TrackerMetrics";
  }
  protected:
  explicit TrackerMetrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAiidFieldNumber = 5,
    kMotMotaFieldNumber = 1,
    kMotNumSwitchesFieldNumber = 2,
    kMorseFragFieldNumber = 3,
    kAvgPrecisionFieldNumber = 4,
    kUniqueSwitchRateFieldNumber = 6,
  };
  // string aiid = 5;
  void clear_aiid();
  const std::string& aiid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_aiid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_aiid();
  PROTOBUF_NODISCARD std::string* release_aiid();
  void set_allocated_aiid(std::string* aiid);
  private:
  const std::string& _internal_aiid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_aiid(const std::string& value);
  std::string* _internal_mutable_aiid();
  public:

  // float mot_mota = 1;
  void clear_mot_mota();
  float mot_mota() const;
  void set_mot_mota(float value);
  private:
  float _internal_mot_mota() const;
  void _internal_set_mot_mota(float value);
  public:

  // int32 mot_num_switches = 2;
  void clear_mot_num_switches();
  int32_t mot_num_switches() const;
  void set_mot_num_switches(int32_t value);
  private:
  int32_t _internal_mot_num_switches() const;
  void _internal_set_mot_num_switches(int32_t value);
  public:

  // float morse_frag = 3;
  void clear_morse_frag();
  float morse_frag() const;
  void set_morse_frag(float value);
  private:
  float _internal_morse_frag() const;
  void _internal_set_morse_frag(float value);
  public:

  // float avg_precision = 4;
  void clear_avg_precision();
  float avg_precision() const;
  void set_avg_precision(float value);
  private:
  float _internal_avg_precision() const;
  void _internal_set_avg_precision(float value);
  public:

  // float unique_switch_rate = 6;
  void clear_unique_switch_rate();
  float unique_switch_rate() const;
  void set_unique_switch_rate(float value);
  private:
  float _internal_unique_switch_rate() const;
  void _internal_set_unique_switch_rate(float value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.TrackerMetrics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr aiid_;
    float mot_mota_;
    int32_t mot_num_switches_;
    float morse_frag_;
    float avg_precision_;
    float unique_switch_rate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class EvalTestSetEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.EvalTestSetEntry) */ {
 public:
  inline EvalTestSetEntry() : EvalTestSetEntry(nullptr) {}
  ~EvalTestSetEntry() override;
  explicit PROTOBUF_CONSTEXPR EvalTestSetEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EvalTestSetEntry(const EvalTestSetEntry& from);
  EvalTestSetEntry(EvalTestSetEntry&& from) noexcept
    : EvalTestSetEntry() {
    *this = ::std::move(from);
  }

  inline EvalTestSetEntry& operator=(const EvalTestSetEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline EvalTestSetEntry& operator=(EvalTestSetEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EvalTestSetEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const EvalTestSetEntry* internal_default_instance() {
    return reinterpret_cast<const EvalTestSetEntry*>(
               &_EvalTestSetEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(EvalTestSetEntry& a, EvalTestSetEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(EvalTestSetEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EvalTestSetEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EvalTestSetEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EvalTestSetEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EvalTestSetEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EvalTestSetEntry& from) {
    EvalTestSetEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EvalTestSetEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.EvalTestSetEntry";
  }
  protected:
  explicit EvalTestSetEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPredictedConceptsFieldNumber = 3,
    kGroundTruthConceptsFieldNumber = 4,
    kIdFieldNumber = 1,
    kUrlFieldNumber = 2,
    kAnnotationFieldNumber = 5,
    kInputFieldNumber = 6,
  };
  // repeated .clarifai.api.Concept predicted_concepts = 3;
  int predicted_concepts_size() const;
  private:
  int _internal_predicted_concepts_size() const;
  public:
  void clear_predicted_concepts();
  ::clarifai::api::Concept* mutable_predicted_concepts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept >*
      mutable_predicted_concepts();
  private:
  const ::clarifai::api::Concept& _internal_predicted_concepts(int index) const;
  ::clarifai::api::Concept* _internal_add_predicted_concepts();
  public:
  const ::clarifai::api::Concept& predicted_concepts(int index) const;
  ::clarifai::api::Concept* add_predicted_concepts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept >&
      predicted_concepts() const;

  // repeated .clarifai.api.Concept ground_truth_concepts = 4;
  int ground_truth_concepts_size() const;
  private:
  int _internal_ground_truth_concepts_size() const;
  public:
  void clear_ground_truth_concepts();
  ::clarifai::api::Concept* mutable_ground_truth_concepts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept >*
      mutable_ground_truth_concepts();
  private:
  const ::clarifai::api::Concept& _internal_ground_truth_concepts(int index) const;
  ::clarifai::api::Concept* _internal_add_ground_truth_concepts();
  public:
  const ::clarifai::api::Concept& ground_truth_concepts(int index) const;
  ::clarifai::api::Concept* add_ground_truth_concepts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept >&
      ground_truth_concepts() const;

  // string id = 1 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_id();
  PROTOBUF_DEPRECATED const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_id(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_id();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_id();
  PROTOBUF_DEPRECATED void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string url = 2 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_url();
  PROTOBUF_DEPRECATED const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_url(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_url();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_url();
  PROTOBUF_DEPRECATED void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // .clarifai.api.Annotation annotation = 5;
  bool has_annotation() const;
  private:
  bool _internal_has_annotation() const;
  public:
  void clear_annotation();
  const ::clarifai::api::Annotation& annotation() const;
  PROTOBUF_NODISCARD ::clarifai::api::Annotation* release_annotation();
  ::clarifai::api::Annotation* mutable_annotation();
  void set_allocated_annotation(::clarifai::api::Annotation* annotation);
  private:
  const ::clarifai::api::Annotation& _internal_annotation() const;
  ::clarifai::api::Annotation* _internal_mutable_annotation();
  public:
  void unsafe_arena_set_allocated_annotation(
      ::clarifai::api::Annotation* annotation);
  ::clarifai::api::Annotation* unsafe_arena_release_annotation();

  // .clarifai.api.Input input = 6;
  bool has_input() const;
  private:
  bool _internal_has_input() const;
  public:
  void clear_input();
  const ::clarifai::api::Input& input() const;
  PROTOBUF_NODISCARD ::clarifai::api::Input* release_input();
  ::clarifai::api::Input* mutable_input();
  void set_allocated_input(::clarifai::api::Input* input);
  private:
  const ::clarifai::api::Input& _internal_input() const;
  ::clarifai::api::Input* _internal_mutable_input();
  public:
  void unsafe_arena_set_allocated_input(
      ::clarifai::api::Input* input);
  ::clarifai::api::Input* unsafe_arena_release_input();

  // @@protoc_insertion_point(class_scope:clarifai.api.EvalTestSetEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept > predicted_concepts_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept > ground_truth_concepts_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::clarifai::api::Annotation* annotation_;
    ::clarifai::api::Input* input_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class LOPQEvalResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.LOPQEvalResult) */ {
 public:
  inline LOPQEvalResult() : LOPQEvalResult(nullptr) {}
  ~LOPQEvalResult() override;
  explicit PROTOBUF_CONSTEXPR LOPQEvalResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LOPQEvalResult(const LOPQEvalResult& from);
  LOPQEvalResult(LOPQEvalResult&& from) noexcept
    : LOPQEvalResult() {
    *this = ::std::move(from);
  }

  inline LOPQEvalResult& operator=(const LOPQEvalResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline LOPQEvalResult& operator=(LOPQEvalResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LOPQEvalResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const LOPQEvalResult* internal_default_instance() {
    return reinterpret_cast<const LOPQEvalResult*>(
               &_LOPQEvalResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(LOPQEvalResult& a, LOPQEvalResult& b) {
    a.Swap(&b);
  }
  inline void Swap(LOPQEvalResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LOPQEvalResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LOPQEvalResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LOPQEvalResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LOPQEvalResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LOPQEvalResult& from) {
    LOPQEvalResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LOPQEvalResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.LOPQEvalResult";
  }
  protected:
  explicit LOPQEvalResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKFieldNumber = 1,
    kRecallVsBruteForceFieldNumber = 2,
    kKendallTauVsBruteForceFieldNumber = 3,
    kMostFrequentCodePercentFieldNumber = 4,
    kLopqNdcgFieldNumber = 5,
    kBruteForceNdcgFieldNumber = 6,
  };
  // int32 k = 1;
  void clear_k();
  int32_t k() const;
  void set_k(int32_t value);
  private:
  int32_t _internal_k() const;
  void _internal_set_k(int32_t value);
  public:

  // float recall_vs_brute_force = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_recall_vs_brute_force();
  float recall_vs_brute_force() const;
  void set_recall_vs_brute_force(float value);
  private:
  float _internal_recall_vs_brute_force() const;
  void _internal_set_recall_vs_brute_force(float value);
  public:

  // float kendall_tau_vs_brute_force = 3 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_kendall_tau_vs_brute_force();
  float kendall_tau_vs_brute_force() const;
  void set_kendall_tau_vs_brute_force(float value);
  private:
  float _internal_kendall_tau_vs_brute_force() const;
  void _internal_set_kendall_tau_vs_brute_force(float value);
  public:

  // float most_frequent_code_percent = 4 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_most_frequent_code_percent();
  float most_frequent_code_percent() const;
  void set_most_frequent_code_percent(float value);
  private:
  float _internal_most_frequent_code_percent() const;
  void _internal_set_most_frequent_code_percent(float value);
  public:

  // float lopq_ndcg = 5 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_lopq_ndcg();
  float lopq_ndcg() const;
  void set_lopq_ndcg(float value);
  private:
  float _internal_lopq_ndcg() const;
  void _internal_set_lopq_ndcg(float value);
  public:

  // float brute_force_ndcg = 6 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_brute_force_ndcg();
  float brute_force_ndcg() const;
  void set_brute_force_ndcg(float value);
  private:
  float _internal_brute_force_ndcg() const;
  void _internal_set_brute_force_ndcg(float value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.LOPQEvalResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t k_;
    float recall_vs_brute_force_;
    float kendall_tau_vs_brute_force_;
    float most_frequent_code_percent_;
    float lopq_ndcg_;
    float brute_force_ndcg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class MetricsSummary final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.MetricsSummary) */ {
 public:
  inline MetricsSummary() : MetricsSummary(nullptr) {}
  ~MetricsSummary() override;
  explicit PROTOBUF_CONSTEXPR MetricsSummary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetricsSummary(const MetricsSummary& from);
  MetricsSummary(MetricsSummary&& from) noexcept
    : MetricsSummary() {
    *this = ::std::move(from);
  }

  inline MetricsSummary& operator=(const MetricsSummary& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetricsSummary& operator=(MetricsSummary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetricsSummary& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetricsSummary* internal_default_instance() {
    return reinterpret_cast<const MetricsSummary*>(
               &_MetricsSummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  friend void swap(MetricsSummary& a, MetricsSummary& b) {
    a.Swap(&b);
  }
  inline void Swap(MetricsSummary* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetricsSummary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetricsSummary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetricsSummary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetricsSummary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MetricsSummary& from) {
    MetricsSummary::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetricsSummary* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.MetricsSummary";
  }
  protected:
  explicit MetricsSummary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLopqMetricsFieldNumber = 9,
    kTop1AccuracyFieldNumber = 1,
    kTop5AccuracyFieldNumber = 2,
    kMacroAvgRocAucFieldNumber = 3,
    kMacroStdRocAucFieldNumber = 4,
    kMacroAvgF1ScoreFieldNumber = 5,
    kMacroStdF1ScoreFieldNumber = 6,
    kMacroAvgPrecisionFieldNumber = 7,
    kMacroAvgRecallFieldNumber = 8,
    kMeanAvgPrecisionIou50FieldNumber = 10,
    kMeanAvgPrecisionIouRangeFieldNumber = 11,
  };
  // repeated .clarifai.api.LOPQEvalResult lopq_metrics = 9;
  int lopq_metrics_size() const;
  private:
  int _internal_lopq_metrics_size() const;
  public:
  void clear_lopq_metrics();
  ::clarifai::api::LOPQEvalResult* mutable_lopq_metrics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::LOPQEvalResult >*
      mutable_lopq_metrics();
  private:
  const ::clarifai::api::LOPQEvalResult& _internal_lopq_metrics(int index) const;
  ::clarifai::api::LOPQEvalResult* _internal_add_lopq_metrics();
  public:
  const ::clarifai::api::LOPQEvalResult& lopq_metrics(int index) const;
  ::clarifai::api::LOPQEvalResult* add_lopq_metrics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::LOPQEvalResult >&
      lopq_metrics() const;

  // float top1_accuracy = 1 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_top1_accuracy();
  PROTOBUF_DEPRECATED float top1_accuracy() const;
  PROTOBUF_DEPRECATED void set_top1_accuracy(float value);
  private:
  float _internal_top1_accuracy() const;
  void _internal_set_top1_accuracy(float value);
  public:

  // float top5_accuracy = 2 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_top5_accuracy();
  PROTOBUF_DEPRECATED float top5_accuracy() const;
  PROTOBUF_DEPRECATED void set_top5_accuracy(float value);
  private:
  float _internal_top5_accuracy() const;
  void _internal_set_top5_accuracy(float value);
  public:

  // float macro_avg_roc_auc = 3 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_macro_avg_roc_auc();
  float macro_avg_roc_auc() const;
  void set_macro_avg_roc_auc(float value);
  private:
  float _internal_macro_avg_roc_auc() const;
  void _internal_set_macro_avg_roc_auc(float value);
  public:

  // float macro_std_roc_auc = 4 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_macro_std_roc_auc();
  float macro_std_roc_auc() const;
  void set_macro_std_roc_auc(float value);
  private:
  float _internal_macro_std_roc_auc() const;
  void _internal_set_macro_std_roc_auc(float value);
  public:

  // float macro_avg_f1_score = 5 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_macro_avg_f1_score();
  float macro_avg_f1_score() const;
  void set_macro_avg_f1_score(float value);
  private:
  float _internal_macro_avg_f1_score() const;
  void _internal_set_macro_avg_f1_score(float value);
  public:

  // float macro_std_f1_score = 6 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_macro_std_f1_score();
  float macro_std_f1_score() const;
  void set_macro_std_f1_score(float value);
  private:
  float _internal_macro_std_f1_score() const;
  void _internal_set_macro_std_f1_score(float value);
  public:

  // float macro_avg_precision = 7 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_macro_avg_precision();
  float macro_avg_precision() const;
  void set_macro_avg_precision(float value);
  private:
  float _internal_macro_avg_precision() const;
  void _internal_set_macro_avg_precision(float value);
  public:

  // float macro_avg_recall = 8 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_macro_avg_recall();
  float macro_avg_recall() const;
  void set_macro_avg_recall(float value);
  private:
  float _internal_macro_avg_recall() const;
  void _internal_set_macro_avg_recall(float value);
  public:

  // float mean_avg_precision_iou_50 = 10;
  void clear_mean_avg_precision_iou_50();
  float mean_avg_precision_iou_50() const;
  void set_mean_avg_precision_iou_50(float value);
  private:
  float _internal_mean_avg_precision_iou_50() const;
  void _internal_set_mean_avg_precision_iou_50(float value);
  public:

  // float mean_avg_precision_iou_range = 11;
  void clear_mean_avg_precision_iou_range();
  float mean_avg_precision_iou_range() const;
  void set_mean_avg_precision_iou_range(float value);
  private:
  float _internal_mean_avg_precision_iou_range() const;
  void _internal_set_mean_avg_precision_iou_range(float value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.MetricsSummary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::LOPQEvalResult > lopq_metrics_;
    float top1_accuracy_;
    float top5_accuracy_;
    float macro_avg_roc_auc_;
    float macro_std_roc_auc_;
    float macro_avg_f1_score_;
    float macro_std_f1_score_;
    float macro_avg_precision_;
    float macro_avg_recall_;
    float mean_avg_precision_iou_50_;
    float mean_avg_precision_iou_range_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class EvalMetrics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.EvalMetrics) */ {
 public:
  inline EvalMetrics() : EvalMetrics(nullptr) {}
  ~EvalMetrics() override;
  explicit PROTOBUF_CONSTEXPR EvalMetrics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EvalMetrics(const EvalMetrics& from);
  EvalMetrics(EvalMetrics&& from) noexcept
    : EvalMetrics() {
    *this = ::std::move(from);
  }

  inline EvalMetrics& operator=(const EvalMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline EvalMetrics& operator=(EvalMetrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EvalMetrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const EvalMetrics* internal_default_instance() {
    return reinterpret_cast<const EvalMetrics*>(
               &_EvalMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  friend void swap(EvalMetrics& a, EvalMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(EvalMetrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EvalMetrics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EvalMetrics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EvalMetrics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EvalMetrics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EvalMetrics& from) {
    EvalMetrics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EvalMetrics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.EvalMetrics";
  }
  protected:
  explicit EvalMetrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBinaryMetricsFieldNumber = 6,
    kTestSetFieldNumber = 7,
    kMetricsByAreaFieldNumber = 8,
    kMetricsByClassFieldNumber = 9,
    kTrackerMetricsFieldNumber = 11,
    kIdFieldNumber = 10,
    kStatusFieldNumber = 1,
    kSummaryFieldNumber = 2,
    kConfusionMatrixFieldNumber = 3,
    kCooccurrenceMatrixFieldNumber = 4,
    kLabelCountsFieldNumber = 5,
    kEvalInfoFieldNumber = 12,
  };
  // repeated .clarifai.api.BinaryMetrics binary_metrics = 6;
  int binary_metrics_size() const;
  private:
  int _internal_binary_metrics_size() const;
  public:
  void clear_binary_metrics();
  ::clarifai::api::BinaryMetrics* mutable_binary_metrics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::BinaryMetrics >*
      mutable_binary_metrics();
  private:
  const ::clarifai::api::BinaryMetrics& _internal_binary_metrics(int index) const;
  ::clarifai::api::BinaryMetrics* _internal_add_binary_metrics();
  public:
  const ::clarifai::api::BinaryMetrics& binary_metrics(int index) const;
  ::clarifai::api::BinaryMetrics* add_binary_metrics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::BinaryMetrics >&
      binary_metrics() const;

  // repeated .clarifai.api.EvalTestSetEntry test_set = 7;
  int test_set_size() const;
  private:
  int _internal_test_set_size() const;
  public:
  void clear_test_set();
  ::clarifai::api::EvalTestSetEntry* mutable_test_set(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::EvalTestSetEntry >*
      mutable_test_set();
  private:
  const ::clarifai::api::EvalTestSetEntry& _internal_test_set(int index) const;
  ::clarifai::api::EvalTestSetEntry* _internal_add_test_set();
  public:
  const ::clarifai::api::EvalTestSetEntry& test_set(int index) const;
  ::clarifai::api::EvalTestSetEntry* add_test_set();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::EvalTestSetEntry >&
      test_set() const;

  // repeated .clarifai.api.BinaryMetrics metrics_by_area = 8;
  int metrics_by_area_size() const;
  private:
  int _internal_metrics_by_area_size() const;
  public:
  void clear_metrics_by_area();
  ::clarifai::api::BinaryMetrics* mutable_metrics_by_area(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::BinaryMetrics >*
      mutable_metrics_by_area();
  private:
  const ::clarifai::api::BinaryMetrics& _internal_metrics_by_area(int index) const;
  ::clarifai::api::BinaryMetrics* _internal_add_metrics_by_area();
  public:
  const ::clarifai::api::BinaryMetrics& metrics_by_area(int index) const;
  ::clarifai::api::BinaryMetrics* add_metrics_by_area();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::BinaryMetrics >&
      metrics_by_area() const;

  // repeated .clarifai.api.BinaryMetrics metrics_by_class = 9;
  int metrics_by_class_size() const;
  private:
  int _internal_metrics_by_class_size() const;
  public:
  void clear_metrics_by_class();
  ::clarifai::api::BinaryMetrics* mutable_metrics_by_class(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::BinaryMetrics >*
      mutable_metrics_by_class();
  private:
  const ::clarifai::api::BinaryMetrics& _internal_metrics_by_class(int index) const;
  ::clarifai::api::BinaryMetrics* _internal_add_metrics_by_class();
  public:
  const ::clarifai::api::BinaryMetrics& metrics_by_class(int index) const;
  ::clarifai::api::BinaryMetrics* add_metrics_by_class();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::BinaryMetrics >&
      metrics_by_class() const;

  // repeated .clarifai.api.TrackerMetrics tracker_metrics = 11;
  int tracker_metrics_size() const;
  private:
  int _internal_tracker_metrics_size() const;
  public:
  void clear_tracker_metrics();
  ::clarifai::api::TrackerMetrics* mutable_tracker_metrics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::TrackerMetrics >*
      mutable_tracker_metrics();
  private:
  const ::clarifai::api::TrackerMetrics& _internal_tracker_metrics(int index) const;
  ::clarifai::api::TrackerMetrics* _internal_add_tracker_metrics();
  public:
  const ::clarifai::api::TrackerMetrics& tracker_metrics(int index) const;
  ::clarifai::api::TrackerMetrics* add_tracker_metrics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::TrackerMetrics >&
      tracker_metrics() const;

  // string id = 10;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .clarifai.api.status.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::clarifai::api::status::Status& status() const;
  PROTOBUF_NODISCARD ::clarifai::api::status::Status* release_status();
  ::clarifai::api::status::Status* mutable_status();
  void set_allocated_status(::clarifai::api::status::Status* status);
  private:
  const ::clarifai::api::status::Status& _internal_status() const;
  ::clarifai::api::status::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::clarifai::api::status::Status* status);
  ::clarifai::api::status::Status* unsafe_arena_release_status();

  // .clarifai.api.MetricsSummary summary = 2;
  bool has_summary() const;
  private:
  bool _internal_has_summary() const;
  public:
  void clear_summary();
  const ::clarifai::api::MetricsSummary& summary() const;
  PROTOBUF_NODISCARD ::clarifai::api::MetricsSummary* release_summary();
  ::clarifai::api::MetricsSummary* mutable_summary();
  void set_allocated_summary(::clarifai::api::MetricsSummary* summary);
  private:
  const ::clarifai::api::MetricsSummary& _internal_summary() const;
  ::clarifai::api::MetricsSummary* _internal_mutable_summary();
  public:
  void unsafe_arena_set_allocated_summary(
      ::clarifai::api::MetricsSummary* summary);
  ::clarifai::api::MetricsSummary* unsafe_arena_release_summary();

  // .clarifai.api.ConfusionMatrix confusion_matrix = 3;
  bool has_confusion_matrix() const;
  private:
  bool _internal_has_confusion_matrix() const;
  public:
  void clear_confusion_matrix();
  const ::clarifai::api::ConfusionMatrix& confusion_matrix() const;
  PROTOBUF_NODISCARD ::clarifai::api::ConfusionMatrix* release_confusion_matrix();
  ::clarifai::api::ConfusionMatrix* mutable_confusion_matrix();
  void set_allocated_confusion_matrix(::clarifai::api::ConfusionMatrix* confusion_matrix);
  private:
  const ::clarifai::api::ConfusionMatrix& _internal_confusion_matrix() const;
  ::clarifai::api::ConfusionMatrix* _internal_mutable_confusion_matrix();
  public:
  void unsafe_arena_set_allocated_confusion_matrix(
      ::clarifai::api::ConfusionMatrix* confusion_matrix);
  ::clarifai::api::ConfusionMatrix* unsafe_arena_release_confusion_matrix();

  // .clarifai.api.CooccurrenceMatrix cooccurrence_matrix = 4;
  bool has_cooccurrence_matrix() const;
  private:
  bool _internal_has_cooccurrence_matrix() const;
  public:
  void clear_cooccurrence_matrix();
  const ::clarifai::api::CooccurrenceMatrix& cooccurrence_matrix() const;
  PROTOBUF_NODISCARD ::clarifai::api::CooccurrenceMatrix* release_cooccurrence_matrix();
  ::clarifai::api::CooccurrenceMatrix* mutable_cooccurrence_matrix();
  void set_allocated_cooccurrence_matrix(::clarifai::api::CooccurrenceMatrix* cooccurrence_matrix);
  private:
  const ::clarifai::api::CooccurrenceMatrix& _internal_cooccurrence_matrix() const;
  ::clarifai::api::CooccurrenceMatrix* _internal_mutable_cooccurrence_matrix();
  public:
  void unsafe_arena_set_allocated_cooccurrence_matrix(
      ::clarifai::api::CooccurrenceMatrix* cooccurrence_matrix);
  ::clarifai::api::CooccurrenceMatrix* unsafe_arena_release_cooccurrence_matrix();

  // .clarifai.api.LabelDistribution label_counts = 5;
  bool has_label_counts() const;
  private:
  bool _internal_has_label_counts() const;
  public:
  void clear_label_counts();
  const ::clarifai::api::LabelDistribution& label_counts() const;
  PROTOBUF_NODISCARD ::clarifai::api::LabelDistribution* release_label_counts();
  ::clarifai::api::LabelDistribution* mutable_label_counts();
  void set_allocated_label_counts(::clarifai::api::LabelDistribution* label_counts);
  private:
  const ::clarifai::api::LabelDistribution& _internal_label_counts() const;
  ::clarifai::api::LabelDistribution* _internal_mutable_label_counts();
  public:
  void unsafe_arena_set_allocated_label_counts(
      ::clarifai::api::LabelDistribution* label_counts);
  ::clarifai::api::LabelDistribution* unsafe_arena_release_label_counts();

  // .clarifai.api.EvalInfo eval_info = 12;
  bool has_eval_info() const;
  private:
  bool _internal_has_eval_info() const;
  public:
  void clear_eval_info();
  const ::clarifai::api::EvalInfo& eval_info() const;
  PROTOBUF_NODISCARD ::clarifai::api::EvalInfo* release_eval_info();
  ::clarifai::api::EvalInfo* mutable_eval_info();
  void set_allocated_eval_info(::clarifai::api::EvalInfo* eval_info);
  private:
  const ::clarifai::api::EvalInfo& _internal_eval_info() const;
  ::clarifai::api::EvalInfo* _internal_mutable_eval_info();
  public:
  void unsafe_arena_set_allocated_eval_info(
      ::clarifai::api::EvalInfo* eval_info);
  ::clarifai::api::EvalInfo* unsafe_arena_release_eval_info();

  // @@protoc_insertion_point(class_scope:clarifai.api.EvalMetrics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::BinaryMetrics > binary_metrics_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::EvalTestSetEntry > test_set_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::BinaryMetrics > metrics_by_area_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::BinaryMetrics > metrics_by_class_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::TrackerMetrics > tracker_metrics_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::clarifai::api::status::Status* status_;
    ::clarifai::api::MetricsSummary* summary_;
    ::clarifai::api::ConfusionMatrix* confusion_matrix_;
    ::clarifai::api::CooccurrenceMatrix* cooccurrence_matrix_;
    ::clarifai::api::LabelDistribution* label_counts_;
    ::clarifai::api::EvalInfo* eval_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class FieldsValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.FieldsValue) */ {
 public:
  inline FieldsValue() : FieldsValue(nullptr) {}
  ~FieldsValue() override;
  explicit PROTOBUF_CONSTEXPR FieldsValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FieldsValue(const FieldsValue& from);
  FieldsValue(FieldsValue&& from) noexcept
    : FieldsValue() {
    *this = ::std::move(from);
  }

  inline FieldsValue& operator=(const FieldsValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldsValue& operator=(FieldsValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FieldsValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const FieldsValue* internal_default_instance() {
    return reinterpret_cast<const FieldsValue*>(
               &_FieldsValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    93;

  friend void swap(FieldsValue& a, FieldsValue& b) {
    a.Swap(&b);
  }
  inline void Swap(FieldsValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldsValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FieldsValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FieldsValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FieldsValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FieldsValue& from) {
    FieldsValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FieldsValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.FieldsValue";
  }
  protected:
  explicit FieldsValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfusionMatrixFieldNumber = 1,
    kCooccurrenceMatrixFieldNumber = 2,
    kLabelCountsFieldNumber = 3,
    kBinaryMetricsFieldNumber = 4,
    kTestSetFieldNumber = 5,
    kMetricsByAreaFieldNumber = 6,
    kMetricsByClassFieldNumber = 7,
  };
  // bool confusion_matrix = 1;
  void clear_confusion_matrix();
  bool confusion_matrix() const;
  void set_confusion_matrix(bool value);
  private:
  bool _internal_confusion_matrix() const;
  void _internal_set_confusion_matrix(bool value);
  public:

  // bool cooccurrence_matrix = 2;
  void clear_cooccurrence_matrix();
  bool cooccurrence_matrix() const;
  void set_cooccurrence_matrix(bool value);
  private:
  bool _internal_cooccurrence_matrix() const;
  void _internal_set_cooccurrence_matrix(bool value);
  public:

  // bool label_counts = 3;
  void clear_label_counts();
  bool label_counts() const;
  void set_label_counts(bool value);
  private:
  bool _internal_label_counts() const;
  void _internal_set_label_counts(bool value);
  public:

  // bool binary_metrics = 4;
  void clear_binary_metrics();
  bool binary_metrics() const;
  void set_binary_metrics(bool value);
  private:
  bool _internal_binary_metrics() const;
  void _internal_set_binary_metrics(bool value);
  public:

  // bool test_set = 5;
  void clear_test_set();
  bool test_set() const;
  void set_test_set(bool value);
  private:
  bool _internal_test_set() const;
  void _internal_set_test_set(bool value);
  public:

  // bool metrics_by_area = 6;
  void clear_metrics_by_area();
  bool metrics_by_area() const;
  void set_metrics_by_area(bool value);
  private:
  bool _internal_metrics_by_area() const;
  void _internal_set_metrics_by_area(bool value);
  public:

  // bool metrics_by_class = 7;
  void clear_metrics_by_class();
  bool metrics_by_class() const;
  void set_metrics_by_class(bool value);
  private:
  bool _internal_metrics_by_class() const;
  void _internal_set_metrics_by_class(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.FieldsValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool confusion_matrix_;
    bool cooccurrence_matrix_;
    bool label_counts_;
    bool binary_metrics_;
    bool test_set_;
    bool metrics_by_area_;
    bool metrics_by_class_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Output final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Output) */ {
 public:
  inline Output() : Output(nullptr) {}
  ~Output() override;
  explicit PROTOBUF_CONSTEXPR Output(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Output(const Output& from);
  Output(Output&& from) noexcept
    : Output() {
    *this = ::std::move(from);
  }

  inline Output& operator=(const Output& from) {
    CopyFrom(from);
    return *this;
  }
  inline Output& operator=(Output&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Output& default_instance() {
    return *internal_default_instance();
  }
  static inline const Output* internal_default_instance() {
    return reinterpret_cast<const Output*>(
               &_Output_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  friend void swap(Output& a, Output& b) {
    a.Swap(&b);
  }
  inline void Swap(Output* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Output* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Output* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Output>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Output& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Output& from) {
    Output::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Output* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Output";
  }
  protected:
  explicit Output(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kStatusFieldNumber = 2,
    kCreatedAtFieldNumber = 3,
    kModelFieldNumber = 4,
    kInputFieldNumber = 5,
    kDataFieldNumber = 6,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .clarifai.api.status.Status status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::clarifai::api::status::Status& status() const;
  PROTOBUF_NODISCARD ::clarifai::api::status::Status* release_status();
  ::clarifai::api::status::Status* mutable_status();
  void set_allocated_status(::clarifai::api::status::Status* status);
  private:
  const ::clarifai::api::status::Status& _internal_status() const;
  ::clarifai::api::status::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::clarifai::api::status::Status* status);
  ::clarifai::api::status::Status* unsafe_arena_release_status();

  // .google.protobuf.Timestamp created_at = 3;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .clarifai.api.Model model = 4;
  bool has_model() const;
  private:
  bool _internal_has_model() const;
  public:
  void clear_model();
  const ::clarifai::api::Model& model() const;
  PROTOBUF_NODISCARD ::clarifai::api::Model* release_model();
  ::clarifai::api::Model* mutable_model();
  void set_allocated_model(::clarifai::api::Model* model);
  private:
  const ::clarifai::api::Model& _internal_model() const;
  ::clarifai::api::Model* _internal_mutable_model();
  public:
  void unsafe_arena_set_allocated_model(
      ::clarifai::api::Model* model);
  ::clarifai::api::Model* unsafe_arena_release_model();

  // .clarifai.api.Input input = 5;
  bool has_input() const;
  private:
  bool _internal_has_input() const;
  public:
  void clear_input();
  const ::clarifai::api::Input& input() const;
  PROTOBUF_NODISCARD ::clarifai::api::Input* release_input();
  ::clarifai::api::Input* mutable_input();
  void set_allocated_input(::clarifai::api::Input* input);
  private:
  const ::clarifai::api::Input& _internal_input() const;
  ::clarifai::api::Input* _internal_mutable_input();
  public:
  void unsafe_arena_set_allocated_input(
      ::clarifai::api::Input* input);
  ::clarifai::api::Input* unsafe_arena_release_input();

  // .clarifai.api.Data data = 6;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::clarifai::api::Data& data() const;
  PROTOBUF_NODISCARD ::clarifai::api::Data* release_data();
  ::clarifai::api::Data* mutable_data();
  void set_allocated_data(::clarifai::api::Data* data);
  private:
  const ::clarifai::api::Data& _internal_data() const;
  ::clarifai::api::Data* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::clarifai::api::Data* data);
  ::clarifai::api::Data* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:clarifai.api.Output)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::clarifai::api::status::Status* status_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::clarifai::api::Model* model_;
    ::clarifai::api::Input* input_;
    ::clarifai::api::Data* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ScopeDeps final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.ScopeDeps) */ {
 public:
  inline ScopeDeps() : ScopeDeps(nullptr) {}
  ~ScopeDeps() override;
  explicit PROTOBUF_CONSTEXPR ScopeDeps(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScopeDeps(const ScopeDeps& from);
  ScopeDeps(ScopeDeps&& from) noexcept
    : ScopeDeps() {
    *this = ::std::move(from);
  }

  inline ScopeDeps& operator=(const ScopeDeps& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScopeDeps& operator=(ScopeDeps&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScopeDeps& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScopeDeps* internal_default_instance() {
    return reinterpret_cast<const ScopeDeps*>(
               &_ScopeDeps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  friend void swap(ScopeDeps& a, ScopeDeps& b) {
    a.Swap(&b);
  }
  inline void Swap(ScopeDeps* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScopeDeps* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScopeDeps* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScopeDeps>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ScopeDeps& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ScopeDeps& from) {
    ScopeDeps::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScopeDeps* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.ScopeDeps";
  }
  protected:
  explicit ScopeDeps(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDependingScopesFieldNumber = 2,
    kScopeFieldNumber = 1,
  };
  // repeated string depending_scopes = 2;
  int depending_scopes_size() const;
  private:
  int _internal_depending_scopes_size() const;
  public:
  void clear_depending_scopes();
  const std::string& depending_scopes(int index) const;
  std::string* mutable_depending_scopes(int index);
  void set_depending_scopes(int index, const std::string& value);
  void set_depending_scopes(int index, std::string&& value);
  void set_depending_scopes(int index, const char* value);
  void set_depending_scopes(int index, const char* value, size_t size);
  std::string* add_depending_scopes();
  void add_depending_scopes(const std::string& value);
  void add_depending_scopes(std::string&& value);
  void add_depending_scopes(const char* value);
  void add_depending_scopes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& depending_scopes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_depending_scopes();
  private:
  const std::string& _internal_depending_scopes(int index) const;
  std::string* _internal_add_depending_scopes();
  public:

  // string scope = 1;
  void clear_scope();
  const std::string& scope() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_scope(ArgT0&& arg0, ArgT... args);
  std::string* mutable_scope();
  PROTOBUF_NODISCARD std::string* release_scope();
  void set_allocated_scope(std::string* scope);
  private:
  const std::string& _internal_scope() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_scope(const std::string& value);
  std::string* _internal_mutable_scope();
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.ScopeDeps)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> depending_scopes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scope_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class EndpointDeps final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.EndpointDeps) */ {
 public:
  inline EndpointDeps() : EndpointDeps(nullptr) {}
  ~EndpointDeps() override;
  explicit PROTOBUF_CONSTEXPR EndpointDeps(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EndpointDeps(const EndpointDeps& from);
  EndpointDeps(EndpointDeps&& from) noexcept
    : EndpointDeps() {
    *this = ::std::move(from);
  }

  inline EndpointDeps& operator=(const EndpointDeps& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndpointDeps& operator=(EndpointDeps&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EndpointDeps& default_instance() {
    return *internal_default_instance();
  }
  static inline const EndpointDeps* internal_default_instance() {
    return reinterpret_cast<const EndpointDeps*>(
               &_EndpointDeps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  friend void swap(EndpointDeps& a, EndpointDeps& b) {
    a.Swap(&b);
  }
  inline void Swap(EndpointDeps* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndpointDeps* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndpointDeps* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EndpointDeps>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EndpointDeps& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EndpointDeps& from) {
    EndpointDeps::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EndpointDeps* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.EndpointDeps";
  }
  protected:
  explicit EndpointDeps(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDependingScopesFieldNumber = 2,
    kEndpointFieldNumber = 1,
  };
  // repeated string depending_scopes = 2;
  int depending_scopes_size() const;
  private:
  int _internal_depending_scopes_size() const;
  public:
  void clear_depending_scopes();
  const std::string& depending_scopes(int index) const;
  std::string* mutable_depending_scopes(int index);
  void set_depending_scopes(int index, const std::string& value);
  void set_depending_scopes(int index, std::string&& value);
  void set_depending_scopes(int index, const char* value);
  void set_depending_scopes(int index, const char* value, size_t size);
  std::string* add_depending_scopes();
  void add_depending_scopes(const std::string& value);
  void add_depending_scopes(std::string&& value);
  void add_depending_scopes(const char* value);
  void add_depending_scopes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& depending_scopes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_depending_scopes();
  private:
  const std::string& _internal_depending_scopes(int index) const;
  std::string* _internal_add_depending_scopes();
  public:

  // string endpoint = 1;
  void clear_endpoint();
  const std::string& endpoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_endpoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_endpoint();
  PROTOBUF_NODISCARD std::string* release_endpoint();
  void set_allocated_endpoint(std::string* endpoint);
  private:
  const std::string& _internal_endpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint(const std::string& value);
  std::string* _internal_mutable_endpoint();
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.EndpointDeps)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> depending_scopes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Hit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Hit) */ {
 public:
  inline Hit() : Hit(nullptr) {}
  ~Hit() override;
  explicit PROTOBUF_CONSTEXPR Hit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Hit(const Hit& from);
  Hit(Hit&& from) noexcept
    : Hit() {
    *this = ::std::move(from);
  }

  inline Hit& operator=(const Hit& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hit& operator=(Hit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Hit& default_instance() {
    return *internal_default_instance();
  }
  static inline const Hit* internal_default_instance() {
    return reinterpret_cast<const Hit*>(
               &_Hit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    97;

  friend void swap(Hit& a, Hit& b) {
    a.Swap(&b);
  }
  inline void Swap(Hit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Hit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Hit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Hit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Hit& from) {
    Hit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Hit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Hit";
  }
  protected:
  explicit Hit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 4,
    kAppIdFieldNumber = 5,
    kInputFieldNumber = 2,
    kAnnotationFieldNumber = 3,
    kScoreFieldNumber = 1,
  };
  // string user_id = 4;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string app_id = 5;
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // .clarifai.api.Input input = 2;
  bool has_input() const;
  private:
  bool _internal_has_input() const;
  public:
  void clear_input();
  const ::clarifai::api::Input& input() const;
  PROTOBUF_NODISCARD ::clarifai::api::Input* release_input();
  ::clarifai::api::Input* mutable_input();
  void set_allocated_input(::clarifai::api::Input* input);
  private:
  const ::clarifai::api::Input& _internal_input() const;
  ::clarifai::api::Input* _internal_mutable_input();
  public:
  void unsafe_arena_set_allocated_input(
      ::clarifai::api::Input* input);
  ::clarifai::api::Input* unsafe_arena_release_input();

  // .clarifai.api.Annotation annotation = 3;
  bool has_annotation() const;
  private:
  bool _internal_has_annotation() const;
  public:
  void clear_annotation();
  const ::clarifai::api::Annotation& annotation() const;
  PROTOBUF_NODISCARD ::clarifai::api::Annotation* release_annotation();
  ::clarifai::api::Annotation* mutable_annotation();
  void set_allocated_annotation(::clarifai::api::Annotation* annotation);
  private:
  const ::clarifai::api::Annotation& _internal_annotation() const;
  ::clarifai::api::Annotation* _internal_mutable_annotation();
  public:
  void unsafe_arena_set_allocated_annotation(
      ::clarifai::api::Annotation* annotation);
  ::clarifai::api::Annotation* unsafe_arena_release_annotation();

  // float score = 1 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_score();
  float score() const;
  void set_score(float value);
  private:
  float _internal_score() const;
  void _internal_set_score(float value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.Hit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
    ::clarifai::api::Input* input_;
    ::clarifai::api::Annotation* annotation_;
    float score_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class And final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.And) */ {
 public:
  inline And() : And(nullptr) {}
  ~And() override;
  explicit PROTOBUF_CONSTEXPR And(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  And(const And& from);
  And(And&& from) noexcept
    : And() {
    *this = ::std::move(from);
  }

  inline And& operator=(const And& from) {
    CopyFrom(from);
    return *this;
  }
  inline And& operator=(And&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const And& default_instance() {
    return *internal_default_instance();
  }
  static inline const And* internal_default_instance() {
    return reinterpret_cast<const And*>(
               &_And_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    98;

  friend void swap(And& a, And& b) {
    a.Swap(&b);
  }
  inline void Swap(And* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(And* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  And* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<And>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const And& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const And& from) {
    And::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(And* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.And";
  }
  protected:
  explicit And(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputFieldNumber = 1,
    kOutputFieldNumber = 2,
    kAnnotationFieldNumber = 4,
    kNegateFieldNumber = 3,
  };
  // .clarifai.api.Input input = 1;
  bool has_input() const;
  private:
  bool _internal_has_input() const;
  public:
  void clear_input();
  const ::clarifai::api::Input& input() const;
  PROTOBUF_NODISCARD ::clarifai::api::Input* release_input();
  ::clarifai::api::Input* mutable_input();
  void set_allocated_input(::clarifai::api::Input* input);
  private:
  const ::clarifai::api::Input& _internal_input() const;
  ::clarifai::api::Input* _internal_mutable_input();
  public:
  void unsafe_arena_set_allocated_input(
      ::clarifai::api::Input* input);
  ::clarifai::api::Input* unsafe_arena_release_input();

  // .clarifai.api.Output output = 2;
  bool has_output() const;
  private:
  bool _internal_has_output() const;
  public:
  void clear_output();
  const ::clarifai::api::Output& output() const;
  PROTOBUF_NODISCARD ::clarifai::api::Output* release_output();
  ::clarifai::api::Output* mutable_output();
  void set_allocated_output(::clarifai::api::Output* output);
  private:
  const ::clarifai::api::Output& _internal_output() const;
  ::clarifai::api::Output* _internal_mutable_output();
  public:
  void unsafe_arena_set_allocated_output(
      ::clarifai::api::Output* output);
  ::clarifai::api::Output* unsafe_arena_release_output();

  // .clarifai.api.Annotation annotation = 4;
  bool has_annotation() const;
  private:
  bool _internal_has_annotation() const;
  public:
  void clear_annotation();
  const ::clarifai::api::Annotation& annotation() const;
  PROTOBUF_NODISCARD ::clarifai::api::Annotation* release_annotation();
  ::clarifai::api::Annotation* mutable_annotation();
  void set_allocated_annotation(::clarifai::api::Annotation* annotation);
  private:
  const ::clarifai::api::Annotation& _internal_annotation() const;
  ::clarifai::api::Annotation* _internal_mutable_annotation();
  public:
  void unsafe_arena_set_allocated_annotation(
      ::clarifai::api::Annotation* annotation);
  ::clarifai::api::Annotation* unsafe_arena_release_annotation();

  // bool negate = 3;
  void clear_negate();
  bool negate() const;
  void set_negate(bool value);
  private:
  bool _internal_negate() const;
  void _internal_set_negate(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.And)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::clarifai::api::Input* input_;
    ::clarifai::api::Output* output_;
    ::clarifai::api::Annotation* annotation_;
    bool negate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Query final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Query) */ {
 public:
  inline Query() : Query(nullptr) {}
  ~Query() override;
  explicit PROTOBUF_CONSTEXPR Query(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Query(const Query& from);
  Query(Query&& from) noexcept
    : Query() {
    *this = ::std::move(from);
  }

  inline Query& operator=(const Query& from) {
    CopyFrom(from);
    return *this;
  }
  inline Query& operator=(Query&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Query& default_instance() {
    return *internal_default_instance();
  }
  static inline const Query* internal_default_instance() {
    return reinterpret_cast<const Query*>(
               &_Query_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    99;

  friend void swap(Query& a, Query& b) {
    a.Swap(&b);
  }
  inline void Swap(Query* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Query* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Query* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Query>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Query& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Query& from) {
    Query::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Query* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Query";
  }
  protected:
  explicit Query(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAndsFieldNumber = 1,
    kFiltersFieldNumber = 3,
    kRanksFieldNumber = 4,
    kLanguageFieldNumber = 2,
  };
  // repeated .clarifai.api.And ands = 1 [deprecated = true];
  PROTOBUF_DEPRECATED int ands_size() const;
  private:
  int _internal_ands_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_ands();
  PROTOBUF_DEPRECATED ::clarifai::api::And* mutable_ands(int index);
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::And >*
      mutable_ands();
  private:
  const ::clarifai::api::And& _internal_ands(int index) const;
  ::clarifai::api::And* _internal_add_ands();
  public:
  PROTOBUF_DEPRECATED const ::clarifai::api::And& ands(int index) const;
  PROTOBUF_DEPRECATED ::clarifai::api::And* add_ands();
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::And >&
      ands() const;

  // repeated .clarifai.api.Filter filters = 3;
  int filters_size() const;
  private:
  int _internal_filters_size() const;
  public:
  void clear_filters();
  ::clarifai::api::Filter* mutable_filters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Filter >*
      mutable_filters();
  private:
  const ::clarifai::api::Filter& _internal_filters(int index) const;
  ::clarifai::api::Filter* _internal_add_filters();
  public:
  const ::clarifai::api::Filter& filters(int index) const;
  ::clarifai::api::Filter* add_filters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Filter >&
      filters() const;

  // repeated .clarifai.api.Rank ranks = 4;
  int ranks_size() const;
  private:
  int _internal_ranks_size() const;
  public:
  void clear_ranks();
  ::clarifai::api::Rank* mutable_ranks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Rank >*
      mutable_ranks();
  private:
  const ::clarifai::api::Rank& _internal_ranks(int index) const;
  ::clarifai::api::Rank* _internal_add_ranks();
  public:
  const ::clarifai::api::Rank& ranks(int index) const;
  ::clarifai::api::Rank* add_ranks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Rank >&
      ranks() const;

  // string language = 2;
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.Query)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::And > ands_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Filter > filters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Rank > ranks_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Search final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Search) */ {
 public:
  inline Search() : Search(nullptr) {}
  ~Search() override;
  explicit PROTOBUF_CONSTEXPR Search(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Search(const Search& from);
  Search(Search&& from) noexcept
    : Search() {
    *this = ::std::move(from);
  }

  inline Search& operator=(const Search& from) {
    CopyFrom(from);
    return *this;
  }
  inline Search& operator=(Search&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Search& default_instance() {
    return *internal_default_instance();
  }
  static inline const Search* internal_default_instance() {
    return reinterpret_cast<const Search*>(
               &_Search_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    100;

  friend void swap(Search& a, Search& b) {
    a.Swap(&b);
  }
  inline void Swap(Search* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Search* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Search* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Search>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Search& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Search& from) {
    Search::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Search* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Search";
  }
  protected:
  explicit Search(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kApplicationIdFieldNumber = 3,
    kNameFieldNumber = 4,
    kGitHashFieldNumber = 6,
    kAlgorithmFieldNumber = 9,
    kQueryFieldNumber = 1,
    kAsOfFieldNumber = 5,
    kCreatedAtFieldNumber = 7,
    kModifiedAtFieldNumber = 8,
    kVisibilityFieldNumber = 12,
    kSaveFieldNumber = 10,
    kMinValueFieldNumber = 11,
  };
  // string id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string application_id = 3;
  void clear_application_id();
  const std::string& application_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_application_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_application_id();
  PROTOBUF_NODISCARD std::string* release_application_id();
  void set_allocated_application_id(std::string* application_id);
  private:
  const std::string& _internal_application_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_application_id(const std::string& value);
  std::string* _internal_mutable_application_id();
  public:

  // string name = 4;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string git_hash = 6;
  void clear_git_hash();
  const std::string& git_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_git_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_git_hash();
  PROTOBUF_NODISCARD std::string* release_git_hash();
  void set_allocated_git_hash(std::string* git_hash);
  private:
  const std::string& _internal_git_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_git_hash(const std::string& value);
  std::string* _internal_mutable_git_hash();
  public:

  // string algorithm = 9;
  void clear_algorithm();
  const std::string& algorithm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_algorithm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_algorithm();
  PROTOBUF_NODISCARD std::string* release_algorithm();
  void set_allocated_algorithm(std::string* algorithm);
  private:
  const std::string& _internal_algorithm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_algorithm(const std::string& value);
  std::string* _internal_mutable_algorithm();
  public:

  // .clarifai.api.Query query = 1;
  bool has_query() const;
  private:
  bool _internal_has_query() const;
  public:
  void clear_query();
  const ::clarifai::api::Query& query() const;
  PROTOBUF_NODISCARD ::clarifai::api::Query* release_query();
  ::clarifai::api::Query* mutable_query();
  void set_allocated_query(::clarifai::api::Query* query);
  private:
  const ::clarifai::api::Query& _internal_query() const;
  ::clarifai::api::Query* _internal_mutable_query();
  public:
  void unsafe_arena_set_allocated_query(
      ::clarifai::api::Query* query);
  ::clarifai::api::Query* unsafe_arena_release_query();

  // .google.protobuf.Timestamp as_of = 5;
  bool has_as_of() const;
  private:
  bool _internal_has_as_of() const;
  public:
  void clear_as_of();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& as_of() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_as_of();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_as_of();
  void set_allocated_as_of(::PROTOBUF_NAMESPACE_ID::Timestamp* as_of);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_as_of() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_as_of();
  public:
  void unsafe_arena_set_allocated_as_of(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* as_of);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_as_of();

  // .google.protobuf.Timestamp created_at = 7;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp modified_at = 8;
  bool has_modified_at() const;
  private:
  bool _internal_has_modified_at() const;
  public:
  void clear_modified_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& modified_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_modified_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_modified_at();
  void set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_modified_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_modified_at();
  public:
  void unsafe_arena_set_allocated_modified_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_modified_at();

  // .clarifai.api.Visibility visibility = 12;
  bool has_visibility() const;
  private:
  bool _internal_has_visibility() const;
  public:
  void clear_visibility();
  const ::clarifai::api::Visibility& visibility() const;
  PROTOBUF_NODISCARD ::clarifai::api::Visibility* release_visibility();
  ::clarifai::api::Visibility* mutable_visibility();
  void set_allocated_visibility(::clarifai::api::Visibility* visibility);
  private:
  const ::clarifai::api::Visibility& _internal_visibility() const;
  ::clarifai::api::Visibility* _internal_mutable_visibility();
  public:
  void unsafe_arena_set_allocated_visibility(
      ::clarifai::api::Visibility* visibility);
  ::clarifai::api::Visibility* unsafe_arena_release_visibility();

  // bool save = 10;
  void clear_save();
  bool save() const;
  void set_save(bool value);
  private:
  bool _internal_save() const;
  void _internal_set_save(bool value);
  public:

  // float min_value = 11;
  void clear_min_value();
  float min_value() const;
  void set_min_value(float value);
  private:
  float _internal_min_value() const;
  void _internal_set_min_value(float value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.Search)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr application_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr git_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr algorithm_;
    ::clarifai::api::Query* query_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* as_of_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at_;
    ::clarifai::api::Visibility* visibility_;
    bool save_;
    float min_value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Filter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Filter) */ {
 public:
  inline Filter() : Filter(nullptr) {}
  ~Filter() override;
  explicit PROTOBUF_CONSTEXPR Filter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Filter(const Filter& from);
  Filter(Filter&& from) noexcept
    : Filter() {
    *this = ::std::move(from);
  }

  inline Filter& operator=(const Filter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Filter& operator=(Filter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Filter& default_instance() {
    return *internal_default_instance();
  }
  static inline const Filter* internal_default_instance() {
    return reinterpret_cast<const Filter*>(
               &_Filter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    101;

  friend void swap(Filter& a, Filter& b) {
    a.Swap(&b);
  }
  inline void Swap(Filter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Filter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Filter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Filter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Filter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Filter& from) {
    Filter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Filter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Filter";
  }
  protected:
  explicit Filter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnnotationFieldNumber = 4,
    kInputFieldNumber = 5,
    kLastUpdatedTimeRangeFieldNumber = 6,
    kNegateFieldNumber = 3,
  };
  // .clarifai.api.Annotation annotation = 4;
  bool has_annotation() const;
  private:
  bool _internal_has_annotation() const;
  public:
  void clear_annotation();
  const ::clarifai::api::Annotation& annotation() const;
  PROTOBUF_NODISCARD ::clarifai::api::Annotation* release_annotation();
  ::clarifai::api::Annotation* mutable_annotation();
  void set_allocated_annotation(::clarifai::api::Annotation* annotation);
  private:
  const ::clarifai::api::Annotation& _internal_annotation() const;
  ::clarifai::api::Annotation* _internal_mutable_annotation();
  public:
  void unsafe_arena_set_allocated_annotation(
      ::clarifai::api::Annotation* annotation);
  ::clarifai::api::Annotation* unsafe_arena_release_annotation();

  // .clarifai.api.Input input = 5;
  bool has_input() const;
  private:
  bool _internal_has_input() const;
  public:
  void clear_input();
  const ::clarifai::api::Input& input() const;
  PROTOBUF_NODISCARD ::clarifai::api::Input* release_input();
  ::clarifai::api::Input* mutable_input();
  void set_allocated_input(::clarifai::api::Input* input);
  private:
  const ::clarifai::api::Input& _internal_input() const;
  ::clarifai::api::Input* _internal_mutable_input();
  public:
  void unsafe_arena_set_allocated_input(
      ::clarifai::api::Input* input);
  ::clarifai::api::Input* unsafe_arena_release_input();

  // .clarifai.api.TimeRange last_updated_time_range = 6;
  bool has_last_updated_time_range() const;
  private:
  bool _internal_has_last_updated_time_range() const;
  public:
  void clear_last_updated_time_range();
  const ::clarifai::api::TimeRange& last_updated_time_range() const;
  PROTOBUF_NODISCARD ::clarifai::api::TimeRange* release_last_updated_time_range();
  ::clarifai::api::TimeRange* mutable_last_updated_time_range();
  void set_allocated_last_updated_time_range(::clarifai::api::TimeRange* last_updated_time_range);
  private:
  const ::clarifai::api::TimeRange& _internal_last_updated_time_range() const;
  ::clarifai::api::TimeRange* _internal_mutable_last_updated_time_range();
  public:
  void unsafe_arena_set_allocated_last_updated_time_range(
      ::clarifai::api::TimeRange* last_updated_time_range);
  ::clarifai::api::TimeRange* unsafe_arena_release_last_updated_time_range();

  // bool negate = 3;
  void clear_negate();
  bool negate() const;
  void set_negate(bool value);
  private:
  bool _internal_negate() const;
  void _internal_set_negate(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.Filter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::clarifai::api::Annotation* annotation_;
    ::clarifai::api::Input* input_;
    ::clarifai::api::TimeRange* last_updated_time_range_;
    bool negate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class TimeRange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.TimeRange) */ {
 public:
  inline TimeRange() : TimeRange(nullptr) {}
  ~TimeRange() override;
  explicit PROTOBUF_CONSTEXPR TimeRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimeRange(const TimeRange& from);
  TimeRange(TimeRange&& from) noexcept
    : TimeRange() {
    *this = ::std::move(from);
  }

  inline TimeRange& operator=(const TimeRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeRange& operator=(TimeRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimeRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeRange* internal_default_instance() {
    return reinterpret_cast<const TimeRange*>(
               &_TimeRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    102;

  friend void swap(TimeRange& a, TimeRange& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimeRange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TimeRange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TimeRange& from) {
    TimeRange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeRange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.TimeRange";
  }
  protected:
  explicit TimeRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartTimeFieldNumber = 1,
    kEndTimeFieldNumber = 2,
  };
  // .google.protobuf.Timestamp start_time = 1;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // .google.protobuf.Timestamp end_time = 2;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_time();
  void set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_time();
  public:
  void unsafe_arena_set_allocated_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_time();

  // @@protoc_insertion_point(class_scope:clarifai.api.TimeRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Rank final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Rank) */ {
 public:
  inline Rank() : Rank(nullptr) {}
  ~Rank() override;
  explicit PROTOBUF_CONSTEXPR Rank(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rank(const Rank& from);
  Rank(Rank&& from) noexcept
    : Rank() {
    *this = ::std::move(from);
  }

  inline Rank& operator=(const Rank& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rank& operator=(Rank&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rank& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rank* internal_default_instance() {
    return reinterpret_cast<const Rank*>(
               &_Rank_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    103;

  friend void swap(Rank& a, Rank& b) {
    a.Swap(&b);
  }
  inline void Swap(Rank* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rank* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rank* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rank>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rank& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Rank& from) {
    Rank::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rank* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Rank";
  }
  protected:
  explicit Rank(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnnotationFieldNumber = 4,
    kNegateFieldNumber = 3,
  };
  // .clarifai.api.Annotation annotation = 4;
  bool has_annotation() const;
  private:
  bool _internal_has_annotation() const;
  public:
  void clear_annotation();
  const ::clarifai::api::Annotation& annotation() const;
  PROTOBUF_NODISCARD ::clarifai::api::Annotation* release_annotation();
  ::clarifai::api::Annotation* mutable_annotation();
  void set_allocated_annotation(::clarifai::api::Annotation* annotation);
  private:
  const ::clarifai::api::Annotation& _internal_annotation() const;
  ::clarifai::api::Annotation* _internal_mutable_annotation();
  public:
  void unsafe_arena_set_allocated_annotation(
      ::clarifai::api::Annotation* annotation);
  ::clarifai::api::Annotation* unsafe_arena_release_annotation();

  // bool negate = 3;
  void clear_negate();
  bool negate() const;
  void set_negate(bool value);
  private:
  bool _internal_negate() const;
  void _internal_set_negate(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.Rank)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::clarifai::api::Annotation* annotation_;
    bool negate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class AnnotationSearchMetrics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.AnnotationSearchMetrics) */ {
 public:
  inline AnnotationSearchMetrics() : AnnotationSearchMetrics(nullptr) {}
  ~AnnotationSearchMetrics() override;
  explicit PROTOBUF_CONSTEXPR AnnotationSearchMetrics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnnotationSearchMetrics(const AnnotationSearchMetrics& from);
  AnnotationSearchMetrics(AnnotationSearchMetrics&& from) noexcept
    : AnnotationSearchMetrics() {
    *this = ::std::move(from);
  }

  inline AnnotationSearchMetrics& operator=(const AnnotationSearchMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnnotationSearchMetrics& operator=(AnnotationSearchMetrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnnotationSearchMetrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnnotationSearchMetrics* internal_default_instance() {
    return reinterpret_cast<const AnnotationSearchMetrics*>(
               &_AnnotationSearchMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    104;

  friend void swap(AnnotationSearchMetrics& a, AnnotationSearchMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(AnnotationSearchMetrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnnotationSearchMetrics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnnotationSearchMetrics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnnotationSearchMetrics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnnotationSearchMetrics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnnotationSearchMetrics& from) {
    AnnotationSearchMetrics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnnotationSearchMetrics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.AnnotationSearchMetrics";
  }
  protected:
  explicit AnnotationSearchMetrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroundTruthFieldNumber = 1,
    kSearchToEvalFieldNumber = 2,
    kMetricsFieldNumber = 3,
    kDataFieldNumber = 4,
    kVisibilityFieldNumber = 6,
    kActiveConceptCountFieldNumber = 5,
  };
  // .clarifai.api.Search ground_truth = 1;
  bool has_ground_truth() const;
  private:
  bool _internal_has_ground_truth() const;
  public:
  void clear_ground_truth();
  const ::clarifai::api::Search& ground_truth() const;
  PROTOBUF_NODISCARD ::clarifai::api::Search* release_ground_truth();
  ::clarifai::api::Search* mutable_ground_truth();
  void set_allocated_ground_truth(::clarifai::api::Search* ground_truth);
  private:
  const ::clarifai::api::Search& _internal_ground_truth() const;
  ::clarifai::api::Search* _internal_mutable_ground_truth();
  public:
  void unsafe_arena_set_allocated_ground_truth(
      ::clarifai::api::Search* ground_truth);
  ::clarifai::api::Search* unsafe_arena_release_ground_truth();

  // .clarifai.api.Search search_to_eval = 2;
  bool has_search_to_eval() const;
  private:
  bool _internal_has_search_to_eval() const;
  public:
  void clear_search_to_eval();
  const ::clarifai::api::Search& search_to_eval() const;
  PROTOBUF_NODISCARD ::clarifai::api::Search* release_search_to_eval();
  ::clarifai::api::Search* mutable_search_to_eval();
  void set_allocated_search_to_eval(::clarifai::api::Search* search_to_eval);
  private:
  const ::clarifai::api::Search& _internal_search_to_eval() const;
  ::clarifai::api::Search* _internal_mutable_search_to_eval();
  public:
  void unsafe_arena_set_allocated_search_to_eval(
      ::clarifai::api::Search* search_to_eval);
  ::clarifai::api::Search* unsafe_arena_release_search_to_eval();

  // .clarifai.api.EvalMetrics metrics = 3;
  bool has_metrics() const;
  private:
  bool _internal_has_metrics() const;
  public:
  void clear_metrics();
  const ::clarifai::api::EvalMetrics& metrics() const;
  PROTOBUF_NODISCARD ::clarifai::api::EvalMetrics* release_metrics();
  ::clarifai::api::EvalMetrics* mutable_metrics();
  void set_allocated_metrics(::clarifai::api::EvalMetrics* metrics);
  private:
  const ::clarifai::api::EvalMetrics& _internal_metrics() const;
  ::clarifai::api::EvalMetrics* _internal_mutable_metrics();
  public:
  void unsafe_arena_set_allocated_metrics(
      ::clarifai::api::EvalMetrics* metrics);
  ::clarifai::api::EvalMetrics* unsafe_arena_release_metrics();

  // .clarifai.api.Data data = 4;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::clarifai::api::Data& data() const;
  PROTOBUF_NODISCARD ::clarifai::api::Data* release_data();
  ::clarifai::api::Data* mutable_data();
  void set_allocated_data(::clarifai::api::Data* data);
  private:
  const ::clarifai::api::Data& _internal_data() const;
  ::clarifai::api::Data* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::clarifai::api::Data* data);
  ::clarifai::api::Data* unsafe_arena_release_data();

  // .clarifai.api.Visibility visibility = 6;
  bool has_visibility() const;
  private:
  bool _internal_has_visibility() const;
  public:
  void clear_visibility();
  const ::clarifai::api::Visibility& visibility() const;
  PROTOBUF_NODISCARD ::clarifai::api::Visibility* release_visibility();
  ::clarifai::api::Visibility* mutable_visibility();
  void set_allocated_visibility(::clarifai::api::Visibility* visibility);
  private:
  const ::clarifai::api::Visibility& _internal_visibility() const;
  ::clarifai::api::Visibility* _internal_mutable_visibility();
  public:
  void unsafe_arena_set_allocated_visibility(
      ::clarifai::api::Visibility* visibility);
  ::clarifai::api::Visibility* unsafe_arena_release_visibility();

  // uint32 active_concept_count = 5;
  void clear_active_concept_count();
  uint32_t active_concept_count() const;
  void set_active_concept_count(uint32_t value);
  private:
  uint32_t _internal_active_concept_count() const;
  void _internal_set_active_concept_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.AnnotationSearchMetrics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::clarifai::api::Search* ground_truth_;
    ::clarifai::api::Search* search_to_eval_;
    ::clarifai::api::EvalMetrics* metrics_;
    ::clarifai::api::Data* data_;
    ::clarifai::api::Visibility* visibility_;
    uint32_t active_concept_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Text final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Text) */ {
 public:
  inline Text() : Text(nullptr) {}
  ~Text() override;
  explicit PROTOBUF_CONSTEXPR Text(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Text(const Text& from);
  Text(Text&& from) noexcept
    : Text() {
    *this = ::std::move(from);
  }

  inline Text& operator=(const Text& from) {
    CopyFrom(from);
    return *this;
  }
  inline Text& operator=(Text&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Text& default_instance() {
    return *internal_default_instance();
  }
  static inline const Text* internal_default_instance() {
    return reinterpret_cast<const Text*>(
               &_Text_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    105;

  friend void swap(Text& a, Text& b) {
    a.Swap(&b);
  }
  inline void Swap(Text* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Text* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Text* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Text>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Text& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Text& from) {
    Text::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Text* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Text";
  }
  protected:
  explicit Text(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRawFieldNumber = 1,
    kUrlFieldNumber = 2,
    kHostedFieldNumber = 4,
    kTextInfoFieldNumber = 5,
    kAllowDuplicateUrlFieldNumber = 3,
  };
  // string raw = 1;
  void clear_raw();
  const std::string& raw() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_raw(ArgT0&& arg0, ArgT... args);
  std::string* mutable_raw();
  PROTOBUF_NODISCARD std::string* release_raw();
  void set_allocated_raw(std::string* raw);
  private:
  const std::string& _internal_raw() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw(const std::string& value);
  std::string* _internal_mutable_raw();
  public:

  // string url = 2;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // .clarifai.api.HostedURL hosted = 4;
  bool has_hosted() const;
  private:
  bool _internal_has_hosted() const;
  public:
  void clear_hosted();
  const ::clarifai::api::HostedURL& hosted() const;
  PROTOBUF_NODISCARD ::clarifai::api::HostedURL* release_hosted();
  ::clarifai::api::HostedURL* mutable_hosted();
  void set_allocated_hosted(::clarifai::api::HostedURL* hosted);
  private:
  const ::clarifai::api::HostedURL& _internal_hosted() const;
  ::clarifai::api::HostedURL* _internal_mutable_hosted();
  public:
  void unsafe_arena_set_allocated_hosted(
      ::clarifai::api::HostedURL* hosted);
  ::clarifai::api::HostedURL* unsafe_arena_release_hosted();

  // .clarifai.api.TextInfo text_info = 5;
  bool has_text_info() const;
  private:
  bool _internal_has_text_info() const;
  public:
  void clear_text_info();
  const ::clarifai::api::TextInfo& text_info() const;
  PROTOBUF_NODISCARD ::clarifai::api::TextInfo* release_text_info();
  ::clarifai::api::TextInfo* mutable_text_info();
  void set_allocated_text_info(::clarifai::api::TextInfo* text_info);
  private:
  const ::clarifai::api::TextInfo& _internal_text_info() const;
  ::clarifai::api::TextInfo* _internal_mutable_text_info();
  public:
  void unsafe_arena_set_allocated_text_info(
      ::clarifai::api::TextInfo* text_info);
  ::clarifai::api::TextInfo* unsafe_arena_release_text_info();

  // bool allow_duplicate_url = 3;
  void clear_allow_duplicate_url();
  bool allow_duplicate_url() const;
  void set_allow_duplicate_url(bool value);
  private:
  bool _internal_allow_duplicate_url() const;
  void _internal_set_allow_duplicate_url(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.Text)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::clarifai::api::HostedURL* hosted_;
    ::clarifai::api::TextInfo* text_info_;
    bool allow_duplicate_url_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class TextInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.TextInfo) */ {
 public:
  inline TextInfo() : TextInfo(nullptr) {}
  ~TextInfo() override;
  explicit PROTOBUF_CONSTEXPR TextInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextInfo(const TextInfo& from);
  TextInfo(TextInfo&& from) noexcept
    : TextInfo() {
    *this = ::std::move(from);
  }

  inline TextInfo& operator=(const TextInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextInfo& operator=(TextInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextInfo* internal_default_instance() {
    return reinterpret_cast<const TextInfo*>(
               &_TextInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    106;

  friend void swap(TextInfo& a, TextInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TextInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TextInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TextInfo& from) {
    TextInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.TextInfo";
  }
  protected:
  explicit TextInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncodingFieldNumber = 2,
    kCharCountFieldNumber = 1,
  };
  // string encoding = 2;
  void clear_encoding();
  const std::string& encoding() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encoding(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encoding();
  PROTOBUF_NODISCARD std::string* release_encoding();
  void set_allocated_encoding(std::string* encoding);
  private:
  const std::string& _internal_encoding() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encoding(const std::string& value);
  std::string* _internal_mutable_encoding();
  public:

  // int32 char_count = 1;
  void clear_char_count();
  int32_t char_count() const;
  void set_char_count(int32_t value);
  private:
  int32_t _internal_char_count() const;
  void _internal_set_char_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.TextInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encoding_;
    int32_t char_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() override;
  explicit PROTOBUF_CONSTEXPR User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    107;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const User& from) {
    User::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.User";
  }
  protected:
  explicit User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailAddressesFieldNumber = 12,
    kIdFieldNumber = 1,
    kPrimaryEmailFieldNumber = 2,
    kFirstNameFieldNumber = 3,
    kLastNameFieldNumber = 4,
    kCompanyNameFieldNumber = 5,
    kBillTypeFieldNumber = 7,
    kJobTitleFieldNumber = 19,
    kJobRoleFieldNumber = 20,
    kCreatedAtFieldNumber = 6,
    kDateGdprConsentFieldNumber = 8,
    kDateTosConsentFieldNumber = 9,
    kDateMarketingConsentFieldNumber = 10,
    kMetadataFieldNumber = 11,
    kVisibilityFieldNumber = 17,
    kUserDetailFieldNumber = 18,
    kDatePiiConsentFieldNumber = 23,
    kTeamsCountFieldNumber = 16,
    kTwoFactorAuthEnabledFieldNumber = 15,
    kIsStarredFieldNumber = 21,
    kStarCountFieldNumber = 22,
  };
  // repeated .clarifai.api.EmailAddress email_addresses = 12 [deprecated = true];
  PROTOBUF_DEPRECATED int email_addresses_size() const;
  private:
  int _internal_email_addresses_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_email_addresses();
  PROTOBUF_DEPRECATED ::clarifai::api::EmailAddress* mutable_email_addresses(int index);
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::EmailAddress >*
      mutable_email_addresses();
  private:
  const ::clarifai::api::EmailAddress& _internal_email_addresses(int index) const;
  ::clarifai::api::EmailAddress* _internal_add_email_addresses();
  public:
  PROTOBUF_DEPRECATED const ::clarifai::api::EmailAddress& email_addresses(int index) const;
  PROTOBUF_DEPRECATED ::clarifai::api::EmailAddress* add_email_addresses();
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::EmailAddress >&
      email_addresses() const;

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string primary_email = 2 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_primary_email();
  PROTOBUF_DEPRECATED const std::string& primary_email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_primary_email(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_primary_email();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_primary_email();
  PROTOBUF_DEPRECATED void set_allocated_primary_email(std::string* primary_email);
  private:
  const std::string& _internal_primary_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_primary_email(const std::string& value);
  std::string* _internal_mutable_primary_email();
  public:

  // string first_name = 3;
  void clear_first_name();
  const std::string& first_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_first_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_first_name();
  PROTOBUF_NODISCARD std::string* release_first_name();
  void set_allocated_first_name(std::string* first_name);
  private:
  const std::string& _internal_first_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_first_name(const std::string& value);
  std::string* _internal_mutable_first_name();
  public:

  // string last_name = 4;
  void clear_last_name();
  const std::string& last_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_last_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_last_name();
  PROTOBUF_NODISCARD std::string* release_last_name();
  void set_allocated_last_name(std::string* last_name);
  private:
  const std::string& _internal_last_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_name(const std::string& value);
  std::string* _internal_mutable_last_name();
  public:

  // string company_name = 5;
  void clear_company_name();
  const std::string& company_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_company_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_company_name();
  PROTOBUF_NODISCARD std::string* release_company_name();
  void set_allocated_company_name(std::string* company_name);
  private:
  const std::string& _internal_company_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_company_name(const std::string& value);
  std::string* _internal_mutable_company_name();
  public:

  // string bill_type = 7 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_bill_type();
  PROTOBUF_DEPRECATED const std::string& bill_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_bill_type(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_bill_type();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_bill_type();
  PROTOBUF_DEPRECATED void set_allocated_bill_type(std::string* bill_type);
  private:
  const std::string& _internal_bill_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bill_type(const std::string& value);
  std::string* _internal_mutable_bill_type();
  public:

  // string job_title = 19;
  void clear_job_title();
  const std::string& job_title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_title();
  PROTOBUF_NODISCARD std::string* release_job_title();
  void set_allocated_job_title(std::string* job_title);
  private:
  const std::string& _internal_job_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_title(const std::string& value);
  std::string* _internal_mutable_job_title();
  public:

  // string job_role = 20;
  void clear_job_role();
  const std::string& job_role() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_role(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_role();
  PROTOBUF_NODISCARD std::string* release_job_role();
  void set_allocated_job_role(std::string* job_role);
  private:
  const std::string& _internal_job_role() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_role(const std::string& value);
  std::string* _internal_mutable_job_role();
  public:

  // .google.protobuf.Timestamp created_at = 6;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp date_gdpr_consent = 8 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_date_gdpr_consent() const;
  private:
  bool _internal_has_date_gdpr_consent() const;
  public:
  PROTOBUF_DEPRECATED void clear_date_gdpr_consent();
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::Timestamp& date_gdpr_consent() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::Timestamp* release_date_gdpr_consent();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_date_gdpr_consent();
  PROTOBUF_DEPRECATED void set_allocated_date_gdpr_consent(::PROTOBUF_NAMESPACE_ID::Timestamp* date_gdpr_consent);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_date_gdpr_consent() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_date_gdpr_consent();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_date_gdpr_consent(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* date_gdpr_consent);
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_date_gdpr_consent();

  // .google.protobuf.Timestamp date_tos_consent = 9 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_date_tos_consent() const;
  private:
  bool _internal_has_date_tos_consent() const;
  public:
  PROTOBUF_DEPRECATED void clear_date_tos_consent();
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::Timestamp& date_tos_consent() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::Timestamp* release_date_tos_consent();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_date_tos_consent();
  PROTOBUF_DEPRECATED void set_allocated_date_tos_consent(::PROTOBUF_NAMESPACE_ID::Timestamp* date_tos_consent);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_date_tos_consent() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_date_tos_consent();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_date_tos_consent(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* date_tos_consent);
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_date_tos_consent();

  // .google.protobuf.Timestamp date_marketing_consent = 10 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_date_marketing_consent() const;
  private:
  bool _internal_has_date_marketing_consent() const;
  public:
  PROTOBUF_DEPRECATED void clear_date_marketing_consent();
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::Timestamp& date_marketing_consent() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::Timestamp* release_date_marketing_consent();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_date_marketing_consent();
  PROTOBUF_DEPRECATED void set_allocated_date_marketing_consent(::PROTOBUF_NAMESPACE_ID::Timestamp* date_marketing_consent);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_date_marketing_consent() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_date_marketing_consent();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_date_marketing_consent(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* date_marketing_consent);
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_date_marketing_consent();

  // .google.protobuf.Struct metadata = 11 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  PROTOBUF_DEPRECATED void clear_metadata();
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  PROTOBUF_DEPRECATED void set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata();

  // .clarifai.api.Visibility visibility = 17;
  bool has_visibility() const;
  private:
  bool _internal_has_visibility() const;
  public:
  void clear_visibility();
  const ::clarifai::api::Visibility& visibility() const;
  PROTOBUF_NODISCARD ::clarifai::api::Visibility* release_visibility();
  ::clarifai::api::Visibility* mutable_visibility();
  void set_allocated_visibility(::clarifai::api::Visibility* visibility);
  private:
  const ::clarifai::api::Visibility& _internal_visibility() const;
  ::clarifai::api::Visibility* _internal_mutable_visibility();
  public:
  void unsafe_arena_set_allocated_visibility(
      ::clarifai::api::Visibility* visibility);
  ::clarifai::api::Visibility* unsafe_arena_release_visibility();

  // .clarifai.api.UserDetail user_detail = 18;
  bool has_user_detail() const;
  private:
  bool _internal_has_user_detail() const;
  public:
  void clear_user_detail();
  const ::clarifai::api::UserDetail& user_detail() const;
  PROTOBUF_NODISCARD ::clarifai::api::UserDetail* release_user_detail();
  ::clarifai::api::UserDetail* mutable_user_detail();
  void set_allocated_user_detail(::clarifai::api::UserDetail* user_detail);
  private:
  const ::clarifai::api::UserDetail& _internal_user_detail() const;
  ::clarifai::api::UserDetail* _internal_mutable_user_detail();
  public:
  void unsafe_arena_set_allocated_user_detail(
      ::clarifai::api::UserDetail* user_detail);
  ::clarifai::api::UserDetail* unsafe_arena_release_user_detail();

  // .google.protobuf.Timestamp date_pii_consent = 23 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_date_pii_consent() const;
  private:
  bool _internal_has_date_pii_consent() const;
  public:
  PROTOBUF_DEPRECATED void clear_date_pii_consent();
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::Timestamp& date_pii_consent() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::Timestamp* release_date_pii_consent();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_date_pii_consent();
  PROTOBUF_DEPRECATED void set_allocated_date_pii_consent(::PROTOBUF_NAMESPACE_ID::Timestamp* date_pii_consent);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_date_pii_consent() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_date_pii_consent();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_date_pii_consent(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* date_pii_consent);
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_date_pii_consent();

  // uint32 teams_count = 16 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_teams_count();
  PROTOBUF_DEPRECATED uint32_t teams_count() const;
  PROTOBUF_DEPRECATED void set_teams_count(uint32_t value);
  private:
  uint32_t _internal_teams_count() const;
  void _internal_set_teams_count(uint32_t value);
  public:

  // bool two_factor_auth_enabled = 15 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_two_factor_auth_enabled();
  PROTOBUF_DEPRECATED bool two_factor_auth_enabled() const;
  PROTOBUF_DEPRECATED void set_two_factor_auth_enabled(bool value);
  private:
  bool _internal_two_factor_auth_enabled() const;
  void _internal_set_two_factor_auth_enabled(bool value);
  public:

  // bool is_starred = 21;
  void clear_is_starred();
  bool is_starred() const;
  void set_is_starred(bool value);
  private:
  bool _internal_is_starred() const;
  void _internal_set_is_starred(bool value);
  public:

  // int32 star_count = 22;
  void clear_star_count();
  int32_t star_count() const;
  void set_star_count(int32_t value);
  private:
  int32_t _internal_star_count() const;
  void _internal_set_star_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::EmailAddress > email_addresses_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr primary_email_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr first_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr company_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bill_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_role_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* date_gdpr_consent_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* date_tos_consent_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* date_marketing_consent_;
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_;
    ::clarifai::api::Visibility* visibility_;
    ::clarifai::api::UserDetail* user_detail_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* date_pii_consent_;
    uint32_t teams_count_;
    bool two_factor_auth_enabled_;
    bool is_starred_;
    int32_t star_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class UserDetail final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.UserDetail) */ {
 public:
  inline UserDetail() : UserDetail(nullptr) {}
  ~UserDetail() override;
  explicit PROTOBUF_CONSTEXPR UserDetail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserDetail(const UserDetail& from);
  UserDetail(UserDetail&& from) noexcept
    : UserDetail() {
    *this = ::std::move(from);
  }

  inline UserDetail& operator=(const UserDetail& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserDetail& operator=(UserDetail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserDetail& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserDetail* internal_default_instance() {
    return reinterpret_cast<const UserDetail*>(
               &_UserDetail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    108;

  friend void swap(UserDetail& a, UserDetail& b) {
    a.Swap(&b);
  }
  inline void Swap(UserDetail* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserDetail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserDetail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserDetail>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserDetail& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserDetail& from) {
    UserDetail::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserDetail* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.UserDetail";
  }
  protected:
  explicit UserDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailAddressesFieldNumber = 7,
    kPrimaryEmailFieldNumber = 1,
    kBillTypeFieldNumber = 2,
    kCountryFieldNumber = 11,
    kStateFieldNumber = 12,
    kDateGdprConsentFieldNumber = 3,
    kDateTosConsentFieldNumber = 4,
    kDateMarketingConsentFieldNumber = 5,
    kMetadataFieldNumber = 6,
    kDatePiiConsentFieldNumber = 13,
    kTwoFactorAuthEnabledFieldNumber = 9,
    kTeamsCountFieldNumber = 10,
  };
  // repeated .clarifai.api.EmailAddress email_addresses = 7;
  int email_addresses_size() const;
  private:
  int _internal_email_addresses_size() const;
  public:
  void clear_email_addresses();
  ::clarifai::api::EmailAddress* mutable_email_addresses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::EmailAddress >*
      mutable_email_addresses();
  private:
  const ::clarifai::api::EmailAddress& _internal_email_addresses(int index) const;
  ::clarifai::api::EmailAddress* _internal_add_email_addresses();
  public:
  const ::clarifai::api::EmailAddress& email_addresses(int index) const;
  ::clarifai::api::EmailAddress* add_email_addresses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::EmailAddress >&
      email_addresses() const;

  // string primary_email = 1;
  void clear_primary_email();
  const std::string& primary_email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_primary_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_primary_email();
  PROTOBUF_NODISCARD std::string* release_primary_email();
  void set_allocated_primary_email(std::string* primary_email);
  private:
  const std::string& _internal_primary_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_primary_email(const std::string& value);
  std::string* _internal_mutable_primary_email();
  public:

  // string bill_type = 2;
  void clear_bill_type();
  const std::string& bill_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bill_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bill_type();
  PROTOBUF_NODISCARD std::string* release_bill_type();
  void set_allocated_bill_type(std::string* bill_type);
  private:
  const std::string& _internal_bill_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bill_type(const std::string& value);
  std::string* _internal_mutable_bill_type();
  public:

  // string country = 11;
  void clear_country();
  const std::string& country() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_country(ArgT0&& arg0, ArgT... args);
  std::string* mutable_country();
  PROTOBUF_NODISCARD std::string* release_country();
  void set_allocated_country(std::string* country);
  private:
  const std::string& _internal_country() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country(const std::string& value);
  std::string* _internal_mutable_country();
  public:

  // string state = 12;
  void clear_state();
  const std::string& state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* state);
  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(const std::string& value);
  std::string* _internal_mutable_state();
  public:

  // .google.protobuf.Timestamp date_gdpr_consent = 3;
  bool has_date_gdpr_consent() const;
  private:
  bool _internal_has_date_gdpr_consent() const;
  public:
  void clear_date_gdpr_consent();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& date_gdpr_consent() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_date_gdpr_consent();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_date_gdpr_consent();
  void set_allocated_date_gdpr_consent(::PROTOBUF_NAMESPACE_ID::Timestamp* date_gdpr_consent);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_date_gdpr_consent() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_date_gdpr_consent();
  public:
  void unsafe_arena_set_allocated_date_gdpr_consent(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* date_gdpr_consent);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_date_gdpr_consent();

  // .google.protobuf.Timestamp date_tos_consent = 4;
  bool has_date_tos_consent() const;
  private:
  bool _internal_has_date_tos_consent() const;
  public:
  void clear_date_tos_consent();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& date_tos_consent() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_date_tos_consent();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_date_tos_consent();
  void set_allocated_date_tos_consent(::PROTOBUF_NAMESPACE_ID::Timestamp* date_tos_consent);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_date_tos_consent() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_date_tos_consent();
  public:
  void unsafe_arena_set_allocated_date_tos_consent(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* date_tos_consent);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_date_tos_consent();

  // .google.protobuf.Timestamp date_marketing_consent = 5;
  bool has_date_marketing_consent() const;
  private:
  bool _internal_has_date_marketing_consent() const;
  public:
  void clear_date_marketing_consent();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& date_marketing_consent() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_date_marketing_consent();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_date_marketing_consent();
  void set_allocated_date_marketing_consent(::PROTOBUF_NAMESPACE_ID::Timestamp* date_marketing_consent);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_date_marketing_consent() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_date_marketing_consent();
  public:
  void unsafe_arena_set_allocated_date_marketing_consent(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* date_marketing_consent);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_date_marketing_consent();

  // .google.protobuf.Struct metadata = 6;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  void set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata();

  // .google.protobuf.Timestamp date_pii_consent = 13;
  bool has_date_pii_consent() const;
  private:
  bool _internal_has_date_pii_consent() const;
  public:
  void clear_date_pii_consent();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& date_pii_consent() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_date_pii_consent();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_date_pii_consent();
  void set_allocated_date_pii_consent(::PROTOBUF_NAMESPACE_ID::Timestamp* date_pii_consent);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_date_pii_consent() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_date_pii_consent();
  public:
  void unsafe_arena_set_allocated_date_pii_consent(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* date_pii_consent);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_date_pii_consent();

  // bool two_factor_auth_enabled = 9;
  void clear_two_factor_auth_enabled();
  bool two_factor_auth_enabled() const;
  void set_two_factor_auth_enabled(bool value);
  private:
  bool _internal_two_factor_auth_enabled() const;
  void _internal_set_two_factor_auth_enabled(bool value);
  public:

  // uint32 teams_count = 10;
  void clear_teams_count();
  uint32_t teams_count() const;
  void set_teams_count(uint32_t value);
  private:
  uint32_t _internal_teams_count() const;
  void _internal_set_teams_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.UserDetail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::EmailAddress > email_addresses_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr primary_email_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bill_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* date_gdpr_consent_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* date_tos_consent_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* date_marketing_consent_;
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* date_pii_consent_;
    bool two_factor_auth_enabled_;
    uint32_t teams_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class EmailAddress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.EmailAddress) */ {
 public:
  inline EmailAddress() : EmailAddress(nullptr) {}
  ~EmailAddress() override;
  explicit PROTOBUF_CONSTEXPR EmailAddress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmailAddress(const EmailAddress& from);
  EmailAddress(EmailAddress&& from) noexcept
    : EmailAddress() {
    *this = ::std::move(from);
  }

  inline EmailAddress& operator=(const EmailAddress& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmailAddress& operator=(EmailAddress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmailAddress& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmailAddress* internal_default_instance() {
    return reinterpret_cast<const EmailAddress*>(
               &_EmailAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    109;

  friend void swap(EmailAddress& a, EmailAddress& b) {
    a.Swap(&b);
  }
  inline void Swap(EmailAddress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmailAddress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmailAddress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmailAddress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EmailAddress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EmailAddress& from) {
    EmailAddress::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmailAddress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.EmailAddress";
  }
  protected:
  explicit EmailAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailFieldNumber = 1,
    kPrimaryFieldNumber = 2,
    kVerifiedFieldNumber = 3,
  };
  // string email = 1 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // bool primary = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_primary();
  bool primary() const;
  void set_primary(bool value);
  private:
  bool _internal_primary() const;
  void _internal_set_primary(bool value);
  public:

  // bool verified = 3 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_verified();
  bool verified() const;
  void set_verified(bool value);
  private:
  bool _internal_verified() const;
  void _internal_set_verified(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.EmailAddress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    bool primary_;
    bool verified_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Password final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Password) */ {
 public:
  inline Password() : Password(nullptr) {}
  ~Password() override;
  explicit PROTOBUF_CONSTEXPR Password(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Password(const Password& from);
  Password(Password&& from) noexcept
    : Password() {
    *this = ::std::move(from);
  }

  inline Password& operator=(const Password& from) {
    CopyFrom(from);
    return *this;
  }
  inline Password& operator=(Password&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Password& default_instance() {
    return *internal_default_instance();
  }
  static inline const Password* internal_default_instance() {
    return reinterpret_cast<const Password*>(
               &_Password_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    110;

  friend void swap(Password& a, Password& b) {
    a.Swap(&b);
  }
  inline void Swap(Password* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Password* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Password* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Password>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Password& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Password& from) {
    Password::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Password* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Password";
  }
  protected:
  explicit Password(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlaintextFieldNumber = 1,
  };
  // string plaintext = 1;
  void clear_plaintext();
  const std::string& plaintext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_plaintext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_plaintext();
  PROTOBUF_NODISCARD std::string* release_plaintext();
  void set_allocated_plaintext(std::string* plaintext);
  private:
  const std::string& _internal_plaintext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plaintext(const std::string& value);
  std::string* _internal_mutable_plaintext();
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.Password)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plaintext_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class PasswordViolations final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.PasswordViolations) */ {
 public:
  inline PasswordViolations() : PasswordViolations(nullptr) {}
  ~PasswordViolations() override;
  explicit PROTOBUF_CONSTEXPR PasswordViolations(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PasswordViolations(const PasswordViolations& from);
  PasswordViolations(PasswordViolations&& from) noexcept
    : PasswordViolations() {
    *this = ::std::move(from);
  }

  inline PasswordViolations& operator=(const PasswordViolations& from) {
    CopyFrom(from);
    return *this;
  }
  inline PasswordViolations& operator=(PasswordViolations&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PasswordViolations& default_instance() {
    return *internal_default_instance();
  }
  static inline const PasswordViolations* internal_default_instance() {
    return reinterpret_cast<const PasswordViolations*>(
               &_PasswordViolations_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    111;

  friend void swap(PasswordViolations& a, PasswordViolations& b) {
    a.Swap(&b);
  }
  inline void Swap(PasswordViolations* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PasswordViolations* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PasswordViolations* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PasswordViolations>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PasswordViolations& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PasswordViolations& from) {
    PasswordViolations::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PasswordViolations* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.PasswordViolations";
  }
  protected:
  explicit PasswordViolations(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinimumLengthFieldNumber = 1,
    kMaximumLengthFieldNumber = 2,
    kUpperCaseNeededFieldNumber = 3,
    kLowerCaseNeededFieldNumber = 4,
    kNumericNeededFieldNumber = 5,
    kNonAlphanumericNeededFieldNumber = 6,
    kPasswordReuseFieldNumber = 7,
    kExcludeNamesFieldNumber = 8,
    kExcludeEmailFieldNumber = 9,
    kNoConfusingLettersFieldNumber = 10,
    kNoSimplePasswordsFieldNumber = 11,
    kNoCommonVocabsFieldNumber = 12,
    kNoOverlapWithOldFieldNumber = 13,
    kPasswordLifespanFieldNumber = 14,
  };
  // bool minimum_length = 1;
  void clear_minimum_length();
  bool minimum_length() const;
  void set_minimum_length(bool value);
  private:
  bool _internal_minimum_length() const;
  void _internal_set_minimum_length(bool value);
  public:

  // bool maximum_length = 2;
  void clear_maximum_length();
  bool maximum_length() const;
  void set_maximum_length(bool value);
  private:
  bool _internal_maximum_length() const;
  void _internal_set_maximum_length(bool value);
  public:

  // bool upper_case_needed = 3;
  void clear_upper_case_needed();
  bool upper_case_needed() const;
  void set_upper_case_needed(bool value);
  private:
  bool _internal_upper_case_needed() const;
  void _internal_set_upper_case_needed(bool value);
  public:

  // bool lower_case_needed = 4;
  void clear_lower_case_needed();
  bool lower_case_needed() const;
  void set_lower_case_needed(bool value);
  private:
  bool _internal_lower_case_needed() const;
  void _internal_set_lower_case_needed(bool value);
  public:

  // bool numeric_needed = 5;
  void clear_numeric_needed();
  bool numeric_needed() const;
  void set_numeric_needed(bool value);
  private:
  bool _internal_numeric_needed() const;
  void _internal_set_numeric_needed(bool value);
  public:

  // bool non_alphanumeric_needed = 6;
  void clear_non_alphanumeric_needed();
  bool non_alphanumeric_needed() const;
  void set_non_alphanumeric_needed(bool value);
  private:
  bool _internal_non_alphanumeric_needed() const;
  void _internal_set_non_alphanumeric_needed(bool value);
  public:

  // bool password_reuse = 7;
  void clear_password_reuse();
  bool password_reuse() const;
  void set_password_reuse(bool value);
  private:
  bool _internal_password_reuse() const;
  void _internal_set_password_reuse(bool value);
  public:

  // bool exclude_names = 8;
  void clear_exclude_names();
  bool exclude_names() const;
  void set_exclude_names(bool value);
  private:
  bool _internal_exclude_names() const;
  void _internal_set_exclude_names(bool value);
  public:

  // bool exclude_email = 9;
  void clear_exclude_email();
  bool exclude_email() const;
  void set_exclude_email(bool value);
  private:
  bool _internal_exclude_email() const;
  void _internal_set_exclude_email(bool value);
  public:

  // bool no_confusing_letters = 10;
  void clear_no_confusing_letters();
  bool no_confusing_letters() const;
  void set_no_confusing_letters(bool value);
  private:
  bool _internal_no_confusing_letters() const;
  void _internal_set_no_confusing_letters(bool value);
  public:

  // bool no_simple_passwords = 11;
  void clear_no_simple_passwords();
  bool no_simple_passwords() const;
  void set_no_simple_passwords(bool value);
  private:
  bool _internal_no_simple_passwords() const;
  void _internal_set_no_simple_passwords(bool value);
  public:

  // bool no_common_vocabs = 12;
  void clear_no_common_vocabs();
  bool no_common_vocabs() const;
  void set_no_common_vocabs(bool value);
  private:
  bool _internal_no_common_vocabs() const;
  void _internal_set_no_common_vocabs(bool value);
  public:

  // bool no_overlap_with_old = 13;
  void clear_no_overlap_with_old();
  bool no_overlap_with_old() const;
  void set_no_overlap_with_old(bool value);
  private:
  bool _internal_no_overlap_with_old() const;
  void _internal_set_no_overlap_with_old(bool value);
  public:

  // bool password_lifespan = 14;
  void clear_password_lifespan();
  bool password_lifespan() const;
  void set_password_lifespan(bool value);
  private:
  bool _internal_password_lifespan() const;
  void _internal_set_password_lifespan(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.PasswordViolations)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool minimum_length_;
    bool maximum_length_;
    bool upper_case_needed_;
    bool lower_case_needed_;
    bool numeric_needed_;
    bool non_alphanumeric_needed_;
    bool password_reuse_;
    bool exclude_names_;
    bool exclude_email_;
    bool no_confusing_letters_;
    bool no_simple_passwords_;
    bool no_common_vocabs_;
    bool no_overlap_with_old_;
    bool password_lifespan_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Video final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Video) */ {
 public:
  inline Video() : Video(nullptr) {}
  ~Video() override;
  explicit PROTOBUF_CONSTEXPR Video(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Video(const Video& from);
  Video(Video&& from) noexcept
    : Video() {
    *this = ::std::move(from);
  }

  inline Video& operator=(const Video& from) {
    CopyFrom(from);
    return *this;
  }
  inline Video& operator=(Video&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Video& default_instance() {
    return *internal_default_instance();
  }
  static inline const Video* internal_default_instance() {
    return reinterpret_cast<const Video*>(
               &_Video_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    112;

  friend void swap(Video& a, Video& b) {
    a.Swap(&b);
  }
  inline void Swap(Video* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Video* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Video* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Video>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Video& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Video& from) {
    Video::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Video* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Video";
  }
  protected:
  explicit Video(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kBase64FieldNumber = 2,
    kThumbnailUrlFieldNumber = 5,
    kHostedFieldNumber = 6,
    kVideoInfoFieldNumber = 7,
    kAllowDuplicateUrlFieldNumber = 4,
  };
  // string url = 1;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // bytes base64 = 2;
  void clear_base64();
  const std::string& base64() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_base64(ArgT0&& arg0, ArgT... args);
  std::string* mutable_base64();
  PROTOBUF_NODISCARD std::string* release_base64();
  void set_allocated_base64(std::string* base64);
  private:
  const std::string& _internal_base64() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base64(const std::string& value);
  std::string* _internal_mutable_base64();
  public:

  // string thumbnail_url = 5;
  void clear_thumbnail_url();
  const std::string& thumbnail_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thumbnail_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thumbnail_url();
  PROTOBUF_NODISCARD std::string* release_thumbnail_url();
  void set_allocated_thumbnail_url(std::string* thumbnail_url);
  private:
  const std::string& _internal_thumbnail_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbnail_url(const std::string& value);
  std::string* _internal_mutable_thumbnail_url();
  public:

  // .clarifai.api.HostedURL hosted = 6;
  bool has_hosted() const;
  private:
  bool _internal_has_hosted() const;
  public:
  void clear_hosted();
  const ::clarifai::api::HostedURL& hosted() const;
  PROTOBUF_NODISCARD ::clarifai::api::HostedURL* release_hosted();
  ::clarifai::api::HostedURL* mutable_hosted();
  void set_allocated_hosted(::clarifai::api::HostedURL* hosted);
  private:
  const ::clarifai::api::HostedURL& _internal_hosted() const;
  ::clarifai::api::HostedURL* _internal_mutable_hosted();
  public:
  void unsafe_arena_set_allocated_hosted(
      ::clarifai::api::HostedURL* hosted);
  ::clarifai::api::HostedURL* unsafe_arena_release_hosted();

  // .clarifai.api.VideoInfo video_info = 7;
  bool has_video_info() const;
  private:
  bool _internal_has_video_info() const;
  public:
  void clear_video_info();
  const ::clarifai::api::VideoInfo& video_info() const;
  PROTOBUF_NODISCARD ::clarifai::api::VideoInfo* release_video_info();
  ::clarifai::api::VideoInfo* mutable_video_info();
  void set_allocated_video_info(::clarifai::api::VideoInfo* video_info);
  private:
  const ::clarifai::api::VideoInfo& _internal_video_info() const;
  ::clarifai::api::VideoInfo* _internal_mutable_video_info();
  public:
  void unsafe_arena_set_allocated_video_info(
      ::clarifai::api::VideoInfo* video_info);
  ::clarifai::api::VideoInfo* unsafe_arena_release_video_info();

  // bool allow_duplicate_url = 4;
  void clear_allow_duplicate_url();
  bool allow_duplicate_url() const;
  void set_allow_duplicate_url(bool value);
  private:
  bool _internal_allow_duplicate_url() const;
  void _internal_set_allow_duplicate_url(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.Video)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base64_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnail_url_;
    ::clarifai::api::HostedURL* hosted_;
    ::clarifai::api::VideoInfo* video_info_;
    bool allow_duplicate_url_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class VideoInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.VideoInfo) */ {
 public:
  inline VideoInfo() : VideoInfo(nullptr) {}
  ~VideoInfo() override;
  explicit PROTOBUF_CONSTEXPR VideoInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoInfo(const VideoInfo& from);
  VideoInfo(VideoInfo&& from) noexcept
    : VideoInfo() {
    *this = ::std::move(from);
  }

  inline VideoInfo& operator=(const VideoInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoInfo& operator=(VideoInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoInfo* internal_default_instance() {
    return reinterpret_cast<const VideoInfo*>(
               &_VideoInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    113;

  friend void swap(VideoInfo& a, VideoInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VideoInfo& from) {
    VideoInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.VideoInfo";
  }
  protected:
  explicit VideoInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVideoFormatFieldNumber = 4,
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kFpsFieldNumber = 3,
    kBitRateFieldNumber = 5,
    kFrameCountFieldNumber = 6,
    kDurationSecondsFieldNumber = 7,
  };
  // string video_format = 4;
  void clear_video_format();
  const std::string& video_format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_video_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_video_format();
  PROTOBUF_NODISCARD std::string* release_video_format();
  void set_allocated_video_format(std::string* video_format);
  private:
  const std::string& _internal_video_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_video_format(const std::string& value);
  std::string* _internal_mutable_video_format();
  public:

  // int32 width = 1;
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // int32 height = 2;
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // float fps = 3;
  void clear_fps();
  float fps() const;
  void set_fps(float value);
  private:
  float _internal_fps() const;
  void _internal_set_fps(float value);
  public:

  // int32 bit_rate = 5;
  void clear_bit_rate();
  int32_t bit_rate() const;
  void set_bit_rate(int32_t value);
  private:
  int32_t _internal_bit_rate() const;
  void _internal_set_bit_rate(int32_t value);
  public:

  // int32 frame_count = 6;
  void clear_frame_count();
  int32_t frame_count() const;
  void set_frame_count(int32_t value);
  private:
  int32_t _internal_frame_count() const;
  void _internal_set_frame_count(int32_t value);
  public:

  // float duration_seconds = 7;
  void clear_duration_seconds();
  float duration_seconds() const;
  void set_duration_seconds(float value);
  private:
  float _internal_duration_seconds() const;
  void _internal_set_duration_seconds(float value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.VideoInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr video_format_;
    int32_t width_;
    int32_t height_;
    float fps_;
    int32_t bit_rate_;
    int32_t frame_count_;
    float duration_seconds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Workflow final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Workflow) */ {
 public:
  inline Workflow() : Workflow(nullptr) {}
  ~Workflow() override;
  explicit PROTOBUF_CONSTEXPR Workflow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Workflow(const Workflow& from);
  Workflow(Workflow&& from) noexcept
    : Workflow() {
    *this = ::std::move(from);
  }

  inline Workflow& operator=(const Workflow& from) {
    CopyFrom(from);
    return *this;
  }
  inline Workflow& operator=(Workflow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Workflow& default_instance() {
    return *internal_default_instance();
  }
  static inline const Workflow* internal_default_instance() {
    return reinterpret_cast<const Workflow*>(
               &_Workflow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    114;

  friend void swap(Workflow& a, Workflow& b) {
    a.Swap(&b);
  }
  inline void Swap(Workflow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Workflow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Workflow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Workflow>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Workflow& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Workflow& from) {
    Workflow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Workflow* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Workflow";
  }
  protected:
  explicit Workflow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 4,
    kUseCasesFieldNumber = 14,
    kCheckConsentsFieldNumber = 15,
    kIdFieldNumber = 1,
    kAppIdFieldNumber = 2,
    kUserIdFieldNumber = 7,
    kDescriptionFieldNumber = 12,
    kNotesFieldNumber = 13,
    kCreatedAtFieldNumber = 3,
    kMetadataFieldNumber = 5,
    kVisibilityFieldNumber = 6,
    kModifiedAtFieldNumber = 8,
    kVersionFieldNumber = 9,
    kIsStarredFieldNumber = 10,
    kStarCountFieldNumber = 11,
  };
  // repeated .clarifai.api.WorkflowNode nodes = 4;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::clarifai::api::WorkflowNode* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::WorkflowNode >*
      mutable_nodes();
  private:
  const ::clarifai::api::WorkflowNode& _internal_nodes(int index) const;
  ::clarifai::api::WorkflowNode* _internal_add_nodes();
  public:
  const ::clarifai::api::WorkflowNode& nodes(int index) const;
  ::clarifai::api::WorkflowNode* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::WorkflowNode >&
      nodes() const;

  // repeated string use_cases = 14 [(.clarifai.api.utils.cl_show_if_empty) = true];
  int use_cases_size() const;
  private:
  int _internal_use_cases_size() const;
  public:
  void clear_use_cases();
  const std::string& use_cases(int index) const;
  std::string* mutable_use_cases(int index);
  void set_use_cases(int index, const std::string& value);
  void set_use_cases(int index, std::string&& value);
  void set_use_cases(int index, const char* value);
  void set_use_cases(int index, const char* value, size_t size);
  std::string* add_use_cases();
  void add_use_cases(const std::string& value);
  void add_use_cases(std::string&& value);
  void add_use_cases(const char* value);
  void add_use_cases(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& use_cases() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_use_cases();
  private:
  const std::string& _internal_use_cases(int index) const;
  std::string* _internal_add_use_cases();
  public:

  // repeated string check_consents = 15 [(.clarifai.api.utils.cl_show_if_empty) = true];
  int check_consents_size() const;
  private:
  int _internal_check_consents_size() const;
  public:
  void clear_check_consents();
  const std::string& check_consents(int index) const;
  std::string* mutable_check_consents(int index);
  void set_check_consents(int index, const std::string& value);
  void set_check_consents(int index, std::string&& value);
  void set_check_consents(int index, const char* value);
  void set_check_consents(int index, const char* value, size_t size);
  std::string* add_check_consents();
  void add_check_consents(const std::string& value);
  void add_check_consents(std::string&& value);
  void add_check_consents(const char* value);
  void add_check_consents(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& check_consents() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_check_consents();
  private:
  const std::string& _internal_check_consents(int index) const;
  std::string* _internal_add_check_consents();
  public:

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string app_id = 2;
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // string user_id = 7;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string description = 12;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string notes = 13;
  void clear_notes();
  const std::string& notes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_notes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_notes();
  PROTOBUF_NODISCARD std::string* release_notes();
  void set_allocated_notes(std::string* notes);
  private:
  const std::string& _internal_notes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_notes(const std::string& value);
  std::string* _internal_mutable_notes();
  public:

  // .google.protobuf.Timestamp created_at = 3;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Struct metadata = 5;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  void set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata();

  // .clarifai.api.Visibility visibility = 6;
  bool has_visibility() const;
  private:
  bool _internal_has_visibility() const;
  public:
  void clear_visibility();
  const ::clarifai::api::Visibility& visibility() const;
  PROTOBUF_NODISCARD ::clarifai::api::Visibility* release_visibility();
  ::clarifai::api::Visibility* mutable_visibility();
  void set_allocated_visibility(::clarifai::api::Visibility* visibility);
  private:
  const ::clarifai::api::Visibility& _internal_visibility() const;
  ::clarifai::api::Visibility* _internal_mutable_visibility();
  public:
  void unsafe_arena_set_allocated_visibility(
      ::clarifai::api::Visibility* visibility);
  ::clarifai::api::Visibility* unsafe_arena_release_visibility();

  // .google.protobuf.Timestamp modified_at = 8;
  bool has_modified_at() const;
  private:
  bool _internal_has_modified_at() const;
  public:
  void clear_modified_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& modified_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_modified_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_modified_at();
  void set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_modified_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_modified_at();
  public:
  void unsafe_arena_set_allocated_modified_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_modified_at();

  // .clarifai.api.WorkflowVersion version = 9;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const ::clarifai::api::WorkflowVersion& version() const;
  PROTOBUF_NODISCARD ::clarifai::api::WorkflowVersion* release_version();
  ::clarifai::api::WorkflowVersion* mutable_version();
  void set_allocated_version(::clarifai::api::WorkflowVersion* version);
  private:
  const ::clarifai::api::WorkflowVersion& _internal_version() const;
  ::clarifai::api::WorkflowVersion* _internal_mutable_version();
  public:
  void unsafe_arena_set_allocated_version(
      ::clarifai::api::WorkflowVersion* version);
  ::clarifai::api::WorkflowVersion* unsafe_arena_release_version();

  // bool is_starred = 10;
  void clear_is_starred();
  bool is_starred() const;
  void set_is_starred(bool value);
  private:
  bool _internal_is_starred() const;
  void _internal_set_is_starred(bool value);
  public:

  // int32 star_count = 11;
  void clear_star_count();
  int32_t star_count() const;
  void set_star_count(int32_t value);
  private:
  int32_t _internal_star_count() const;
  void _internal_set_star_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.Workflow)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::WorkflowNode > nodes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> use_cases_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> check_consents_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr notes_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_;
    ::clarifai::api::Visibility* visibility_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at_;
    ::clarifai::api::WorkflowVersion* version_;
    bool is_starred_;
    int32_t star_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class WorkflowVersion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.WorkflowVersion) */ {
 public:
  inline WorkflowVersion() : WorkflowVersion(nullptr) {}
  ~WorkflowVersion() override;
  explicit PROTOBUF_CONSTEXPR WorkflowVersion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkflowVersion(const WorkflowVersion& from);
  WorkflowVersion(WorkflowVersion&& from) noexcept
    : WorkflowVersion() {
    *this = ::std::move(from);
  }

  inline WorkflowVersion& operator=(const WorkflowVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkflowVersion& operator=(WorkflowVersion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkflowVersion& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkflowVersion* internal_default_instance() {
    return reinterpret_cast<const WorkflowVersion*>(
               &_WorkflowVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    115;

  friend void swap(WorkflowVersion& a, WorkflowVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkflowVersion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkflowVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkflowVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkflowVersion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkflowVersion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkflowVersion& from) {
    WorkflowVersion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowVersion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.WorkflowVersion";
  }
  protected:
  explicit WorkflowVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 6,
    kIdFieldNumber = 1,
    kWorkflowIdFieldNumber = 2,
    kAppIdFieldNumber = 8,
    kUserIdFieldNumber = 9,
    kDescriptionFieldNumber = 10,
    kLicenseFieldNumber = 11,
    kCreatedAtFieldNumber = 3,
    kModifiedAtFieldNumber = 4,
    kVisibilityFieldNumber = 5,
    kMetadataFieldNumber = 7,
  };
  // repeated .clarifai.api.WorkflowNode nodes = 6;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::clarifai::api::WorkflowNode* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::WorkflowNode >*
      mutable_nodes();
  private:
  const ::clarifai::api::WorkflowNode& _internal_nodes(int index) const;
  ::clarifai::api::WorkflowNode* _internal_add_nodes();
  public:
  const ::clarifai::api::WorkflowNode& nodes(int index) const;
  ::clarifai::api::WorkflowNode* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::WorkflowNode >&
      nodes() const;

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string workflow_id = 2;
  void clear_workflow_id();
  const std::string& workflow_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_workflow_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_workflow_id();
  PROTOBUF_NODISCARD std::string* release_workflow_id();
  void set_allocated_workflow_id(std::string* workflow_id);
  private:
  const std::string& _internal_workflow_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_workflow_id(const std::string& value);
  std::string* _internal_mutable_workflow_id();
  public:

  // string app_id = 8;
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // string user_id = 9;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string description = 10;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string license = 11;
  void clear_license();
  const std::string& license() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_license(ArgT0&& arg0, ArgT... args);
  std::string* mutable_license();
  PROTOBUF_NODISCARD std::string* release_license();
  void set_allocated_license(std::string* license);
  private:
  const std::string& _internal_license() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_license(const std::string& value);
  std::string* _internal_mutable_license();
  public:

  // .google.protobuf.Timestamp created_at = 3;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp modified_at = 4;
  bool has_modified_at() const;
  private:
  bool _internal_has_modified_at() const;
  public:
  void clear_modified_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& modified_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_modified_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_modified_at();
  void set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_modified_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_modified_at();
  public:
  void unsafe_arena_set_allocated_modified_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_modified_at();

  // .clarifai.api.Visibility visibility = 5;
  bool has_visibility() const;
  private:
  bool _internal_has_visibility() const;
  public:
  void clear_visibility();
  const ::clarifai::api::Visibility& visibility() const;
  PROTOBUF_NODISCARD ::clarifai::api::Visibility* release_visibility();
  ::clarifai::api::Visibility* mutable_visibility();
  void set_allocated_visibility(::clarifai::api::Visibility* visibility);
  private:
  const ::clarifai::api::Visibility& _internal_visibility() const;
  ::clarifai::api::Visibility* _internal_mutable_visibility();
  public:
  void unsafe_arena_set_allocated_visibility(
      ::clarifai::api::Visibility* visibility);
  ::clarifai::api::Visibility* unsafe_arena_release_visibility();

  // .google.protobuf.Struct metadata = 7;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  void set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:clarifai.api.WorkflowVersion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::WorkflowNode > nodes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr workflow_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr license_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at_;
    ::clarifai::api::Visibility* visibility_;
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class WorkflowNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.WorkflowNode) */ {
 public:
  inline WorkflowNode() : WorkflowNode(nullptr) {}
  ~WorkflowNode() override;
  explicit PROTOBUF_CONSTEXPR WorkflowNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkflowNode(const WorkflowNode& from);
  WorkflowNode(WorkflowNode&& from) noexcept
    : WorkflowNode() {
    *this = ::std::move(from);
  }

  inline WorkflowNode& operator=(const WorkflowNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkflowNode& operator=(WorkflowNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkflowNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkflowNode* internal_default_instance() {
    return reinterpret_cast<const WorkflowNode*>(
               &_WorkflowNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    116;

  friend void swap(WorkflowNode& a, WorkflowNode& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkflowNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkflowNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkflowNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkflowNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkflowNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkflowNode& from) {
    WorkflowNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.WorkflowNode";
  }
  protected:
  explicit WorkflowNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeInputsFieldNumber = 3,
    kIdFieldNumber = 1,
    kModelFieldNumber = 2,
    kSuppressOutputFieldNumber = 4,
  };
  // repeated .clarifai.api.NodeInput node_inputs = 3;
  int node_inputs_size() const;
  private:
  int _internal_node_inputs_size() const;
  public:
  void clear_node_inputs();
  ::clarifai::api::NodeInput* mutable_node_inputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::NodeInput >*
      mutable_node_inputs();
  private:
  const ::clarifai::api::NodeInput& _internal_node_inputs(int index) const;
  ::clarifai::api::NodeInput* _internal_add_node_inputs();
  public:
  const ::clarifai::api::NodeInput& node_inputs(int index) const;
  ::clarifai::api::NodeInput* add_node_inputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::NodeInput >&
      node_inputs() const;

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .clarifai.api.Model model = 2;
  bool has_model() const;
  private:
  bool _internal_has_model() const;
  public:
  void clear_model();
  const ::clarifai::api::Model& model() const;
  PROTOBUF_NODISCARD ::clarifai::api::Model* release_model();
  ::clarifai::api::Model* mutable_model();
  void set_allocated_model(::clarifai::api::Model* model);
  private:
  const ::clarifai::api::Model& _internal_model() const;
  ::clarifai::api::Model* _internal_mutable_model();
  public:
  void unsafe_arena_set_allocated_model(
      ::clarifai::api::Model* model);
  ::clarifai::api::Model* unsafe_arena_release_model();

  // bool suppress_output = 4;
  void clear_suppress_output();
  bool suppress_output() const;
  void set_suppress_output(bool value);
  private:
  bool _internal_suppress_output() const;
  void _internal_set_suppress_output(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.WorkflowNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::NodeInput > node_inputs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::clarifai::api::Model* model_;
    bool suppress_output_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class NodeInput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.NodeInput) */ {
 public:
  inline NodeInput() : NodeInput(nullptr) {}
  ~NodeInput() override;
  explicit PROTOBUF_CONSTEXPR NodeInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeInput(const NodeInput& from);
  NodeInput(NodeInput&& from) noexcept
    : NodeInput() {
    *this = ::std::move(from);
  }

  inline NodeInput& operator=(const NodeInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInput& operator=(NodeInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeInput* internal_default_instance() {
    return reinterpret_cast<const NodeInput*>(
               &_NodeInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    117;

  friend void swap(NodeInput& a, NodeInput& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeInput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeInput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NodeInput& from) {
    NodeInput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeInput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.NodeInput";
  }
  protected:
  explicit NodeInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
  };
  // string node_id = 1;
  void clear_node_id();
  const std::string& node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_id();
  PROTOBUF_NODISCARD std::string* release_node_id();
  void set_allocated_node_id(std::string* node_id);
  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(const std::string& value);
  std::string* _internal_mutable_node_id();
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.NodeInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class WorkflowResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.WorkflowResult) */ {
 public:
  inline WorkflowResult() : WorkflowResult(nullptr) {}
  ~WorkflowResult() override;
  explicit PROTOBUF_CONSTEXPR WorkflowResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkflowResult(const WorkflowResult& from);
  WorkflowResult(WorkflowResult&& from) noexcept
    : WorkflowResult() {
    *this = ::std::move(from);
  }

  inline WorkflowResult& operator=(const WorkflowResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkflowResult& operator=(WorkflowResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkflowResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkflowResult* internal_default_instance() {
    return reinterpret_cast<const WorkflowResult*>(
               &_WorkflowResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    118;

  friend void swap(WorkflowResult& a, WorkflowResult& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkflowResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkflowResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkflowResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkflowResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkflowResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkflowResult& from) {
    WorkflowResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.WorkflowResult";
  }
  protected:
  explicit WorkflowResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOutputsFieldNumber = 6,
    kIdFieldNumber = 1,
    kStatusFieldNumber = 2,
    kCreatedAtFieldNumber = 3,
    kModelFieldNumber = 4,
    kInputFieldNumber = 5,
    kSuppressOutputFieldNumber = 7,
  };
  // repeated .clarifai.api.Output outputs = 6;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;
  public:
  void clear_outputs();
  ::clarifai::api::Output* mutable_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Output >*
      mutable_outputs();
  private:
  const ::clarifai::api::Output& _internal_outputs(int index) const;
  ::clarifai::api::Output* _internal_add_outputs();
  public:
  const ::clarifai::api::Output& outputs(int index) const;
  ::clarifai::api::Output* add_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Output >&
      outputs() const;

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .clarifai.api.status.Status status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::clarifai::api::status::Status& status() const;
  PROTOBUF_NODISCARD ::clarifai::api::status::Status* release_status();
  ::clarifai::api::status::Status* mutable_status();
  void set_allocated_status(::clarifai::api::status::Status* status);
  private:
  const ::clarifai::api::status::Status& _internal_status() const;
  ::clarifai::api::status::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::clarifai::api::status::Status* status);
  ::clarifai::api::status::Status* unsafe_arena_release_status();

  // .google.protobuf.Timestamp created_at = 3;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .clarifai.api.Model model = 4;
  bool has_model() const;
  private:
  bool _internal_has_model() const;
  public:
  void clear_model();
  const ::clarifai::api::Model& model() const;
  PROTOBUF_NODISCARD ::clarifai::api::Model* release_model();
  ::clarifai::api::Model* mutable_model();
  void set_allocated_model(::clarifai::api::Model* model);
  private:
  const ::clarifai::api::Model& _internal_model() const;
  ::clarifai::api::Model* _internal_mutable_model();
  public:
  void unsafe_arena_set_allocated_model(
      ::clarifai::api::Model* model);
  ::clarifai::api::Model* unsafe_arena_release_model();

  // .clarifai.api.Input input = 5;
  bool has_input() const;
  private:
  bool _internal_has_input() const;
  public:
  void clear_input();
  const ::clarifai::api::Input& input() const;
  PROTOBUF_NODISCARD ::clarifai::api::Input* release_input();
  ::clarifai::api::Input* mutable_input();
  void set_allocated_input(::clarifai::api::Input* input);
  private:
  const ::clarifai::api::Input& _internal_input() const;
  ::clarifai::api::Input* _internal_mutable_input();
  public:
  void unsafe_arena_set_allocated_input(
      ::clarifai::api::Input* input);
  ::clarifai::api::Input* unsafe_arena_release_input();

  // bool suppress_output = 7;
  void clear_suppress_output();
  bool suppress_output() const;
  void set_suppress_output(bool value);
  private:
  bool _internal_suppress_output() const;
  void _internal_set_suppress_output(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.WorkflowResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Output > outputs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::clarifai::api::status::Status* status_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::clarifai::api::Model* model_;
    ::clarifai::api::Input* input_;
    bool suppress_output_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class WorkflowState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.WorkflowState) */ {
 public:
  inline WorkflowState() : WorkflowState(nullptr) {}
  ~WorkflowState() override;
  explicit PROTOBUF_CONSTEXPR WorkflowState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkflowState(const WorkflowState& from);
  WorkflowState(WorkflowState&& from) noexcept
    : WorkflowState() {
    *this = ::std::move(from);
  }

  inline WorkflowState& operator=(const WorkflowState& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkflowState& operator=(WorkflowState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkflowState& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkflowState* internal_default_instance() {
    return reinterpret_cast<const WorkflowState*>(
               &_WorkflowState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    119;

  friend void swap(WorkflowState& a, WorkflowState& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkflowState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkflowState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkflowState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkflowState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkflowState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkflowState& from) {
    WorkflowState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.WorkflowState";
  }
  protected:
  explicit WorkflowState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.WorkflowState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class AppDuplication final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.AppDuplication) */ {
 public:
  inline AppDuplication() : AppDuplication(nullptr) {}
  ~AppDuplication() override;
  explicit PROTOBUF_CONSTEXPR AppDuplication(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppDuplication(const AppDuplication& from);
  AppDuplication(AppDuplication&& from) noexcept
    : AppDuplication() {
    *this = ::std::move(from);
  }

  inline AppDuplication& operator=(const AppDuplication& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppDuplication& operator=(AppDuplication&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppDuplication& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppDuplication* internal_default_instance() {
    return reinterpret_cast<const AppDuplication*>(
               &_AppDuplication_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    120;

  friend void swap(AppDuplication& a, AppDuplication& b) {
    a.Swap(&b);
  }
  inline void Swap(AppDuplication* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppDuplication* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppDuplication* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppDuplication>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppDuplication& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppDuplication& from) {
    AppDuplication::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppDuplication* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.AppDuplication";
  }
  protected:
  explicit AppDuplication(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProgressFieldNumber = 9,
    kIdFieldNumber = 1,
    kNewAppIdFieldNumber = 2,
    kNewAppNameFieldNumber = 3,
    kExistingAppIdFieldNumber = 8,
    kStatusFieldNumber = 4,
    kCreatedAtFieldNumber = 5,
    kLastModifiedAtFieldNumber = 6,
    kFilterFieldNumber = 7,
  };
  // repeated .clarifai.api.AppCopyProgress progress = 9;
  int progress_size() const;
  private:
  int _internal_progress_size() const;
  public:
  void clear_progress();
  ::clarifai::api::AppCopyProgress* mutable_progress(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::AppCopyProgress >*
      mutable_progress();
  private:
  const ::clarifai::api::AppCopyProgress& _internal_progress(int index) const;
  ::clarifai::api::AppCopyProgress* _internal_add_progress();
  public:
  const ::clarifai::api::AppCopyProgress& progress(int index) const;
  ::clarifai::api::AppCopyProgress* add_progress();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::AppCopyProgress >&
      progress() const;

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string new_app_id = 2;
  void clear_new_app_id();
  const std::string& new_app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_app_id();
  PROTOBUF_NODISCARD std::string* release_new_app_id();
  void set_allocated_new_app_id(std::string* new_app_id);
  private:
  const std::string& _internal_new_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_app_id(const std::string& value);
  std::string* _internal_mutable_new_app_id();
  public:

  // string new_app_name = 3;
  void clear_new_app_name();
  const std::string& new_app_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_app_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_app_name();
  PROTOBUF_NODISCARD std::string* release_new_app_name();
  void set_allocated_new_app_name(std::string* new_app_name);
  private:
  const std::string& _internal_new_app_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_app_name(const std::string& value);
  std::string* _internal_mutable_new_app_name();
  public:

  // string existing_app_id = 8;
  void clear_existing_app_id();
  const std::string& existing_app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_existing_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_existing_app_id();
  PROTOBUF_NODISCARD std::string* release_existing_app_id();
  void set_allocated_existing_app_id(std::string* existing_app_id);
  private:
  const std::string& _internal_existing_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_existing_app_id(const std::string& value);
  std::string* _internal_mutable_existing_app_id();
  public:

  // .clarifai.api.status.Status status = 4;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::clarifai::api::status::Status& status() const;
  PROTOBUF_NODISCARD ::clarifai::api::status::Status* release_status();
  ::clarifai::api::status::Status* mutable_status();
  void set_allocated_status(::clarifai::api::status::Status* status);
  private:
  const ::clarifai::api::status::Status& _internal_status() const;
  ::clarifai::api::status::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::clarifai::api::status::Status* status);
  ::clarifai::api::status::Status* unsafe_arena_release_status();

  // .google.protobuf.Timestamp created_at = 5;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp last_modified_at = 6;
  bool has_last_modified_at() const;
  private:
  bool _internal_has_last_modified_at() const;
  public:
  void clear_last_modified_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_modified_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_modified_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_modified_at();
  void set_allocated_last_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* last_modified_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_modified_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_modified_at();
  public:
  void unsafe_arena_set_allocated_last_modified_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_modified_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_modified_at();

  // .clarifai.api.AppDuplicationFilters filter = 7;
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const ::clarifai::api::AppDuplicationFilters& filter() const;
  PROTOBUF_NODISCARD ::clarifai::api::AppDuplicationFilters* release_filter();
  ::clarifai::api::AppDuplicationFilters* mutable_filter();
  void set_allocated_filter(::clarifai::api::AppDuplicationFilters* filter);
  private:
  const ::clarifai::api::AppDuplicationFilters& _internal_filter() const;
  ::clarifai::api::AppDuplicationFilters* _internal_mutable_filter();
  public:
  void unsafe_arena_set_allocated_filter(
      ::clarifai::api::AppDuplicationFilters* filter);
  ::clarifai::api::AppDuplicationFilters* unsafe_arena_release_filter();

  // @@protoc_insertion_point(class_scope:clarifai.api.AppDuplication)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::AppCopyProgress > progress_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_app_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_app_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr existing_app_id_;
    ::clarifai::api::status::Status* status_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_modified_at_;
    ::clarifai::api::AppDuplicationFilters* filter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class AppCopyProgress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.AppCopyProgress) */ {
 public:
  inline AppCopyProgress() : AppCopyProgress(nullptr) {}
  ~AppCopyProgress() override;
  explicit PROTOBUF_CONSTEXPR AppCopyProgress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppCopyProgress(const AppCopyProgress& from);
  AppCopyProgress(AppCopyProgress&& from) noexcept
    : AppCopyProgress() {
    *this = ::std::move(from);
  }

  inline AppCopyProgress& operator=(const AppCopyProgress& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppCopyProgress& operator=(AppCopyProgress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppCopyProgress& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppCopyProgress* internal_default_instance() {
    return reinterpret_cast<const AppCopyProgress*>(
               &_AppCopyProgress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    121;

  friend void swap(AppCopyProgress& a, AppCopyProgress& b) {
    a.Swap(&b);
  }
  inline void Swap(AppCopyProgress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppCopyProgress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppCopyProgress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppCopyProgress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppCopyProgress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppCopyProgress& from) {
    AppCopyProgress::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppCopyProgress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.AppCopyProgress";
  }
  protected:
  explicit AppCopyProgress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string field = 1;
  void clear_field();
  const std::string& field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field();
  PROTOBUF_NODISCARD std::string* release_field();
  void set_allocated_field(std::string* field);
  private:
  const std::string& _internal_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field(const std::string& value);
  std::string* _internal_mutable_field();
  public:

  // int32 value = 2;
  void clear_value();
  int32_t value() const;
  void set_value(int32_t value);
  private:
  int32_t _internal_value() const;
  void _internal_set_value(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.AppCopyProgress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field_;
    int32_t value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class AppDuplicationFilters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.AppDuplicationFilters) */ {
 public:
  inline AppDuplicationFilters() : AppDuplicationFilters(nullptr) {}
  ~AppDuplicationFilters() override;
  explicit PROTOBUF_CONSTEXPR AppDuplicationFilters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppDuplicationFilters(const AppDuplicationFilters& from);
  AppDuplicationFilters(AppDuplicationFilters&& from) noexcept
    : AppDuplicationFilters() {
    *this = ::std::move(from);
  }

  inline AppDuplicationFilters& operator=(const AppDuplicationFilters& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppDuplicationFilters& operator=(AppDuplicationFilters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppDuplicationFilters& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppDuplicationFilters* internal_default_instance() {
    return reinterpret_cast<const AppDuplicationFilters*>(
               &_AppDuplicationFilters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    122;

  friend void swap(AppDuplicationFilters& a, AppDuplicationFilters& b) {
    a.Swap(&b);
  }
  inline void Swap(AppDuplicationFilters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppDuplicationFilters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppDuplicationFilters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppDuplicationFilters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppDuplicationFilters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppDuplicationFilters& from) {
    AppDuplicationFilters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppDuplicationFilters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.AppDuplicationFilters";
  }
  protected:
  explicit AppDuplicationFilters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCopyInputsFieldNumber = 1,
    kCopyConceptsFieldNumber = 2,
    kCopyAnnotationsFieldNumber = 3,
    kCopyModelsFieldNumber = 4,
    kCopyWorkflowsFieldNumber = 5,
  };
  // bool copy_inputs = 1;
  void clear_copy_inputs();
  bool copy_inputs() const;
  void set_copy_inputs(bool value);
  private:
  bool _internal_copy_inputs() const;
  void _internal_set_copy_inputs(bool value);
  public:

  // bool copy_concepts = 2;
  void clear_copy_concepts();
  bool copy_concepts() const;
  void set_copy_concepts(bool value);
  private:
  bool _internal_copy_concepts() const;
  void _internal_set_copy_concepts(bool value);
  public:

  // bool copy_annotations = 3;
  void clear_copy_annotations();
  bool copy_annotations() const;
  void set_copy_annotations(bool value);
  private:
  bool _internal_copy_annotations() const;
  void _internal_set_copy_annotations(bool value);
  public:

  // bool copy_models = 4;
  void clear_copy_models();
  bool copy_models() const;
  void set_copy_models(bool value);
  private:
  bool _internal_copy_models() const;
  void _internal_set_copy_models(bool value);
  public:

  // bool copy_workflows = 5;
  void clear_copy_workflows();
  bool copy_workflows() const;
  void set_copy_workflows(bool value);
  private:
  bool _internal_copy_workflows() const;
  void _internal_set_copy_workflows(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.AppDuplicationFilters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool copy_inputs_;
    bool copy_concepts_;
    bool copy_annotations_;
    bool copy_models_;
    bool copy_workflows_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class LabelOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.LabelOrder) */ {
 public:
  inline LabelOrder() : LabelOrder(nullptr) {}
  ~LabelOrder() override;
  explicit PROTOBUF_CONSTEXPR LabelOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LabelOrder(const LabelOrder& from);
  LabelOrder(LabelOrder&& from) noexcept
    : LabelOrder() {
    *this = ::std::move(from);
  }

  inline LabelOrder& operator=(const LabelOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline LabelOrder& operator=(LabelOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LabelOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const LabelOrder* internal_default_instance() {
    return reinterpret_cast<const LabelOrder*>(
               &_LabelOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    123;

  friend void swap(LabelOrder& a, LabelOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(LabelOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LabelOrder* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LabelOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LabelOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LabelOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LabelOrder& from) {
    LabelOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LabelOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.LabelOrder";
  }
  protected:
  explicit LabelOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kStatusFieldNumber = 3,
    kDesiredFulfillTimeFieldNumber = 6,
    kEstimateFulfillTimeFieldNumber = 7,
    kTaskFieldNumber = 8,
    kCreatedAtFieldNumber = 9,
    kModifiedAtFieldNumber = 10,
    kAutoReleaseFieldNumber = 4,
    kAllowEmptyTagFieldNumber = 5,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .clarifai.api.status.Status status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::clarifai::api::status::Status& status() const;
  PROTOBUF_NODISCARD ::clarifai::api::status::Status* release_status();
  ::clarifai::api::status::Status* mutable_status();
  void set_allocated_status(::clarifai::api::status::Status* status);
  private:
  const ::clarifai::api::status::Status& _internal_status() const;
  ::clarifai::api::status::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::clarifai::api::status::Status* status);
  ::clarifai::api::status::Status* unsafe_arena_release_status();

  // .google.protobuf.Timestamp desired_fulfill_time = 6;
  bool has_desired_fulfill_time() const;
  private:
  bool _internal_has_desired_fulfill_time() const;
  public:
  void clear_desired_fulfill_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& desired_fulfill_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_desired_fulfill_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_desired_fulfill_time();
  void set_allocated_desired_fulfill_time(::PROTOBUF_NAMESPACE_ID::Timestamp* desired_fulfill_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_desired_fulfill_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_desired_fulfill_time();
  public:
  void unsafe_arena_set_allocated_desired_fulfill_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* desired_fulfill_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_desired_fulfill_time();

  // .google.protobuf.Timestamp estimate_fulfill_time = 7;
  bool has_estimate_fulfill_time() const;
  private:
  bool _internal_has_estimate_fulfill_time() const;
  public:
  void clear_estimate_fulfill_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& estimate_fulfill_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_estimate_fulfill_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_estimate_fulfill_time();
  void set_allocated_estimate_fulfill_time(::PROTOBUF_NAMESPACE_ID::Timestamp* estimate_fulfill_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_estimate_fulfill_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_estimate_fulfill_time();
  public:
  void unsafe_arena_set_allocated_estimate_fulfill_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* estimate_fulfill_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_estimate_fulfill_time();

  // .clarifai.api.Task task = 8;
  bool has_task() const;
  private:
  bool _internal_has_task() const;
  public:
  void clear_task();
  const ::clarifai::api::Task& task() const;
  PROTOBUF_NODISCARD ::clarifai::api::Task* release_task();
  ::clarifai::api::Task* mutable_task();
  void set_allocated_task(::clarifai::api::Task* task);
  private:
  const ::clarifai::api::Task& _internal_task() const;
  ::clarifai::api::Task* _internal_mutable_task();
  public:
  void unsafe_arena_set_allocated_task(
      ::clarifai::api::Task* task);
  ::clarifai::api::Task* unsafe_arena_release_task();

  // .google.protobuf.Timestamp created_at = 9;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp modified_at = 10;
  bool has_modified_at() const;
  private:
  bool _internal_has_modified_at() const;
  public:
  void clear_modified_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& modified_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_modified_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_modified_at();
  void set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_modified_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_modified_at();
  public:
  void unsafe_arena_set_allocated_modified_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_modified_at();

  // bool auto_release = 4;
  void clear_auto_release();
  bool auto_release() const;
  void set_auto_release(bool value);
  private:
  bool _internal_auto_release() const;
  void _internal_set_auto_release(bool value);
  public:

  // bool allow_empty_tag = 5;
  void clear_allow_empty_tag();
  bool allow_empty_tag() const;
  void set_allow_empty_tag(bool value);
  private:
  bool _internal_allow_empty_tag() const;
  void _internal_set_allow_empty_tag(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.LabelOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::clarifai::api::status::Status* status_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* desired_fulfill_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* estimate_fulfill_time_;
    ::clarifai::api::Task* task_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at_;
    bool auto_release_;
    bool allow_empty_tag_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Task final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Task) */ {
 public:
  inline Task() : Task(nullptr) {}
  ~Task() override;
  explicit PROTOBUF_CONSTEXPR Task(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Task(const Task& from);
  Task(Task&& from) noexcept
    : Task() {
    *this = ::std::move(from);
  }

  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }
  inline Task& operator=(Task&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Task& default_instance() {
    return *internal_default_instance();
  }
  static inline const Task* internal_default_instance() {
    return reinterpret_cast<const Task*>(
               &_Task_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    124;

  friend void swap(Task& a, Task& b) {
    a.Swap(&b);
  }
  inline void Swap(Task* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Task* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Task* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Task>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Task& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Task& from) {
    Task::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Task* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Task";
  }
  protected:
  explicit Task(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Task_TaskType TaskType;
  static constexpr TaskType TYPE_NOT_SET =
    Task_TaskType_TYPE_NOT_SET;
  static constexpr TaskType CONCEPTS_CLASSIFICATION =
    Task_TaskType_CONCEPTS_CLASSIFICATION;
  static constexpr TaskType BOUNDING_BOX_DETECTION =
    Task_TaskType_BOUNDING_BOX_DETECTION;
  static constexpr TaskType POLYGON_DETECTION =
    Task_TaskType_POLYGON_DETECTION;
  static inline bool TaskType_IsValid(int value) {
    return Task_TaskType_IsValid(value);
  }
  static constexpr TaskType TaskType_MIN =
    Task_TaskType_TaskType_MIN;
  static constexpr TaskType TaskType_MAX =
    Task_TaskType_TaskType_MAX;
  static constexpr int TaskType_ARRAYSIZE =
    Task_TaskType_TaskType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TaskType_descriptor() {
    return Task_TaskType_descriptor();
  }
  template<typename T>
  static inline const std::string& TaskType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TaskType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TaskType_Name.");
    return Task_TaskType_Name(enum_t_value);
  }
  static inline bool TaskType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TaskType* value) {
    return Task_TaskType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConceptIdsFieldNumber = 7,
    kIdFieldNumber = 1,
    kDescriptionFieldNumber = 5,
    kNameFieldNumber = 13,
    kAppIdFieldNumber = 16,
    kUserIdFieldNumber = 17,
    kLabelOrderIdFieldNumber = 18,
    kCreatedAtFieldNumber = 2,
    kModifiedAtFieldNumber = 3,
    kWorkerFieldNumber = 6,
    kInputSourceFieldNumber = 8,
    kAiAssistantFieldNumber = 10,
    kReviewFieldNumber = 11,
    kStatusFieldNumber = 12,
    kAiAssistParamsFieldNumber = 14,
    kVisibilityFieldNumber = 15,
    kTypeFieldNumber = 4,
    kSampleMsFieldNumber = 9,
  };
  // repeated string concept_ids = 7;
  int concept_ids_size() const;
  private:
  int _internal_concept_ids_size() const;
  public:
  void clear_concept_ids();
  const std::string& concept_ids(int index) const;
  std::string* mutable_concept_ids(int index);
  void set_concept_ids(int index, const std::string& value);
  void set_concept_ids(int index, std::string&& value);
  void set_concept_ids(int index, const char* value);
  void set_concept_ids(int index, const char* value, size_t size);
  std::string* add_concept_ids();
  void add_concept_ids(const std::string& value);
  void add_concept_ids(std::string&& value);
  void add_concept_ids(const char* value);
  void add_concept_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& concept_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_concept_ids();
  private:
  const std::string& _internal_concept_ids(int index) const;
  std::string* _internal_add_concept_ids();
  public:

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string description = 5;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string name = 13;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string app_id = 16;
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // string user_id = 17;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string label_order_id = 18;
  void clear_label_order_id();
  const std::string& label_order_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label_order_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label_order_id();
  PROTOBUF_NODISCARD std::string* release_label_order_id();
  void set_allocated_label_order_id(std::string* label_order_id);
  private:
  const std::string& _internal_label_order_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label_order_id(const std::string& value);
  std::string* _internal_mutable_label_order_id();
  public:

  // .google.protobuf.Timestamp created_at = 2;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp modified_at = 3;
  bool has_modified_at() const;
  private:
  bool _internal_has_modified_at() const;
  public:
  void clear_modified_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& modified_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_modified_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_modified_at();
  void set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_modified_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_modified_at();
  public:
  void unsafe_arena_set_allocated_modified_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_modified_at();

  // .clarifai.api.TaskWorker worker = 6;
  bool has_worker() const;
  private:
  bool _internal_has_worker() const;
  public:
  void clear_worker();
  const ::clarifai::api::TaskWorker& worker() const;
  PROTOBUF_NODISCARD ::clarifai::api::TaskWorker* release_worker();
  ::clarifai::api::TaskWorker* mutable_worker();
  void set_allocated_worker(::clarifai::api::TaskWorker* worker);
  private:
  const ::clarifai::api::TaskWorker& _internal_worker() const;
  ::clarifai::api::TaskWorker* _internal_mutable_worker();
  public:
  void unsafe_arena_set_allocated_worker(
      ::clarifai::api::TaskWorker* worker);
  ::clarifai::api::TaskWorker* unsafe_arena_release_worker();

  // .clarifai.api.TaskInputSource input_source = 8;
  bool has_input_source() const;
  private:
  bool _internal_has_input_source() const;
  public:
  void clear_input_source();
  const ::clarifai::api::TaskInputSource& input_source() const;
  PROTOBUF_NODISCARD ::clarifai::api::TaskInputSource* release_input_source();
  ::clarifai::api::TaskInputSource* mutable_input_source();
  void set_allocated_input_source(::clarifai::api::TaskInputSource* input_source);
  private:
  const ::clarifai::api::TaskInputSource& _internal_input_source() const;
  ::clarifai::api::TaskInputSource* _internal_mutable_input_source();
  public:
  void unsafe_arena_set_allocated_input_source(
      ::clarifai::api::TaskInputSource* input_source);
  ::clarifai::api::TaskInputSource* unsafe_arena_release_input_source();

  // .clarifai.api.TaskAIAssistant ai_assistant = 10;
  bool has_ai_assistant() const;
  private:
  bool _internal_has_ai_assistant() const;
  public:
  void clear_ai_assistant();
  const ::clarifai::api::TaskAIAssistant& ai_assistant() const;
  PROTOBUF_NODISCARD ::clarifai::api::TaskAIAssistant* release_ai_assistant();
  ::clarifai::api::TaskAIAssistant* mutable_ai_assistant();
  void set_allocated_ai_assistant(::clarifai::api::TaskAIAssistant* ai_assistant);
  private:
  const ::clarifai::api::TaskAIAssistant& _internal_ai_assistant() const;
  ::clarifai::api::TaskAIAssistant* _internal_mutable_ai_assistant();
  public:
  void unsafe_arena_set_allocated_ai_assistant(
      ::clarifai::api::TaskAIAssistant* ai_assistant);
  ::clarifai::api::TaskAIAssistant* unsafe_arena_release_ai_assistant();

  // .clarifai.api.TaskReview review = 11;
  bool has_review() const;
  private:
  bool _internal_has_review() const;
  public:
  void clear_review();
  const ::clarifai::api::TaskReview& review() const;
  PROTOBUF_NODISCARD ::clarifai::api::TaskReview* release_review();
  ::clarifai::api::TaskReview* mutable_review();
  void set_allocated_review(::clarifai::api::TaskReview* review);
  private:
  const ::clarifai::api::TaskReview& _internal_review() const;
  ::clarifai::api::TaskReview* _internal_mutable_review();
  public:
  void unsafe_arena_set_allocated_review(
      ::clarifai::api::TaskReview* review);
  ::clarifai::api::TaskReview* unsafe_arena_release_review();

  // .clarifai.api.status.Status status = 12;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::clarifai::api::status::Status& status() const;
  PROTOBUF_NODISCARD ::clarifai::api::status::Status* release_status();
  ::clarifai::api::status::Status* mutable_status();
  void set_allocated_status(::clarifai::api::status::Status* status);
  private:
  const ::clarifai::api::status::Status& _internal_status() const;
  ::clarifai::api::status::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::clarifai::api::status::Status* status);
  ::clarifai::api::status::Status* unsafe_arena_release_status();

  // .clarifai.api.AiAssistParameters ai_assist_params = 14;
  bool has_ai_assist_params() const;
  private:
  bool _internal_has_ai_assist_params() const;
  public:
  void clear_ai_assist_params();
  const ::clarifai::api::AiAssistParameters& ai_assist_params() const;
  PROTOBUF_NODISCARD ::clarifai::api::AiAssistParameters* release_ai_assist_params();
  ::clarifai::api::AiAssistParameters* mutable_ai_assist_params();
  void set_allocated_ai_assist_params(::clarifai::api::AiAssistParameters* ai_assist_params);
  private:
  const ::clarifai::api::AiAssistParameters& _internal_ai_assist_params() const;
  ::clarifai::api::AiAssistParameters* _internal_mutable_ai_assist_params();
  public:
  void unsafe_arena_set_allocated_ai_assist_params(
      ::clarifai::api::AiAssistParameters* ai_assist_params);
  ::clarifai::api::AiAssistParameters* unsafe_arena_release_ai_assist_params();

  // .clarifai.api.Visibility visibility = 15;
  bool has_visibility() const;
  private:
  bool _internal_has_visibility() const;
  public:
  void clear_visibility();
  const ::clarifai::api::Visibility& visibility() const;
  PROTOBUF_NODISCARD ::clarifai::api::Visibility* release_visibility();
  ::clarifai::api::Visibility* mutable_visibility();
  void set_allocated_visibility(::clarifai::api::Visibility* visibility);
  private:
  const ::clarifai::api::Visibility& _internal_visibility() const;
  ::clarifai::api::Visibility* _internal_mutable_visibility();
  public:
  void unsafe_arena_set_allocated_visibility(
      ::clarifai::api::Visibility* visibility);
  ::clarifai::api::Visibility* unsafe_arena_release_visibility();

  // .clarifai.api.Task.TaskType type = 4;
  void clear_type();
  ::clarifai::api::Task_TaskType type() const;
  void set_type(::clarifai::api::Task_TaskType value);
  private:
  ::clarifai::api::Task_TaskType _internal_type() const;
  void _internal_set_type(::clarifai::api::Task_TaskType value);
  public:

  // uint32 sample_ms = 9;
  void clear_sample_ms();
  uint32_t sample_ms() const;
  void set_sample_ms(uint32_t value);
  private:
  uint32_t _internal_sample_ms() const;
  void _internal_set_sample_ms(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.Task)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> concept_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_order_id_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at_;
    ::clarifai::api::TaskWorker* worker_;
    ::clarifai::api::TaskInputSource* input_source_;
    ::clarifai::api::TaskAIAssistant* ai_assistant_;
    ::clarifai::api::TaskReview* review_;
    ::clarifai::api::status::Status* status_;
    ::clarifai::api::AiAssistParameters* ai_assist_params_;
    ::clarifai::api::Visibility* visibility_;
    int type_;
    uint32_t sample_ms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class AiAssistParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.AiAssistParameters) */ {
 public:
  inline AiAssistParameters() : AiAssistParameters(nullptr) {}
  ~AiAssistParameters() override;
  explicit PROTOBUF_CONSTEXPR AiAssistParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AiAssistParameters(const AiAssistParameters& from);
  AiAssistParameters(AiAssistParameters&& from) noexcept
    : AiAssistParameters() {
    *this = ::std::move(from);
  }

  inline AiAssistParameters& operator=(const AiAssistParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiAssistParameters& operator=(AiAssistParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiAssistParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiAssistParameters* internal_default_instance() {
    return reinterpret_cast<const AiAssistParameters*>(
               &_AiAssistParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    125;

  friend void swap(AiAssistParameters& a, AiAssistParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(AiAssistParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiAssistParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiAssistParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiAssistParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AiAssistParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AiAssistParameters& from) {
    AiAssistParameters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiAssistParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.AiAssistParameters";
  }
  protected:
  explicit AiAssistParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConceptRelationIdsFieldNumber = 3,
    kMinThresholdFieldNumber = 1,
    kMaxThresholdFieldNumber = 2,
  };
  // repeated string concept_relation_ids = 3;
  int concept_relation_ids_size() const;
  private:
  int _internal_concept_relation_ids_size() const;
  public:
  void clear_concept_relation_ids();
  const std::string& concept_relation_ids(int index) const;
  std::string* mutable_concept_relation_ids(int index);
  void set_concept_relation_ids(int index, const std::string& value);
  void set_concept_relation_ids(int index, std::string&& value);
  void set_concept_relation_ids(int index, const char* value);
  void set_concept_relation_ids(int index, const char* value, size_t size);
  std::string* add_concept_relation_ids();
  void add_concept_relation_ids(const std::string& value);
  void add_concept_relation_ids(std::string&& value);
  void add_concept_relation_ids(const char* value);
  void add_concept_relation_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& concept_relation_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_concept_relation_ids();
  private:
  const std::string& _internal_concept_relation_ids(int index) const;
  std::string* _internal_add_concept_relation_ids();
  public:

  // float min_threshold = 1;
  void clear_min_threshold();
  float min_threshold() const;
  void set_min_threshold(float value);
  private:
  float _internal_min_threshold() const;
  void _internal_set_min_threshold(float value);
  public:

  // float max_threshold = 2;
  void clear_max_threshold();
  float max_threshold() const;
  void set_max_threshold(float value);
  private:
  float _internal_max_threshold() const;
  void _internal_set_max_threshold(float value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.AiAssistParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> concept_relation_ids_;
    float min_threshold_;
    float max_threshold_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class TaskWorker final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.TaskWorker) */ {
 public:
  inline TaskWorker() : TaskWorker(nullptr) {}
  ~TaskWorker() override;
  explicit PROTOBUF_CONSTEXPR TaskWorker(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskWorker(const TaskWorker& from);
  TaskWorker(TaskWorker&& from) noexcept
    : TaskWorker() {
    *this = ::std::move(from);
  }

  inline TaskWorker& operator=(const TaskWorker& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskWorker& operator=(TaskWorker&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskWorker& default_instance() {
    return *internal_default_instance();
  }
  enum StrategyInfoCase {
    kPartitionedStrategyInfo = 3,
    STRATEGY_INFO_NOT_SET = 0,
  };

  static inline const TaskWorker* internal_default_instance() {
    return reinterpret_cast<const TaskWorker*>(
               &_TaskWorker_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    126;

  friend void swap(TaskWorker& a, TaskWorker& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskWorker* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskWorker* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskWorker* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskWorker>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskWorker& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TaskWorker& from) {
    TaskWorker::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskWorker* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.TaskWorker";
  }
  protected:
  explicit TaskWorker(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TaskWorker_TaskWorkerStrategy TaskWorkerStrategy;
  static constexpr TaskWorkerStrategy WORKER_STRATEGY_NOT_SET =
    TaskWorker_TaskWorkerStrategy_WORKER_STRATEGY_NOT_SET;
  static constexpr TaskWorkerStrategy PARTITIONED =
    TaskWorker_TaskWorkerStrategy_PARTITIONED;
  static constexpr TaskWorkerStrategy FULL =
    TaskWorker_TaskWorkerStrategy_FULL;
  static inline bool TaskWorkerStrategy_IsValid(int value) {
    return TaskWorker_TaskWorkerStrategy_IsValid(value);
  }
  static constexpr TaskWorkerStrategy TaskWorkerStrategy_MIN =
    TaskWorker_TaskWorkerStrategy_TaskWorkerStrategy_MIN;
  static constexpr TaskWorkerStrategy TaskWorkerStrategy_MAX =
    TaskWorker_TaskWorkerStrategy_TaskWorkerStrategy_MAX;
  static constexpr int TaskWorkerStrategy_ARRAYSIZE =
    TaskWorker_TaskWorkerStrategy_TaskWorkerStrategy_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TaskWorkerStrategy_descriptor() {
    return TaskWorker_TaskWorkerStrategy_descriptor();
  }
  template<typename T>
  static inline const std::string& TaskWorkerStrategy_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TaskWorkerStrategy>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TaskWorkerStrategy_Name.");
    return TaskWorker_TaskWorkerStrategy_Name(enum_t_value);
  }
  static inline bool TaskWorkerStrategy_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TaskWorkerStrategy* value) {
    return TaskWorker_TaskWorkerStrategy_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdsFieldNumber = 2,
    kUsersFieldNumber = 4,
    kStrategyFieldNumber = 1,
    kPartitionedStrategyInfoFieldNumber = 3,
  };
  // repeated string user_ids = 2 [deprecated = true];
  PROTOBUF_DEPRECATED int user_ids_size() const;
  private:
  int _internal_user_ids_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_user_ids();
  PROTOBUF_DEPRECATED const std::string& user_ids(int index) const;
  PROTOBUF_DEPRECATED std::string* mutable_user_ids(int index);
  PROTOBUF_DEPRECATED void set_user_ids(int index, const std::string& value);
  PROTOBUF_DEPRECATED void set_user_ids(int index, std::string&& value);
  PROTOBUF_DEPRECATED void set_user_ids(int index, const char* value);
  PROTOBUF_DEPRECATED void set_user_ids(int index, const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* add_user_ids();
  PROTOBUF_DEPRECATED void add_user_ids(const std::string& value);
  PROTOBUF_DEPRECATED void add_user_ids(std::string&& value);
  PROTOBUF_DEPRECATED void add_user_ids(const char* value);
  PROTOBUF_DEPRECATED void add_user_ids(const char* value, size_t size);
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& user_ids() const;
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_user_ids();
  private:
  const std::string& _internal_user_ids(int index) const;
  std::string* _internal_add_user_ids();
  public:

  // repeated .clarifai.api.User users = 4;
  int users_size() const;
  private:
  int _internal_users_size() const;
  public:
  void clear_users();
  ::clarifai::api::User* mutable_users(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::User >*
      mutable_users();
  private:
  const ::clarifai::api::User& _internal_users(int index) const;
  ::clarifai::api::User* _internal_add_users();
  public:
  const ::clarifai::api::User& users(int index) const;
  ::clarifai::api::User* add_users();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::User >&
      users() const;

  // .clarifai.api.TaskWorker.TaskWorkerStrategy strategy = 1;
  void clear_strategy();
  ::clarifai::api::TaskWorker_TaskWorkerStrategy strategy() const;
  void set_strategy(::clarifai::api::TaskWorker_TaskWorkerStrategy value);
  private:
  ::clarifai::api::TaskWorker_TaskWorkerStrategy _internal_strategy() const;
  void _internal_set_strategy(::clarifai::api::TaskWorker_TaskWorkerStrategy value);
  public:

  // .clarifai.api.TaskWorkerPartitionedStrategyInfo partitioned_strategy_info = 3;
  bool has_partitioned_strategy_info() const;
  private:
  bool _internal_has_partitioned_strategy_info() const;
  public:
  void clear_partitioned_strategy_info();
  const ::clarifai::api::TaskWorkerPartitionedStrategyInfo& partitioned_strategy_info() const;
  PROTOBUF_NODISCARD ::clarifai::api::TaskWorkerPartitionedStrategyInfo* release_partitioned_strategy_info();
  ::clarifai::api::TaskWorkerPartitionedStrategyInfo* mutable_partitioned_strategy_info();
  void set_allocated_partitioned_strategy_info(::clarifai::api::TaskWorkerPartitionedStrategyInfo* partitioned_strategy_info);
  private:
  const ::clarifai::api::TaskWorkerPartitionedStrategyInfo& _internal_partitioned_strategy_info() const;
  ::clarifai::api::TaskWorkerPartitionedStrategyInfo* _internal_mutable_partitioned_strategy_info();
  public:
  void unsafe_arena_set_allocated_partitioned_strategy_info(
      ::clarifai::api::TaskWorkerPartitionedStrategyInfo* partitioned_strategy_info);
  ::clarifai::api::TaskWorkerPartitionedStrategyInfo* unsafe_arena_release_partitioned_strategy_info();

  void clear_strategy_info();
  StrategyInfoCase strategy_info_case() const;
  // @@protoc_insertion_point(class_scope:clarifai.api.TaskWorker)
 private:
  class _Internal;
  void set_has_partitioned_strategy_info();

  inline bool has_strategy_info() const;
  inline void clear_has_strategy_info();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> user_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::User > users_;
    int strategy_;
    union StrategyInfoUnion {
      constexpr StrategyInfoUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::clarifai::api::TaskWorkerPartitionedStrategyInfo* partitioned_strategy_info_;
    } strategy_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class TaskWorkerPartitionedStrategyInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.TaskWorkerPartitionedStrategyInfo) */ {
 public:
  inline TaskWorkerPartitionedStrategyInfo() : TaskWorkerPartitionedStrategyInfo(nullptr) {}
  ~TaskWorkerPartitionedStrategyInfo() override;
  explicit PROTOBUF_CONSTEXPR TaskWorkerPartitionedStrategyInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskWorkerPartitionedStrategyInfo(const TaskWorkerPartitionedStrategyInfo& from);
  TaskWorkerPartitionedStrategyInfo(TaskWorkerPartitionedStrategyInfo&& from) noexcept
    : TaskWorkerPartitionedStrategyInfo() {
    *this = ::std::move(from);
  }

  inline TaskWorkerPartitionedStrategyInfo& operator=(const TaskWorkerPartitionedStrategyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskWorkerPartitionedStrategyInfo& operator=(TaskWorkerPartitionedStrategyInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskWorkerPartitionedStrategyInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskWorkerPartitionedStrategyInfo* internal_default_instance() {
    return reinterpret_cast<const TaskWorkerPartitionedStrategyInfo*>(
               &_TaskWorkerPartitionedStrategyInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    127;

  friend void swap(TaskWorkerPartitionedStrategyInfo& a, TaskWorkerPartitionedStrategyInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskWorkerPartitionedStrategyInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskWorkerPartitionedStrategyInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskWorkerPartitionedStrategyInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskWorkerPartitionedStrategyInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskWorkerPartitionedStrategyInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TaskWorkerPartitionedStrategyInfo& from) {
    TaskWorkerPartitionedStrategyInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskWorkerPartitionedStrategyInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.TaskWorkerPartitionedStrategyInfo";
  }
  protected:
  explicit TaskWorkerPartitionedStrategyInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy TaskWorkerPartitionedStrategy;
  static constexpr TaskWorkerPartitionedStrategy PARTITIONED_WORKER_STRATEGY_NOT_SET =
    TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_PARTITIONED_WORKER_STRATEGY_NOT_SET;
  static constexpr TaskWorkerPartitionedStrategy EVENLY =
    TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_EVENLY;
  static constexpr TaskWorkerPartitionedStrategy WEIGHTED =
    TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_WEIGHTED;
  static inline bool TaskWorkerPartitionedStrategy_IsValid(int value) {
    return TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_IsValid(value);
  }
  static constexpr TaskWorkerPartitionedStrategy TaskWorkerPartitionedStrategy_MIN =
    TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_TaskWorkerPartitionedStrategy_MIN;
  static constexpr TaskWorkerPartitionedStrategy TaskWorkerPartitionedStrategy_MAX =
    TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_TaskWorkerPartitionedStrategy_MAX;
  static constexpr int TaskWorkerPartitionedStrategy_ARRAYSIZE =
    TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_TaskWorkerPartitionedStrategy_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TaskWorkerPartitionedStrategy_descriptor() {
    return TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_descriptor();
  }
  template<typename T>
  static inline const std::string& TaskWorkerPartitionedStrategy_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TaskWorkerPartitionedStrategy>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TaskWorkerPartitionedStrategy_Name.");
    return TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_Name(enum_t_value);
  }
  static inline bool TaskWorkerPartitionedStrategy_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TaskWorkerPartitionedStrategy* value) {
    return TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kWeightsFieldNumber = 3,
    kTypeFieldNumber = 1,
    kWorkersPerInputFieldNumber = 2,
  };
  // .google.protobuf.Struct weights = 3;
  bool has_weights() const;
  private:
  bool _internal_has_weights() const;
  public:
  void clear_weights();
  const ::PROTOBUF_NAMESPACE_ID::Struct& weights() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_weights();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_weights();
  void set_allocated_weights(::PROTOBUF_NAMESPACE_ID::Struct* weights);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_weights() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_weights();
  public:
  void unsafe_arena_set_allocated_weights(
      ::PROTOBUF_NAMESPACE_ID::Struct* weights);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_weights();

  // .clarifai.api.TaskWorkerPartitionedStrategyInfo.TaskWorkerPartitionedStrategy type = 1;
  void clear_type();
  ::clarifai::api::TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy type() const;
  void set_type(::clarifai::api::TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy value);
  private:
  ::clarifai::api::TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy _internal_type() const;
  void _internal_set_type(::clarifai::api::TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy value);
  public:

  // int32 workers_per_input = 2;
  void clear_workers_per_input();
  int32_t workers_per_input() const;
  void set_workers_per_input(int32_t value);
  private:
  int32_t _internal_workers_per_input() const;
  void _internal_set_workers_per_input(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.TaskWorkerPartitionedStrategyInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Struct* weights_;
    int type_;
    int32_t workers_per_input_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class TaskInputSource final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.TaskInputSource) */ {
 public:
  inline TaskInputSource() : TaskInputSource(nullptr) {}
  ~TaskInputSource() override;
  explicit PROTOBUF_CONSTEXPR TaskInputSource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskInputSource(const TaskInputSource& from);
  TaskInputSource(TaskInputSource&& from) noexcept
    : TaskInputSource() {
    *this = ::std::move(from);
  }

  inline TaskInputSource& operator=(const TaskInputSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskInputSource& operator=(TaskInputSource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskInputSource& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskInputSource* internal_default_instance() {
    return reinterpret_cast<const TaskInputSource*>(
               &_TaskInputSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    128;

  friend void swap(TaskInputSource& a, TaskInputSource& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskInputSource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskInputSource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskInputSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskInputSource>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskInputSource& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TaskInputSource& from) {
    TaskInputSource::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskInputSource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.TaskInputSource";
  }
  protected:
  explicit TaskInputSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TaskInputSource_TaskInputSourceType TaskInputSourceType;
  static constexpr TaskInputSourceType INPUT_SOURCE_TYPE_NOT_SET =
    TaskInputSource_TaskInputSourceType_INPUT_SOURCE_TYPE_NOT_SET;
  static constexpr TaskInputSourceType ALL_INPUTS =
    TaskInputSource_TaskInputSourceType_ALL_INPUTS;
  static constexpr TaskInputSourceType SAVED_SEARCH =
    TaskInputSource_TaskInputSourceType_SAVED_SEARCH;
  static constexpr TaskInputSourceType DATASET =
    TaskInputSource_TaskInputSourceType_DATASET;
  static inline bool TaskInputSourceType_IsValid(int value) {
    return TaskInputSource_TaskInputSourceType_IsValid(value);
  }
  static constexpr TaskInputSourceType TaskInputSourceType_MIN =
    TaskInputSource_TaskInputSourceType_TaskInputSourceType_MIN;
  static constexpr TaskInputSourceType TaskInputSourceType_MAX =
    TaskInputSource_TaskInputSourceType_TaskInputSourceType_MAX;
  static constexpr int TaskInputSourceType_ARRAYSIZE =
    TaskInputSource_TaskInputSourceType_TaskInputSourceType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TaskInputSourceType_descriptor() {
    return TaskInputSource_TaskInputSourceType_descriptor();
  }
  template<typename T>
  static inline const std::string& TaskInputSourceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TaskInputSourceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TaskInputSourceType_Name.");
    return TaskInputSource_TaskInputSourceType_Name(enum_t_value);
  }
  static inline bool TaskInputSourceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TaskInputSourceType* value) {
    return TaskInputSource_TaskInputSourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // string id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .clarifai.api.TaskInputSource.TaskInputSourceType type = 1;
  void clear_type();
  ::clarifai::api::TaskInputSource_TaskInputSourceType type() const;
  void set_type(::clarifai::api::TaskInputSource_TaskInputSourceType value);
  private:
  ::clarifai::api::TaskInputSource_TaskInputSourceType _internal_type() const;
  void _internal_set_type(::clarifai::api::TaskInputSource_TaskInputSourceType value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.TaskInputSource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class TaskReview final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.TaskReview) */ {
 public:
  inline TaskReview() : TaskReview(nullptr) {}
  ~TaskReview() override;
  explicit PROTOBUF_CONSTEXPR TaskReview(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskReview(const TaskReview& from);
  TaskReview(TaskReview&& from) noexcept
    : TaskReview() {
    *this = ::std::move(from);
  }

  inline TaskReview& operator=(const TaskReview& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskReview& operator=(TaskReview&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskReview& default_instance() {
    return *internal_default_instance();
  }
  enum StrategyInfoCase {
    kManualStrategyInfo = 3,
    kConsensusStrategyInfo = 4,
    STRATEGY_INFO_NOT_SET = 0,
  };

  static inline const TaskReview* internal_default_instance() {
    return reinterpret_cast<const TaskReview*>(
               &_TaskReview_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    129;

  friend void swap(TaskReview& a, TaskReview& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskReview* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskReview* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskReview* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskReview>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskReview& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TaskReview& from) {
    TaskReview::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskReview* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.TaskReview";
  }
  protected:
  explicit TaskReview(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TaskReview_TaskReviewStrategy TaskReviewStrategy;
  static constexpr TaskReviewStrategy TASK_REVIEW_STRATEGY_NOT_SET =
    TaskReview_TaskReviewStrategy_TASK_REVIEW_STRATEGY_NOT_SET;
  static constexpr TaskReviewStrategy NONE =
    TaskReview_TaskReviewStrategy_NONE;
  static constexpr TaskReviewStrategy MANUAL =
    TaskReview_TaskReviewStrategy_MANUAL;
  static constexpr TaskReviewStrategy CONSENSUS =
    TaskReview_TaskReviewStrategy_CONSENSUS;
  static inline bool TaskReviewStrategy_IsValid(int value) {
    return TaskReview_TaskReviewStrategy_IsValid(value);
  }
  static constexpr TaskReviewStrategy TaskReviewStrategy_MIN =
    TaskReview_TaskReviewStrategy_TaskReviewStrategy_MIN;
  static constexpr TaskReviewStrategy TaskReviewStrategy_MAX =
    TaskReview_TaskReviewStrategy_TaskReviewStrategy_MAX;
  static constexpr int TaskReviewStrategy_ARRAYSIZE =
    TaskReview_TaskReviewStrategy_TaskReviewStrategy_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TaskReviewStrategy_descriptor() {
    return TaskReview_TaskReviewStrategy_descriptor();
  }
  template<typename T>
  static inline const std::string& TaskReviewStrategy_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TaskReviewStrategy>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TaskReviewStrategy_Name.");
    return TaskReview_TaskReviewStrategy_Name(enum_t_value);
  }
  static inline bool TaskReviewStrategy_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TaskReviewStrategy* value) {
    return TaskReview_TaskReviewStrategy_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdsFieldNumber = 2,
    kUsersFieldNumber = 5,
    kStrategyFieldNumber = 1,
    kManualStrategyInfoFieldNumber = 3,
    kConsensusStrategyInfoFieldNumber = 4,
  };
  // repeated string user_ids = 2 [deprecated = true];
  PROTOBUF_DEPRECATED int user_ids_size() const;
  private:
  int _internal_user_ids_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_user_ids();
  PROTOBUF_DEPRECATED const std::string& user_ids(int index) const;
  PROTOBUF_DEPRECATED std::string* mutable_user_ids(int index);
  PROTOBUF_DEPRECATED void set_user_ids(int index, const std::string& value);
  PROTOBUF_DEPRECATED void set_user_ids(int index, std::string&& value);
  PROTOBUF_DEPRECATED void set_user_ids(int index, const char* value);
  PROTOBUF_DEPRECATED void set_user_ids(int index, const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* add_user_ids();
  PROTOBUF_DEPRECATED void add_user_ids(const std::string& value);
  PROTOBUF_DEPRECATED void add_user_ids(std::string&& value);
  PROTOBUF_DEPRECATED void add_user_ids(const char* value);
  PROTOBUF_DEPRECATED void add_user_ids(const char* value, size_t size);
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& user_ids() const;
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_user_ids();
  private:
  const std::string& _internal_user_ids(int index) const;
  std::string* _internal_add_user_ids();
  public:

  // repeated .clarifai.api.User users = 5;
  int users_size() const;
  private:
  int _internal_users_size() const;
  public:
  void clear_users();
  ::clarifai::api::User* mutable_users(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::User >*
      mutable_users();
  private:
  const ::clarifai::api::User& _internal_users(int index) const;
  ::clarifai::api::User* _internal_add_users();
  public:
  const ::clarifai::api::User& users(int index) const;
  ::clarifai::api::User* add_users();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::User >&
      users() const;

  // .clarifai.api.TaskReview.TaskReviewStrategy strategy = 1;
  void clear_strategy();
  ::clarifai::api::TaskReview_TaskReviewStrategy strategy() const;
  void set_strategy(::clarifai::api::TaskReview_TaskReviewStrategy value);
  private:
  ::clarifai::api::TaskReview_TaskReviewStrategy _internal_strategy() const;
  void _internal_set_strategy(::clarifai::api::TaskReview_TaskReviewStrategy value);
  public:

  // .clarifai.api.TaskReviewManualStrategyInfo manual_strategy_info = 3;
  bool has_manual_strategy_info() const;
  private:
  bool _internal_has_manual_strategy_info() const;
  public:
  void clear_manual_strategy_info();
  const ::clarifai::api::TaskReviewManualStrategyInfo& manual_strategy_info() const;
  PROTOBUF_NODISCARD ::clarifai::api::TaskReviewManualStrategyInfo* release_manual_strategy_info();
  ::clarifai::api::TaskReviewManualStrategyInfo* mutable_manual_strategy_info();
  void set_allocated_manual_strategy_info(::clarifai::api::TaskReviewManualStrategyInfo* manual_strategy_info);
  private:
  const ::clarifai::api::TaskReviewManualStrategyInfo& _internal_manual_strategy_info() const;
  ::clarifai::api::TaskReviewManualStrategyInfo* _internal_mutable_manual_strategy_info();
  public:
  void unsafe_arena_set_allocated_manual_strategy_info(
      ::clarifai::api::TaskReviewManualStrategyInfo* manual_strategy_info);
  ::clarifai::api::TaskReviewManualStrategyInfo* unsafe_arena_release_manual_strategy_info();

  // .clarifai.api.TaskReviewConsensusStrategyInfo consensus_strategy_info = 4;
  bool has_consensus_strategy_info() const;
  private:
  bool _internal_has_consensus_strategy_info() const;
  public:
  void clear_consensus_strategy_info();
  const ::clarifai::api::TaskReviewConsensusStrategyInfo& consensus_strategy_info() const;
  PROTOBUF_NODISCARD ::clarifai::api::TaskReviewConsensusStrategyInfo* release_consensus_strategy_info();
  ::clarifai::api::TaskReviewConsensusStrategyInfo* mutable_consensus_strategy_info();
  void set_allocated_consensus_strategy_info(::clarifai::api::TaskReviewConsensusStrategyInfo* consensus_strategy_info);
  private:
  const ::clarifai::api::TaskReviewConsensusStrategyInfo& _internal_consensus_strategy_info() const;
  ::clarifai::api::TaskReviewConsensusStrategyInfo* _internal_mutable_consensus_strategy_info();
  public:
  void unsafe_arena_set_allocated_consensus_strategy_info(
      ::clarifai::api::TaskReviewConsensusStrategyInfo* consensus_strategy_info);
  ::clarifai::api::TaskReviewConsensusStrategyInfo* unsafe_arena_release_consensus_strategy_info();

  void clear_strategy_info();
  StrategyInfoCase strategy_info_case() const;
  // @@protoc_insertion_point(class_scope:clarifai.api.TaskReview)
 private:
  class _Internal;
  void set_has_manual_strategy_info();
  void set_has_consensus_strategy_info();

  inline bool has_strategy_info() const;
  inline void clear_has_strategy_info();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> user_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::User > users_;
    int strategy_;
    union StrategyInfoUnion {
      constexpr StrategyInfoUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::clarifai::api::TaskReviewManualStrategyInfo* manual_strategy_info_;
      ::clarifai::api::TaskReviewConsensusStrategyInfo* consensus_strategy_info_;
    } strategy_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class TaskReviewManualStrategyInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.TaskReviewManualStrategyInfo) */ {
 public:
  inline TaskReviewManualStrategyInfo() : TaskReviewManualStrategyInfo(nullptr) {}
  ~TaskReviewManualStrategyInfo() override;
  explicit PROTOBUF_CONSTEXPR TaskReviewManualStrategyInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskReviewManualStrategyInfo(const TaskReviewManualStrategyInfo& from);
  TaskReviewManualStrategyInfo(TaskReviewManualStrategyInfo&& from) noexcept
    : TaskReviewManualStrategyInfo() {
    *this = ::std::move(from);
  }

  inline TaskReviewManualStrategyInfo& operator=(const TaskReviewManualStrategyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskReviewManualStrategyInfo& operator=(TaskReviewManualStrategyInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskReviewManualStrategyInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskReviewManualStrategyInfo* internal_default_instance() {
    return reinterpret_cast<const TaskReviewManualStrategyInfo*>(
               &_TaskReviewManualStrategyInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    130;

  friend void swap(TaskReviewManualStrategyInfo& a, TaskReviewManualStrategyInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskReviewManualStrategyInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskReviewManualStrategyInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskReviewManualStrategyInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskReviewManualStrategyInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskReviewManualStrategyInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TaskReviewManualStrategyInfo& from) {
    TaskReviewManualStrategyInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskReviewManualStrategyInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.TaskReviewManualStrategyInfo";
  }
  protected:
  explicit TaskReviewManualStrategyInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSamplePercentageFieldNumber = 1,
  };
  // float sample_percentage = 1;
  void clear_sample_percentage();
  float sample_percentage() const;
  void set_sample_percentage(float value);
  private:
  float _internal_sample_percentage() const;
  void _internal_set_sample_percentage(float value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.TaskReviewManualStrategyInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float sample_percentage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class TaskReviewConsensusStrategyInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.TaskReviewConsensusStrategyInfo) */ {
 public:
  inline TaskReviewConsensusStrategyInfo() : TaskReviewConsensusStrategyInfo(nullptr) {}
  ~TaskReviewConsensusStrategyInfo() override;
  explicit PROTOBUF_CONSTEXPR TaskReviewConsensusStrategyInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskReviewConsensusStrategyInfo(const TaskReviewConsensusStrategyInfo& from);
  TaskReviewConsensusStrategyInfo(TaskReviewConsensusStrategyInfo&& from) noexcept
    : TaskReviewConsensusStrategyInfo() {
    *this = ::std::move(from);
  }

  inline TaskReviewConsensusStrategyInfo& operator=(const TaskReviewConsensusStrategyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskReviewConsensusStrategyInfo& operator=(TaskReviewConsensusStrategyInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskReviewConsensusStrategyInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskReviewConsensusStrategyInfo* internal_default_instance() {
    return reinterpret_cast<const TaskReviewConsensusStrategyInfo*>(
               &_TaskReviewConsensusStrategyInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    131;

  friend void swap(TaskReviewConsensusStrategyInfo& a, TaskReviewConsensusStrategyInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskReviewConsensusStrategyInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskReviewConsensusStrategyInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskReviewConsensusStrategyInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskReviewConsensusStrategyInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskReviewConsensusStrategyInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TaskReviewConsensusStrategyInfo& from) {
    TaskReviewConsensusStrategyInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskReviewConsensusStrategyInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.TaskReviewConsensusStrategyInfo";
  }
  protected:
  explicit TaskReviewConsensusStrategyInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApprovalThresholdFieldNumber = 2,
  };
  // uint32 approval_threshold = 2;
  void clear_approval_threshold();
  uint32_t approval_threshold() const;
  void set_approval_threshold(uint32_t value);
  private:
  uint32_t _internal_approval_threshold() const;
  void _internal_set_approval_threshold(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.TaskReviewConsensusStrategyInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t approval_threshold_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class TaskAIAssistant final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.TaskAIAssistant) */ {
 public:
  inline TaskAIAssistant() : TaskAIAssistant(nullptr) {}
  ~TaskAIAssistant() override;
  explicit PROTOBUF_CONSTEXPR TaskAIAssistant(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskAIAssistant(const TaskAIAssistant& from);
  TaskAIAssistant(TaskAIAssistant&& from) noexcept
    : TaskAIAssistant() {
    *this = ::std::move(from);
  }

  inline TaskAIAssistant& operator=(const TaskAIAssistant& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskAIAssistant& operator=(TaskAIAssistant&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskAIAssistant& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskAIAssistant* internal_default_instance() {
    return reinterpret_cast<const TaskAIAssistant*>(
               &_TaskAIAssistant_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    132;

  friend void swap(TaskAIAssistant& a, TaskAIAssistant& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskAIAssistant* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskAIAssistant* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskAIAssistant* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskAIAssistant>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskAIAssistant& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TaskAIAssistant& from) {
    TaskAIAssistant::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskAIAssistant* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.TaskAIAssistant";
  }
  protected:
  explicit TaskAIAssistant(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorkflowIdFieldNumber = 1,
  };
  // string workflow_id = 1;
  void clear_workflow_id();
  const std::string& workflow_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_workflow_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_workflow_id();
  PROTOBUF_NODISCARD std::string* release_workflow_id();
  void set_allocated_workflow_id(std::string* workflow_id);
  private:
  const std::string& _internal_workflow_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_workflow_id(const std::string& value);
  std::string* _internal_mutable_workflow_id();
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.TaskAIAssistant)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr workflow_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class TaskStatusCountPerUser final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.TaskStatusCountPerUser) */ {
 public:
  inline TaskStatusCountPerUser() : TaskStatusCountPerUser(nullptr) {}
  ~TaskStatusCountPerUser() override;
  explicit PROTOBUF_CONSTEXPR TaskStatusCountPerUser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskStatusCountPerUser(const TaskStatusCountPerUser& from);
  TaskStatusCountPerUser(TaskStatusCountPerUser&& from) noexcept
    : TaskStatusCountPerUser() {
    *this = ::std::move(from);
  }

  inline TaskStatusCountPerUser& operator=(const TaskStatusCountPerUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskStatusCountPerUser& operator=(TaskStatusCountPerUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskStatusCountPerUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskStatusCountPerUser* internal_default_instance() {
    return reinterpret_cast<const TaskStatusCountPerUser*>(
               &_TaskStatusCountPerUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    133;

  friend void swap(TaskStatusCountPerUser& a, TaskStatusCountPerUser& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskStatusCountPerUser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskStatusCountPerUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskStatusCountPerUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskStatusCountPerUser>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskStatusCountPerUser& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TaskStatusCountPerUser& from) {
    TaskStatusCountPerUser::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskStatusCountPerUser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.TaskStatusCountPerUser";
  }
  protected:
  explicit TaskStatusCountPerUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kPendingFieldNumber = 2,
    kAwaitingReviewFieldNumber = 3,
    kSuccessFieldNumber = 4,
    kReviewDeniedFieldNumber = 5,
    kAwaitingConsensusReviewFieldNumber = 6,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // uint32 pending = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_pending();
  uint32_t pending() const;
  void set_pending(uint32_t value);
  private:
  uint32_t _internal_pending() const;
  void _internal_set_pending(uint32_t value);
  public:

  // uint32 awaiting_review = 3 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_awaiting_review();
  uint32_t awaiting_review() const;
  void set_awaiting_review(uint32_t value);
  private:
  uint32_t _internal_awaiting_review() const;
  void _internal_set_awaiting_review(uint32_t value);
  public:

  // uint32 success = 4 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_success();
  uint32_t success() const;
  void set_success(uint32_t value);
  private:
  uint32_t _internal_success() const;
  void _internal_set_success(uint32_t value);
  public:

  // uint32 review_denied = 5 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_review_denied();
  uint32_t review_denied() const;
  void set_review_denied(uint32_t value);
  private:
  uint32_t _internal_review_denied() const;
  void _internal_set_review_denied(uint32_t value);
  public:

  // uint32 awaiting_consensus_review = 6 [(.clarifai.api.utils.cl_show_if_empty) = true];
  void clear_awaiting_consensus_review();
  uint32_t awaiting_consensus_review() const;
  void set_awaiting_consensus_review(uint32_t value);
  private:
  uint32_t _internal_awaiting_consensus_review() const;
  void _internal_set_awaiting_consensus_review(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.TaskStatusCountPerUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    uint32_t pending_;
    uint32_t awaiting_review_;
    uint32_t success_;
    uint32_t review_denied_;
    uint32_t awaiting_consensus_review_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Collector final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Collector) */ {
 public:
  inline Collector() : Collector(nullptr) {}
  ~Collector() override;
  explicit PROTOBUF_CONSTEXPR Collector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Collector(const Collector& from);
  Collector(Collector&& from) noexcept
    : Collector() {
    *this = ::std::move(from);
  }

  inline Collector& operator=(const Collector& from) {
    CopyFrom(from);
    return *this;
  }
  inline Collector& operator=(Collector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Collector& default_instance() {
    return *internal_default_instance();
  }
  static inline const Collector* internal_default_instance() {
    return reinterpret_cast<const Collector*>(
               &_Collector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    134;

  friend void swap(Collector& a, Collector& b) {
    a.Swap(&b);
  }
  inline void Swap(Collector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Collector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Collector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Collector>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Collector& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Collector& from) {
    Collector::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Collector* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Collector";
  }
  protected:
  explicit Collector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kPreQueueWorkflowIdFieldNumber = 4,
    kPostQueueWorkflowIdFieldNumber = 5,
    kCreatedAtFieldNumber = 3,
    kCollectorSourceFieldNumber = 6,
    kStatusFieldNumber = 7,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string pre_queue_workflow_id = 4;
  void clear_pre_queue_workflow_id();
  const std::string& pre_queue_workflow_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pre_queue_workflow_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pre_queue_workflow_id();
  PROTOBUF_NODISCARD std::string* release_pre_queue_workflow_id();
  void set_allocated_pre_queue_workflow_id(std::string* pre_queue_workflow_id);
  private:
  const std::string& _internal_pre_queue_workflow_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pre_queue_workflow_id(const std::string& value);
  std::string* _internal_mutable_pre_queue_workflow_id();
  public:

  // string post_queue_workflow_id = 5;
  void clear_post_queue_workflow_id();
  const std::string& post_queue_workflow_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_post_queue_workflow_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_post_queue_workflow_id();
  PROTOBUF_NODISCARD std::string* release_post_queue_workflow_id();
  void set_allocated_post_queue_workflow_id(std::string* post_queue_workflow_id);
  private:
  const std::string& _internal_post_queue_workflow_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_post_queue_workflow_id(const std::string& value);
  std::string* _internal_mutable_post_queue_workflow_id();
  public:

  // .google.protobuf.Timestamp created_at = 3;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .clarifai.api.CollectorSource collector_source = 6;
  bool has_collector_source() const;
  private:
  bool _internal_has_collector_source() const;
  public:
  void clear_collector_source();
  const ::clarifai::api::CollectorSource& collector_source() const;
  PROTOBUF_NODISCARD ::clarifai::api::CollectorSource* release_collector_source();
  ::clarifai::api::CollectorSource* mutable_collector_source();
  void set_allocated_collector_source(::clarifai::api::CollectorSource* collector_source);
  private:
  const ::clarifai::api::CollectorSource& _internal_collector_source() const;
  ::clarifai::api::CollectorSource* _internal_mutable_collector_source();
  public:
  void unsafe_arena_set_allocated_collector_source(
      ::clarifai::api::CollectorSource* collector_source);
  ::clarifai::api::CollectorSource* unsafe_arena_release_collector_source();

  // .clarifai.api.status.Status status = 7;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::clarifai::api::status::Status& status() const;
  PROTOBUF_NODISCARD ::clarifai::api::status::Status* release_status();
  ::clarifai::api::status::Status* mutable_status();
  void set_allocated_status(::clarifai::api::status::Status* status);
  private:
  const ::clarifai::api::status::Status& _internal_status() const;
  ::clarifai::api::status::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::clarifai::api::status::Status* status);
  ::clarifai::api::status::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:clarifai.api.Collector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pre_queue_workflow_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr post_queue_workflow_id_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::clarifai::api::CollectorSource* collector_source_;
    ::clarifai::api::status::Status* status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class CollectorSource final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.CollectorSource) */ {
 public:
  inline CollectorSource() : CollectorSource(nullptr) {}
  ~CollectorSource() override;
  explicit PROTOBUF_CONSTEXPR CollectorSource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CollectorSource(const CollectorSource& from);
  CollectorSource(CollectorSource&& from) noexcept
    : CollectorSource() {
    *this = ::std::move(from);
  }

  inline CollectorSource& operator=(const CollectorSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectorSource& operator=(CollectorSource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollectorSource& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollectorSource* internal_default_instance() {
    return reinterpret_cast<const CollectorSource*>(
               &_CollectorSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    135;

  friend void swap(CollectorSource& a, CollectorSource& b) {
    a.Swap(&b);
  }
  inline void Swap(CollectorSource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectorSource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollectorSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CollectorSource>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CollectorSource& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CollectorSource& from) {
    CollectorSource::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CollectorSource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.CollectorSource";
  }
  protected:
  explicit CollectorSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApiPostModelOutputsCollectorSourceFieldNumber = 2,
  };
  // .clarifai.api.APIPostModelOutputsCollectorSource api_post_model_outputs_collector_source = 2;
  bool has_api_post_model_outputs_collector_source() const;
  private:
  bool _internal_has_api_post_model_outputs_collector_source() const;
  public:
  void clear_api_post_model_outputs_collector_source();
  const ::clarifai::api::APIPostModelOutputsCollectorSource& api_post_model_outputs_collector_source() const;
  PROTOBUF_NODISCARD ::clarifai::api::APIPostModelOutputsCollectorSource* release_api_post_model_outputs_collector_source();
  ::clarifai::api::APIPostModelOutputsCollectorSource* mutable_api_post_model_outputs_collector_source();
  void set_allocated_api_post_model_outputs_collector_source(::clarifai::api::APIPostModelOutputsCollectorSource* api_post_model_outputs_collector_source);
  private:
  const ::clarifai::api::APIPostModelOutputsCollectorSource& _internal_api_post_model_outputs_collector_source() const;
  ::clarifai::api::APIPostModelOutputsCollectorSource* _internal_mutable_api_post_model_outputs_collector_source();
  public:
  void unsafe_arena_set_allocated_api_post_model_outputs_collector_source(
      ::clarifai::api::APIPostModelOutputsCollectorSource* api_post_model_outputs_collector_source);
  ::clarifai::api::APIPostModelOutputsCollectorSource* unsafe_arena_release_api_post_model_outputs_collector_source();

  // @@protoc_insertion_point(class_scope:clarifai.api.CollectorSource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::clarifai::api::APIPostModelOutputsCollectorSource* api_post_model_outputs_collector_source_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class APIPostModelOutputsCollectorSource final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.APIPostModelOutputsCollectorSource) */ {
 public:
  inline APIPostModelOutputsCollectorSource() : APIPostModelOutputsCollectorSource(nullptr) {}
  ~APIPostModelOutputsCollectorSource() override;
  explicit PROTOBUF_CONSTEXPR APIPostModelOutputsCollectorSource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  APIPostModelOutputsCollectorSource(const APIPostModelOutputsCollectorSource& from);
  APIPostModelOutputsCollectorSource(APIPostModelOutputsCollectorSource&& from) noexcept
    : APIPostModelOutputsCollectorSource() {
    *this = ::std::move(from);
  }

  inline APIPostModelOutputsCollectorSource& operator=(const APIPostModelOutputsCollectorSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline APIPostModelOutputsCollectorSource& operator=(APIPostModelOutputsCollectorSource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const APIPostModelOutputsCollectorSource& default_instance() {
    return *internal_default_instance();
  }
  static inline const APIPostModelOutputsCollectorSource* internal_default_instance() {
    return reinterpret_cast<const APIPostModelOutputsCollectorSource*>(
               &_APIPostModelOutputsCollectorSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    136;

  friend void swap(APIPostModelOutputsCollectorSource& a, APIPostModelOutputsCollectorSource& b) {
    a.Swap(&b);
  }
  inline void Swap(APIPostModelOutputsCollectorSource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(APIPostModelOutputsCollectorSource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  APIPostModelOutputsCollectorSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<APIPostModelOutputsCollectorSource>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const APIPostModelOutputsCollectorSource& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const APIPostModelOutputsCollectorSource& from) {
    APIPostModelOutputsCollectorSource::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(APIPostModelOutputsCollectorSource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.APIPostModelOutputsCollectorSource";
  }
  protected:
  explicit APIPostModelOutputsCollectorSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelUserIdFieldNumber = 1,
    kModelAppIdFieldNumber = 2,
    kModelIdFieldNumber = 3,
    kModelVersionIdFieldNumber = 4,
    kPostInputsKeyIdFieldNumber = 5,
  };
  // string model_user_id = 1;
  void clear_model_user_id();
  const std::string& model_user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_user_id();
  PROTOBUF_NODISCARD std::string* release_model_user_id();
  void set_allocated_model_user_id(std::string* model_user_id);
  private:
  const std::string& _internal_model_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_user_id(const std::string& value);
  std::string* _internal_mutable_model_user_id();
  public:

  // string model_app_id = 2;
  void clear_model_app_id();
  const std::string& model_app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_app_id();
  PROTOBUF_NODISCARD std::string* release_model_app_id();
  void set_allocated_model_app_id(std::string* model_app_id);
  private:
  const std::string& _internal_model_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_app_id(const std::string& value);
  std::string* _internal_mutable_model_app_id();
  public:

  // string model_id = 3;
  void clear_model_id();
  const std::string& model_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_id();
  PROTOBUF_NODISCARD std::string* release_model_id();
  void set_allocated_model_id(std::string* model_id);
  private:
  const std::string& _internal_model_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_id(const std::string& value);
  std::string* _internal_mutable_model_id();
  public:

  // string model_version_id = 4;
  void clear_model_version_id();
  const std::string& model_version_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_version_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_version_id();
  PROTOBUF_NODISCARD std::string* release_model_version_id();
  void set_allocated_model_version_id(std::string* model_version_id);
  private:
  const std::string& _internal_model_version_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_version_id(const std::string& value);
  std::string* _internal_mutable_model_version_id();
  public:

  // string post_inputs_key_id = 5;
  void clear_post_inputs_key_id();
  const std::string& post_inputs_key_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_post_inputs_key_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_post_inputs_key_id();
  PROTOBUF_NODISCARD std::string* release_post_inputs_key_id();
  void set_allocated_post_inputs_key_id(std::string* post_inputs_key_id);
  private:
  const std::string& _internal_post_inputs_key_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_post_inputs_key_id(const std::string& value);
  std::string* _internal_mutable_post_inputs_key_id();
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.APIPostModelOutputsCollectorSource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_app_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_version_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr post_inputs_key_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class StatValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.StatValue) */ {
 public:
  inline StatValue() : StatValue(nullptr) {}
  ~StatValue() override;
  explicit PROTOBUF_CONSTEXPR StatValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatValue(const StatValue& from);
  StatValue(StatValue&& from) noexcept
    : StatValue() {
    *this = ::std::move(from);
  }

  inline StatValue& operator=(const StatValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatValue& operator=(StatValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatValue* internal_default_instance() {
    return reinterpret_cast<const StatValue*>(
               &_StatValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    137;

  friend void swap(StatValue& a, StatValue& b) {
    a.Swap(&b);
  }
  inline void Swap(StatValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatValue& from) {
    StatValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.StatValue";
  }
  protected:
  explicit StatValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 3,
    kTimeFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // repeated string tags = 3;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // .google.protobuf.Timestamp time = 1;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_time();
  void set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_time();

  // float value = 2;
  void clear_value();
  float value() const;
  void set_value(float value);
  private:
  float _internal_value() const;
  void _internal_set_value(float value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.StatValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time_;
    float value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class StatValueAggregateResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.StatValueAggregateResult) */ {
 public:
  inline StatValueAggregateResult() : StatValueAggregateResult(nullptr) {}
  ~StatValueAggregateResult() override;
  explicit PROTOBUF_CONSTEXPR StatValueAggregateResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatValueAggregateResult(const StatValueAggregateResult& from);
  StatValueAggregateResult(StatValueAggregateResult&& from) noexcept
    : StatValueAggregateResult() {
    *this = ::std::move(from);
  }

  inline StatValueAggregateResult& operator=(const StatValueAggregateResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatValueAggregateResult& operator=(StatValueAggregateResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatValueAggregateResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatValueAggregateResult* internal_default_instance() {
    return reinterpret_cast<const StatValueAggregateResult*>(
               &_StatValueAggregateResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    138;

  friend void swap(StatValueAggregateResult& a, StatValueAggregateResult& b) {
    a.Swap(&b);
  }
  inline void Swap(StatValueAggregateResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatValueAggregateResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatValueAggregateResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatValueAggregateResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatValueAggregateResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatValueAggregateResult& from) {
    StatValueAggregateResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatValueAggregateResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.StatValueAggregateResult";
  }
  protected:
  explicit StatValueAggregateResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatValueAggregatesFieldNumber = 1,
    kStatValueAggregateQueryFieldNumber = 2,
  };
  // repeated .clarifai.api.StatValueAggregate stat_value_aggregates = 1;
  int stat_value_aggregates_size() const;
  private:
  int _internal_stat_value_aggregates_size() const;
  public:
  void clear_stat_value_aggregates();
  ::clarifai::api::StatValueAggregate* mutable_stat_value_aggregates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::StatValueAggregate >*
      mutable_stat_value_aggregates();
  private:
  const ::clarifai::api::StatValueAggregate& _internal_stat_value_aggregates(int index) const;
  ::clarifai::api::StatValueAggregate* _internal_add_stat_value_aggregates();
  public:
  const ::clarifai::api::StatValueAggregate& stat_value_aggregates(int index) const;
  ::clarifai::api::StatValueAggregate* add_stat_value_aggregates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::StatValueAggregate >&
      stat_value_aggregates() const;

  // .clarifai.api.StatValueAggregateQuery stat_value_aggregate_query = 2;
  bool has_stat_value_aggregate_query() const;
  private:
  bool _internal_has_stat_value_aggregate_query() const;
  public:
  void clear_stat_value_aggregate_query();
  const ::clarifai::api::StatValueAggregateQuery& stat_value_aggregate_query() const;
  PROTOBUF_NODISCARD ::clarifai::api::StatValueAggregateQuery* release_stat_value_aggregate_query();
  ::clarifai::api::StatValueAggregateQuery* mutable_stat_value_aggregate_query();
  void set_allocated_stat_value_aggregate_query(::clarifai::api::StatValueAggregateQuery* stat_value_aggregate_query);
  private:
  const ::clarifai::api::StatValueAggregateQuery& _internal_stat_value_aggregate_query() const;
  ::clarifai::api::StatValueAggregateQuery* _internal_mutable_stat_value_aggregate_query();
  public:
  void unsafe_arena_set_allocated_stat_value_aggregate_query(
      ::clarifai::api::StatValueAggregateQuery* stat_value_aggregate_query);
  ::clarifai::api::StatValueAggregateQuery* unsafe_arena_release_stat_value_aggregate_query();

  // @@protoc_insertion_point(class_scope:clarifai.api.StatValueAggregateResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::StatValueAggregate > stat_value_aggregates_;
    ::clarifai::api::StatValueAggregateQuery* stat_value_aggregate_query_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class StatValueAggregate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.StatValueAggregate) */ {
 public:
  inline StatValueAggregate() : StatValueAggregate(nullptr) {}
  ~StatValueAggregate() override;
  explicit PROTOBUF_CONSTEXPR StatValueAggregate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatValueAggregate(const StatValueAggregate& from);
  StatValueAggregate(StatValueAggregate&& from) noexcept
    : StatValueAggregate() {
    *this = ::std::move(from);
  }

  inline StatValueAggregate& operator=(const StatValueAggregate& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatValueAggregate& operator=(StatValueAggregate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatValueAggregate& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatValueAggregate* internal_default_instance() {
    return reinterpret_cast<const StatValueAggregate*>(
               &_StatValueAggregate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    139;

  friend void swap(StatValueAggregate& a, StatValueAggregate& b) {
    a.Swap(&b);
  }
  inline void Swap(StatValueAggregate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatValueAggregate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatValueAggregate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatValueAggregate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatValueAggregate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatValueAggregate& from) {
    StatValueAggregate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatValueAggregate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.StatValueAggregate";
  }
  protected:
  explicit StatValueAggregate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 4,
    kTimeFieldNumber = 1,
    kCountFieldNumber = 3,
    kAggregateValueFieldNumber = 2,
  };
  // repeated string tags = 4;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // .google.protobuf.Timestamp time = 1;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_time();
  void set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_time();

  // uint64 count = 3;
  void clear_count();
  uint64_t count() const;
  void set_count(uint64_t value);
  private:
  uint64_t _internal_count() const;
  void _internal_set_count(uint64_t value);
  public:

  // float aggregate_value = 2;
  void clear_aggregate_value();
  float aggregate_value() const;
  void set_aggregate_value(float value);
  private:
  float _internal_aggregate_value() const;
  void _internal_set_aggregate_value(float value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.StatValueAggregate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time_;
    uint64_t count_;
    float aggregate_value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class StatValueAggregateQuery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.StatValueAggregateQuery) */ {
 public:
  inline StatValueAggregateQuery() : StatValueAggregateQuery(nullptr) {}
  ~StatValueAggregateQuery() override;
  explicit PROTOBUF_CONSTEXPR StatValueAggregateQuery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatValueAggregateQuery(const StatValueAggregateQuery& from);
  StatValueAggregateQuery(StatValueAggregateQuery&& from) noexcept
    : StatValueAggregateQuery() {
    *this = ::std::move(from);
  }

  inline StatValueAggregateQuery& operator=(const StatValueAggregateQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatValueAggregateQuery& operator=(StatValueAggregateQuery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatValueAggregateQuery& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatValueAggregateQuery* internal_default_instance() {
    return reinterpret_cast<const StatValueAggregateQuery*>(
               &_StatValueAggregateQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    140;

  friend void swap(StatValueAggregateQuery& a, StatValueAggregateQuery& b) {
    a.Swap(&b);
  }
  inline void Swap(StatValueAggregateQuery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatValueAggregateQuery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatValueAggregateQuery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatValueAggregateQuery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatValueAggregateQuery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatValueAggregateQuery& from) {
    StatValueAggregateQuery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatValueAggregateQuery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.StatValueAggregateQuery";
  }
  protected:
  explicit StatValueAggregateQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 1,
    kTagGroupsFieldNumber = 2,
    kStartTimeFieldNumber = 5,
    kEndTimeFieldNumber = 6,
    kStatValueAggTypeFieldNumber = 3,
    kStatTimeAggTypeFieldNumber = 4,
  };
  // repeated string tags = 1;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // repeated string tag_groups = 2;
  int tag_groups_size() const;
  private:
  int _internal_tag_groups_size() const;
  public:
  void clear_tag_groups();
  const std::string& tag_groups(int index) const;
  std::string* mutable_tag_groups(int index);
  void set_tag_groups(int index, const std::string& value);
  void set_tag_groups(int index, std::string&& value);
  void set_tag_groups(int index, const char* value);
  void set_tag_groups(int index, const char* value, size_t size);
  std::string* add_tag_groups();
  void add_tag_groups(const std::string& value);
  void add_tag_groups(std::string&& value);
  void add_tag_groups(const char* value);
  void add_tag_groups(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tag_groups() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tag_groups();
  private:
  const std::string& _internal_tag_groups(int index) const;
  std::string* _internal_add_tag_groups();
  public:

  // .google.protobuf.Timestamp start_time = 5;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // .google.protobuf.Timestamp end_time = 6;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_time();
  void set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_time();
  public:
  void unsafe_arena_set_allocated_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_time();

  // .clarifai.api.StatValueAggType stat_value_agg_type = 3;
  void clear_stat_value_agg_type();
  ::clarifai::api::StatValueAggType stat_value_agg_type() const;
  void set_stat_value_agg_type(::clarifai::api::StatValueAggType value);
  private:
  ::clarifai::api::StatValueAggType _internal_stat_value_agg_type() const;
  void _internal_set_stat_value_agg_type(::clarifai::api::StatValueAggType value);
  public:

  // .clarifai.api.StatTimeAggType stat_time_agg_type = 4;
  void clear_stat_time_agg_type();
  ::clarifai::api::StatTimeAggType stat_time_agg_type() const;
  void set_stat_time_agg_type(::clarifai::api::StatTimeAggType value);
  private:
  ::clarifai::api::StatTimeAggType _internal_stat_time_agg_type() const;
  void _internal_set_stat_time_agg_type(::clarifai::api::StatTimeAggType value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.StatValueAggregateQuery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tag_groups_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time_;
    int stat_value_agg_type_;
    int stat_time_agg_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class DatasetInputsSearchAddJob final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.DatasetInputsSearchAddJob) */ {
 public:
  inline DatasetInputsSearchAddJob() : DatasetInputsSearchAddJob(nullptr) {}
  ~DatasetInputsSearchAddJob() override;
  explicit PROTOBUF_CONSTEXPR DatasetInputsSearchAddJob(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DatasetInputsSearchAddJob(const DatasetInputsSearchAddJob& from);
  DatasetInputsSearchAddJob(DatasetInputsSearchAddJob&& from) noexcept
    : DatasetInputsSearchAddJob() {
    *this = ::std::move(from);
  }

  inline DatasetInputsSearchAddJob& operator=(const DatasetInputsSearchAddJob& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatasetInputsSearchAddJob& operator=(DatasetInputsSearchAddJob&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatasetInputsSearchAddJob& default_instance() {
    return *internal_default_instance();
  }
  static inline const DatasetInputsSearchAddJob* internal_default_instance() {
    return reinterpret_cast<const DatasetInputsSearchAddJob*>(
               &_DatasetInputsSearchAddJob_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    141;

  friend void swap(DatasetInputsSearchAddJob& a, DatasetInputsSearchAddJob& b) {
    a.Swap(&b);
  }
  inline void Swap(DatasetInputsSearchAddJob* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatasetInputsSearchAddJob* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatasetInputsSearchAddJob* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatasetInputsSearchAddJob>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DatasetInputsSearchAddJob& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DatasetInputsSearchAddJob& from) {
    DatasetInputsSearchAddJob::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatasetInputsSearchAddJob* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.DatasetInputsSearchAddJob";
  }
  protected:
  explicit DatasetInputsSearchAddJob(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kDatasetIdFieldNumber = 5,
    kCreatedAtFieldNumber = 2,
    kModifiedAtFieldNumber = 3,
    kStatusFieldNumber = 4,
    kSearchFieldNumber = 6,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string dataset_id = 5;
  void clear_dataset_id();
  const std::string& dataset_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dataset_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dataset_id();
  PROTOBUF_NODISCARD std::string* release_dataset_id();
  void set_allocated_dataset_id(std::string* dataset_id);
  private:
  const std::string& _internal_dataset_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dataset_id(const std::string& value);
  std::string* _internal_mutable_dataset_id();
  public:

  // .google.protobuf.Timestamp created_at = 2;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp modified_at = 3;
  bool has_modified_at() const;
  private:
  bool _internal_has_modified_at() const;
  public:
  void clear_modified_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& modified_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_modified_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_modified_at();
  void set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_modified_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_modified_at();
  public:
  void unsafe_arena_set_allocated_modified_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_modified_at();

  // .clarifai.api.status.Status status = 4;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::clarifai::api::status::Status& status() const;
  PROTOBUF_NODISCARD ::clarifai::api::status::Status* release_status();
  ::clarifai::api::status::Status* mutable_status();
  void set_allocated_status(::clarifai::api::status::Status* status);
  private:
  const ::clarifai::api::status::Status& _internal_status() const;
  ::clarifai::api::status::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::clarifai::api::status::Status* status);
  ::clarifai::api::status::Status* unsafe_arena_release_status();

  // .clarifai.api.Search search = 6;
  bool has_search() const;
  private:
  bool _internal_has_search() const;
  public:
  void clear_search();
  const ::clarifai::api::Search& search() const;
  PROTOBUF_NODISCARD ::clarifai::api::Search* release_search();
  ::clarifai::api::Search* mutable_search();
  void set_allocated_search(::clarifai::api::Search* search);
  private:
  const ::clarifai::api::Search& _internal_search() const;
  ::clarifai::api::Search* _internal_mutable_search();
  public:
  void unsafe_arena_set_allocated_search(
      ::clarifai::api::Search* search);
  ::clarifai::api::Search* unsafe_arena_release_search();

  // @@protoc_insertion_point(class_scope:clarifai.api.DatasetInputsSearchAddJob)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dataset_id_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at_;
    ::clarifai::api::status::Status* status_;
    ::clarifai::api::Search* search_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Visibility final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Visibility) */ {
 public:
  inline Visibility() : Visibility(nullptr) {}
  ~Visibility() override;
  explicit PROTOBUF_CONSTEXPR Visibility(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Visibility(const Visibility& from);
  Visibility(Visibility&& from) noexcept
    : Visibility() {
    *this = ::std::move(from);
  }

  inline Visibility& operator=(const Visibility& from) {
    CopyFrom(from);
    return *this;
  }
  inline Visibility& operator=(Visibility&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Visibility& default_instance() {
    return *internal_default_instance();
  }
  static inline const Visibility* internal_default_instance() {
    return reinterpret_cast<const Visibility*>(
               &_Visibility_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    142;

  friend void swap(Visibility& a, Visibility& b) {
    a.Swap(&b);
  }
  inline void Swap(Visibility* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Visibility* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Visibility* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Visibility>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Visibility& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Visibility& from) {
    Visibility::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Visibility* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Visibility";
  }
  protected:
  explicit Visibility(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Visibility_Gettable Gettable;
  static constexpr Gettable UNKNOWN_VISIBILITY =
    Visibility_Gettable_UNKNOWN_VISIBILITY;
  static constexpr Gettable PRIVATE =
    Visibility_Gettable_PRIVATE;
  static constexpr Gettable ORG =
    Visibility_Gettable_ORG;
  static constexpr Gettable PUBLIC =
    Visibility_Gettable_PUBLIC;
  static inline bool Gettable_IsValid(int value) {
    return Visibility_Gettable_IsValid(value);
  }
  static constexpr Gettable Gettable_MIN =
    Visibility_Gettable_Gettable_MIN;
  static constexpr Gettable Gettable_MAX =
    Visibility_Gettable_Gettable_MAX;
  static constexpr int Gettable_ARRAYSIZE =
    Visibility_Gettable_Gettable_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Gettable_descriptor() {
    return Visibility_Gettable_descriptor();
  }
  template<typename T>
  static inline const std::string& Gettable_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Gettable>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Gettable_Name.");
    return Visibility_Gettable_Name(enum_t_value);
  }
  static inline bool Gettable_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Gettable* value) {
    return Visibility_Gettable_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGettableFieldNumber = 1,
  };
  // .clarifai.api.Visibility.Gettable gettable = 1;
  void clear_gettable();
  ::clarifai::api::Visibility_Gettable gettable() const;
  void set_gettable(::clarifai::api::Visibility_Gettable value);
  private:
  ::clarifai::api::Visibility_Gettable _internal_gettable() const;
  void _internal_set_gettable(::clarifai::api::Visibility_Gettable value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.Visibility)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int gettable_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class TrendingMetric final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.TrendingMetric) */ {
 public:
  inline TrendingMetric() : TrendingMetric(nullptr) {}
  ~TrendingMetric() override;
  explicit PROTOBUF_CONSTEXPR TrendingMetric(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrendingMetric(const TrendingMetric& from);
  TrendingMetric(TrendingMetric&& from) noexcept
    : TrendingMetric() {
    *this = ::std::move(from);
  }

  inline TrendingMetric& operator=(const TrendingMetric& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrendingMetric& operator=(TrendingMetric&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrendingMetric& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrendingMetric* internal_default_instance() {
    return reinterpret_cast<const TrendingMetric*>(
               &_TrendingMetric_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    143;

  friend void swap(TrendingMetric& a, TrendingMetric& b) {
    a.Swap(&b);
  }
  inline void Swap(TrendingMetric* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrendingMetric* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrendingMetric* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrendingMetric>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrendingMetric& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrendingMetric& from) {
    TrendingMetric::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrendingMetric* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.TrendingMetric";
  }
  protected:
  explicit TrendingMetric(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kAppIdFieldNumber = 2,
    kObjectIdFieldNumber = 3,
    kViewCountFieldNumber = 4,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string app_id = 2;
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // string object_id = 3;
  void clear_object_id();
  const std::string& object_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_object_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_object_id();
  PROTOBUF_NODISCARD std::string* release_object_id();
  void set_allocated_object_id(std::string* object_id);
  private:
  const std::string& _internal_object_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_object_id(const std::string& value);
  std::string* _internal_mutable_object_id();
  public:

  // uint64 view_count = 4;
  void clear_view_count();
  uint64_t view_count() const;
  void set_view_count(uint64_t value);
  private:
  uint64_t _internal_view_count() const;
  void _internal_set_view_count(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.TrendingMetric)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr object_id_;
    uint64_t view_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class FullTag final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.FullTag) */ {
 public:
  inline FullTag() : FullTag(nullptr) {}
  ~FullTag() override;
  explicit PROTOBUF_CONSTEXPR FullTag(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FullTag(const FullTag& from);
  FullTag(FullTag&& from) noexcept
    : FullTag() {
    *this = ::std::move(from);
  }

  inline FullTag& operator=(const FullTag& from) {
    CopyFrom(from);
    return *this;
  }
  inline FullTag& operator=(FullTag&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FullTag& default_instance() {
    return *internal_default_instance();
  }
  static inline const FullTag* internal_default_instance() {
    return reinterpret_cast<const FullTag*>(
               &_FullTag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    144;

  friend void swap(FullTag& a, FullTag& b) {
    a.Swap(&b);
  }
  inline void Swap(FullTag* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FullTag* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FullTag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FullTag>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FullTag& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FullTag& from) {
    FullTag::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FullTag* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.FullTag";
  }
  protected:
  explicit FullTag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.FullTag)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class TimeSegment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.TimeSegment) */ {
 public:
  inline TimeSegment() : TimeSegment(nullptr) {}
  ~TimeSegment() override;
  explicit PROTOBUF_CONSTEXPR TimeSegment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimeSegment(const TimeSegment& from);
  TimeSegment(TimeSegment&& from) noexcept
    : TimeSegment() {
    *this = ::std::move(from);
  }

  inline TimeSegment& operator=(const TimeSegment& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeSegment& operator=(TimeSegment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimeSegment& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeSegment* internal_default_instance() {
    return reinterpret_cast<const TimeSegment*>(
               &_TimeSegment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    145;

  friend void swap(TimeSegment& a, TimeSegment& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeSegment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeSegment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeSegment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimeSegment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TimeSegment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TimeSegment& from) {
    TimeSegment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeSegment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.TimeSegment";
  }
  protected:
  explicit TimeSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kDataFieldNumber = 2,
    kTimeInfoFieldNumber = 3,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .clarifai.api.Data data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::clarifai::api::Data& data() const;
  PROTOBUF_NODISCARD ::clarifai::api::Data* release_data();
  ::clarifai::api::Data* mutable_data();
  void set_allocated_data(::clarifai::api::Data* data);
  private:
  const ::clarifai::api::Data& _internal_data() const;
  ::clarifai::api::Data* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::clarifai::api::Data* data);
  ::clarifai::api::Data* unsafe_arena_release_data();

  // .clarifai.api.TimeInfo time_info = 3;
  bool has_time_info() const;
  private:
  bool _internal_has_time_info() const;
  public:
  void clear_time_info();
  const ::clarifai::api::TimeInfo& time_info() const;
  PROTOBUF_NODISCARD ::clarifai::api::TimeInfo* release_time_info();
  ::clarifai::api::TimeInfo* mutable_time_info();
  void set_allocated_time_info(::clarifai::api::TimeInfo* time_info);
  private:
  const ::clarifai::api::TimeInfo& _internal_time_info() const;
  ::clarifai::api::TimeInfo* _internal_mutable_time_info();
  public:
  void unsafe_arena_set_allocated_time_info(
      ::clarifai::api::TimeInfo* time_info);
  ::clarifai::api::TimeInfo* unsafe_arena_release_time_info();

  // @@protoc_insertion_point(class_scope:clarifai.api.TimeSegment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::clarifai::api::Data* data_;
    ::clarifai::api::TimeInfo* time_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class TimeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.TimeInfo) */ {
 public:
  inline TimeInfo() : TimeInfo(nullptr) {}
  ~TimeInfo() override;
  explicit PROTOBUF_CONSTEXPR TimeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimeInfo(const TimeInfo& from);
  TimeInfo(TimeInfo&& from) noexcept
    : TimeInfo() {
    *this = ::std::move(from);
  }

  inline TimeInfo& operator=(const TimeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeInfo& operator=(TimeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeInfo* internal_default_instance() {
    return reinterpret_cast<const TimeInfo*>(
               &_TimeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    146;

  friend void swap(TimeInfo& a, TimeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TimeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TimeInfo& from) {
    TimeInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.TimeInfo";
  }
  protected:
  explicit TimeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumFramesFieldNumber = 1,
    kBeginTimeFieldNumber = 2,
    kEndTimeFieldNumber = 3,
  };
  // uint32 num_frames = 1;
  void clear_num_frames();
  uint32_t num_frames() const;
  void set_num_frames(uint32_t value);
  private:
  uint32_t _internal_num_frames() const;
  void _internal_set_num_frames(uint32_t value);
  public:

  // uint32 begin_time = 2;
  void clear_begin_time();
  uint32_t begin_time() const;
  void set_begin_time(uint32_t value);
  private:
  uint32_t _internal_begin_time() const;
  void _internal_set_begin_time(uint32_t value);
  public:

  // uint32 end_time = 3;
  void clear_end_time();
  uint32_t end_time() const;
  void set_end_time(uint32_t value);
  private:
  uint32_t _internal_end_time() const;
  void _internal_set_end_time(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.TimeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t num_frames_;
    uint32_t begin_time_;
    uint32_t end_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Module final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Module) */ {
 public:
  inline Module() : Module(nullptr) {}
  ~Module() override;
  explicit PROTOBUF_CONSTEXPR Module(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Module(const Module& from);
  Module(Module&& from) noexcept
    : Module() {
    *this = ::std::move(from);
  }

  inline Module& operator=(const Module& from) {
    CopyFrom(from);
    return *this;
  }
  inline Module& operator=(Module&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Module& default_instance() {
    return *internal_default_instance();
  }
  static inline const Module* internal_default_instance() {
    return reinterpret_cast<const Module*>(
               &_Module_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    147;

  friend void swap(Module& a, Module& b) {
    a.Swap(&b);
  }
  inline void Swap(Module* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Module* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Module* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Module>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Module& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Module& from) {
    Module::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Module* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Module";
  }
  protected:
  explicit Module(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kDescriptionFieldNumber = 3,
    kUserIdFieldNumber = 9,
    kAppIdFieldNumber = 10,
    kCreatedAtFieldNumber = 4,
    kModifiedAtFieldNumber = 5,
    kVisibilityFieldNumber = 7,
    kMetadataFieldNumber = 8,
    kModuleVersionFieldNumber = 11,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string user_id = 9;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string app_id = 10;
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // .google.protobuf.Timestamp created_at = 4;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp modified_at = 5;
  bool has_modified_at() const;
  private:
  bool _internal_has_modified_at() const;
  public:
  void clear_modified_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& modified_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_modified_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_modified_at();
  void set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_modified_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_modified_at();
  public:
  void unsafe_arena_set_allocated_modified_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_modified_at();

  // .clarifai.api.Visibility visibility = 7;
  bool has_visibility() const;
  private:
  bool _internal_has_visibility() const;
  public:
  void clear_visibility();
  const ::clarifai::api::Visibility& visibility() const;
  PROTOBUF_NODISCARD ::clarifai::api::Visibility* release_visibility();
  ::clarifai::api::Visibility* mutable_visibility();
  void set_allocated_visibility(::clarifai::api::Visibility* visibility);
  private:
  const ::clarifai::api::Visibility& _internal_visibility() const;
  ::clarifai::api::Visibility* _internal_mutable_visibility();
  public:
  void unsafe_arena_set_allocated_visibility(
      ::clarifai::api::Visibility* visibility);
  ::clarifai::api::Visibility* unsafe_arena_release_visibility();

  // .google.protobuf.Struct metadata = 8;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  void set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata();

  // .clarifai.api.ModuleVersion module_version = 11;
  bool has_module_version() const;
  private:
  bool _internal_has_module_version() const;
  public:
  void clear_module_version();
  const ::clarifai::api::ModuleVersion& module_version() const;
  PROTOBUF_NODISCARD ::clarifai::api::ModuleVersion* release_module_version();
  ::clarifai::api::ModuleVersion* mutable_module_version();
  void set_allocated_module_version(::clarifai::api::ModuleVersion* module_version);
  private:
  const ::clarifai::api::ModuleVersion& _internal_module_version() const;
  ::clarifai::api::ModuleVersion* _internal_mutable_module_version();
  public:
  void unsafe_arena_set_allocated_module_version(
      ::clarifai::api::ModuleVersion* module_version);
  ::clarifai::api::ModuleVersion* unsafe_arena_release_module_version();

  // @@protoc_insertion_point(class_scope:clarifai.api.Module)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at_;
    ::clarifai::api::Visibility* visibility_;
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_;
    ::clarifai::api::ModuleVersion* module_version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ModuleVersion_ModuleSubNav final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.ModuleVersion.ModuleSubNav) */ {
 public:
  inline ModuleVersion_ModuleSubNav() : ModuleVersion_ModuleSubNav(nullptr) {}
  ~ModuleVersion_ModuleSubNav() override;
  explicit PROTOBUF_CONSTEXPR ModuleVersion_ModuleSubNav(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModuleVersion_ModuleSubNav(const ModuleVersion_ModuleSubNav& from);
  ModuleVersion_ModuleSubNav(ModuleVersion_ModuleSubNav&& from) noexcept
    : ModuleVersion_ModuleSubNav() {
    *this = ::std::move(from);
  }

  inline ModuleVersion_ModuleSubNav& operator=(const ModuleVersion_ModuleSubNav& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleVersion_ModuleSubNav& operator=(ModuleVersion_ModuleSubNav&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModuleVersion_ModuleSubNav& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModuleVersion_ModuleSubNav* internal_default_instance() {
    return reinterpret_cast<const ModuleVersion_ModuleSubNav*>(
               &_ModuleVersion_ModuleSubNav_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    148;

  friend void swap(ModuleVersion_ModuleSubNav& a, ModuleVersion_ModuleSubNav& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleVersion_ModuleSubNav* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModuleVersion_ModuleSubNav* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModuleVersion_ModuleSubNav* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModuleVersion_ModuleSubNav>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModuleVersion_ModuleSubNav& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModuleVersion_ModuleSubNav& from) {
    ModuleVersion_ModuleSubNav::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleVersion_ModuleSubNav* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.ModuleVersion.ModuleSubNav";
  }
  protected:
  explicit ModuleVersion_ModuleSubNav(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kQueryKeyFieldNumber = 2,
    kQueryValueFieldNumber = 3,
  };
  // string title = 1;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string query_key = 2;
  void clear_query_key();
  const std::string& query_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_query_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_query_key();
  PROTOBUF_NODISCARD std::string* release_query_key();
  void set_allocated_query_key(std::string* query_key);
  private:
  const std::string& _internal_query_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_query_key(const std::string& value);
  std::string* _internal_mutable_query_key();
  public:

  // string query_value = 3;
  void clear_query_value();
  const std::string& query_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_query_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_query_value();
  PROTOBUF_NODISCARD std::string* release_query_value();
  void set_allocated_query_value(std::string* query_value);
  private:
  const std::string& _internal_query_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_query_value(const std::string& value);
  std::string* _internal_mutable_query_value();
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.ModuleVersion.ModuleSubNav)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr query_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr query_value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ModuleVersion_ModuleNav final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.ModuleVersion.ModuleNav) */ {
 public:
  inline ModuleVersion_ModuleNav() : ModuleVersion_ModuleNav(nullptr) {}
  ~ModuleVersion_ModuleNav() override;
  explicit PROTOBUF_CONSTEXPR ModuleVersion_ModuleNav(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModuleVersion_ModuleNav(const ModuleVersion_ModuleNav& from);
  ModuleVersion_ModuleNav(ModuleVersion_ModuleNav&& from) noexcept
    : ModuleVersion_ModuleNav() {
    *this = ::std::move(from);
  }

  inline ModuleVersion_ModuleNav& operator=(const ModuleVersion_ModuleNav& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleVersion_ModuleNav& operator=(ModuleVersion_ModuleNav&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModuleVersion_ModuleNav& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModuleVersion_ModuleNav* internal_default_instance() {
    return reinterpret_cast<const ModuleVersion_ModuleNav*>(
               &_ModuleVersion_ModuleNav_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    149;

  friend void swap(ModuleVersion_ModuleNav& a, ModuleVersion_ModuleNav& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleVersion_ModuleNav* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModuleVersion_ModuleNav* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModuleVersion_ModuleNav* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModuleVersion_ModuleNav>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModuleVersion_ModuleNav& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModuleVersion_ModuleNav& from) {
    ModuleVersion_ModuleNav::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleVersion_ModuleNav* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.ModuleVersion.ModuleNav";
  }
  protected:
  explicit ModuleVersion_ModuleNav(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModuleSubNavsFieldNumber = 2,
    kTitleFieldNumber = 1,
  };
  // repeated .clarifai.api.ModuleVersion.ModuleSubNav module_sub_navs = 2;
  int module_sub_navs_size() const;
  private:
  int _internal_module_sub_navs_size() const;
  public:
  void clear_module_sub_navs();
  ::clarifai::api::ModuleVersion_ModuleSubNav* mutable_module_sub_navs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModuleVersion_ModuleSubNav >*
      mutable_module_sub_navs();
  private:
  const ::clarifai::api::ModuleVersion_ModuleSubNav& _internal_module_sub_navs(int index) const;
  ::clarifai::api::ModuleVersion_ModuleSubNav* _internal_add_module_sub_navs();
  public:
  const ::clarifai::api::ModuleVersion_ModuleSubNav& module_sub_navs(int index) const;
  ::clarifai::api::ModuleVersion_ModuleSubNav* add_module_sub_navs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModuleVersion_ModuleSubNav >&
      module_sub_navs() const;

  // string title = 1;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.ModuleVersion.ModuleNav)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModuleVersion_ModuleSubNav > module_sub_navs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ModuleVersion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.ModuleVersion) */ {
 public:
  inline ModuleVersion() : ModuleVersion(nullptr) {}
  ~ModuleVersion() override;
  explicit PROTOBUF_CONSTEXPR ModuleVersion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModuleVersion(const ModuleVersion& from);
  ModuleVersion(ModuleVersion&& from) noexcept
    : ModuleVersion() {
    *this = ::std::move(from);
  }

  inline ModuleVersion& operator=(const ModuleVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleVersion& operator=(ModuleVersion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModuleVersion& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModuleVersion* internal_default_instance() {
    return reinterpret_cast<const ModuleVersion*>(
               &_ModuleVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    150;

  friend void swap(ModuleVersion& a, ModuleVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleVersion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModuleVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModuleVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModuleVersion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModuleVersion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModuleVersion& from) {
    ModuleVersion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleVersion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.ModuleVersion";
  }
  protected:
  explicit ModuleVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModuleVersion_ModuleSubNav ModuleSubNav;
  typedef ModuleVersion_ModuleNav ModuleNav;

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kModuleIdFieldNumber = 2,
    kAppIdFieldNumber = 3,
    kUserIdFieldNumber = 4,
    kDescriptionFieldNumber = 6,
    kNotesFieldNumber = 7,
    kGitCommitUrlFieldNumber = 10,
    kCreatedAtFieldNumber = 8,
    kModifiedAtFieldNumber = 9,
    kModuleNavFieldNumber = 11,
    kVisibilityFieldNumber = 13,
    kMetadataFieldNumber = 14,
    kApprovedFieldNumber = 12,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string module_id = 2;
  void clear_module_id();
  const std::string& module_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_module_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_module_id();
  PROTOBUF_NODISCARD std::string* release_module_id();
  void set_allocated_module_id(std::string* module_id);
  private:
  const std::string& _internal_module_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module_id(const std::string& value);
  std::string* _internal_mutable_module_id();
  public:

  // string app_id = 3;
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // string user_id = 4;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string description = 6;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string notes = 7;
  void clear_notes();
  const std::string& notes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_notes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_notes();
  PROTOBUF_NODISCARD std::string* release_notes();
  void set_allocated_notes(std::string* notes);
  private:
  const std::string& _internal_notes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_notes(const std::string& value);
  std::string* _internal_mutable_notes();
  public:

  // string git_commit_url = 10;
  void clear_git_commit_url();
  const std::string& git_commit_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_git_commit_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_git_commit_url();
  PROTOBUF_NODISCARD std::string* release_git_commit_url();
  void set_allocated_git_commit_url(std::string* git_commit_url);
  private:
  const std::string& _internal_git_commit_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_git_commit_url(const std::string& value);
  std::string* _internal_mutable_git_commit_url();
  public:

  // .google.protobuf.Timestamp created_at = 8;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp modified_at = 9;
  bool has_modified_at() const;
  private:
  bool _internal_has_modified_at() const;
  public:
  void clear_modified_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& modified_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_modified_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_modified_at();
  void set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_modified_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_modified_at();
  public:
  void unsafe_arena_set_allocated_modified_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_modified_at();

  // .clarifai.api.ModuleVersion.ModuleNav module_nav = 11;
  bool has_module_nav() const;
  private:
  bool _internal_has_module_nav() const;
  public:
  void clear_module_nav();
  const ::clarifai::api::ModuleVersion_ModuleNav& module_nav() const;
  PROTOBUF_NODISCARD ::clarifai::api::ModuleVersion_ModuleNav* release_module_nav();
  ::clarifai::api::ModuleVersion_ModuleNav* mutable_module_nav();
  void set_allocated_module_nav(::clarifai::api::ModuleVersion_ModuleNav* module_nav);
  private:
  const ::clarifai::api::ModuleVersion_ModuleNav& _internal_module_nav() const;
  ::clarifai::api::ModuleVersion_ModuleNav* _internal_mutable_module_nav();
  public:
  void unsafe_arena_set_allocated_module_nav(
      ::clarifai::api::ModuleVersion_ModuleNav* module_nav);
  ::clarifai::api::ModuleVersion_ModuleNav* unsafe_arena_release_module_nav();

  // .clarifai.api.Visibility visibility = 13;
  bool has_visibility() const;
  private:
  bool _internal_has_visibility() const;
  public:
  void clear_visibility();
  const ::clarifai::api::Visibility& visibility() const;
  PROTOBUF_NODISCARD ::clarifai::api::Visibility* release_visibility();
  ::clarifai::api::Visibility* mutable_visibility();
  void set_allocated_visibility(::clarifai::api::Visibility* visibility);
  private:
  const ::clarifai::api::Visibility& _internal_visibility() const;
  ::clarifai::api::Visibility* _internal_mutable_visibility();
  public:
  void unsafe_arena_set_allocated_visibility(
      ::clarifai::api::Visibility* visibility);
  ::clarifai::api::Visibility* unsafe_arena_release_visibility();

  // .google.protobuf.Struct metadata = 14;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  void set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata();

  // bool approved = 12;
  void clear_approved();
  bool approved() const;
  void set_approved(bool value);
  private:
  bool _internal_approved() const;
  void _internal_set_approved(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.ModuleVersion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr module_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr notes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr git_commit_url_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at_;
    ::clarifai::api::ModuleVersion_ModuleNav* module_nav_;
    ::clarifai::api::Visibility* visibility_;
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_;
    bool approved_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class InstalledModuleVersion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.InstalledModuleVersion) */ {
 public:
  inline InstalledModuleVersion() : InstalledModuleVersion(nullptr) {}
  ~InstalledModuleVersion() override;
  explicit PROTOBUF_CONSTEXPR InstalledModuleVersion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstalledModuleVersion(const InstalledModuleVersion& from);
  InstalledModuleVersion(InstalledModuleVersion&& from) noexcept
    : InstalledModuleVersion() {
    *this = ::std::move(from);
  }

  inline InstalledModuleVersion& operator=(const InstalledModuleVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstalledModuleVersion& operator=(InstalledModuleVersion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstalledModuleVersion& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstalledModuleVersion* internal_default_instance() {
    return reinterpret_cast<const InstalledModuleVersion*>(
               &_InstalledModuleVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    151;

  friend void swap(InstalledModuleVersion& a, InstalledModuleVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(InstalledModuleVersion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstalledModuleVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstalledModuleVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstalledModuleVersion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstalledModuleVersion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InstalledModuleVersion& from) {
    InstalledModuleVersion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstalledModuleVersion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.InstalledModuleVersion";
  }
  protected:
  explicit InstalledModuleVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kAppIdFieldNumber = 3,
    kUserIdFieldNumber = 4,
    kDeployUrlFieldNumber = 7,
    kKeyIdFieldNumber = 9,
    kModuleVersionFieldNumber = 2,
    kCreatedAtFieldNumber = 5,
    kModifiedAtFieldNumber = 6,
    kVisibilityFieldNumber = 8,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string app_id = 3;
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // string user_id = 4;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string deploy_url = 7;
  void clear_deploy_url();
  const std::string& deploy_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deploy_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deploy_url();
  PROTOBUF_NODISCARD std::string* release_deploy_url();
  void set_allocated_deploy_url(std::string* deploy_url);
  private:
  const std::string& _internal_deploy_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deploy_url(const std::string& value);
  std::string* _internal_mutable_deploy_url();
  public:

  // string key_id = 9;
  void clear_key_id();
  const std::string& key_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key_id();
  PROTOBUF_NODISCARD std::string* release_key_id();
  void set_allocated_key_id(std::string* key_id);
  private:
  const std::string& _internal_key_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_id(const std::string& value);
  std::string* _internal_mutable_key_id();
  public:

  // .clarifai.api.ModuleVersion module_version = 2;
  bool has_module_version() const;
  private:
  bool _internal_has_module_version() const;
  public:
  void clear_module_version();
  const ::clarifai::api::ModuleVersion& module_version() const;
  PROTOBUF_NODISCARD ::clarifai::api::ModuleVersion* release_module_version();
  ::clarifai::api::ModuleVersion* mutable_module_version();
  void set_allocated_module_version(::clarifai::api::ModuleVersion* module_version);
  private:
  const ::clarifai::api::ModuleVersion& _internal_module_version() const;
  ::clarifai::api::ModuleVersion* _internal_mutable_module_version();
  public:
  void unsafe_arena_set_allocated_module_version(
      ::clarifai::api::ModuleVersion* module_version);
  ::clarifai::api::ModuleVersion* unsafe_arena_release_module_version();

  // .google.protobuf.Timestamp created_at = 5;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp modified_at = 6;
  bool has_modified_at() const;
  private:
  bool _internal_has_modified_at() const;
  public:
  void clear_modified_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& modified_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_modified_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_modified_at();
  void set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_modified_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_modified_at();
  public:
  void unsafe_arena_set_allocated_modified_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_modified_at();

  // .clarifai.api.Visibility visibility = 8;
  bool has_visibility() const;
  private:
  bool _internal_has_visibility() const;
  public:
  void clear_visibility();
  const ::clarifai::api::Visibility& visibility() const;
  PROTOBUF_NODISCARD ::clarifai::api::Visibility* release_visibility();
  ::clarifai::api::Visibility* mutable_visibility();
  void set_allocated_visibility(::clarifai::api::Visibility* visibility);
  private:
  const ::clarifai::api::Visibility& _internal_visibility() const;
  ::clarifai::api::Visibility* _internal_mutable_visibility();
  public:
  void unsafe_arena_set_allocated_visibility(
      ::clarifai::api::Visibility* visibility);
  ::clarifai::api::Visibility* unsafe_arena_release_visibility();

  // @@protoc_insertion_point(class_scope:clarifai.api.InstalledModuleVersion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deploy_url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_id_;
    ::clarifai::api::ModuleVersion* module_version_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at_;
    ::clarifai::api::Visibility* visibility_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class BulkOperation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.BulkOperation) */ {
 public:
  inline BulkOperation() : BulkOperation(nullptr) {}
  ~BulkOperation() override;
  explicit PROTOBUF_CONSTEXPR BulkOperation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BulkOperation(const BulkOperation& from);
  BulkOperation(BulkOperation&& from) noexcept
    : BulkOperation() {
    *this = ::std::move(from);
  }

  inline BulkOperation& operator=(const BulkOperation& from) {
    CopyFrom(from);
    return *this;
  }
  inline BulkOperation& operator=(BulkOperation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BulkOperation& default_instance() {
    return *internal_default_instance();
  }
  enum InputSourceCase {
    kInputIds = 2,
    kSearch = 10,
    INPUT_SOURCE_NOT_SET = 0,
  };

  static inline const BulkOperation* internal_default_instance() {
    return reinterpret_cast<const BulkOperation*>(
               &_BulkOperation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    152;

  friend void swap(BulkOperation& a, BulkOperation& b) {
    a.Swap(&b);
  }
  inline void Swap(BulkOperation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BulkOperation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BulkOperation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BulkOperation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BulkOperation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BulkOperation& from) {
    BulkOperation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BulkOperation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.BulkOperation";
  }
  protected:
  explicit BulkOperation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kAppIdFieldNumber = 4,
    kCreatedByFieldNumber = 7,
    kOperationFieldNumber = 3,
    kStatusFieldNumber = 5,
    kProgressFieldNumber = 6,
    kCreatedAtFieldNumber = 8,
    kLastModifiedAtFieldNumber = 9,
    kInputIdsFieldNumber = 2,
    kSearchFieldNumber = 10,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string app_id = 4;
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // string created_by = 7;
  void clear_created_by();
  const std::string& created_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_created_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_created_by();
  PROTOBUF_NODISCARD std::string* release_created_by();
  void set_allocated_created_by(std::string* created_by);
  private:
  const std::string& _internal_created_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_by(const std::string& value);
  std::string* _internal_mutable_created_by();
  public:

  // .clarifai.api.Operation operation = 3;
  bool has_operation() const;
  private:
  bool _internal_has_operation() const;
  public:
  void clear_operation();
  const ::clarifai::api::Operation& operation() const;
  PROTOBUF_NODISCARD ::clarifai::api::Operation* release_operation();
  ::clarifai::api::Operation* mutable_operation();
  void set_allocated_operation(::clarifai::api::Operation* operation);
  private:
  const ::clarifai::api::Operation& _internal_operation() const;
  ::clarifai::api::Operation* _internal_mutable_operation();
  public:
  void unsafe_arena_set_allocated_operation(
      ::clarifai::api::Operation* operation);
  ::clarifai::api::Operation* unsafe_arena_release_operation();

  // .clarifai.api.status.Status status = 5;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::clarifai::api::status::Status& status() const;
  PROTOBUF_NODISCARD ::clarifai::api::status::Status* release_status();
  ::clarifai::api::status::Status* mutable_status();
  void set_allocated_status(::clarifai::api::status::Status* status);
  private:
  const ::clarifai::api::status::Status& _internal_status() const;
  ::clarifai::api::status::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::clarifai::api::status::Status* status);
  ::clarifai::api::status::Status* unsafe_arena_release_status();

  // .clarifai.api.Progress progress = 6;
  bool has_progress() const;
  private:
  bool _internal_has_progress() const;
  public:
  void clear_progress();
  const ::clarifai::api::Progress& progress() const;
  PROTOBUF_NODISCARD ::clarifai::api::Progress* release_progress();
  ::clarifai::api::Progress* mutable_progress();
  void set_allocated_progress(::clarifai::api::Progress* progress);
  private:
  const ::clarifai::api::Progress& _internal_progress() const;
  ::clarifai::api::Progress* _internal_mutable_progress();
  public:
  void unsafe_arena_set_allocated_progress(
      ::clarifai::api::Progress* progress);
  ::clarifai::api::Progress* unsafe_arena_release_progress();

  // .google.protobuf.Timestamp created_at = 8;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp last_modified_at = 9;
  bool has_last_modified_at() const;
  private:
  bool _internal_has_last_modified_at() const;
  public:
  void clear_last_modified_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_modified_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_modified_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_modified_at();
  void set_allocated_last_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* last_modified_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_modified_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_modified_at();
  public:
  void unsafe_arena_set_allocated_last_modified_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_modified_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_modified_at();

  // .clarifai.api.InputIDs input_ids = 2;
  bool has_input_ids() const;
  private:
  bool _internal_has_input_ids() const;
  public:
  void clear_input_ids();
  const ::clarifai::api::InputIDs& input_ids() const;
  PROTOBUF_NODISCARD ::clarifai::api::InputIDs* release_input_ids();
  ::clarifai::api::InputIDs* mutable_input_ids();
  void set_allocated_input_ids(::clarifai::api::InputIDs* input_ids);
  private:
  const ::clarifai::api::InputIDs& _internal_input_ids() const;
  ::clarifai::api::InputIDs* _internal_mutable_input_ids();
  public:
  void unsafe_arena_set_allocated_input_ids(
      ::clarifai::api::InputIDs* input_ids);
  ::clarifai::api::InputIDs* unsafe_arena_release_input_ids();

  // .clarifai.api.Search search = 10;
  bool has_search() const;
  private:
  bool _internal_has_search() const;
  public:
  void clear_search();
  const ::clarifai::api::Search& search() const;
  PROTOBUF_NODISCARD ::clarifai::api::Search* release_search();
  ::clarifai::api::Search* mutable_search();
  void set_allocated_search(::clarifai::api::Search* search);
  private:
  const ::clarifai::api::Search& _internal_search() const;
  ::clarifai::api::Search* _internal_mutable_search();
  public:
  void unsafe_arena_set_allocated_search(
      ::clarifai::api::Search* search);
  ::clarifai::api::Search* unsafe_arena_release_search();

  void clear_input_source();
  InputSourceCase input_source_case() const;
  // @@protoc_insertion_point(class_scope:clarifai.api.BulkOperation)
 private:
  class _Internal;
  void set_has_input_ids();
  void set_has_search();

  inline bool has_input_source() const;
  inline void clear_has_input_source();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr created_by_;
    ::clarifai::api::Operation* operation_;
    ::clarifai::api::status::Status* status_;
    ::clarifai::api::Progress* progress_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_modified_at_;
    union InputSourceUnion {
      constexpr InputSourceUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::clarifai::api::InputIDs* input_ids_;
      ::clarifai::api::Search* search_;
    } input_source_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class InputIDs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.InputIDs) */ {
 public:
  inline InputIDs() : InputIDs(nullptr) {}
  ~InputIDs() override;
  explicit PROTOBUF_CONSTEXPR InputIDs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InputIDs(const InputIDs& from);
  InputIDs(InputIDs&& from) noexcept
    : InputIDs() {
    *this = ::std::move(from);
  }

  inline InputIDs& operator=(const InputIDs& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputIDs& operator=(InputIDs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputIDs& default_instance() {
    return *internal_default_instance();
  }
  static inline const InputIDs* internal_default_instance() {
    return reinterpret_cast<const InputIDs*>(
               &_InputIDs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    153;

  friend void swap(InputIDs& a, InputIDs& b) {
    a.Swap(&b);
  }
  inline void Swap(InputIDs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputIDs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputIDs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InputIDs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InputIDs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InputIDs& from) {
    InputIDs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputIDs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.InputIDs";
  }
  protected:
  explicit InputIDs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputIdsFieldNumber = 1,
  };
  // repeated string input_ids = 1;
  int input_ids_size() const;
  private:
  int _internal_input_ids_size() const;
  public:
  void clear_input_ids();
  const std::string& input_ids(int index) const;
  std::string* mutable_input_ids(int index);
  void set_input_ids(int index, const std::string& value);
  void set_input_ids(int index, std::string&& value);
  void set_input_ids(int index, const char* value);
  void set_input_ids(int index, const char* value, size_t size);
  std::string* add_input_ids();
  void add_input_ids(const std::string& value);
  void add_input_ids(std::string&& value);
  void add_input_ids(const char* value);
  void add_input_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& input_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_input_ids();
  private:
  const std::string& _internal_input_ids(int index) const;
  std::string* _internal_add_input_ids();
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.InputIDs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> input_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Progress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Progress) */ {
 public:
  inline Progress() : Progress(nullptr) {}
  ~Progress() override;
  explicit PROTOBUF_CONSTEXPR Progress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Progress(const Progress& from);
  Progress(Progress&& from) noexcept
    : Progress() {
    *this = ::std::move(from);
  }

  inline Progress& operator=(const Progress& from) {
    CopyFrom(from);
    return *this;
  }
  inline Progress& operator=(Progress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Progress& default_instance() {
    return *internal_default_instance();
  }
  static inline const Progress* internal_default_instance() {
    return reinterpret_cast<const Progress*>(
               &_Progress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    154;

  friend void swap(Progress& a, Progress& b) {
    a.Swap(&b);
  }
  inline void Swap(Progress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Progress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Progress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Progress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Progress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Progress& from) {
    Progress::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Progress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Progress";
  }
  protected:
  explicit Progress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLastProcessedIdFieldNumber = 2,
    kProcessedFieldNumber = 1,
  };
  // string last_processed_id = 2;
  void clear_last_processed_id();
  const std::string& last_processed_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_last_processed_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_last_processed_id();
  PROTOBUF_NODISCARD std::string* release_last_processed_id();
  void set_allocated_last_processed_id(std::string* last_processed_id);
  private:
  const std::string& _internal_last_processed_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_processed_id(const std::string& value);
  std::string* _internal_mutable_last_processed_id();
  public:

  // uint32 processed = 1;
  void clear_processed();
  uint32_t processed() const;
  void set_processed(uint32_t value);
  private:
  uint32_t _internal_processed() const;
  void _internal_set_processed(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.Progress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_processed_id_;
    uint32_t processed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Operation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Operation) */ {
 public:
  inline Operation() : Operation(nullptr) {}
  ~Operation() override;
  explicit PROTOBUF_CONSTEXPR Operation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Operation(const Operation& from);
  Operation(Operation&& from) noexcept
    : Operation() {
    *this = ::std::move(from);
  }

  inline Operation& operator=(const Operation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Operation& operator=(Operation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Operation& default_instance() {
    return *internal_default_instance();
  }
  enum OperationCase {
    kAddConcepts = 1,
    kDeleteConcepts = 2,
    kAddMetadata = 3,
    kDeleteMetadata = 4,
    kOverwriteGeo = 5,
    kDeleteGeo = 6,
    OPERATION_NOT_SET = 0,
  };

  static inline const Operation* internal_default_instance() {
    return reinterpret_cast<const Operation*>(
               &_Operation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    155;

  friend void swap(Operation& a, Operation& b) {
    a.Swap(&b);
  }
  inline void Swap(Operation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Operation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Operation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Operation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Operation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Operation& from) {
    Operation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Operation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Operation";
  }
  protected:
  explicit Operation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddConceptsFieldNumber = 1,
    kDeleteConceptsFieldNumber = 2,
    kAddMetadataFieldNumber = 3,
    kDeleteMetadataFieldNumber = 4,
    kOverwriteGeoFieldNumber = 5,
    kDeleteGeoFieldNumber = 6,
  };
  // .clarifai.api.AddConcepts add_concepts = 1;
  bool has_add_concepts() const;
  private:
  bool _internal_has_add_concepts() const;
  public:
  void clear_add_concepts();
  const ::clarifai::api::AddConcepts& add_concepts() const;
  PROTOBUF_NODISCARD ::clarifai::api::AddConcepts* release_add_concepts();
  ::clarifai::api::AddConcepts* mutable_add_concepts();
  void set_allocated_add_concepts(::clarifai::api::AddConcepts* add_concepts);
  private:
  const ::clarifai::api::AddConcepts& _internal_add_concepts() const;
  ::clarifai::api::AddConcepts* _internal_mutable_add_concepts();
  public:
  void unsafe_arena_set_allocated_add_concepts(
      ::clarifai::api::AddConcepts* add_concepts);
  ::clarifai::api::AddConcepts* unsafe_arena_release_add_concepts();

  // .clarifai.api.DeleteConcepts delete_concepts = 2;
  bool has_delete_concepts() const;
  private:
  bool _internal_has_delete_concepts() const;
  public:
  void clear_delete_concepts();
  const ::clarifai::api::DeleteConcepts& delete_concepts() const;
  PROTOBUF_NODISCARD ::clarifai::api::DeleteConcepts* release_delete_concepts();
  ::clarifai::api::DeleteConcepts* mutable_delete_concepts();
  void set_allocated_delete_concepts(::clarifai::api::DeleteConcepts* delete_concepts);
  private:
  const ::clarifai::api::DeleteConcepts& _internal_delete_concepts() const;
  ::clarifai::api::DeleteConcepts* _internal_mutable_delete_concepts();
  public:
  void unsafe_arena_set_allocated_delete_concepts(
      ::clarifai::api::DeleteConcepts* delete_concepts);
  ::clarifai::api::DeleteConcepts* unsafe_arena_release_delete_concepts();

  // .clarifai.api.AddMetadata add_metadata = 3;
  bool has_add_metadata() const;
  private:
  bool _internal_has_add_metadata() const;
  public:
  void clear_add_metadata();
  const ::clarifai::api::AddMetadata& add_metadata() const;
  PROTOBUF_NODISCARD ::clarifai::api::AddMetadata* release_add_metadata();
  ::clarifai::api::AddMetadata* mutable_add_metadata();
  void set_allocated_add_metadata(::clarifai::api::AddMetadata* add_metadata);
  private:
  const ::clarifai::api::AddMetadata& _internal_add_metadata() const;
  ::clarifai::api::AddMetadata* _internal_mutable_add_metadata();
  public:
  void unsafe_arena_set_allocated_add_metadata(
      ::clarifai::api::AddMetadata* add_metadata);
  ::clarifai::api::AddMetadata* unsafe_arena_release_add_metadata();

  // .clarifai.api.DeleteMetadata delete_metadata = 4;
  bool has_delete_metadata() const;
  private:
  bool _internal_has_delete_metadata() const;
  public:
  void clear_delete_metadata();
  const ::clarifai::api::DeleteMetadata& delete_metadata() const;
  PROTOBUF_NODISCARD ::clarifai::api::DeleteMetadata* release_delete_metadata();
  ::clarifai::api::DeleteMetadata* mutable_delete_metadata();
  void set_allocated_delete_metadata(::clarifai::api::DeleteMetadata* delete_metadata);
  private:
  const ::clarifai::api::DeleteMetadata& _internal_delete_metadata() const;
  ::clarifai::api::DeleteMetadata* _internal_mutable_delete_metadata();
  public:
  void unsafe_arena_set_allocated_delete_metadata(
      ::clarifai::api::DeleteMetadata* delete_metadata);
  ::clarifai::api::DeleteMetadata* unsafe_arena_release_delete_metadata();

  // .clarifai.api.OverwriteGeo overwrite_geo = 5;
  bool has_overwrite_geo() const;
  private:
  bool _internal_has_overwrite_geo() const;
  public:
  void clear_overwrite_geo();
  const ::clarifai::api::OverwriteGeo& overwrite_geo() const;
  PROTOBUF_NODISCARD ::clarifai::api::OverwriteGeo* release_overwrite_geo();
  ::clarifai::api::OverwriteGeo* mutable_overwrite_geo();
  void set_allocated_overwrite_geo(::clarifai::api::OverwriteGeo* overwrite_geo);
  private:
  const ::clarifai::api::OverwriteGeo& _internal_overwrite_geo() const;
  ::clarifai::api::OverwriteGeo* _internal_mutable_overwrite_geo();
  public:
  void unsafe_arena_set_allocated_overwrite_geo(
      ::clarifai::api::OverwriteGeo* overwrite_geo);
  ::clarifai::api::OverwriteGeo* unsafe_arena_release_overwrite_geo();

  // .clarifai.api.DeleteGeo delete_geo = 6;
  bool has_delete_geo() const;
  private:
  bool _internal_has_delete_geo() const;
  public:
  void clear_delete_geo();
  const ::clarifai::api::DeleteGeo& delete_geo() const;
  PROTOBUF_NODISCARD ::clarifai::api::DeleteGeo* release_delete_geo();
  ::clarifai::api::DeleteGeo* mutable_delete_geo();
  void set_allocated_delete_geo(::clarifai::api::DeleteGeo* delete_geo);
  private:
  const ::clarifai::api::DeleteGeo& _internal_delete_geo() const;
  ::clarifai::api::DeleteGeo* _internal_mutable_delete_geo();
  public:
  void unsafe_arena_set_allocated_delete_geo(
      ::clarifai::api::DeleteGeo* delete_geo);
  ::clarifai::api::DeleteGeo* unsafe_arena_release_delete_geo();

  void clear_operation();
  OperationCase operation_case() const;
  // @@protoc_insertion_point(class_scope:clarifai.api.Operation)
 private:
  class _Internal;
  void set_has_add_concepts();
  void set_has_delete_concepts();
  void set_has_add_metadata();
  void set_has_delete_metadata();
  void set_has_overwrite_geo();
  void set_has_delete_geo();

  inline bool has_operation() const;
  inline void clear_has_operation();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union OperationUnion {
      constexpr OperationUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::clarifai::api::AddConcepts* add_concepts_;
      ::clarifai::api::DeleteConcepts* delete_concepts_;
      ::clarifai::api::AddMetadata* add_metadata_;
      ::clarifai::api::DeleteMetadata* delete_metadata_;
      ::clarifai::api::OverwriteGeo* overwrite_geo_;
      ::clarifai::api::DeleteGeo* delete_geo_;
    } operation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class AddConcepts final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.AddConcepts) */ {
 public:
  inline AddConcepts() : AddConcepts(nullptr) {}
  ~AddConcepts() override;
  explicit PROTOBUF_CONSTEXPR AddConcepts(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddConcepts(const AddConcepts& from);
  AddConcepts(AddConcepts&& from) noexcept
    : AddConcepts() {
    *this = ::std::move(from);
  }

  inline AddConcepts& operator=(const AddConcepts& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddConcepts& operator=(AddConcepts&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddConcepts& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddConcepts* internal_default_instance() {
    return reinterpret_cast<const AddConcepts*>(
               &_AddConcepts_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    156;

  friend void swap(AddConcepts& a, AddConcepts& b) {
    a.Swap(&b);
  }
  inline void Swap(AddConcepts* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddConcepts* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddConcepts* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddConcepts>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddConcepts& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddConcepts& from) {
    AddConcepts::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddConcepts* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.AddConcepts";
  }
  protected:
  explicit AddConcepts(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConceptsFieldNumber = 1,
  };
  // repeated .clarifai.api.Concept concepts = 1;
  int concepts_size() const;
  private:
  int _internal_concepts_size() const;
  public:
  void clear_concepts();
  ::clarifai::api::Concept* mutable_concepts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept >*
      mutable_concepts();
  private:
  const ::clarifai::api::Concept& _internal_concepts(int index) const;
  ::clarifai::api::Concept* _internal_add_concepts();
  public:
  const ::clarifai::api::Concept& concepts(int index) const;
  ::clarifai::api::Concept* add_concepts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept >&
      concepts() const;

  // @@protoc_insertion_point(class_scope:clarifai.api.AddConcepts)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept > concepts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class DeleteConcepts final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.DeleteConcepts) */ {
 public:
  inline DeleteConcepts() : DeleteConcepts(nullptr) {}
  ~DeleteConcepts() override;
  explicit PROTOBUF_CONSTEXPR DeleteConcepts(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteConcepts(const DeleteConcepts& from);
  DeleteConcepts(DeleteConcepts&& from) noexcept
    : DeleteConcepts() {
    *this = ::std::move(from);
  }

  inline DeleteConcepts& operator=(const DeleteConcepts& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteConcepts& operator=(DeleteConcepts&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteConcepts& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteConcepts* internal_default_instance() {
    return reinterpret_cast<const DeleteConcepts*>(
               &_DeleteConcepts_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    157;

  friend void swap(DeleteConcepts& a, DeleteConcepts& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteConcepts* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteConcepts* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteConcepts* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteConcepts>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteConcepts& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteConcepts& from) {
    DeleteConcepts::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteConcepts* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.DeleteConcepts";
  }
  protected:
  explicit DeleteConcepts(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConceptsFieldNumber = 1,
    kUserIdsFieldNumber = 2,
  };
  // repeated .clarifai.api.Concept concepts = 1;
  int concepts_size() const;
  private:
  int _internal_concepts_size() const;
  public:
  void clear_concepts();
  ::clarifai::api::Concept* mutable_concepts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept >*
      mutable_concepts();
  private:
  const ::clarifai::api::Concept& _internal_concepts(int index) const;
  ::clarifai::api::Concept* _internal_add_concepts();
  public:
  const ::clarifai::api::Concept& concepts(int index) const;
  ::clarifai::api::Concept* add_concepts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept >&
      concepts() const;

  // repeated string user_ids = 2;
  int user_ids_size() const;
  private:
  int _internal_user_ids_size() const;
  public:
  void clear_user_ids();
  const std::string& user_ids(int index) const;
  std::string* mutable_user_ids(int index);
  void set_user_ids(int index, const std::string& value);
  void set_user_ids(int index, std::string&& value);
  void set_user_ids(int index, const char* value);
  void set_user_ids(int index, const char* value, size_t size);
  std::string* add_user_ids();
  void add_user_ids(const std::string& value);
  void add_user_ids(std::string&& value);
  void add_user_ids(const char* value);
  void add_user_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& user_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_user_ids();
  private:
  const std::string& _internal_user_ids(int index) const;
  std::string* _internal_add_user_ids();
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.DeleteConcepts)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept > concepts_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> user_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class AddMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.AddMetadata) */ {
 public:
  inline AddMetadata() : AddMetadata(nullptr) {}
  ~AddMetadata() override;
  explicit PROTOBUF_CONSTEXPR AddMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddMetadata(const AddMetadata& from);
  AddMetadata(AddMetadata&& from) noexcept
    : AddMetadata() {
    *this = ::std::move(from);
  }

  inline AddMetadata& operator=(const AddMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddMetadata& operator=(AddMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddMetadata* internal_default_instance() {
    return reinterpret_cast<const AddMetadata*>(
               &_AddMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    158;

  friend void swap(AddMetadata& a, AddMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(AddMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddMetadata& from) {
    AddMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.AddMetadata";
  }
  protected:
  explicit AddMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
  };
  // .google.protobuf.Struct metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  void set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:clarifai.api.AddMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class DeleteMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.DeleteMetadata) */ {
 public:
  inline DeleteMetadata() : DeleteMetadata(nullptr) {}
  ~DeleteMetadata() override;
  explicit PROTOBUF_CONSTEXPR DeleteMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteMetadata(const DeleteMetadata& from);
  DeleteMetadata(DeleteMetadata&& from) noexcept
    : DeleteMetadata() {
    *this = ::std::move(from);
  }

  inline DeleteMetadata& operator=(const DeleteMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteMetadata& operator=(DeleteMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteMetadata* internal_default_instance() {
    return reinterpret_cast<const DeleteMetadata*>(
               &_DeleteMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    159;

  friend void swap(DeleteMetadata& a, DeleteMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteMetadata& from) {
    DeleteMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.DeleteMetadata";
  }
  protected:
  explicit DeleteMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
  };
  // .google.protobuf.Struct metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  void set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:clarifai.api.DeleteMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class OverwriteGeo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.OverwriteGeo) */ {
 public:
  inline OverwriteGeo() : OverwriteGeo(nullptr) {}
  ~OverwriteGeo() override;
  explicit PROTOBUF_CONSTEXPR OverwriteGeo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OverwriteGeo(const OverwriteGeo& from);
  OverwriteGeo(OverwriteGeo&& from) noexcept
    : OverwriteGeo() {
    *this = ::std::move(from);
  }

  inline OverwriteGeo& operator=(const OverwriteGeo& from) {
    CopyFrom(from);
    return *this;
  }
  inline OverwriteGeo& operator=(OverwriteGeo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OverwriteGeo& default_instance() {
    return *internal_default_instance();
  }
  static inline const OverwriteGeo* internal_default_instance() {
    return reinterpret_cast<const OverwriteGeo*>(
               &_OverwriteGeo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    160;

  friend void swap(OverwriteGeo& a, OverwriteGeo& b) {
    a.Swap(&b);
  }
  inline void Swap(OverwriteGeo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OverwriteGeo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OverwriteGeo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OverwriteGeo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OverwriteGeo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OverwriteGeo& from) {
    OverwriteGeo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OverwriteGeo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.OverwriteGeo";
  }
  protected:
  explicit OverwriteGeo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGeoFieldNumber = 1,
  };
  // .clarifai.api.Geo geo = 1;
  bool has_geo() const;
  private:
  bool _internal_has_geo() const;
  public:
  void clear_geo();
  const ::clarifai::api::Geo& geo() const;
  PROTOBUF_NODISCARD ::clarifai::api::Geo* release_geo();
  ::clarifai::api::Geo* mutable_geo();
  void set_allocated_geo(::clarifai::api::Geo* geo);
  private:
  const ::clarifai::api::Geo& _internal_geo() const;
  ::clarifai::api::Geo* _internal_mutable_geo();
  public:
  void unsafe_arena_set_allocated_geo(
      ::clarifai::api::Geo* geo);
  ::clarifai::api::Geo* unsafe_arena_release_geo();

  // @@protoc_insertion_point(class_scope:clarifai.api.OverwriteGeo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::clarifai::api::Geo* geo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class DeleteGeo final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:clarifai.api.DeleteGeo) */ {
 public:
  inline DeleteGeo() : DeleteGeo(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteGeo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteGeo(const DeleteGeo& from);
  DeleteGeo(DeleteGeo&& from) noexcept
    : DeleteGeo() {
    *this = ::std::move(from);
  }

  inline DeleteGeo& operator=(const DeleteGeo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteGeo& operator=(DeleteGeo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteGeo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteGeo* internal_default_instance() {
    return reinterpret_cast<const DeleteGeo*>(
               &_DeleteGeo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    161;

  friend void swap(DeleteGeo& a, DeleteGeo& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteGeo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteGeo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteGeo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteGeo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteGeo& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteGeo& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.DeleteGeo";
  }
  protected:
  explicit DeleteGeo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:clarifai.api.DeleteGeo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class InputsAddJob final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.InputsAddJob) */ {
 public:
  inline InputsAddJob() : InputsAddJob(nullptr) {}
  ~InputsAddJob() override;
  explicit PROTOBUF_CONSTEXPR InputsAddJob(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InputsAddJob(const InputsAddJob& from);
  InputsAddJob(InputsAddJob&& from) noexcept
    : InputsAddJob() {
    *this = ::std::move(from);
  }

  inline InputsAddJob& operator=(const InputsAddJob& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputsAddJob& operator=(InputsAddJob&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputsAddJob& default_instance() {
    return *internal_default_instance();
  }
  static inline const InputsAddJob* internal_default_instance() {
    return reinterpret_cast<const InputsAddJob*>(
               &_InputsAddJob_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    162;

  friend void swap(InputsAddJob& a, InputsAddJob& b) {
    a.Swap(&b);
  }
  inline void Swap(InputsAddJob* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputsAddJob* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputsAddJob* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InputsAddJob>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InputsAddJob& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InputsAddJob& from) {
    InputsAddJob::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputsAddJob* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.InputsAddJob";
  }
  protected:
  explicit InputsAddJob(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtractionJobsFieldNumber = 10,
    kIdFieldNumber = 1,
    kCloudStorageUrlFieldNumber = 2,
    kCallBackUrlFieldNumber = 3,
    kAppPatFieldNumber = 4,
    kProgressFieldNumber = 7,
    kCreatedAtFieldNumber = 8,
    kModifiedAtFieldNumber = 9,
  };
  // repeated .clarifai.api.InputsExtractionJob extraction_jobs = 10;
  int extraction_jobs_size() const;
  private:
  int _internal_extraction_jobs_size() const;
  public:
  void clear_extraction_jobs();
  ::clarifai::api::InputsExtractionJob* mutable_extraction_jobs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::InputsExtractionJob >*
      mutable_extraction_jobs();
  private:
  const ::clarifai::api::InputsExtractionJob& _internal_extraction_jobs(int index) const;
  ::clarifai::api::InputsExtractionJob* _internal_add_extraction_jobs();
  public:
  const ::clarifai::api::InputsExtractionJob& extraction_jobs(int index) const;
  ::clarifai::api::InputsExtractionJob* add_extraction_jobs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::InputsExtractionJob >&
      extraction_jobs() const;

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string cloud_storage_url = 2;
  void clear_cloud_storage_url();
  const std::string& cloud_storage_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cloud_storage_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cloud_storage_url();
  PROTOBUF_NODISCARD std::string* release_cloud_storage_url();
  void set_allocated_cloud_storage_url(std::string* cloud_storage_url);
  private:
  const std::string& _internal_cloud_storage_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cloud_storage_url(const std::string& value);
  std::string* _internal_mutable_cloud_storage_url();
  public:

  // string call_back_url = 3;
  void clear_call_back_url();
  const std::string& call_back_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_call_back_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_call_back_url();
  PROTOBUF_NODISCARD std::string* release_call_back_url();
  void set_allocated_call_back_url(std::string* call_back_url);
  private:
  const std::string& _internal_call_back_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_call_back_url(const std::string& value);
  std::string* _internal_mutable_call_back_url();
  public:

  // string app_pat = 4;
  void clear_app_pat();
  const std::string& app_pat() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_pat(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_pat();
  PROTOBUF_NODISCARD std::string* release_app_pat();
  void set_allocated_app_pat(std::string* app_pat);
  private:
  const std::string& _internal_app_pat() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_pat(const std::string& value);
  std::string* _internal_mutable_app_pat();
  public:

  // .clarifai.api.InputsAddJobProgress progress = 7;
  bool has_progress() const;
  private:
  bool _internal_has_progress() const;
  public:
  void clear_progress();
  const ::clarifai::api::InputsAddJobProgress& progress() const;
  PROTOBUF_NODISCARD ::clarifai::api::InputsAddJobProgress* release_progress();
  ::clarifai::api::InputsAddJobProgress* mutable_progress();
  void set_allocated_progress(::clarifai::api::InputsAddJobProgress* progress);
  private:
  const ::clarifai::api::InputsAddJobProgress& _internal_progress() const;
  ::clarifai::api::InputsAddJobProgress* _internal_mutable_progress();
  public:
  void unsafe_arena_set_allocated_progress(
      ::clarifai::api::InputsAddJobProgress* progress);
  ::clarifai::api::InputsAddJobProgress* unsafe_arena_release_progress();

  // .google.protobuf.Timestamp created_at = 8;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp modified_at = 9;
  bool has_modified_at() const;
  private:
  bool _internal_has_modified_at() const;
  public:
  void clear_modified_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& modified_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_modified_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_modified_at();
  void set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_modified_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_modified_at();
  public:
  void unsafe_arena_set_allocated_modified_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_modified_at();

  // @@protoc_insertion_point(class_scope:clarifai.api.InputsAddJob)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::InputsExtractionJob > extraction_jobs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cloud_storage_url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr call_back_url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_pat_;
    ::clarifai::api::InputsAddJobProgress* progress_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class InputsAddJobProgress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.InputsAddJobProgress) */ {
 public:
  inline InputsAddJobProgress() : InputsAddJobProgress(nullptr) {}
  ~InputsAddJobProgress() override;
  explicit PROTOBUF_CONSTEXPR InputsAddJobProgress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InputsAddJobProgress(const InputsAddJobProgress& from);
  InputsAddJobProgress(InputsAddJobProgress&& from) noexcept
    : InputsAddJobProgress() {
    *this = ::std::move(from);
  }

  inline InputsAddJobProgress& operator=(const InputsAddJobProgress& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputsAddJobProgress& operator=(InputsAddJobProgress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputsAddJobProgress& default_instance() {
    return *internal_default_instance();
  }
  static inline const InputsAddJobProgress* internal_default_instance() {
    return reinterpret_cast<const InputsAddJobProgress*>(
               &_InputsAddJobProgress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    163;

  friend void swap(InputsAddJobProgress& a, InputsAddJobProgress& b) {
    a.Swap(&b);
  }
  inline void Swap(InputsAddJobProgress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputsAddJobProgress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputsAddJobProgress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InputsAddJobProgress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InputsAddJobProgress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InputsAddJobProgress& from) {
    InputsAddJobProgress::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputsAddJobProgress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.InputsAddJobProgress";
  }
  protected:
  explicit InputsAddJobProgress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPendingCountFieldNumber = 1,
    kInProgressCountFieldNumber = 2,
    kSuccessCountFieldNumber = 3,
    kFailedCountFieldNumber = 4,
  };
  // uint64 pending_count = 1;
  void clear_pending_count();
  uint64_t pending_count() const;
  void set_pending_count(uint64_t value);
  private:
  uint64_t _internal_pending_count() const;
  void _internal_set_pending_count(uint64_t value);
  public:

  // uint64 in_progress_count = 2;
  void clear_in_progress_count();
  uint64_t in_progress_count() const;
  void set_in_progress_count(uint64_t value);
  private:
  uint64_t _internal_in_progress_count() const;
  void _internal_set_in_progress_count(uint64_t value);
  public:

  // uint64 success_count = 3;
  void clear_success_count();
  uint64_t success_count() const;
  void set_success_count(uint64_t value);
  private:
  uint64_t _internal_success_count() const;
  void _internal_set_success_count(uint64_t value);
  public:

  // uint64 failed_count = 4;
  void clear_failed_count();
  uint64_t failed_count() const;
  void set_failed_count(uint64_t value);
  private:
  uint64_t _internal_failed_count() const;
  void _internal_set_failed_count(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.InputsAddJobProgress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t pending_count_;
    uint64_t in_progress_count_;
    uint64_t success_count_;
    uint64_t failed_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Upload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.Upload) */ {
 public:
  inline Upload() : Upload(nullptr) {}
  ~Upload() override;
  explicit PROTOBUF_CONSTEXPR Upload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Upload(const Upload& from);
  Upload(Upload&& from) noexcept
    : Upload() {
    *this = ::std::move(from);
  }

  inline Upload& operator=(const Upload& from) {
    CopyFrom(from);
    return *this;
  }
  inline Upload& operator=(Upload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Upload& default_instance() {
    return *internal_default_instance();
  }
  static inline const Upload* internal_default_instance() {
    return reinterpret_cast<const Upload*>(
               &_Upload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    164;

  friend void swap(Upload& a, Upload& b) {
    a.Swap(&b);
  }
  inline void Swap(Upload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Upload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Upload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Upload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Upload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Upload& from) {
    Upload::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Upload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.Upload";
  }
  protected:
  explicit Upload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kContentUrlFieldNumber = 7,
    kContentNameFieldNumber = 8,
    kCreatedAtFieldNumber = 2,
    kModifiedAtFieldNumber = 3,
    kExpiresAtFieldNumber = 4,
    kStatusFieldNumber = 5,
    kContentLengthFieldNumber = 6,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string content_url = 7;
  void clear_content_url();
  const std::string& content_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content_url();
  PROTOBUF_NODISCARD std::string* release_content_url();
  void set_allocated_content_url(std::string* content_url);
  private:
  const std::string& _internal_content_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content_url(const std::string& value);
  std::string* _internal_mutable_content_url();
  public:

  // string content_name = 8;
  void clear_content_name();
  const std::string& content_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content_name();
  PROTOBUF_NODISCARD std::string* release_content_name();
  void set_allocated_content_name(std::string* content_name);
  private:
  const std::string& _internal_content_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content_name(const std::string& value);
  std::string* _internal_mutable_content_name();
  public:

  // .google.protobuf.Timestamp created_at = 2;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp modified_at = 3;
  bool has_modified_at() const;
  private:
  bool _internal_has_modified_at() const;
  public:
  void clear_modified_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& modified_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_modified_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_modified_at();
  void set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_modified_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_modified_at();
  public:
  void unsafe_arena_set_allocated_modified_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_modified_at();

  // .google.protobuf.Timestamp expires_at = 4;
  bool has_expires_at() const;
  private:
  bool _internal_has_expires_at() const;
  public:
  void clear_expires_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& expires_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_expires_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_expires_at();
  void set_allocated_expires_at(::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_expires_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_expires_at();
  public:
  void unsafe_arena_set_allocated_expires_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_expires_at();

  // .clarifai.api.status.Status status = 5;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::clarifai::api::status::Status& status() const;
  PROTOBUF_NODISCARD ::clarifai::api::status::Status* release_status();
  ::clarifai::api::status::Status* mutable_status();
  void set_allocated_status(::clarifai::api::status::Status* status);
  private:
  const ::clarifai::api::status::Status& _internal_status() const;
  ::clarifai::api::status::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::clarifai::api::status::Status* status);
  ::clarifai::api::status::Status* unsafe_arena_release_status();

  // uint64 content_length = 6;
  void clear_content_length();
  uint64_t content_length() const;
  void set_content_length(uint64_t value);
  private:
  uint64_t _internal_content_length() const;
  void _internal_set_content_length(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.Upload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_name_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at_;
    ::clarifai::api::status::Status* status_;
    uint64_t content_length_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class UploadContentPart final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.UploadContentPart) */ {
 public:
  inline UploadContentPart() : UploadContentPart(nullptr) {}
  ~UploadContentPart() override;
  explicit PROTOBUF_CONSTEXPR UploadContentPart(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadContentPart(const UploadContentPart& from);
  UploadContentPart(UploadContentPart&& from) noexcept
    : UploadContentPart() {
    *this = ::std::move(from);
  }

  inline UploadContentPart& operator=(const UploadContentPart& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadContentPart& operator=(UploadContentPart&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadContentPart& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadContentPart* internal_default_instance() {
    return reinterpret_cast<const UploadContentPart*>(
               &_UploadContentPart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    165;

  friend void swap(UploadContentPart& a, UploadContentPart& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadContentPart* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadContentPart* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadContentPart* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadContentPart>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadContentPart& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UploadContentPart& from) {
    UploadContentPart::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadContentPart* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.UploadContentPart";
  }
  protected:
  explicit UploadContentPart(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kRangeStartFieldNumber = 1,
    kPartNumberFieldNumber = 2,
  };
  // bytes data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // uint64 range_start = 1;
  void clear_range_start();
  uint64_t range_start() const;
  void set_range_start(uint64_t value);
  private:
  uint64_t _internal_range_start() const;
  void _internal_set_range_start(uint64_t value);
  public:

  // int64 part_number = 2;
  void clear_part_number();
  int64_t part_number() const;
  void set_part_number(int64_t value);
  private:
  int64_t _internal_part_number() const;
  void _internal_set_part_number(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.UploadContentPart)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    uint64_t range_start_;
    int64_t part_number_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class InputsExtractionJob final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.InputsExtractionJob) */ {
 public:
  inline InputsExtractionJob() : InputsExtractionJob(nullptr) {}
  ~InputsExtractionJob() override;
  explicit PROTOBUF_CONSTEXPR InputsExtractionJob(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InputsExtractionJob(const InputsExtractionJob& from);
  InputsExtractionJob(InputsExtractionJob&& from) noexcept
    : InputsExtractionJob() {
    *this = ::std::move(from);
  }

  inline InputsExtractionJob& operator=(const InputsExtractionJob& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputsExtractionJob& operator=(InputsExtractionJob&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputsExtractionJob& default_instance() {
    return *internal_default_instance();
  }
  static inline const InputsExtractionJob* internal_default_instance() {
    return reinterpret_cast<const InputsExtractionJob*>(
               &_InputsExtractionJob_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    166;

  friend void swap(InputsExtractionJob& a, InputsExtractionJob& b) {
    a.Swap(&b);
  }
  inline void Swap(InputsExtractionJob* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputsExtractionJob* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputsExtractionJob* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InputsExtractionJob>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InputsExtractionJob& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InputsExtractionJob& from) {
    InputsExtractionJob::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputsExtractionJob* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.InputsExtractionJob";
  }
  protected:
  explicit InputsExtractionJob(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kUrlFieldNumber = 3,
    kStatusFieldNumber = 1,
    kProgressFieldNumber = 4,
    kCreatedAtFieldNumber = 5,
    kModifiedAtFieldNumber = 6,
  };
  // string id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string url = 3;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // .clarifai.api.status.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::clarifai::api::status::Status& status() const;
  PROTOBUF_NODISCARD ::clarifai::api::status::Status* release_status();
  ::clarifai::api::status::Status* mutable_status();
  void set_allocated_status(::clarifai::api::status::Status* status);
  private:
  const ::clarifai::api::status::Status& _internal_status() const;
  ::clarifai::api::status::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::clarifai::api::status::Status* status);
  ::clarifai::api::status::Status* unsafe_arena_release_status();

  // .clarifai.api.InputsExtractionJobProgress progress = 4;
  bool has_progress() const;
  private:
  bool _internal_has_progress() const;
  public:
  void clear_progress();
  const ::clarifai::api::InputsExtractionJobProgress& progress() const;
  PROTOBUF_NODISCARD ::clarifai::api::InputsExtractionJobProgress* release_progress();
  ::clarifai::api::InputsExtractionJobProgress* mutable_progress();
  void set_allocated_progress(::clarifai::api::InputsExtractionJobProgress* progress);
  private:
  const ::clarifai::api::InputsExtractionJobProgress& _internal_progress() const;
  ::clarifai::api::InputsExtractionJobProgress* _internal_mutable_progress();
  public:
  void unsafe_arena_set_allocated_progress(
      ::clarifai::api::InputsExtractionJobProgress* progress);
  ::clarifai::api::InputsExtractionJobProgress* unsafe_arena_release_progress();

  // .google.protobuf.Timestamp created_at = 5;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp modified_at = 6;
  bool has_modified_at() const;
  private:
  bool _internal_has_modified_at() const;
  public:
  void clear_modified_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& modified_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_modified_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_modified_at();
  void set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_modified_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_modified_at();
  public:
  void unsafe_arena_set_allocated_modified_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_modified_at();

  // @@protoc_insertion_point(class_scope:clarifai.api.InputsExtractionJob)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::clarifai::api::status::Status* status_;
    ::clarifai::api::InputsExtractionJobProgress* progress_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class InputsExtractionJobProgress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.InputsExtractionJobProgress) */ {
 public:
  inline InputsExtractionJobProgress() : InputsExtractionJobProgress(nullptr) {}
  ~InputsExtractionJobProgress() override;
  explicit PROTOBUF_CONSTEXPR InputsExtractionJobProgress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InputsExtractionJobProgress(const InputsExtractionJobProgress& from);
  InputsExtractionJobProgress(InputsExtractionJobProgress&& from) noexcept
    : InputsExtractionJobProgress() {
    *this = ::std::move(from);
  }

  inline InputsExtractionJobProgress& operator=(const InputsExtractionJobProgress& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputsExtractionJobProgress& operator=(InputsExtractionJobProgress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputsExtractionJobProgress& default_instance() {
    return *internal_default_instance();
  }
  static inline const InputsExtractionJobProgress* internal_default_instance() {
    return reinterpret_cast<const InputsExtractionJobProgress*>(
               &_InputsExtractionJobProgress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    167;

  friend void swap(InputsExtractionJobProgress& a, InputsExtractionJobProgress& b) {
    a.Swap(&b);
  }
  inline void Swap(InputsExtractionJobProgress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputsExtractionJobProgress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputsExtractionJobProgress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InputsExtractionJobProgress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InputsExtractionJobProgress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InputsExtractionJobProgress& from) {
    InputsExtractionJobProgress::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputsExtractionJobProgress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.InputsExtractionJobProgress";
  }
  protected:
  explicit InputsExtractionJobProgress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReadObjectsCountFieldNumber = 1,
    kAudioInputsCountFieldNumber = 2,
    kImageInputsCountFieldNumber = 3,
    kVideoInputsCountFieldNumber = 4,
    kTextInputsCountFieldNumber = 5,
  };
  // uint64 read_objects_count = 1;
  void clear_read_objects_count();
  uint64_t read_objects_count() const;
  void set_read_objects_count(uint64_t value);
  private:
  uint64_t _internal_read_objects_count() const;
  void _internal_set_read_objects_count(uint64_t value);
  public:

  // uint64 audio_inputs_count = 2;
  void clear_audio_inputs_count();
  uint64_t audio_inputs_count() const;
  void set_audio_inputs_count(uint64_t value);
  private:
  uint64_t _internal_audio_inputs_count() const;
  void _internal_set_audio_inputs_count(uint64_t value);
  public:

  // uint64 image_inputs_count = 3;
  void clear_image_inputs_count();
  uint64_t image_inputs_count() const;
  void set_image_inputs_count(uint64_t value);
  private:
  uint64_t _internal_image_inputs_count() const;
  void _internal_set_image_inputs_count(uint64_t value);
  public:

  // uint64 video_inputs_count = 4;
  void clear_video_inputs_count();
  uint64_t video_inputs_count() const;
  void set_video_inputs_count(uint64_t value);
  private:
  uint64_t _internal_video_inputs_count() const;
  void _internal_set_video_inputs_count(uint64_t value);
  public:

  // uint64 text_inputs_count = 5;
  void clear_text_inputs_count();
  uint64_t text_inputs_count() const;
  void set_text_inputs_count(uint64_t value);
  private:
  uint64_t _internal_text_inputs_count() const;
  void _internal_set_text_inputs_count(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.InputsExtractionJobProgress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t read_objects_count_;
    uint64_t audio_inputs_count_;
    uint64_t image_inputs_count_;
    uint64_t video_inputs_count_;
    uint64_t text_inputs_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class InputsDataSource final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.InputsDataSource) */ {
 public:
  inline InputsDataSource() : InputsDataSource(nullptr) {}
  ~InputsDataSource() override;
  explicit PROTOBUF_CONSTEXPR InputsDataSource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InputsDataSource(const InputsDataSource& from);
  InputsDataSource(InputsDataSource&& from) noexcept
    : InputsDataSource() {
    *this = ::std::move(from);
  }

  inline InputsDataSource& operator=(const InputsDataSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputsDataSource& operator=(InputsDataSource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputsDataSource& default_instance() {
    return *internal_default_instance();
  }
  static inline const InputsDataSource* internal_default_instance() {
    return reinterpret_cast<const InputsDataSource*>(
               &_InputsDataSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    168;

  friend void swap(InputsDataSource& a, InputsDataSource& b) {
    a.Swap(&b);
  }
  inline void Swap(InputsDataSource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputsDataSource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputsDataSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InputsDataSource>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InputsDataSource& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InputsDataSource& from) {
    InputsDataSource::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputsDataSource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.InputsDataSource";
  }
  protected:
  explicit InputsDataSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputsAddJobIdFieldNumber = 1,
    kUrlFieldNumber = 2,
  };
  // string inputs_add_job_id = 1;
  void clear_inputs_add_job_id();
  const std::string& inputs_add_job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_inputs_add_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_inputs_add_job_id();
  PROTOBUF_NODISCARD std::string* release_inputs_add_job_id();
  void set_allocated_inputs_add_job_id(std::string* inputs_add_job_id);
  private:
  const std::string& _internal_inputs_add_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_inputs_add_job_id(const std::string& value);
  std::string* _internal_mutable_inputs_add_job_id();
  public:

  // .clarifai.api.DataSourceURL url = 2;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const ::clarifai::api::DataSourceURL& url() const;
  PROTOBUF_NODISCARD ::clarifai::api::DataSourceURL* release_url();
  ::clarifai::api::DataSourceURL* mutable_url();
  void set_allocated_url(::clarifai::api::DataSourceURL* url);
  private:
  const ::clarifai::api::DataSourceURL& _internal_url() const;
  ::clarifai::api::DataSourceURL* _internal_mutable_url();
  public:
  void unsafe_arena_set_allocated_url(
      ::clarifai::api::DataSourceURL* url);
  ::clarifai::api::DataSourceURL* unsafe_arena_release_url();

  // @@protoc_insertion_point(class_scope:clarifai.api.InputsDataSource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr inputs_add_job_id_;
    ::clarifai::api::DataSourceURL* url_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class DataSourceURL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.DataSourceURL) */ {
 public:
  inline DataSourceURL() : DataSourceURL(nullptr) {}
  ~DataSourceURL() override;
  explicit PROTOBUF_CONSTEXPR DataSourceURL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataSourceURL(const DataSourceURL& from);
  DataSourceURL(DataSourceURL&& from) noexcept
    : DataSourceURL() {
    *this = ::std::move(from);
  }

  inline DataSourceURL& operator=(const DataSourceURL& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataSourceURL& operator=(DataSourceURL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataSourceURL& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataSourceURL* internal_default_instance() {
    return reinterpret_cast<const DataSourceURL*>(
               &_DataSourceURL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    169;

  friend void swap(DataSourceURL& a, DataSourceURL& b) {
    a.Swap(&b);
  }
  inline void Swap(DataSourceURL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataSourceURL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataSourceURL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataSourceURL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataSourceURL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataSourceURL& from) {
    DataSourceURL::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataSourceURL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.DataSourceURL";
  }
  protected:
  explicit DataSourceURL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kCredentialsFieldNumber = 2,
  };
  // string url = 1;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // .clarifai.api.DataSourceCredentials credentials = 2;
  bool has_credentials() const;
  private:
  bool _internal_has_credentials() const;
  public:
  void clear_credentials();
  const ::clarifai::api::DataSourceCredentials& credentials() const;
  PROTOBUF_NODISCARD ::clarifai::api::DataSourceCredentials* release_credentials();
  ::clarifai::api::DataSourceCredentials* mutable_credentials();
  void set_allocated_credentials(::clarifai::api::DataSourceCredentials* credentials);
  private:
  const ::clarifai::api::DataSourceCredentials& _internal_credentials() const;
  ::clarifai::api::DataSourceCredentials* _internal_mutable_credentials();
  public:
  void unsafe_arena_set_allocated_credentials(
      ::clarifai::api::DataSourceCredentials* credentials);
  ::clarifai::api::DataSourceCredentials* unsafe_arena_release_credentials();

  // @@protoc_insertion_point(class_scope:clarifai.api.DataSourceURL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::clarifai::api::DataSourceCredentials* credentials_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class DataSourceCredentials final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.DataSourceCredentials) */ {
 public:
  inline DataSourceCredentials() : DataSourceCredentials(nullptr) {}
  ~DataSourceCredentials() override;
  explicit PROTOBUF_CONSTEXPR DataSourceCredentials(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataSourceCredentials(const DataSourceCredentials& from);
  DataSourceCredentials(DataSourceCredentials&& from) noexcept
    : DataSourceCredentials() {
    *this = ::std::move(from);
  }

  inline DataSourceCredentials& operator=(const DataSourceCredentials& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataSourceCredentials& operator=(DataSourceCredentials&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataSourceCredentials& default_instance() {
    return *internal_default_instance();
  }
  enum CredentialsCase {
    kS3Creds = 1,
    kGcpCreds = 2,
    kAzureBlobCreds = 3,
    CREDENTIALS_NOT_SET = 0,
  };

  static inline const DataSourceCredentials* internal_default_instance() {
    return reinterpret_cast<const DataSourceCredentials*>(
               &_DataSourceCredentials_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    170;

  friend void swap(DataSourceCredentials& a, DataSourceCredentials& b) {
    a.Swap(&b);
  }
  inline void Swap(DataSourceCredentials* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataSourceCredentials* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataSourceCredentials* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataSourceCredentials>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataSourceCredentials& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataSourceCredentials& from) {
    DataSourceCredentials::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataSourceCredentials* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.DataSourceCredentials";
  }
  protected:
  explicit DataSourceCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kS3CredsFieldNumber = 1,
    kGcpCredsFieldNumber = 2,
    kAzureBlobCredsFieldNumber = 3,
  };
  // .clarifai.api.AWSCreds s3_creds = 1;
  bool has_s3_creds() const;
  private:
  bool _internal_has_s3_creds() const;
  public:
  void clear_s3_creds();
  const ::clarifai::api::AWSCreds& s3_creds() const;
  PROTOBUF_NODISCARD ::clarifai::api::AWSCreds* release_s3_creds();
  ::clarifai::api::AWSCreds* mutable_s3_creds();
  void set_allocated_s3_creds(::clarifai::api::AWSCreds* s3_creds);
  private:
  const ::clarifai::api::AWSCreds& _internal_s3_creds() const;
  ::clarifai::api::AWSCreds* _internal_mutable_s3_creds();
  public:
  void unsafe_arena_set_allocated_s3_creds(
      ::clarifai::api::AWSCreds* s3_creds);
  ::clarifai::api::AWSCreds* unsafe_arena_release_s3_creds();

  // bytes gcp_creds = 2;
  bool has_gcp_creds() const;
  private:
  bool _internal_has_gcp_creds() const;
  public:
  void clear_gcp_creds();
  const std::string& gcp_creds() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gcp_creds(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gcp_creds();
  PROTOBUF_NODISCARD std::string* release_gcp_creds();
  void set_allocated_gcp_creds(std::string* gcp_creds);
  private:
  const std::string& _internal_gcp_creds() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gcp_creds(const std::string& value);
  std::string* _internal_mutable_gcp_creds();
  public:

  // string azure_blob_creds = 3;
  bool has_azure_blob_creds() const;
  private:
  bool _internal_has_azure_blob_creds() const;
  public:
  void clear_azure_blob_creds();
  const std::string& azure_blob_creds() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_azure_blob_creds(ArgT0&& arg0, ArgT... args);
  std::string* mutable_azure_blob_creds();
  PROTOBUF_NODISCARD std::string* release_azure_blob_creds();
  void set_allocated_azure_blob_creds(std::string* azure_blob_creds);
  private:
  const std::string& _internal_azure_blob_creds() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_azure_blob_creds(const std::string& value);
  std::string* _internal_mutable_azure_blob_creds();
  public:

  void clear_credentials();
  CredentialsCase credentials_case() const;
  // @@protoc_insertion_point(class_scope:clarifai.api.DataSourceCredentials)
 private:
  class _Internal;
  void set_has_s3_creds();
  void set_has_gcp_creds();
  void set_has_azure_blob_creds();

  inline bool has_credentials() const;
  inline void clear_has_credentials();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union CredentialsUnion {
      constexpr CredentialsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::clarifai::api::AWSCreds* s3_creds_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gcp_creds_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr azure_blob_creds_;
    } credentials_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// -------------------------------------------------------------------

class AWSCreds final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clarifai.api.AWSCreds) */ {
 public:
  inline AWSCreds() : AWSCreds(nullptr) {}
  ~AWSCreds() override;
  explicit PROTOBUF_CONSTEXPR AWSCreds(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AWSCreds(const AWSCreds& from);
  AWSCreds(AWSCreds&& from) noexcept
    : AWSCreds() {
    *this = ::std::move(from);
  }

  inline AWSCreds& operator=(const AWSCreds& from) {
    CopyFrom(from);
    return *this;
  }
  inline AWSCreds& operator=(AWSCreds&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AWSCreds& default_instance() {
    return *internal_default_instance();
  }
  static inline const AWSCreds* internal_default_instance() {
    return reinterpret_cast<const AWSCreds*>(
               &_AWSCreds_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    171;

  friend void swap(AWSCreds& a, AWSCreds& b) {
    a.Swap(&b);
  }
  inline void Swap(AWSCreds* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AWSCreds* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AWSCreds* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AWSCreds>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AWSCreds& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AWSCreds& from) {
    AWSCreds::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AWSCreds* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clarifai.api.AWSCreds";
  }
  protected:
  explicit AWSCreds(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCredsFieldNumber = 1,
    kRegionFieldNumber = 2,
  };
  // string creds = 1;
  void clear_creds();
  const std::string& creds() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creds(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creds();
  PROTOBUF_NODISCARD std::string* release_creds();
  void set_allocated_creds(std::string* creds);
  private:
  const std::string& _internal_creds() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creds(const std::string& value);
  std::string* _internal_mutable_creds();
  public:

  // string region = 2;
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // @@protoc_insertion_point(class_scope:clarifai.api.AWSCreds)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creds_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fclarifai_2fapi_2fresources_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Annotation

// string id = 1;
inline void Annotation::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Annotation::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Annotation.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Annotation::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Annotation.id)
}
inline std::string* Annotation::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Annotation.id)
  return _s;
}
inline const std::string& Annotation::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Annotation::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Annotation::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Annotation::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Annotation.id)
  return _impl_.id_.Release();
}
inline void Annotation::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Annotation.id)
}

// string input_id = 2;
inline void Annotation::clear_input_id() {
  _impl_.input_id_.ClearToEmpty();
}
inline const std::string& Annotation::input_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Annotation.input_id)
  return _internal_input_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Annotation::set_input_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.input_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Annotation.input_id)
}
inline std::string* Annotation::mutable_input_id() {
  std::string* _s = _internal_mutable_input_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Annotation.input_id)
  return _s;
}
inline const std::string& Annotation::_internal_input_id() const {
  return _impl_.input_id_.Get();
}
inline void Annotation::_internal_set_input_id(const std::string& value) {
  
  _impl_.input_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Annotation::_internal_mutable_input_id() {
  
  return _impl_.input_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Annotation::release_input_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Annotation.input_id)
  return _impl_.input_id_.Release();
}
inline void Annotation::set_allocated_input_id(std::string* input_id) {
  if (input_id != nullptr) {
    
  } else {
    
  }
  _impl_.input_id_.SetAllocated(input_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.input_id_.IsDefault()) {
    _impl_.input_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Annotation.input_id)
}

// .clarifai.api.Data data = 3;
inline bool Annotation::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool Annotation::has_data() const {
  return _internal_has_data();
}
inline void Annotation::clear_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.data_ != nullptr) {
    delete _impl_.data_;
  }
  _impl_.data_ = nullptr;
}
inline const ::clarifai::api::Data& Annotation::_internal_data() const {
  const ::clarifai::api::Data* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Data&>(
      ::clarifai::api::_Data_default_instance_);
}
inline const ::clarifai::api::Data& Annotation::data() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Annotation.data)
  return _internal_data();
}
inline void Annotation::unsafe_arena_set_allocated_data(
    ::clarifai::api::Data* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Annotation.data)
}
inline ::clarifai::api::Data* Annotation::release_data() {
  
  ::clarifai::api::Data* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Data* Annotation::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:clarifai.api.Annotation.data)
  
  ::clarifai::api::Data* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::clarifai::api::Data* Annotation::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Data>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::clarifai::api::Data* Annotation::mutable_data() {
  ::clarifai::api::Data* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Annotation.data)
  return _msg;
}
inline void Annotation::set_allocated_data(::clarifai::api::Data* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Annotation.data)
}

// .google.protobuf.Struct annotation_info = 13;
inline bool Annotation::_internal_has_annotation_info() const {
  return this != internal_default_instance() && _impl_.annotation_info_ != nullptr;
}
inline bool Annotation::has_annotation_info() const {
  return _internal_has_annotation_info();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Annotation::_internal_annotation_info() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.annotation_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Annotation::annotation_info() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Annotation.annotation_info)
  return _internal_annotation_info();
}
inline void Annotation::unsafe_arena_set_allocated_annotation_info(
    ::PROTOBUF_NAMESPACE_ID::Struct* annotation_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.annotation_info_);
  }
  _impl_.annotation_info_ = annotation_info;
  if (annotation_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Annotation.annotation_info)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Annotation::release_annotation_info() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.annotation_info_;
  _impl_.annotation_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Annotation::unsafe_arena_release_annotation_info() {
  // @@protoc_insertion_point(field_release:clarifai.api.Annotation.annotation_info)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.annotation_info_;
  _impl_.annotation_info_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Annotation::_internal_mutable_annotation_info() {
  
  if (_impl_.annotation_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.annotation_info_ = p;
  }
  return _impl_.annotation_info_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Annotation::mutable_annotation_info() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_annotation_info();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Annotation.annotation_info)
  return _msg;
}
inline void Annotation::set_allocated_annotation_info(::PROTOBUF_NAMESPACE_ID::Struct* annotation_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.annotation_info_);
  }
  if (annotation_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(annotation_info));
    if (message_arena != submessage_arena) {
      annotation_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, annotation_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.annotation_info_ = annotation_info;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Annotation.annotation_info)
}

// string user_id = 15;
inline void Annotation::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& Annotation::user_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Annotation.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Annotation::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Annotation.user_id)
}
inline std::string* Annotation::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Annotation.user_id)
  return _s;
}
inline const std::string& Annotation::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void Annotation::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Annotation::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Annotation::release_user_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Annotation.user_id)
  return _impl_.user_id_.Release();
}
inline void Annotation::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Annotation.user_id)
}

// string model_version_id = 16;
inline void Annotation::clear_model_version_id() {
  _impl_.model_version_id_.ClearToEmpty();
}
inline const std::string& Annotation::model_version_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Annotation.model_version_id)
  return _internal_model_version_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Annotation::set_model_version_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_version_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Annotation.model_version_id)
}
inline std::string* Annotation::mutable_model_version_id() {
  std::string* _s = _internal_mutable_model_version_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Annotation.model_version_id)
  return _s;
}
inline const std::string& Annotation::_internal_model_version_id() const {
  return _impl_.model_version_id_.Get();
}
inline void Annotation::_internal_set_model_version_id(const std::string& value) {
  
  _impl_.model_version_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Annotation::_internal_mutable_model_version_id() {
  
  return _impl_.model_version_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Annotation::release_model_version_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Annotation.model_version_id)
  return _impl_.model_version_id_.Release();
}
inline void Annotation::set_allocated_model_version_id(std::string* model_version_id) {
  if (model_version_id != nullptr) {
    
  } else {
    
  }
  _impl_.model_version_id_.SetAllocated(model_version_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_version_id_.IsDefault()) {
    _impl_.model_version_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Annotation.model_version_id)
}

// string embed_model_version_id = 14 [deprecated = true];
inline void Annotation::clear_embed_model_version_id() {
  _impl_.embed_model_version_id_.ClearToEmpty();
}
inline const std::string& Annotation::embed_model_version_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Annotation.embed_model_version_id)
  return _internal_embed_model_version_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Annotation::set_embed_model_version_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.embed_model_version_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Annotation.embed_model_version_id)
}
inline std::string* Annotation::mutable_embed_model_version_id() {
  std::string* _s = _internal_mutable_embed_model_version_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Annotation.embed_model_version_id)
  return _s;
}
inline const std::string& Annotation::_internal_embed_model_version_id() const {
  return _impl_.embed_model_version_id_.Get();
}
inline void Annotation::_internal_set_embed_model_version_id(const std::string& value) {
  
  _impl_.embed_model_version_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Annotation::_internal_mutable_embed_model_version_id() {
  
  return _impl_.embed_model_version_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Annotation::release_embed_model_version_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Annotation.embed_model_version_id)
  return _impl_.embed_model_version_id_.Release();
}
inline void Annotation::set_allocated_embed_model_version_id(std::string* embed_model_version_id) {
  if (embed_model_version_id != nullptr) {
    
  } else {
    
  }
  _impl_.embed_model_version_id_.SetAllocated(embed_model_version_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.embed_model_version_id_.IsDefault()) {
    _impl_.embed_model_version_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Annotation.embed_model_version_id)
}

// .clarifai.api.status.Status status = 7;
inline bool Annotation::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool Annotation::has_status() const {
  return _internal_has_status();
}
inline const ::clarifai::api::status::Status& Annotation::_internal_status() const {
  const ::clarifai::api::status::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::status::Status&>(
      ::clarifai::api::status::_Status_default_instance_);
}
inline const ::clarifai::api::status::Status& Annotation::status() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Annotation.status)
  return _internal_status();
}
inline void Annotation::unsafe_arena_set_allocated_status(
    ::clarifai::api::status::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Annotation.status)
}
inline ::clarifai::api::status::Status* Annotation::release_status() {
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::status::Status* Annotation::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:clarifai.api.Annotation.status)
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::clarifai::api::status::Status* Annotation::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::status::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::clarifai::api::status::Status* Annotation::mutable_status() {
  ::clarifai::api::status::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Annotation.status)
  return _msg;
}
inline void Annotation::set_allocated_status(::clarifai::api::status::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Annotation.status)
}

// .google.protobuf.Timestamp created_at = 8;
inline bool Annotation::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool Annotation::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Annotation::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Annotation::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Annotation.created_at)
  return _internal_created_at();
}
inline void Annotation::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Annotation.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Annotation::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Annotation::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.Annotation.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Annotation::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Annotation::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Annotation.created_at)
  return _msg;
}
inline void Annotation::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Annotation.created_at)
}

// .google.protobuf.Timestamp modified_at = 9;
inline bool Annotation::_internal_has_modified_at() const {
  return this != internal_default_instance() && _impl_.modified_at_ != nullptr;
}
inline bool Annotation::has_modified_at() const {
  return _internal_has_modified_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Annotation::_internal_modified_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.modified_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Annotation::modified_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Annotation.modified_at)
  return _internal_modified_at();
}
inline void Annotation::unsafe_arena_set_allocated_modified_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  _impl_.modified_at_ = modified_at;
  if (modified_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Annotation.modified_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Annotation::release_modified_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Annotation::unsafe_arena_release_modified_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.Annotation.modified_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Annotation::_internal_mutable_modified_at() {
  
  if (_impl_.modified_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.modified_at_ = p;
  }
  return _impl_.modified_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Annotation::mutable_modified_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_modified_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Annotation.modified_at)
  return _msg;
}
inline void Annotation::set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  if (modified_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(modified_at));
    if (message_arena != submessage_arena) {
      modified_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modified_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.modified_at_ = modified_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Annotation.modified_at)
}

// bool trusted = 10 [deprecated = true];
inline void Annotation::clear_trusted() {
  _impl_.trusted_ = false;
}
inline bool Annotation::_internal_trusted() const {
  return _impl_.trusted_;
}
inline bool Annotation::trusted() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Annotation.trusted)
  return _internal_trusted();
}
inline void Annotation::_internal_set_trusted(bool value) {
  
  _impl_.trusted_ = value;
}
inline void Annotation::set_trusted(bool value) {
  _internal_set_trusted(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Annotation.trusted)
}

// bool input_level = 17;
inline void Annotation::clear_input_level() {
  _impl_.input_level_ = false;
}
inline bool Annotation::_internal_input_level() const {
  return _impl_.input_level_;
}
inline bool Annotation::input_level() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Annotation.input_level)
  return _internal_input_level();
}
inline void Annotation::_internal_set_input_level(bool value) {
  
  _impl_.input_level_ = value;
}
inline void Annotation::set_input_level(bool value) {
  _internal_set_input_level(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Annotation.input_level)
}

// .google.protobuf.Struct consensus_info = 18;
inline bool Annotation::_internal_has_consensus_info() const {
  return this != internal_default_instance() && _impl_.consensus_info_ != nullptr;
}
inline bool Annotation::has_consensus_info() const {
  return _internal_has_consensus_info();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Annotation::_internal_consensus_info() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.consensus_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Annotation::consensus_info() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Annotation.consensus_info)
  return _internal_consensus_info();
}
inline void Annotation::unsafe_arena_set_allocated_consensus_info(
    ::PROTOBUF_NAMESPACE_ID::Struct* consensus_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.consensus_info_);
  }
  _impl_.consensus_info_ = consensus_info;
  if (consensus_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Annotation.consensus_info)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Annotation::release_consensus_info() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.consensus_info_;
  _impl_.consensus_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Annotation::unsafe_arena_release_consensus_info() {
  // @@protoc_insertion_point(field_release:clarifai.api.Annotation.consensus_info)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.consensus_info_;
  _impl_.consensus_info_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Annotation::_internal_mutable_consensus_info() {
  
  if (_impl_.consensus_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.consensus_info_ = p;
  }
  return _impl_.consensus_info_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Annotation::mutable_consensus_info() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_consensus_info();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Annotation.consensus_info)
  return _msg;
}
inline void Annotation::set_allocated_consensus_info(::PROTOBUF_NAMESPACE_ID::Struct* consensus_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.consensus_info_);
  }
  if (consensus_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(consensus_info));
    if (message_arena != submessage_arena) {
      consensus_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, consensus_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.consensus_info_ = consensus_info;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Annotation.consensus_info)
}

// string task_id = 19;
inline void Annotation::clear_task_id() {
  _impl_.task_id_.ClearToEmpty();
}
inline const std::string& Annotation::task_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Annotation.task_id)
  return _internal_task_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Annotation::set_task_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.task_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Annotation.task_id)
}
inline std::string* Annotation::mutable_task_id() {
  std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Annotation.task_id)
  return _s;
}
inline const std::string& Annotation::_internal_task_id() const {
  return _impl_.task_id_.Get();
}
inline void Annotation::_internal_set_task_id(const std::string& value) {
  
  _impl_.task_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Annotation::_internal_mutable_task_id() {
  
  return _impl_.task_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Annotation::release_task_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Annotation.task_id)
  return _impl_.task_id_.Release();
}
inline void Annotation::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    
  } else {
    
  }
  _impl_.task_id_.SetAllocated(task_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.task_id_.IsDefault()) {
    _impl_.task_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Annotation.task_id)
}

// -------------------------------------------------------------------

// App

// string id = 1;
inline void App::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& App::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.App.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void App::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.App.id)
}
inline std::string* App::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.App.id)
  return _s;
}
inline const std::string& App::_internal_id() const {
  return _impl_.id_.Get();
}
inline void App::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* App::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.App.id)
  return _impl_.id_.Release();
}
inline void App::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.App.id)
}

// string name = 2;
inline void App::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& App::name() const {
  // @@protoc_insertion_point(field_get:clarifai.api.App.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void App::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.App.name)
}
inline std::string* App::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:clarifai.api.App.name)
  return _s;
}
inline const std::string& App::_internal_name() const {
  return _impl_.name_.Get();
}
inline void App::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* App::release_name() {
  // @@protoc_insertion_point(field_release:clarifai.api.App.name)
  return _impl_.name_.Release();
}
inline void App::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.App.name)
}

// string default_language = 3;
inline void App::clear_default_language() {
  _impl_.default_language_.ClearToEmpty();
}
inline const std::string& App::default_language() const {
  // @@protoc_insertion_point(field_get:clarifai.api.App.default_language)
  return _internal_default_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void App::set_default_language(ArgT0&& arg0, ArgT... args) {
 
 _impl_.default_language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.App.default_language)
}
inline std::string* App::mutable_default_language() {
  std::string* _s = _internal_mutable_default_language();
  // @@protoc_insertion_point(field_mutable:clarifai.api.App.default_language)
  return _s;
}
inline const std::string& App::_internal_default_language() const {
  return _impl_.default_language_.Get();
}
inline void App::_internal_set_default_language(const std::string& value) {
  
  _impl_.default_language_.Set(value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_default_language() {
  
  return _impl_.default_language_.Mutable(GetArenaForAllocation());
}
inline std::string* App::release_default_language() {
  // @@protoc_insertion_point(field_release:clarifai.api.App.default_language)
  return _impl_.default_language_.Release();
}
inline void App::set_allocated_default_language(std::string* default_language) {
  if (default_language != nullptr) {
    
  } else {
    
  }
  _impl_.default_language_.SetAllocated(default_language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.default_language_.IsDefault()) {
    _impl_.default_language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.App.default_language)
}

// string default_workflow_id = 4;
inline void App::clear_default_workflow_id() {
  _impl_.default_workflow_id_.ClearToEmpty();
}
inline const std::string& App::default_workflow_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.App.default_workflow_id)
  return _internal_default_workflow_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void App::set_default_workflow_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.default_workflow_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.App.default_workflow_id)
}
inline std::string* App::mutable_default_workflow_id() {
  std::string* _s = _internal_mutable_default_workflow_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.App.default_workflow_id)
  return _s;
}
inline const std::string& App::_internal_default_workflow_id() const {
  return _impl_.default_workflow_id_.Get();
}
inline void App::_internal_set_default_workflow_id(const std::string& value) {
  
  _impl_.default_workflow_id_.Set(value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_default_workflow_id() {
  
  return _impl_.default_workflow_id_.Mutable(GetArenaForAllocation());
}
inline std::string* App::release_default_workflow_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.App.default_workflow_id)
  return _impl_.default_workflow_id_.Release();
}
inline void App::set_allocated_default_workflow_id(std::string* default_workflow_id) {
  if (default_workflow_id != nullptr) {
    
  } else {
    
  }
  _impl_.default_workflow_id_.SetAllocated(default_workflow_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.default_workflow_id_.IsDefault()) {
    _impl_.default_workflow_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.App.default_workflow_id)
}

// string user_id = 5;
inline void App::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& App::user_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.App.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void App::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.App.user_id)
}
inline std::string* App::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.App.user_id)
  return _s;
}
inline const std::string& App::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void App::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* App::release_user_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.App.user_id)
  return _impl_.user_id_.Release();
}
inline void App::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.App.user_id)
}

// .google.protobuf.Timestamp created_at = 6;
inline bool App::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool App::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& App::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& App::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.App.created_at)
  return _internal_created_at();
}
inline void App::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.App.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* App::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* App::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.App.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* App::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* App::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.App.created_at)
  return _msg;
}
inline void App::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.App.created_at)
}

// .google.protobuf.Timestamp modified_at = 17;
inline bool App::_internal_has_modified_at() const {
  return this != internal_default_instance() && _impl_.modified_at_ != nullptr;
}
inline bool App::has_modified_at() const {
  return _internal_has_modified_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& App::_internal_modified_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.modified_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& App::modified_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.App.modified_at)
  return _internal_modified_at();
}
inline void App::unsafe_arena_set_allocated_modified_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  _impl_.modified_at_ = modified_at;
  if (modified_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.App.modified_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* App::release_modified_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* App::unsafe_arena_release_modified_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.App.modified_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* App::_internal_mutable_modified_at() {
  
  if (_impl_.modified_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.modified_at_ = p;
  }
  return _impl_.modified_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* App::mutable_modified_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_modified_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.App.modified_at)
  return _msg;
}
inline void App::set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  if (modified_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(modified_at));
    if (message_arena != submessage_arena) {
      modified_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modified_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.modified_at_ = modified_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.App.modified_at)
}

// uint32 legal_consent_status = 7;
inline void App::clear_legal_consent_status() {
  _impl_.legal_consent_status_ = 0u;
}
inline uint32_t App::_internal_legal_consent_status() const {
  return _impl_.legal_consent_status_;
}
inline uint32_t App::legal_consent_status() const {
  // @@protoc_insertion_point(field_get:clarifai.api.App.legal_consent_status)
  return _internal_legal_consent_status();
}
inline void App::_internal_set_legal_consent_status(uint32_t value) {
  
  _impl_.legal_consent_status_ = value;
}
inline void App::set_legal_consent_status(uint32_t value) {
  _internal_set_legal_consent_status(value);
  // @@protoc_insertion_point(field_set:clarifai.api.App.legal_consent_status)
}

// .google.protobuf.Struct metadata = 13;
inline bool App::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool App::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& App::_internal_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& App::metadata() const {
  // @@protoc_insertion_point(field_get:clarifai.api.App.metadata)
  return _internal_metadata();
}
inline void App::unsafe_arena_set_allocated_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.App.metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* App::release_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* App::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:clarifai.api.App.metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* App::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* App::mutable_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:clarifai.api.App.metadata)
  return _msg;
}
inline void App::set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.App.metadata)
}

// string description = 14;
inline void App::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& App::description() const {
  // @@protoc_insertion_point(field_get:clarifai.api.App.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void App::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.App.description)
}
inline std::string* App::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:clarifai.api.App.description)
  return _s;
}
inline const std::string& App::_internal_description() const {
  return _impl_.description_.Get();
}
inline void App::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* App::release_description() {
  // @@protoc_insertion_point(field_release:clarifai.api.App.description)
  return _impl_.description_.Release();
}
inline void App::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.App.description)
}

// uint32 sample_ms = 15;
inline void App::clear_sample_ms() {
  _impl_.sample_ms_ = 0u;
}
inline uint32_t App::_internal_sample_ms() const {
  return _impl_.sample_ms_;
}
inline uint32_t App::sample_ms() const {
  // @@protoc_insertion_point(field_get:clarifai.api.App.sample_ms)
  return _internal_sample_ms();
}
inline void App::_internal_set_sample_ms(uint32_t value) {
  
  _impl_.sample_ms_ = value;
}
inline void App::set_sample_ms(uint32_t value) {
  _internal_set_sample_ms(value);
  // @@protoc_insertion_point(field_set:clarifai.api.App.sample_ms)
}

// .clarifai.api.Visibility visibility = 16;
inline bool App::_internal_has_visibility() const {
  return this != internal_default_instance() && _impl_.visibility_ != nullptr;
}
inline bool App::has_visibility() const {
  return _internal_has_visibility();
}
inline void App::clear_visibility() {
  if (GetArenaForAllocation() == nullptr && _impl_.visibility_ != nullptr) {
    delete _impl_.visibility_;
  }
  _impl_.visibility_ = nullptr;
}
inline const ::clarifai::api::Visibility& App::_internal_visibility() const {
  const ::clarifai::api::Visibility* p = _impl_.visibility_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Visibility&>(
      ::clarifai::api::_Visibility_default_instance_);
}
inline const ::clarifai::api::Visibility& App::visibility() const {
  // @@protoc_insertion_point(field_get:clarifai.api.App.visibility)
  return _internal_visibility();
}
inline void App::unsafe_arena_set_allocated_visibility(
    ::clarifai::api::Visibility* visibility) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visibility_);
  }
  _impl_.visibility_ = visibility;
  if (visibility) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.App.visibility)
}
inline ::clarifai::api::Visibility* App::release_visibility() {
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Visibility* App::unsafe_arena_release_visibility() {
  // @@protoc_insertion_point(field_release:clarifai.api.App.visibility)
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
  return temp;
}
inline ::clarifai::api::Visibility* App::_internal_mutable_visibility() {
  
  if (_impl_.visibility_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Visibility>(GetArenaForAllocation());
    _impl_.visibility_ = p;
  }
  return _impl_.visibility_;
}
inline ::clarifai::api::Visibility* App::mutable_visibility() {
  ::clarifai::api::Visibility* _msg = _internal_mutable_visibility();
  // @@protoc_insertion_point(field_mutable:clarifai.api.App.visibility)
  return _msg;
}
inline void App::set_allocated_visibility(::clarifai::api::Visibility* visibility) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.visibility_;
  }
  if (visibility) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(visibility);
    if (message_arena != submessage_arena) {
      visibility = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visibility, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.visibility_ = visibility;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.App.visibility)
}

// string data_tier_id = 18;
inline void App::clear_data_tier_id() {
  _impl_.data_tier_id_.ClearToEmpty();
}
inline const std::string& App::data_tier_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.App.data_tier_id)
  return _internal_data_tier_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void App::set_data_tier_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_tier_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.App.data_tier_id)
}
inline std::string* App::mutable_data_tier_id() {
  std::string* _s = _internal_mutable_data_tier_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.App.data_tier_id)
  return _s;
}
inline const std::string& App::_internal_data_tier_id() const {
  return _impl_.data_tier_id_.Get();
}
inline void App::_internal_set_data_tier_id(const std::string& value) {
  
  _impl_.data_tier_id_.Set(value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_data_tier_id() {
  
  return _impl_.data_tier_id_.Mutable(GetArenaForAllocation());
}
inline std::string* App::release_data_tier_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.App.data_tier_id)
  return _impl_.data_tier_id_.Release();
}
inline void App::set_allocated_data_tier_id(std::string* data_tier_id) {
  if (data_tier_id != nullptr) {
    
  } else {
    
  }
  _impl_.data_tier_id_.SetAllocated(data_tier_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_tier_id_.IsDefault()) {
    _impl_.data_tier_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.App.data_tier_id)
}

// bool is_starred = 19;
inline void App::clear_is_starred() {
  _impl_.is_starred_ = false;
}
inline bool App::_internal_is_starred() const {
  return _impl_.is_starred_;
}
inline bool App::is_starred() const {
  // @@protoc_insertion_point(field_get:clarifai.api.App.is_starred)
  return _internal_is_starred();
}
inline void App::_internal_set_is_starred(bool value) {
  
  _impl_.is_starred_ = value;
}
inline void App::set_is_starred(bool value) {
  _internal_set_is_starred(value);
  // @@protoc_insertion_point(field_set:clarifai.api.App.is_starred)
}

// int32 star_count = 20;
inline void App::clear_star_count() {
  _impl_.star_count_ = 0;
}
inline int32_t App::_internal_star_count() const {
  return _impl_.star_count_;
}
inline int32_t App::star_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.App.star_count)
  return _internal_star_count();
}
inline void App::_internal_set_star_count(int32_t value) {
  
  _impl_.star_count_ = value;
}
inline void App::set_star_count(int32_t value) {
  _internal_set_star_count(value);
  // @@protoc_insertion_point(field_set:clarifai.api.App.star_count)
}

// string notes = 21;
inline void App::clear_notes() {
  _impl_.notes_.ClearToEmpty();
}
inline const std::string& App::notes() const {
  // @@protoc_insertion_point(field_get:clarifai.api.App.notes)
  return _internal_notes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void App::set_notes(ArgT0&& arg0, ArgT... args) {
 
 _impl_.notes_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.App.notes)
}
inline std::string* App::mutable_notes() {
  std::string* _s = _internal_mutable_notes();
  // @@protoc_insertion_point(field_mutable:clarifai.api.App.notes)
  return _s;
}
inline const std::string& App::_internal_notes() const {
  return _impl_.notes_.Get();
}
inline void App::_internal_set_notes(const std::string& value) {
  
  _impl_.notes_.Set(value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_notes() {
  
  return _impl_.notes_.Mutable(GetArenaForAllocation());
}
inline std::string* App::release_notes() {
  // @@protoc_insertion_point(field_release:clarifai.api.App.notes)
  return _impl_.notes_.Release();
}
inline void App::set_allocated_notes(std::string* notes) {
  if (notes != nullptr) {
    
  } else {
    
  }
  _impl_.notes_.SetAllocated(notes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.notes_.IsDefault()) {
    _impl_.notes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.App.notes)
}

// .clarifai.api.Image image = 22;
inline bool App::_internal_has_image() const {
  return this != internal_default_instance() && _impl_.image_ != nullptr;
}
inline bool App::has_image() const {
  return _internal_has_image();
}
inline void App::clear_image() {
  if (GetArenaForAllocation() == nullptr && _impl_.image_ != nullptr) {
    delete _impl_.image_;
  }
  _impl_.image_ = nullptr;
}
inline const ::clarifai::api::Image& App::_internal_image() const {
  const ::clarifai::api::Image* p = _impl_.image_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Image&>(
      ::clarifai::api::_Image_default_instance_);
}
inline const ::clarifai::api::Image& App::image() const {
  // @@protoc_insertion_point(field_get:clarifai.api.App.image)
  return _internal_image();
}
inline void App::unsafe_arena_set_allocated_image(
    ::clarifai::api::Image* image) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_);
  }
  _impl_.image_ = image;
  if (image) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.App.image)
}
inline ::clarifai::api::Image* App::release_image() {
  
  ::clarifai::api::Image* temp = _impl_.image_;
  _impl_.image_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Image* App::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_release:clarifai.api.App.image)
  
  ::clarifai::api::Image* temp = _impl_.image_;
  _impl_.image_ = nullptr;
  return temp;
}
inline ::clarifai::api::Image* App::_internal_mutable_image() {
  
  if (_impl_.image_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Image>(GetArenaForAllocation());
    _impl_.image_ = p;
  }
  return _impl_.image_;
}
inline ::clarifai::api::Image* App::mutable_image() {
  ::clarifai::api::Image* _msg = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:clarifai.api.App.image)
  return _msg;
}
inline void App::set_allocated_image(::clarifai::api::Image* image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.image_;
  }
  if (image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(image);
    if (message_arena != submessage_arena) {
      image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.image_ = image;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.App.image)
}

// -------------------------------------------------------------------

// AppQuery

// string name = 1;
inline void AppQuery::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& AppQuery::name() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AppQuery.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppQuery::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.AppQuery.name)
}
inline std::string* AppQuery::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:clarifai.api.AppQuery.name)
  return _s;
}
inline const std::string& AppQuery::_internal_name() const {
  return _impl_.name_.Get();
}
inline void AppQuery::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AppQuery::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* AppQuery::release_name() {
  // @@protoc_insertion_point(field_release:clarifai.api.AppQuery.name)
  return _impl_.name_.Release();
}
inline void AppQuery::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.AppQuery.name)
}

// -------------------------------------------------------------------

// Collaborator

// string id = 1;
inline void Collaborator::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Collaborator::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Collaborator.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Collaborator::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Collaborator.id)
}
inline std::string* Collaborator::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Collaborator.id)
  return _s;
}
inline const std::string& Collaborator::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Collaborator::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Collaborator::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Collaborator::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Collaborator.id)
  return _impl_.id_.Release();
}
inline void Collaborator::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Collaborator.id)
}

// .clarifai.api.App app = 2;
inline bool Collaborator::_internal_has_app() const {
  return this != internal_default_instance() && _impl_.app_ != nullptr;
}
inline bool Collaborator::has_app() const {
  return _internal_has_app();
}
inline void Collaborator::clear_app() {
  if (GetArenaForAllocation() == nullptr && _impl_.app_ != nullptr) {
    delete _impl_.app_;
  }
  _impl_.app_ = nullptr;
}
inline const ::clarifai::api::App& Collaborator::_internal_app() const {
  const ::clarifai::api::App* p = _impl_.app_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::App&>(
      ::clarifai::api::_App_default_instance_);
}
inline const ::clarifai::api::App& Collaborator::app() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Collaborator.app)
  return _internal_app();
}
inline void Collaborator::unsafe_arena_set_allocated_app(
    ::clarifai::api::App* app) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.app_);
  }
  _impl_.app_ = app;
  if (app) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Collaborator.app)
}
inline ::clarifai::api::App* Collaborator::release_app() {
  
  ::clarifai::api::App* temp = _impl_.app_;
  _impl_.app_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::App* Collaborator::unsafe_arena_release_app() {
  // @@protoc_insertion_point(field_release:clarifai.api.Collaborator.app)
  
  ::clarifai::api::App* temp = _impl_.app_;
  _impl_.app_ = nullptr;
  return temp;
}
inline ::clarifai::api::App* Collaborator::_internal_mutable_app() {
  
  if (_impl_.app_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::App>(GetArenaForAllocation());
    _impl_.app_ = p;
  }
  return _impl_.app_;
}
inline ::clarifai::api::App* Collaborator::mutable_app() {
  ::clarifai::api::App* _msg = _internal_mutable_app();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Collaborator.app)
  return _msg;
}
inline void Collaborator::set_allocated_app(::clarifai::api::App* app) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.app_;
  }
  if (app) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(app);
    if (message_arena != submessage_arena) {
      app = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, app, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.app_ = app;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Collaborator.app)
}

// .clarifai.api.User user = 3;
inline bool Collaborator::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool Collaborator::has_user() const {
  return _internal_has_user();
}
inline void Collaborator::clear_user() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
}
inline const ::clarifai::api::User& Collaborator::_internal_user() const {
  const ::clarifai::api::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::User&>(
      ::clarifai::api::_User_default_instance_);
}
inline const ::clarifai::api::User& Collaborator::user() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Collaborator.user)
  return _internal_user();
}
inline void Collaborator::unsafe_arena_set_allocated_user(
    ::clarifai::api::User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Collaborator.user)
}
inline ::clarifai::api::User* Collaborator::release_user() {
  
  ::clarifai::api::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::User* Collaborator::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:clarifai.api.Collaborator.user)
  
  ::clarifai::api::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::clarifai::api::User* Collaborator::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::User>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::clarifai::api::User* Collaborator::mutable_user() {
  ::clarifai::api::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Collaborator.user)
  return _msg;
}
inline void Collaborator::set_allocated_user(::clarifai::api::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Collaborator.user)
}

// repeated string scopes = 4;
inline int Collaborator::_internal_scopes_size() const {
  return _impl_.scopes_.size();
}
inline int Collaborator::scopes_size() const {
  return _internal_scopes_size();
}
inline void Collaborator::clear_scopes() {
  _impl_.scopes_.Clear();
}
inline std::string* Collaborator::add_scopes() {
  std::string* _s = _internal_add_scopes();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.Collaborator.scopes)
  return _s;
}
inline const std::string& Collaborator::_internal_scopes(int index) const {
  return _impl_.scopes_.Get(index);
}
inline const std::string& Collaborator::scopes(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Collaborator.scopes)
  return _internal_scopes(index);
}
inline std::string* Collaborator::mutable_scopes(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Collaborator.scopes)
  return _impl_.scopes_.Mutable(index);
}
inline void Collaborator::set_scopes(int index, const std::string& value) {
  _impl_.scopes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Collaborator.scopes)
}
inline void Collaborator::set_scopes(int index, std::string&& value) {
  _impl_.scopes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.Collaborator.scopes)
}
inline void Collaborator::set_scopes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.scopes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.Collaborator.scopes)
}
inline void Collaborator::set_scopes(int index, const char* value, size_t size) {
  _impl_.scopes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.Collaborator.scopes)
}
inline std::string* Collaborator::_internal_add_scopes() {
  return _impl_.scopes_.Add();
}
inline void Collaborator::add_scopes(const std::string& value) {
  _impl_.scopes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.Collaborator.scopes)
}
inline void Collaborator::add_scopes(std::string&& value) {
  _impl_.scopes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.Collaborator.scopes)
}
inline void Collaborator::add_scopes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.scopes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.Collaborator.scopes)
}
inline void Collaborator::add_scopes(const char* value, size_t size) {
  _impl_.scopes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.Collaborator.scopes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Collaborator::scopes() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Collaborator.scopes)
  return _impl_.scopes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Collaborator::mutable_scopes() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Collaborator.scopes)
  return &_impl_.scopes_;
}

// repeated string endpoints = 5;
inline int Collaborator::_internal_endpoints_size() const {
  return _impl_.endpoints_.size();
}
inline int Collaborator::endpoints_size() const {
  return _internal_endpoints_size();
}
inline void Collaborator::clear_endpoints() {
  _impl_.endpoints_.Clear();
}
inline std::string* Collaborator::add_endpoints() {
  std::string* _s = _internal_add_endpoints();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.Collaborator.endpoints)
  return _s;
}
inline const std::string& Collaborator::_internal_endpoints(int index) const {
  return _impl_.endpoints_.Get(index);
}
inline const std::string& Collaborator::endpoints(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Collaborator.endpoints)
  return _internal_endpoints(index);
}
inline std::string* Collaborator::mutable_endpoints(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Collaborator.endpoints)
  return _impl_.endpoints_.Mutable(index);
}
inline void Collaborator::set_endpoints(int index, const std::string& value) {
  _impl_.endpoints_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Collaborator.endpoints)
}
inline void Collaborator::set_endpoints(int index, std::string&& value) {
  _impl_.endpoints_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.Collaborator.endpoints)
}
inline void Collaborator::set_endpoints(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.endpoints_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.Collaborator.endpoints)
}
inline void Collaborator::set_endpoints(int index, const char* value, size_t size) {
  _impl_.endpoints_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.Collaborator.endpoints)
}
inline std::string* Collaborator::_internal_add_endpoints() {
  return _impl_.endpoints_.Add();
}
inline void Collaborator::add_endpoints(const std::string& value) {
  _impl_.endpoints_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.Collaborator.endpoints)
}
inline void Collaborator::add_endpoints(std::string&& value) {
  _impl_.endpoints_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.Collaborator.endpoints)
}
inline void Collaborator::add_endpoints(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.endpoints_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.Collaborator.endpoints)
}
inline void Collaborator::add_endpoints(const char* value, size_t size) {
  _impl_.endpoints_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.Collaborator.endpoints)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Collaborator::endpoints() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Collaborator.endpoints)
  return _impl_.endpoints_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Collaborator::mutable_endpoints() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Collaborator.endpoints)
  return &_impl_.endpoints_;
}

// .google.protobuf.Timestamp created_at = 6;
inline bool Collaborator::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool Collaborator::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Collaborator::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Collaborator::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Collaborator.created_at)
  return _internal_created_at();
}
inline void Collaborator::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Collaborator.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Collaborator::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Collaborator::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.Collaborator.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Collaborator::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Collaborator::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Collaborator.created_at)
  return _msg;
}
inline void Collaborator::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Collaborator.created_at)
}

// .google.protobuf.Timestamp modified_at = 7;
inline bool Collaborator::_internal_has_modified_at() const {
  return this != internal_default_instance() && _impl_.modified_at_ != nullptr;
}
inline bool Collaborator::has_modified_at() const {
  return _internal_has_modified_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Collaborator::_internal_modified_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.modified_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Collaborator::modified_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Collaborator.modified_at)
  return _internal_modified_at();
}
inline void Collaborator::unsafe_arena_set_allocated_modified_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  _impl_.modified_at_ = modified_at;
  if (modified_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Collaborator.modified_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Collaborator::release_modified_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Collaborator::unsafe_arena_release_modified_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.Collaborator.modified_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Collaborator::_internal_mutable_modified_at() {
  
  if (_impl_.modified_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.modified_at_ = p;
  }
  return _impl_.modified_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Collaborator::mutable_modified_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_modified_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Collaborator.modified_at)
  return _msg;
}
inline void Collaborator::set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  if (modified_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(modified_at));
    if (message_arena != submessage_arena) {
      modified_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modified_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.modified_at_ = modified_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Collaborator.modified_at)
}

// .google.protobuf.Timestamp deleted_at = 8;
inline bool Collaborator::_internal_has_deleted_at() const {
  return this != internal_default_instance() && _impl_.deleted_at_ != nullptr;
}
inline bool Collaborator::has_deleted_at() const {
  return _internal_has_deleted_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Collaborator::_internal_deleted_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.deleted_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Collaborator::deleted_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Collaborator.deleted_at)
  return _internal_deleted_at();
}
inline void Collaborator::unsafe_arena_set_allocated_deleted_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deleted_at_);
  }
  _impl_.deleted_at_ = deleted_at;
  if (deleted_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Collaborator.deleted_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Collaborator::release_deleted_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.deleted_at_;
  _impl_.deleted_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Collaborator::unsafe_arena_release_deleted_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.Collaborator.deleted_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.deleted_at_;
  _impl_.deleted_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Collaborator::_internal_mutable_deleted_at() {
  
  if (_impl_.deleted_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.deleted_at_ = p;
  }
  return _impl_.deleted_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Collaborator::mutable_deleted_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_deleted_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Collaborator.deleted_at)
  return _msg;
}
inline void Collaborator::set_allocated_deleted_at(::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deleted_at_);
  }
  if (deleted_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deleted_at));
    if (message_arena != submessage_arena) {
      deleted_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deleted_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.deleted_at_ = deleted_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Collaborator.deleted_at)
}

// -------------------------------------------------------------------

// Collaboration

// .clarifai.api.App app = 1;
inline bool Collaboration::_internal_has_app() const {
  return this != internal_default_instance() && _impl_.app_ != nullptr;
}
inline bool Collaboration::has_app() const {
  return _internal_has_app();
}
inline void Collaboration::clear_app() {
  if (GetArenaForAllocation() == nullptr && _impl_.app_ != nullptr) {
    delete _impl_.app_;
  }
  _impl_.app_ = nullptr;
}
inline const ::clarifai::api::App& Collaboration::_internal_app() const {
  const ::clarifai::api::App* p = _impl_.app_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::App&>(
      ::clarifai::api::_App_default_instance_);
}
inline const ::clarifai::api::App& Collaboration::app() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Collaboration.app)
  return _internal_app();
}
inline void Collaboration::unsafe_arena_set_allocated_app(
    ::clarifai::api::App* app) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.app_);
  }
  _impl_.app_ = app;
  if (app) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Collaboration.app)
}
inline ::clarifai::api::App* Collaboration::release_app() {
  
  ::clarifai::api::App* temp = _impl_.app_;
  _impl_.app_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::App* Collaboration::unsafe_arena_release_app() {
  // @@protoc_insertion_point(field_release:clarifai.api.Collaboration.app)
  
  ::clarifai::api::App* temp = _impl_.app_;
  _impl_.app_ = nullptr;
  return temp;
}
inline ::clarifai::api::App* Collaboration::_internal_mutable_app() {
  
  if (_impl_.app_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::App>(GetArenaForAllocation());
    _impl_.app_ = p;
  }
  return _impl_.app_;
}
inline ::clarifai::api::App* Collaboration::mutable_app() {
  ::clarifai::api::App* _msg = _internal_mutable_app();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Collaboration.app)
  return _msg;
}
inline void Collaboration::set_allocated_app(::clarifai::api::App* app) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.app_;
  }
  if (app) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(app);
    if (message_arena != submessage_arena) {
      app = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, app, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.app_ = app;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Collaboration.app)
}

// .clarifai.api.User app_owner = 2;
inline bool Collaboration::_internal_has_app_owner() const {
  return this != internal_default_instance() && _impl_.app_owner_ != nullptr;
}
inline bool Collaboration::has_app_owner() const {
  return _internal_has_app_owner();
}
inline void Collaboration::clear_app_owner() {
  if (GetArenaForAllocation() == nullptr && _impl_.app_owner_ != nullptr) {
    delete _impl_.app_owner_;
  }
  _impl_.app_owner_ = nullptr;
}
inline const ::clarifai::api::User& Collaboration::_internal_app_owner() const {
  const ::clarifai::api::User* p = _impl_.app_owner_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::User&>(
      ::clarifai::api::_User_default_instance_);
}
inline const ::clarifai::api::User& Collaboration::app_owner() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Collaboration.app_owner)
  return _internal_app_owner();
}
inline void Collaboration::unsafe_arena_set_allocated_app_owner(
    ::clarifai::api::User* app_owner) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.app_owner_);
  }
  _impl_.app_owner_ = app_owner;
  if (app_owner) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Collaboration.app_owner)
}
inline ::clarifai::api::User* Collaboration::release_app_owner() {
  
  ::clarifai::api::User* temp = _impl_.app_owner_;
  _impl_.app_owner_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::User* Collaboration::unsafe_arena_release_app_owner() {
  // @@protoc_insertion_point(field_release:clarifai.api.Collaboration.app_owner)
  
  ::clarifai::api::User* temp = _impl_.app_owner_;
  _impl_.app_owner_ = nullptr;
  return temp;
}
inline ::clarifai::api::User* Collaboration::_internal_mutable_app_owner() {
  
  if (_impl_.app_owner_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::User>(GetArenaForAllocation());
    _impl_.app_owner_ = p;
  }
  return _impl_.app_owner_;
}
inline ::clarifai::api::User* Collaboration::mutable_app_owner() {
  ::clarifai::api::User* _msg = _internal_mutable_app_owner();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Collaboration.app_owner)
  return _msg;
}
inline void Collaboration::set_allocated_app_owner(::clarifai::api::User* app_owner) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.app_owner_;
  }
  if (app_owner) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(app_owner);
    if (message_arena != submessage_arena) {
      app_owner = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, app_owner, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.app_owner_ = app_owner;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Collaboration.app_owner)
}

// repeated string scopes = 3;
inline int Collaboration::_internal_scopes_size() const {
  return _impl_.scopes_.size();
}
inline int Collaboration::scopes_size() const {
  return _internal_scopes_size();
}
inline void Collaboration::clear_scopes() {
  _impl_.scopes_.Clear();
}
inline std::string* Collaboration::add_scopes() {
  std::string* _s = _internal_add_scopes();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.Collaboration.scopes)
  return _s;
}
inline const std::string& Collaboration::_internal_scopes(int index) const {
  return _impl_.scopes_.Get(index);
}
inline const std::string& Collaboration::scopes(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Collaboration.scopes)
  return _internal_scopes(index);
}
inline std::string* Collaboration::mutable_scopes(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Collaboration.scopes)
  return _impl_.scopes_.Mutable(index);
}
inline void Collaboration::set_scopes(int index, const std::string& value) {
  _impl_.scopes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Collaboration.scopes)
}
inline void Collaboration::set_scopes(int index, std::string&& value) {
  _impl_.scopes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.Collaboration.scopes)
}
inline void Collaboration::set_scopes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.scopes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.Collaboration.scopes)
}
inline void Collaboration::set_scopes(int index, const char* value, size_t size) {
  _impl_.scopes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.Collaboration.scopes)
}
inline std::string* Collaboration::_internal_add_scopes() {
  return _impl_.scopes_.Add();
}
inline void Collaboration::add_scopes(const std::string& value) {
  _impl_.scopes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.Collaboration.scopes)
}
inline void Collaboration::add_scopes(std::string&& value) {
  _impl_.scopes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.Collaboration.scopes)
}
inline void Collaboration::add_scopes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.scopes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.Collaboration.scopes)
}
inline void Collaboration::add_scopes(const char* value, size_t size) {
  _impl_.scopes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.Collaboration.scopes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Collaboration::scopes() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Collaboration.scopes)
  return _impl_.scopes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Collaboration::mutable_scopes() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Collaboration.scopes)
  return &_impl_.scopes_;
}

// repeated string endpoints = 4;
inline int Collaboration::_internal_endpoints_size() const {
  return _impl_.endpoints_.size();
}
inline int Collaboration::endpoints_size() const {
  return _internal_endpoints_size();
}
inline void Collaboration::clear_endpoints() {
  _impl_.endpoints_.Clear();
}
inline std::string* Collaboration::add_endpoints() {
  std::string* _s = _internal_add_endpoints();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.Collaboration.endpoints)
  return _s;
}
inline const std::string& Collaboration::_internal_endpoints(int index) const {
  return _impl_.endpoints_.Get(index);
}
inline const std::string& Collaboration::endpoints(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Collaboration.endpoints)
  return _internal_endpoints(index);
}
inline std::string* Collaboration::mutable_endpoints(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Collaboration.endpoints)
  return _impl_.endpoints_.Mutable(index);
}
inline void Collaboration::set_endpoints(int index, const std::string& value) {
  _impl_.endpoints_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Collaboration.endpoints)
}
inline void Collaboration::set_endpoints(int index, std::string&& value) {
  _impl_.endpoints_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.Collaboration.endpoints)
}
inline void Collaboration::set_endpoints(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.endpoints_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.Collaboration.endpoints)
}
inline void Collaboration::set_endpoints(int index, const char* value, size_t size) {
  _impl_.endpoints_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.Collaboration.endpoints)
}
inline std::string* Collaboration::_internal_add_endpoints() {
  return _impl_.endpoints_.Add();
}
inline void Collaboration::add_endpoints(const std::string& value) {
  _impl_.endpoints_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.Collaboration.endpoints)
}
inline void Collaboration::add_endpoints(std::string&& value) {
  _impl_.endpoints_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.Collaboration.endpoints)
}
inline void Collaboration::add_endpoints(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.endpoints_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.Collaboration.endpoints)
}
inline void Collaboration::add_endpoints(const char* value, size_t size) {
  _impl_.endpoints_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.Collaboration.endpoints)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Collaboration::endpoints() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Collaboration.endpoints)
  return _impl_.endpoints_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Collaboration::mutable_endpoints() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Collaboration.endpoints)
  return &_impl_.endpoints_;
}

// .google.protobuf.Timestamp created_at = 5;
inline bool Collaboration::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool Collaboration::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Collaboration::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Collaboration::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Collaboration.created_at)
  return _internal_created_at();
}
inline void Collaboration::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Collaboration.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Collaboration::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Collaboration::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.Collaboration.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Collaboration::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Collaboration::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Collaboration.created_at)
  return _msg;
}
inline void Collaboration::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Collaboration.created_at)
}

// -------------------------------------------------------------------

// Audio

// string url = 1;
inline void Audio::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& Audio::url() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Audio.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Audio::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Audio.url)
}
inline std::string* Audio::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Audio.url)
  return _s;
}
inline const std::string& Audio::_internal_url() const {
  return _impl_.url_.Get();
}
inline void Audio::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* Audio::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* Audio::release_url() {
  // @@protoc_insertion_point(field_release:clarifai.api.Audio.url)
  return _impl_.url_.Release();
}
inline void Audio::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Audio.url)
}

// bytes base64 = 2;
inline void Audio::clear_base64() {
  _impl_.base64_.ClearToEmpty();
}
inline const std::string& Audio::base64() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Audio.base64)
  return _internal_base64();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Audio::set_base64(ArgT0&& arg0, ArgT... args) {
 
 _impl_.base64_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Audio.base64)
}
inline std::string* Audio::mutable_base64() {
  std::string* _s = _internal_mutable_base64();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Audio.base64)
  return _s;
}
inline const std::string& Audio::_internal_base64() const {
  return _impl_.base64_.Get();
}
inline void Audio::_internal_set_base64(const std::string& value) {
  
  _impl_.base64_.Set(value, GetArenaForAllocation());
}
inline std::string* Audio::_internal_mutable_base64() {
  
  return _impl_.base64_.Mutable(GetArenaForAllocation());
}
inline std::string* Audio::release_base64() {
  // @@protoc_insertion_point(field_release:clarifai.api.Audio.base64)
  return _impl_.base64_.Release();
}
inline void Audio::set_allocated_base64(std::string* base64) {
  if (base64 != nullptr) {
    
  } else {
    
  }
  _impl_.base64_.SetAllocated(base64, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.base64_.IsDefault()) {
    _impl_.base64_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Audio.base64)
}

// bool allow_duplicate_url = 4;
inline void Audio::clear_allow_duplicate_url() {
  _impl_.allow_duplicate_url_ = false;
}
inline bool Audio::_internal_allow_duplicate_url() const {
  return _impl_.allow_duplicate_url_;
}
inline bool Audio::allow_duplicate_url() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Audio.allow_duplicate_url)
  return _internal_allow_duplicate_url();
}
inline void Audio::_internal_set_allow_duplicate_url(bool value) {
  
  _impl_.allow_duplicate_url_ = value;
}
inline void Audio::set_allow_duplicate_url(bool value) {
  _internal_set_allow_duplicate_url(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Audio.allow_duplicate_url)
}

// .clarifai.api.HostedURL hosted = 5;
inline bool Audio::_internal_has_hosted() const {
  return this != internal_default_instance() && _impl_.hosted_ != nullptr;
}
inline bool Audio::has_hosted() const {
  return _internal_has_hosted();
}
inline void Audio::clear_hosted() {
  if (GetArenaForAllocation() == nullptr && _impl_.hosted_ != nullptr) {
    delete _impl_.hosted_;
  }
  _impl_.hosted_ = nullptr;
}
inline const ::clarifai::api::HostedURL& Audio::_internal_hosted() const {
  const ::clarifai::api::HostedURL* p = _impl_.hosted_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::HostedURL&>(
      ::clarifai::api::_HostedURL_default_instance_);
}
inline const ::clarifai::api::HostedURL& Audio::hosted() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Audio.hosted)
  return _internal_hosted();
}
inline void Audio::unsafe_arena_set_allocated_hosted(
    ::clarifai::api::HostedURL* hosted) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hosted_);
  }
  _impl_.hosted_ = hosted;
  if (hosted) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Audio.hosted)
}
inline ::clarifai::api::HostedURL* Audio::release_hosted() {
  
  ::clarifai::api::HostedURL* temp = _impl_.hosted_;
  _impl_.hosted_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::HostedURL* Audio::unsafe_arena_release_hosted() {
  // @@protoc_insertion_point(field_release:clarifai.api.Audio.hosted)
  
  ::clarifai::api::HostedURL* temp = _impl_.hosted_;
  _impl_.hosted_ = nullptr;
  return temp;
}
inline ::clarifai::api::HostedURL* Audio::_internal_mutable_hosted() {
  
  if (_impl_.hosted_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::HostedURL>(GetArenaForAllocation());
    _impl_.hosted_ = p;
  }
  return _impl_.hosted_;
}
inline ::clarifai::api::HostedURL* Audio::mutable_hosted() {
  ::clarifai::api::HostedURL* _msg = _internal_mutable_hosted();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Audio.hosted)
  return _msg;
}
inline void Audio::set_allocated_hosted(::clarifai::api::HostedURL* hosted) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hosted_;
  }
  if (hosted) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hosted);
    if (message_arena != submessage_arena) {
      hosted = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hosted, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.hosted_ = hosted;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Audio.hosted)
}

// .clarifai.api.AudioInfo audio_info = 6;
inline bool Audio::_internal_has_audio_info() const {
  return this != internal_default_instance() && _impl_.audio_info_ != nullptr;
}
inline bool Audio::has_audio_info() const {
  return _internal_has_audio_info();
}
inline void Audio::clear_audio_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.audio_info_ != nullptr) {
    delete _impl_.audio_info_;
  }
  _impl_.audio_info_ = nullptr;
}
inline const ::clarifai::api::AudioInfo& Audio::_internal_audio_info() const {
  const ::clarifai::api::AudioInfo* p = _impl_.audio_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::AudioInfo&>(
      ::clarifai::api::_AudioInfo_default_instance_);
}
inline const ::clarifai::api::AudioInfo& Audio::audio_info() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Audio.audio_info)
  return _internal_audio_info();
}
inline void Audio::unsafe_arena_set_allocated_audio_info(
    ::clarifai::api::AudioInfo* audio_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audio_info_);
  }
  _impl_.audio_info_ = audio_info;
  if (audio_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Audio.audio_info)
}
inline ::clarifai::api::AudioInfo* Audio::release_audio_info() {
  
  ::clarifai::api::AudioInfo* temp = _impl_.audio_info_;
  _impl_.audio_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::AudioInfo* Audio::unsafe_arena_release_audio_info() {
  // @@protoc_insertion_point(field_release:clarifai.api.Audio.audio_info)
  
  ::clarifai::api::AudioInfo* temp = _impl_.audio_info_;
  _impl_.audio_info_ = nullptr;
  return temp;
}
inline ::clarifai::api::AudioInfo* Audio::_internal_mutable_audio_info() {
  
  if (_impl_.audio_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::AudioInfo>(GetArenaForAllocation());
    _impl_.audio_info_ = p;
  }
  return _impl_.audio_info_;
}
inline ::clarifai::api::AudioInfo* Audio::mutable_audio_info() {
  ::clarifai::api::AudioInfo* _msg = _internal_mutable_audio_info();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Audio.audio_info)
  return _msg;
}
inline void Audio::set_allocated_audio_info(::clarifai::api::AudioInfo* audio_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.audio_info_;
  }
  if (audio_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(audio_info);
    if (message_arena != submessage_arena) {
      audio_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.audio_info_ = audio_info;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Audio.audio_info)
}

// -------------------------------------------------------------------

// AudioInfo

// string audio_format = 1;
inline void AudioInfo::clear_audio_format() {
  _impl_.audio_format_.ClearToEmpty();
}
inline const std::string& AudioInfo::audio_format() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AudioInfo.audio_format)
  return _internal_audio_format();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioInfo::set_audio_format(ArgT0&& arg0, ArgT... args) {
 
 _impl_.audio_format_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.AudioInfo.audio_format)
}
inline std::string* AudioInfo::mutable_audio_format() {
  std::string* _s = _internal_mutable_audio_format();
  // @@protoc_insertion_point(field_mutable:clarifai.api.AudioInfo.audio_format)
  return _s;
}
inline const std::string& AudioInfo::_internal_audio_format() const {
  return _impl_.audio_format_.Get();
}
inline void AudioInfo::_internal_set_audio_format(const std::string& value) {
  
  _impl_.audio_format_.Set(value, GetArenaForAllocation());
}
inline std::string* AudioInfo::_internal_mutable_audio_format() {
  
  return _impl_.audio_format_.Mutable(GetArenaForAllocation());
}
inline std::string* AudioInfo::release_audio_format() {
  // @@protoc_insertion_point(field_release:clarifai.api.AudioInfo.audio_format)
  return _impl_.audio_format_.Release();
}
inline void AudioInfo::set_allocated_audio_format(std::string* audio_format) {
  if (audio_format != nullptr) {
    
  } else {
    
  }
  _impl_.audio_format_.SetAllocated(audio_format, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.audio_format_.IsDefault()) {
    _impl_.audio_format_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.AudioInfo.audio_format)
}

// int32 sample_rate = 2;
inline void AudioInfo::clear_sample_rate() {
  _impl_.sample_rate_ = 0;
}
inline int32_t AudioInfo::_internal_sample_rate() const {
  return _impl_.sample_rate_;
}
inline int32_t AudioInfo::sample_rate() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AudioInfo.sample_rate)
  return _internal_sample_rate();
}
inline void AudioInfo::_internal_set_sample_rate(int32_t value) {
  
  _impl_.sample_rate_ = value;
}
inline void AudioInfo::set_sample_rate(int32_t value) {
  _internal_set_sample_rate(value);
  // @@protoc_insertion_point(field_set:clarifai.api.AudioInfo.sample_rate)
}

// float duration_seconds = 3;
inline void AudioInfo::clear_duration_seconds() {
  _impl_.duration_seconds_ = 0;
}
inline float AudioInfo::_internal_duration_seconds() const {
  return _impl_.duration_seconds_;
}
inline float AudioInfo::duration_seconds() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AudioInfo.duration_seconds)
  return _internal_duration_seconds();
}
inline void AudioInfo::_internal_set_duration_seconds(float value) {
  
  _impl_.duration_seconds_ = value;
}
inline void AudioInfo::set_duration_seconds(float value) {
  _internal_set_duration_seconds(value);
  // @@protoc_insertion_point(field_set:clarifai.api.AudioInfo.duration_seconds)
}

// int32 bit_rate = 4;
inline void AudioInfo::clear_bit_rate() {
  _impl_.bit_rate_ = 0;
}
inline int32_t AudioInfo::_internal_bit_rate() const {
  return _impl_.bit_rate_;
}
inline int32_t AudioInfo::bit_rate() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AudioInfo.bit_rate)
  return _internal_bit_rate();
}
inline void AudioInfo::_internal_set_bit_rate(int32_t value) {
  
  _impl_.bit_rate_ = value;
}
inline void AudioInfo::set_bit_rate(int32_t value) {
  _internal_set_bit_rate(value);
  // @@protoc_insertion_point(field_set:clarifai.api.AudioInfo.bit_rate)
}

// -------------------------------------------------------------------

// Track

// string id = 1;
inline void Track::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Track::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Track.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Track::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Track.id)
}
inline std::string* Track::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Track.id)
  return _s;
}
inline const std::string& Track::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Track::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Track::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Track::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Track.id)
  return _impl_.id_.Release();
}
inline void Track::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Track.id)
}

// .clarifai.api.Data data = 2;
inline bool Track::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool Track::has_data() const {
  return _internal_has_data();
}
inline void Track::clear_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.data_ != nullptr) {
    delete _impl_.data_;
  }
  _impl_.data_ = nullptr;
}
inline const ::clarifai::api::Data& Track::_internal_data() const {
  const ::clarifai::api::Data* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Data&>(
      ::clarifai::api::_Data_default_instance_);
}
inline const ::clarifai::api::Data& Track::data() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Track.data)
  return _internal_data();
}
inline void Track::unsafe_arena_set_allocated_data(
    ::clarifai::api::Data* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Track.data)
}
inline ::clarifai::api::Data* Track::release_data() {
  
  ::clarifai::api::Data* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Data* Track::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:clarifai.api.Track.data)
  
  ::clarifai::api::Data* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::clarifai::api::Data* Track::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Data>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::clarifai::api::Data* Track::mutable_data() {
  ::clarifai::api::Data* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Track.data)
  return _msg;
}
inline void Track::set_allocated_data(::clarifai::api::Data* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Track.data)
}

// .clarifai.api.TimeInfo time_info = 4;
inline bool Track::_internal_has_time_info() const {
  return this != internal_default_instance() && _impl_.time_info_ != nullptr;
}
inline bool Track::has_time_info() const {
  return _internal_has_time_info();
}
inline void Track::clear_time_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.time_info_ != nullptr) {
    delete _impl_.time_info_;
  }
  _impl_.time_info_ = nullptr;
}
inline const ::clarifai::api::TimeInfo& Track::_internal_time_info() const {
  const ::clarifai::api::TimeInfo* p = _impl_.time_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::TimeInfo&>(
      ::clarifai::api::_TimeInfo_default_instance_);
}
inline const ::clarifai::api::TimeInfo& Track::time_info() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Track.time_info)
  return _internal_time_info();
}
inline void Track::unsafe_arena_set_allocated_time_info(
    ::clarifai::api::TimeInfo* time_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_info_);
  }
  _impl_.time_info_ = time_info;
  if (time_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Track.time_info)
}
inline ::clarifai::api::TimeInfo* Track::release_time_info() {
  
  ::clarifai::api::TimeInfo* temp = _impl_.time_info_;
  _impl_.time_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::TimeInfo* Track::unsafe_arena_release_time_info() {
  // @@protoc_insertion_point(field_release:clarifai.api.Track.time_info)
  
  ::clarifai::api::TimeInfo* temp = _impl_.time_info_;
  _impl_.time_info_ = nullptr;
  return temp;
}
inline ::clarifai::api::TimeInfo* Track::_internal_mutable_time_info() {
  
  if (_impl_.time_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::TimeInfo>(GetArenaForAllocation());
    _impl_.time_info_ = p;
  }
  return _impl_.time_info_;
}
inline ::clarifai::api::TimeInfo* Track::mutable_time_info() {
  ::clarifai::api::TimeInfo* _msg = _internal_mutable_time_info();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Track.time_info)
  return _msg;
}
inline void Track::set_allocated_time_info(::clarifai::api::TimeInfo* time_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.time_info_;
  }
  if (time_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(time_info);
    if (message_arena != submessage_arena) {
      time_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.time_info_ = time_info;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Track.time_info)
}

// float quality = 5;
inline void Track::clear_quality() {
  _impl_.quality_ = 0;
}
inline float Track::_internal_quality() const {
  return _impl_.quality_;
}
inline float Track::quality() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Track.quality)
  return _internal_quality();
}
inline void Track::_internal_set_quality(float value) {
  
  _impl_.quality_ = value;
}
inline void Track::set_quality(float value) {
  _internal_set_quality(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Track.quality)
}

// -------------------------------------------------------------------

// Cluster

// string id = 1;
inline void Cluster::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Cluster::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Cluster.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Cluster::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Cluster.id)
}
inline std::string* Cluster::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Cluster.id)
  return _s;
}
inline const std::string& Cluster::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Cluster::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Cluster::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Cluster::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Cluster.id)
  return _impl_.id_.Release();
}
inline void Cluster::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Cluster.id)
}

// uint32 count = 2;
inline void Cluster::clear_count() {
  _impl_.count_ = 0u;
}
inline uint32_t Cluster::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t Cluster::count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Cluster.count)
  return _internal_count();
}
inline void Cluster::_internal_set_count(uint32_t value) {
  
  _impl_.count_ = value;
}
inline void Cluster::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Cluster.count)
}

// float score = 3;
inline void Cluster::clear_score() {
  _impl_.score_ = 0;
}
inline float Cluster::_internal_score() const {
  return _impl_.score_;
}
inline float Cluster::score() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Cluster.score)
  return _internal_score();
}
inline void Cluster::_internal_set_score(float value) {
  
  _impl_.score_ = value;
}
inline void Cluster::set_score(float value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Cluster.score)
}

// repeated .clarifai.api.Hit hits = 4;
inline int Cluster::_internal_hits_size() const {
  return _impl_.hits_.size();
}
inline int Cluster::hits_size() const {
  return _internal_hits_size();
}
inline void Cluster::clear_hits() {
  _impl_.hits_.Clear();
}
inline ::clarifai::api::Hit* Cluster::mutable_hits(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Cluster.hits)
  return _impl_.hits_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Hit >*
Cluster::mutable_hits() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Cluster.hits)
  return &_impl_.hits_;
}
inline const ::clarifai::api::Hit& Cluster::_internal_hits(int index) const {
  return _impl_.hits_.Get(index);
}
inline const ::clarifai::api::Hit& Cluster::hits(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Cluster.hits)
  return _internal_hits(index);
}
inline ::clarifai::api::Hit* Cluster::_internal_add_hits() {
  return _impl_.hits_.Add();
}
inline ::clarifai::api::Hit* Cluster::add_hits() {
  ::clarifai::api::Hit* _add = _internal_add_hits();
  // @@protoc_insertion_point(field_add:clarifai.api.Cluster.hits)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Hit >&
Cluster::hits() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Cluster.hits)
  return _impl_.hits_;
}

// repeated float projection = 5;
inline int Cluster::_internal_projection_size() const {
  return _impl_.projection_.size();
}
inline int Cluster::projection_size() const {
  return _internal_projection_size();
}
inline void Cluster::clear_projection() {
  _impl_.projection_.Clear();
}
inline float Cluster::_internal_projection(int index) const {
  return _impl_.projection_.Get(index);
}
inline float Cluster::projection(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Cluster.projection)
  return _internal_projection(index);
}
inline void Cluster::set_projection(int index, float value) {
  _impl_.projection_.Set(index, value);
  // @@protoc_insertion_point(field_set:clarifai.api.Cluster.projection)
}
inline void Cluster::_internal_add_projection(float value) {
  _impl_.projection_.Add(value);
}
inline void Cluster::add_projection(float value) {
  _internal_add_projection(value);
  // @@protoc_insertion_point(field_add:clarifai.api.Cluster.projection)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Cluster::_internal_projection() const {
  return _impl_.projection_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Cluster::projection() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Cluster.projection)
  return _internal_projection();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Cluster::_internal_mutable_projection() {
  return &_impl_.projection_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Cluster::mutable_projection() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Cluster.projection)
  return _internal_mutable_projection();
}

// -------------------------------------------------------------------

// Color

// string raw_hex = 1;
inline void Color::clear_raw_hex() {
  _impl_.raw_hex_.ClearToEmpty();
}
inline const std::string& Color::raw_hex() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Color.raw_hex)
  return _internal_raw_hex();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Color::set_raw_hex(ArgT0&& arg0, ArgT... args) {
 
 _impl_.raw_hex_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Color.raw_hex)
}
inline std::string* Color::mutable_raw_hex() {
  std::string* _s = _internal_mutable_raw_hex();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Color.raw_hex)
  return _s;
}
inline const std::string& Color::_internal_raw_hex() const {
  return _impl_.raw_hex_.Get();
}
inline void Color::_internal_set_raw_hex(const std::string& value) {
  
  _impl_.raw_hex_.Set(value, GetArenaForAllocation());
}
inline std::string* Color::_internal_mutable_raw_hex() {
  
  return _impl_.raw_hex_.Mutable(GetArenaForAllocation());
}
inline std::string* Color::release_raw_hex() {
  // @@protoc_insertion_point(field_release:clarifai.api.Color.raw_hex)
  return _impl_.raw_hex_.Release();
}
inline void Color::set_allocated_raw_hex(std::string* raw_hex) {
  if (raw_hex != nullptr) {
    
  } else {
    
  }
  _impl_.raw_hex_.SetAllocated(raw_hex, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.raw_hex_.IsDefault()) {
    _impl_.raw_hex_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Color.raw_hex)
}

// .clarifai.api.W3C w3c = 2;
inline bool Color::_internal_has_w3c() const {
  return this != internal_default_instance() && _impl_.w3c_ != nullptr;
}
inline bool Color::has_w3c() const {
  return _internal_has_w3c();
}
inline void Color::clear_w3c() {
  if (GetArenaForAllocation() == nullptr && _impl_.w3c_ != nullptr) {
    delete _impl_.w3c_;
  }
  _impl_.w3c_ = nullptr;
}
inline const ::clarifai::api::W3C& Color::_internal_w3c() const {
  const ::clarifai::api::W3C* p = _impl_.w3c_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::W3C&>(
      ::clarifai::api::_W3C_default_instance_);
}
inline const ::clarifai::api::W3C& Color::w3c() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Color.w3c)
  return _internal_w3c();
}
inline void Color::unsafe_arena_set_allocated_w3c(
    ::clarifai::api::W3C* w3c) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.w3c_);
  }
  _impl_.w3c_ = w3c;
  if (w3c) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Color.w3c)
}
inline ::clarifai::api::W3C* Color::release_w3c() {
  
  ::clarifai::api::W3C* temp = _impl_.w3c_;
  _impl_.w3c_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::W3C* Color::unsafe_arena_release_w3c() {
  // @@protoc_insertion_point(field_release:clarifai.api.Color.w3c)
  
  ::clarifai::api::W3C* temp = _impl_.w3c_;
  _impl_.w3c_ = nullptr;
  return temp;
}
inline ::clarifai::api::W3C* Color::_internal_mutable_w3c() {
  
  if (_impl_.w3c_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::W3C>(GetArenaForAllocation());
    _impl_.w3c_ = p;
  }
  return _impl_.w3c_;
}
inline ::clarifai::api::W3C* Color::mutable_w3c() {
  ::clarifai::api::W3C* _msg = _internal_mutable_w3c();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Color.w3c)
  return _msg;
}
inline void Color::set_allocated_w3c(::clarifai::api::W3C* w3c) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.w3c_;
  }
  if (w3c) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(w3c);
    if (message_arena != submessage_arena) {
      w3c = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, w3c, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.w3c_ = w3c;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Color.w3c)
}

// float value = 3 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void Color::clear_value() {
  _impl_.value_ = 0;
}
inline float Color::_internal_value() const {
  return _impl_.value_;
}
inline float Color::value() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Color.value)
  return _internal_value();
}
inline void Color::_internal_set_value(float value) {
  
  _impl_.value_ = value;
}
inline void Color::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Color.value)
}

// -------------------------------------------------------------------

// W3C

// string hex = 1;
inline void W3C::clear_hex() {
  _impl_.hex_.ClearToEmpty();
}
inline const std::string& W3C::hex() const {
  // @@protoc_insertion_point(field_get:clarifai.api.W3C.hex)
  return _internal_hex();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void W3C::set_hex(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hex_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.W3C.hex)
}
inline std::string* W3C::mutable_hex() {
  std::string* _s = _internal_mutable_hex();
  // @@protoc_insertion_point(field_mutable:clarifai.api.W3C.hex)
  return _s;
}
inline const std::string& W3C::_internal_hex() const {
  return _impl_.hex_.Get();
}
inline void W3C::_internal_set_hex(const std::string& value) {
  
  _impl_.hex_.Set(value, GetArenaForAllocation());
}
inline std::string* W3C::_internal_mutable_hex() {
  
  return _impl_.hex_.Mutable(GetArenaForAllocation());
}
inline std::string* W3C::release_hex() {
  // @@protoc_insertion_point(field_release:clarifai.api.W3C.hex)
  return _impl_.hex_.Release();
}
inline void W3C::set_allocated_hex(std::string* hex) {
  if (hex != nullptr) {
    
  } else {
    
  }
  _impl_.hex_.SetAllocated(hex, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hex_.IsDefault()) {
    _impl_.hex_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.W3C.hex)
}

// string name = 2;
inline void W3C::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& W3C::name() const {
  // @@protoc_insertion_point(field_get:clarifai.api.W3C.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void W3C::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.W3C.name)
}
inline std::string* W3C::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:clarifai.api.W3C.name)
  return _s;
}
inline const std::string& W3C::_internal_name() const {
  return _impl_.name_.Get();
}
inline void W3C::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* W3C::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* W3C::release_name() {
  // @@protoc_insertion_point(field_release:clarifai.api.W3C.name)
  return _impl_.name_.Release();
}
inline void W3C::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.W3C.name)
}

// -------------------------------------------------------------------

// UserAppIDSet

// string user_id = 1;
inline void UserAppIDSet::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& UserAppIDSet::user_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.UserAppIDSet.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserAppIDSet::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.UserAppIDSet.user_id)
}
inline std::string* UserAppIDSet::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.UserAppIDSet.user_id)
  return _s;
}
inline const std::string& UserAppIDSet::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void UserAppIDSet::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UserAppIDSet::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UserAppIDSet::release_user_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.UserAppIDSet.user_id)
  return _impl_.user_id_.Release();
}
inline void UserAppIDSet::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.UserAppIDSet.user_id)
}

// string app_id = 2;
inline void UserAppIDSet::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& UserAppIDSet::app_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.UserAppIDSet.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserAppIDSet::set_app_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.app_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.UserAppIDSet.app_id)
}
inline std::string* UserAppIDSet::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.UserAppIDSet.app_id)
  return _s;
}
inline const std::string& UserAppIDSet::_internal_app_id() const {
  return _impl_.app_id_.Get();
}
inline void UserAppIDSet::_internal_set_app_id(const std::string& value) {
  
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UserAppIDSet::_internal_mutable_app_id() {
  
  return _impl_.app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UserAppIDSet::release_app_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.UserAppIDSet.app_id)
  return _impl_.app_id_.Release();
}
inline void UserAppIDSet::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    
  } else {
    
  }
  _impl_.app_id_.SetAllocated(app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.UserAppIDSet.app_id)
}

// -------------------------------------------------------------------

// PatchAction

// string op = 1;
inline void PatchAction::clear_op() {
  _impl_.op_.ClearToEmpty();
}
inline const std::string& PatchAction::op() const {
  // @@protoc_insertion_point(field_get:clarifai.api.PatchAction.op)
  return _internal_op();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PatchAction::set_op(ArgT0&& arg0, ArgT... args) {
 
 _impl_.op_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.PatchAction.op)
}
inline std::string* PatchAction::mutable_op() {
  std::string* _s = _internal_mutable_op();
  // @@protoc_insertion_point(field_mutable:clarifai.api.PatchAction.op)
  return _s;
}
inline const std::string& PatchAction::_internal_op() const {
  return _impl_.op_.Get();
}
inline void PatchAction::_internal_set_op(const std::string& value) {
  
  _impl_.op_.Set(value, GetArenaForAllocation());
}
inline std::string* PatchAction::_internal_mutable_op() {
  
  return _impl_.op_.Mutable(GetArenaForAllocation());
}
inline std::string* PatchAction::release_op() {
  // @@protoc_insertion_point(field_release:clarifai.api.PatchAction.op)
  return _impl_.op_.Release();
}
inline void PatchAction::set_allocated_op(std::string* op) {
  if (op != nullptr) {
    
  } else {
    
  }
  _impl_.op_.SetAllocated(op, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.op_.IsDefault()) {
    _impl_.op_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.PatchAction.op)
}

// string merge_conflict_resolution = 2;
inline void PatchAction::clear_merge_conflict_resolution() {
  _impl_.merge_conflict_resolution_.ClearToEmpty();
}
inline const std::string& PatchAction::merge_conflict_resolution() const {
  // @@protoc_insertion_point(field_get:clarifai.api.PatchAction.merge_conflict_resolution)
  return _internal_merge_conflict_resolution();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PatchAction::set_merge_conflict_resolution(ArgT0&& arg0, ArgT... args) {
 
 _impl_.merge_conflict_resolution_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.PatchAction.merge_conflict_resolution)
}
inline std::string* PatchAction::mutable_merge_conflict_resolution() {
  std::string* _s = _internal_mutable_merge_conflict_resolution();
  // @@protoc_insertion_point(field_mutable:clarifai.api.PatchAction.merge_conflict_resolution)
  return _s;
}
inline const std::string& PatchAction::_internal_merge_conflict_resolution() const {
  return _impl_.merge_conflict_resolution_.Get();
}
inline void PatchAction::_internal_set_merge_conflict_resolution(const std::string& value) {
  
  _impl_.merge_conflict_resolution_.Set(value, GetArenaForAllocation());
}
inline std::string* PatchAction::_internal_mutable_merge_conflict_resolution() {
  
  return _impl_.merge_conflict_resolution_.Mutable(GetArenaForAllocation());
}
inline std::string* PatchAction::release_merge_conflict_resolution() {
  // @@protoc_insertion_point(field_release:clarifai.api.PatchAction.merge_conflict_resolution)
  return _impl_.merge_conflict_resolution_.Release();
}
inline void PatchAction::set_allocated_merge_conflict_resolution(std::string* merge_conflict_resolution) {
  if (merge_conflict_resolution != nullptr) {
    
  } else {
    
  }
  _impl_.merge_conflict_resolution_.SetAllocated(merge_conflict_resolution, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.merge_conflict_resolution_.IsDefault()) {
    _impl_.merge_conflict_resolution_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.PatchAction.merge_conflict_resolution)
}

// string path = 3;
inline void PatchAction::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& PatchAction::path() const {
  // @@protoc_insertion_point(field_get:clarifai.api.PatchAction.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PatchAction::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.PatchAction.path)
}
inline std::string* PatchAction::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:clarifai.api.PatchAction.path)
  return _s;
}
inline const std::string& PatchAction::_internal_path() const {
  return _impl_.path_.Get();
}
inline void PatchAction::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* PatchAction::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* PatchAction::release_path() {
  // @@protoc_insertion_point(field_release:clarifai.api.PatchAction.path)
  return _impl_.path_.Release();
}
inline void PatchAction::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.PatchAction.path)
}

// -------------------------------------------------------------------

// Concept

// string id = 1;
inline void Concept::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Concept::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Concept.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Concept::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Concept.id)
}
inline std::string* Concept::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Concept.id)
  return _s;
}
inline const std::string& Concept::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Concept::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Concept::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Concept::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Concept.id)
  return _impl_.id_.Release();
}
inline void Concept::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Concept.id)
}

// string name = 2;
inline void Concept::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Concept::name() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Concept.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Concept::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Concept.name)
}
inline std::string* Concept::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Concept.name)
  return _s;
}
inline const std::string& Concept::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Concept::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Concept::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Concept::release_name() {
  // @@protoc_insertion_point(field_release:clarifai.api.Concept.name)
  return _impl_.name_.Release();
}
inline void Concept::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Concept.name)
}

// float value = 3 [(.clarifai.api.utils.cl_show_if_empty) = true, (.clarifai.api.utils.cl_default_float) = 1];
inline void Concept::clear_value() {
  _impl_.value_ = 0;
}
inline float Concept::_internal_value() const {
  return _impl_.value_;
}
inline float Concept::value() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Concept.value)
  return _internal_value();
}
inline void Concept::_internal_set_value(float value) {
  
  _impl_.value_ = value;
}
inline void Concept::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Concept.value)
}

// .google.protobuf.Timestamp created_at = 4;
inline bool Concept::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool Concept::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Concept::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Concept::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Concept.created_at)
  return _internal_created_at();
}
inline void Concept::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Concept.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Concept::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Concept::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.Concept.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Concept::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Concept::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Concept.created_at)
  return _msg;
}
inline void Concept::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Concept.created_at)
}

// string language = 5;
inline void Concept::clear_language() {
  _impl_.language_.ClearToEmpty();
}
inline const std::string& Concept::language() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Concept.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Concept::set_language(ArgT0&& arg0, ArgT... args) {
 
 _impl_.language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Concept.language)
}
inline std::string* Concept::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Concept.language)
  return _s;
}
inline const std::string& Concept::_internal_language() const {
  return _impl_.language_.Get();
}
inline void Concept::_internal_set_language(const std::string& value) {
  
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* Concept::_internal_mutable_language() {
  
  return _impl_.language_.Mutable(GetArenaForAllocation());
}
inline std::string* Concept::release_language() {
  // @@protoc_insertion_point(field_release:clarifai.api.Concept.language)
  return _impl_.language_.Release();
}
inline void Concept::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    
  } else {
    
  }
  _impl_.language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Concept.language)
}

// string app_id = 6;
inline void Concept::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& Concept::app_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Concept.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Concept::set_app_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.app_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Concept.app_id)
}
inline std::string* Concept::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Concept.app_id)
  return _s;
}
inline const std::string& Concept::_internal_app_id() const {
  return _impl_.app_id_.Get();
}
inline void Concept::_internal_set_app_id(const std::string& value) {
  
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Concept::_internal_mutable_app_id() {
  
  return _impl_.app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Concept::release_app_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Concept.app_id)
  return _impl_.app_id_.Release();
}
inline void Concept::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    
  } else {
    
  }
  _impl_.app_id_.SetAllocated(app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Concept.app_id)
}

// string definition = 7;
inline void Concept::clear_definition() {
  _impl_.definition_.ClearToEmpty();
}
inline const std::string& Concept::definition() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Concept.definition)
  return _internal_definition();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Concept::set_definition(ArgT0&& arg0, ArgT... args) {
 
 _impl_.definition_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Concept.definition)
}
inline std::string* Concept::mutable_definition() {
  std::string* _s = _internal_mutable_definition();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Concept.definition)
  return _s;
}
inline const std::string& Concept::_internal_definition() const {
  return _impl_.definition_.Get();
}
inline void Concept::_internal_set_definition(const std::string& value) {
  
  _impl_.definition_.Set(value, GetArenaForAllocation());
}
inline std::string* Concept::_internal_mutable_definition() {
  
  return _impl_.definition_.Mutable(GetArenaForAllocation());
}
inline std::string* Concept::release_definition() {
  // @@protoc_insertion_point(field_release:clarifai.api.Concept.definition)
  return _impl_.definition_.Release();
}
inline void Concept::set_allocated_definition(std::string* definition) {
  if (definition != nullptr) {
    
  } else {
    
  }
  _impl_.definition_.SetAllocated(definition, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.definition_.IsDefault()) {
    _impl_.definition_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Concept.definition)
}

// string vocab_id = 8;
inline void Concept::clear_vocab_id() {
  _impl_.vocab_id_.ClearToEmpty();
}
inline const std::string& Concept::vocab_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Concept.vocab_id)
  return _internal_vocab_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Concept::set_vocab_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.vocab_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Concept.vocab_id)
}
inline std::string* Concept::mutable_vocab_id() {
  std::string* _s = _internal_mutable_vocab_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Concept.vocab_id)
  return _s;
}
inline const std::string& Concept::_internal_vocab_id() const {
  return _impl_.vocab_id_.Get();
}
inline void Concept::_internal_set_vocab_id(const std::string& value) {
  
  _impl_.vocab_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Concept::_internal_mutable_vocab_id() {
  
  return _impl_.vocab_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Concept::release_vocab_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Concept.vocab_id)
  return _impl_.vocab_id_.Release();
}
inline void Concept::set_allocated_vocab_id(std::string* vocab_id) {
  if (vocab_id != nullptr) {
    
  } else {
    
  }
  _impl_.vocab_id_.SetAllocated(vocab_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vocab_id_.IsDefault()) {
    _impl_.vocab_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Concept.vocab_id)
}

// .clarifai.api.Visibility visibility = 9;
inline bool Concept::_internal_has_visibility() const {
  return this != internal_default_instance() && _impl_.visibility_ != nullptr;
}
inline bool Concept::has_visibility() const {
  return _internal_has_visibility();
}
inline void Concept::clear_visibility() {
  if (GetArenaForAllocation() == nullptr && _impl_.visibility_ != nullptr) {
    delete _impl_.visibility_;
  }
  _impl_.visibility_ = nullptr;
}
inline const ::clarifai::api::Visibility& Concept::_internal_visibility() const {
  const ::clarifai::api::Visibility* p = _impl_.visibility_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Visibility&>(
      ::clarifai::api::_Visibility_default_instance_);
}
inline const ::clarifai::api::Visibility& Concept::visibility() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Concept.visibility)
  return _internal_visibility();
}
inline void Concept::unsafe_arena_set_allocated_visibility(
    ::clarifai::api::Visibility* visibility) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visibility_);
  }
  _impl_.visibility_ = visibility;
  if (visibility) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Concept.visibility)
}
inline ::clarifai::api::Visibility* Concept::release_visibility() {
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Visibility* Concept::unsafe_arena_release_visibility() {
  // @@protoc_insertion_point(field_release:clarifai.api.Concept.visibility)
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
  return temp;
}
inline ::clarifai::api::Visibility* Concept::_internal_mutable_visibility() {
  
  if (_impl_.visibility_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Visibility>(GetArenaForAllocation());
    _impl_.visibility_ = p;
  }
  return _impl_.visibility_;
}
inline ::clarifai::api::Visibility* Concept::mutable_visibility() {
  ::clarifai::api::Visibility* _msg = _internal_mutable_visibility();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Concept.visibility)
  return _msg;
}
inline void Concept::set_allocated_visibility(::clarifai::api::Visibility* visibility) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.visibility_;
  }
  if (visibility) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(visibility);
    if (message_arena != submessage_arena) {
      visibility = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visibility, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.visibility_ = visibility;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Concept.visibility)
}

// string user_id = 10;
inline void Concept::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& Concept::user_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Concept.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Concept::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Concept.user_id)
}
inline std::string* Concept::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Concept.user_id)
  return _s;
}
inline const std::string& Concept::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void Concept::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Concept::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Concept::release_user_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Concept.user_id)
  return _impl_.user_id_.Release();
}
inline void Concept::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Concept.user_id)
}

// .clarifai.api.KeypointInfo keypoint_info = 11;
inline bool Concept::_internal_has_keypoint_info() const {
  return this != internal_default_instance() && _impl_.keypoint_info_ != nullptr;
}
inline bool Concept::has_keypoint_info() const {
  return _internal_has_keypoint_info();
}
inline void Concept::clear_keypoint_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.keypoint_info_ != nullptr) {
    delete _impl_.keypoint_info_;
  }
  _impl_.keypoint_info_ = nullptr;
}
inline const ::clarifai::api::KeypointInfo& Concept::_internal_keypoint_info() const {
  const ::clarifai::api::KeypointInfo* p = _impl_.keypoint_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::KeypointInfo&>(
      ::clarifai::api::_KeypointInfo_default_instance_);
}
inline const ::clarifai::api::KeypointInfo& Concept::keypoint_info() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Concept.keypoint_info)
  return _internal_keypoint_info();
}
inline void Concept::unsafe_arena_set_allocated_keypoint_info(
    ::clarifai::api::KeypointInfo* keypoint_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.keypoint_info_);
  }
  _impl_.keypoint_info_ = keypoint_info;
  if (keypoint_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Concept.keypoint_info)
}
inline ::clarifai::api::KeypointInfo* Concept::release_keypoint_info() {
  
  ::clarifai::api::KeypointInfo* temp = _impl_.keypoint_info_;
  _impl_.keypoint_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::KeypointInfo* Concept::unsafe_arena_release_keypoint_info() {
  // @@protoc_insertion_point(field_release:clarifai.api.Concept.keypoint_info)
  
  ::clarifai::api::KeypointInfo* temp = _impl_.keypoint_info_;
  _impl_.keypoint_info_ = nullptr;
  return temp;
}
inline ::clarifai::api::KeypointInfo* Concept::_internal_mutable_keypoint_info() {
  
  if (_impl_.keypoint_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::KeypointInfo>(GetArenaForAllocation());
    _impl_.keypoint_info_ = p;
  }
  return _impl_.keypoint_info_;
}
inline ::clarifai::api::KeypointInfo* Concept::mutable_keypoint_info() {
  ::clarifai::api::KeypointInfo* _msg = _internal_mutable_keypoint_info();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Concept.keypoint_info)
  return _msg;
}
inline void Concept::set_allocated_keypoint_info(::clarifai::api::KeypointInfo* keypoint_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.keypoint_info_;
  }
  if (keypoint_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(keypoint_info);
    if (message_arena != submessage_arena) {
      keypoint_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, keypoint_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.keypoint_info_ = keypoint_info;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Concept.keypoint_info)
}

// -------------------------------------------------------------------

// KeypointInfo

// repeated string keypoint_names = 1;
inline int KeypointInfo::_internal_keypoint_names_size() const {
  return _impl_.keypoint_names_.size();
}
inline int KeypointInfo::keypoint_names_size() const {
  return _internal_keypoint_names_size();
}
inline void KeypointInfo::clear_keypoint_names() {
  _impl_.keypoint_names_.Clear();
}
inline std::string* KeypointInfo::add_keypoint_names() {
  std::string* _s = _internal_add_keypoint_names();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.KeypointInfo.keypoint_names)
  return _s;
}
inline const std::string& KeypointInfo::_internal_keypoint_names(int index) const {
  return _impl_.keypoint_names_.Get(index);
}
inline const std::string& KeypointInfo::keypoint_names(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.KeypointInfo.keypoint_names)
  return _internal_keypoint_names(index);
}
inline std::string* KeypointInfo::mutable_keypoint_names(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.KeypointInfo.keypoint_names)
  return _impl_.keypoint_names_.Mutable(index);
}
inline void KeypointInfo::set_keypoint_names(int index, const std::string& value) {
  _impl_.keypoint_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.KeypointInfo.keypoint_names)
}
inline void KeypointInfo::set_keypoint_names(int index, std::string&& value) {
  _impl_.keypoint_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.KeypointInfo.keypoint_names)
}
inline void KeypointInfo::set_keypoint_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.keypoint_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.KeypointInfo.keypoint_names)
}
inline void KeypointInfo::set_keypoint_names(int index, const char* value, size_t size) {
  _impl_.keypoint_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.KeypointInfo.keypoint_names)
}
inline std::string* KeypointInfo::_internal_add_keypoint_names() {
  return _impl_.keypoint_names_.Add();
}
inline void KeypointInfo::add_keypoint_names(const std::string& value) {
  _impl_.keypoint_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.KeypointInfo.keypoint_names)
}
inline void KeypointInfo::add_keypoint_names(std::string&& value) {
  _impl_.keypoint_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.KeypointInfo.keypoint_names)
}
inline void KeypointInfo::add_keypoint_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.keypoint_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.KeypointInfo.keypoint_names)
}
inline void KeypointInfo::add_keypoint_names(const char* value, size_t size) {
  _impl_.keypoint_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.KeypointInfo.keypoint_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
KeypointInfo::keypoint_names() const {
  // @@protoc_insertion_point(field_list:clarifai.api.KeypointInfo.keypoint_names)
  return _impl_.keypoint_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
KeypointInfo::mutable_keypoint_names() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.KeypointInfo.keypoint_names)
  return &_impl_.keypoint_names_;
}

// repeated .clarifai.api.KeypointEdge skeleton = 2;
inline int KeypointInfo::_internal_skeleton_size() const {
  return _impl_.skeleton_.size();
}
inline int KeypointInfo::skeleton_size() const {
  return _internal_skeleton_size();
}
inline void KeypointInfo::clear_skeleton() {
  _impl_.skeleton_.Clear();
}
inline ::clarifai::api::KeypointEdge* KeypointInfo::mutable_skeleton(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.KeypointInfo.skeleton)
  return _impl_.skeleton_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::KeypointEdge >*
KeypointInfo::mutable_skeleton() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.KeypointInfo.skeleton)
  return &_impl_.skeleton_;
}
inline const ::clarifai::api::KeypointEdge& KeypointInfo::_internal_skeleton(int index) const {
  return _impl_.skeleton_.Get(index);
}
inline const ::clarifai::api::KeypointEdge& KeypointInfo::skeleton(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.KeypointInfo.skeleton)
  return _internal_skeleton(index);
}
inline ::clarifai::api::KeypointEdge* KeypointInfo::_internal_add_skeleton() {
  return _impl_.skeleton_.Add();
}
inline ::clarifai::api::KeypointEdge* KeypointInfo::add_skeleton() {
  ::clarifai::api::KeypointEdge* _add = _internal_add_skeleton();
  // @@protoc_insertion_point(field_add:clarifai.api.KeypointInfo.skeleton)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::KeypointEdge >&
KeypointInfo::skeleton() const {
  // @@protoc_insertion_point(field_list:clarifai.api.KeypointInfo.skeleton)
  return _impl_.skeleton_;
}

// -------------------------------------------------------------------

// KeypointEdge

// uint32 k1 = 1;
inline void KeypointEdge::clear_k1() {
  _impl_.k1_ = 0u;
}
inline uint32_t KeypointEdge::_internal_k1() const {
  return _impl_.k1_;
}
inline uint32_t KeypointEdge::k1() const {
  // @@protoc_insertion_point(field_get:clarifai.api.KeypointEdge.k1)
  return _internal_k1();
}
inline void KeypointEdge::_internal_set_k1(uint32_t value) {
  
  _impl_.k1_ = value;
}
inline void KeypointEdge::set_k1(uint32_t value) {
  _internal_set_k1(value);
  // @@protoc_insertion_point(field_set:clarifai.api.KeypointEdge.k1)
}

// uint32 k2 = 2;
inline void KeypointEdge::clear_k2() {
  _impl_.k2_ = 0u;
}
inline uint32_t KeypointEdge::_internal_k2() const {
  return _impl_.k2_;
}
inline uint32_t KeypointEdge::k2() const {
  // @@protoc_insertion_point(field_get:clarifai.api.KeypointEdge.k2)
  return _internal_k2();
}
inline void KeypointEdge::_internal_set_k2(uint32_t value) {
  
  _impl_.k2_ = value;
}
inline void KeypointEdge::set_k2(uint32_t value) {
  _internal_set_k2(value);
  // @@protoc_insertion_point(field_set:clarifai.api.KeypointEdge.k2)
}

// -------------------------------------------------------------------

// ConceptCount

// string id = 1;
inline void ConceptCount::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ConceptCount::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ConceptCount.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConceptCount::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ConceptCount.id)
}
inline std::string* ConceptCount::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ConceptCount.id)
  return _s;
}
inline const std::string& ConceptCount::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ConceptCount::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ConceptCount::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ConceptCount::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.ConceptCount.id)
  return _impl_.id_.Release();
}
inline void ConceptCount::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ConceptCount.id)
}

// string name = 2;
inline void ConceptCount::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ConceptCount::name() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ConceptCount.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConceptCount::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ConceptCount.name)
}
inline std::string* ConceptCount::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ConceptCount.name)
  return _s;
}
inline const std::string& ConceptCount::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ConceptCount::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ConceptCount::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ConceptCount::release_name() {
  // @@protoc_insertion_point(field_release:clarifai.api.ConceptCount.name)
  return _impl_.name_.Release();
}
inline void ConceptCount::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ConceptCount.name)
}

// .clarifai.api.ConceptTypeCount concept_type_count = 3;
inline bool ConceptCount::_internal_has_concept_type_count() const {
  return this != internal_default_instance() && _impl_.concept_type_count_ != nullptr;
}
inline bool ConceptCount::has_concept_type_count() const {
  return _internal_has_concept_type_count();
}
inline void ConceptCount::clear_concept_type_count() {
  if (GetArenaForAllocation() == nullptr && _impl_.concept_type_count_ != nullptr) {
    delete _impl_.concept_type_count_;
  }
  _impl_.concept_type_count_ = nullptr;
}
inline const ::clarifai::api::ConceptTypeCount& ConceptCount::_internal_concept_type_count() const {
  const ::clarifai::api::ConceptTypeCount* p = _impl_.concept_type_count_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::ConceptTypeCount&>(
      ::clarifai::api::_ConceptTypeCount_default_instance_);
}
inline const ::clarifai::api::ConceptTypeCount& ConceptCount::concept_type_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ConceptCount.concept_type_count)
  return _internal_concept_type_count();
}
inline void ConceptCount::unsafe_arena_set_allocated_concept_type_count(
    ::clarifai::api::ConceptTypeCount* concept_type_count) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.concept_type_count_);
  }
  _impl_.concept_type_count_ = concept_type_count;
  if (concept_type_count) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.ConceptCount.concept_type_count)
}
inline ::clarifai::api::ConceptTypeCount* ConceptCount::release_concept_type_count() {
  
  ::clarifai::api::ConceptTypeCount* temp = _impl_.concept_type_count_;
  _impl_.concept_type_count_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::ConceptTypeCount* ConceptCount::unsafe_arena_release_concept_type_count() {
  // @@protoc_insertion_point(field_release:clarifai.api.ConceptCount.concept_type_count)
  
  ::clarifai::api::ConceptTypeCount* temp = _impl_.concept_type_count_;
  _impl_.concept_type_count_ = nullptr;
  return temp;
}
inline ::clarifai::api::ConceptTypeCount* ConceptCount::_internal_mutable_concept_type_count() {
  
  if (_impl_.concept_type_count_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::ConceptTypeCount>(GetArenaForAllocation());
    _impl_.concept_type_count_ = p;
  }
  return _impl_.concept_type_count_;
}
inline ::clarifai::api::ConceptTypeCount* ConceptCount::mutable_concept_type_count() {
  ::clarifai::api::ConceptTypeCount* _msg = _internal_mutable_concept_type_count();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ConceptCount.concept_type_count)
  return _msg;
}
inline void ConceptCount::set_allocated_concept_type_count(::clarifai::api::ConceptTypeCount* concept_type_count) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.concept_type_count_;
  }
  if (concept_type_count) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(concept_type_count);
    if (message_arena != submessage_arena) {
      concept_type_count = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, concept_type_count, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.concept_type_count_ = concept_type_count;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ConceptCount.concept_type_count)
}

// .clarifai.api.DetailConceptCount detail_concept_count = 4;
inline bool ConceptCount::_internal_has_detail_concept_count() const {
  return this != internal_default_instance() && _impl_.detail_concept_count_ != nullptr;
}
inline bool ConceptCount::has_detail_concept_count() const {
  return _internal_has_detail_concept_count();
}
inline void ConceptCount::clear_detail_concept_count() {
  if (GetArenaForAllocation() == nullptr && _impl_.detail_concept_count_ != nullptr) {
    delete _impl_.detail_concept_count_;
  }
  _impl_.detail_concept_count_ = nullptr;
}
inline const ::clarifai::api::DetailConceptCount& ConceptCount::_internal_detail_concept_count() const {
  const ::clarifai::api::DetailConceptCount* p = _impl_.detail_concept_count_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::DetailConceptCount&>(
      ::clarifai::api::_DetailConceptCount_default_instance_);
}
inline const ::clarifai::api::DetailConceptCount& ConceptCount::detail_concept_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ConceptCount.detail_concept_count)
  return _internal_detail_concept_count();
}
inline void ConceptCount::unsafe_arena_set_allocated_detail_concept_count(
    ::clarifai::api::DetailConceptCount* detail_concept_count) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.detail_concept_count_);
  }
  _impl_.detail_concept_count_ = detail_concept_count;
  if (detail_concept_count) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.ConceptCount.detail_concept_count)
}
inline ::clarifai::api::DetailConceptCount* ConceptCount::release_detail_concept_count() {
  
  ::clarifai::api::DetailConceptCount* temp = _impl_.detail_concept_count_;
  _impl_.detail_concept_count_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::DetailConceptCount* ConceptCount::unsafe_arena_release_detail_concept_count() {
  // @@protoc_insertion_point(field_release:clarifai.api.ConceptCount.detail_concept_count)
  
  ::clarifai::api::DetailConceptCount* temp = _impl_.detail_concept_count_;
  _impl_.detail_concept_count_ = nullptr;
  return temp;
}
inline ::clarifai::api::DetailConceptCount* ConceptCount::_internal_mutable_detail_concept_count() {
  
  if (_impl_.detail_concept_count_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::DetailConceptCount>(GetArenaForAllocation());
    _impl_.detail_concept_count_ = p;
  }
  return _impl_.detail_concept_count_;
}
inline ::clarifai::api::DetailConceptCount* ConceptCount::mutable_detail_concept_count() {
  ::clarifai::api::DetailConceptCount* _msg = _internal_mutable_detail_concept_count();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ConceptCount.detail_concept_count)
  return _msg;
}
inline void ConceptCount::set_allocated_detail_concept_count(::clarifai::api::DetailConceptCount* detail_concept_count) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.detail_concept_count_;
  }
  if (detail_concept_count) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(detail_concept_count);
    if (message_arena != submessage_arena) {
      detail_concept_count = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, detail_concept_count, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.detail_concept_count_ = detail_concept_count;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ConceptCount.detail_concept_count)
}

// -------------------------------------------------------------------

// ConceptTypeCount

// uint32 positive = 1 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void ConceptTypeCount::clear_positive() {
  _impl_.positive_ = 0u;
}
inline uint32_t ConceptTypeCount::_internal_positive() const {
  return _impl_.positive_;
}
inline uint32_t ConceptTypeCount::positive() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ConceptTypeCount.positive)
  return _internal_positive();
}
inline void ConceptTypeCount::_internal_set_positive(uint32_t value) {
  
  _impl_.positive_ = value;
}
inline void ConceptTypeCount::set_positive(uint32_t value) {
  _internal_set_positive(value);
  // @@protoc_insertion_point(field_set:clarifai.api.ConceptTypeCount.positive)
}

// uint32 negative = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void ConceptTypeCount::clear_negative() {
  _impl_.negative_ = 0u;
}
inline uint32_t ConceptTypeCount::_internal_negative() const {
  return _impl_.negative_;
}
inline uint32_t ConceptTypeCount::negative() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ConceptTypeCount.negative)
  return _internal_negative();
}
inline void ConceptTypeCount::_internal_set_negative(uint32_t value) {
  
  _impl_.negative_ = value;
}
inline void ConceptTypeCount::set_negative(uint32_t value) {
  _internal_set_negative(value);
  // @@protoc_insertion_point(field_set:clarifai.api.ConceptTypeCount.negative)
}

// -------------------------------------------------------------------

// DetailConceptCount

// .clarifai.api.ConceptTypeCount processed = 1;
inline bool DetailConceptCount::_internal_has_processed() const {
  return this != internal_default_instance() && _impl_.processed_ != nullptr;
}
inline bool DetailConceptCount::has_processed() const {
  return _internal_has_processed();
}
inline void DetailConceptCount::clear_processed() {
  if (GetArenaForAllocation() == nullptr && _impl_.processed_ != nullptr) {
    delete _impl_.processed_;
  }
  _impl_.processed_ = nullptr;
}
inline const ::clarifai::api::ConceptTypeCount& DetailConceptCount::_internal_processed() const {
  const ::clarifai::api::ConceptTypeCount* p = _impl_.processed_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::ConceptTypeCount&>(
      ::clarifai::api::_ConceptTypeCount_default_instance_);
}
inline const ::clarifai::api::ConceptTypeCount& DetailConceptCount::processed() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DetailConceptCount.processed)
  return _internal_processed();
}
inline void DetailConceptCount::unsafe_arena_set_allocated_processed(
    ::clarifai::api::ConceptTypeCount* processed) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.processed_);
  }
  _impl_.processed_ = processed;
  if (processed) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DetailConceptCount.processed)
}
inline ::clarifai::api::ConceptTypeCount* DetailConceptCount::release_processed() {
  
  ::clarifai::api::ConceptTypeCount* temp = _impl_.processed_;
  _impl_.processed_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::ConceptTypeCount* DetailConceptCount::unsafe_arena_release_processed() {
  // @@protoc_insertion_point(field_release:clarifai.api.DetailConceptCount.processed)
  
  ::clarifai::api::ConceptTypeCount* temp = _impl_.processed_;
  _impl_.processed_ = nullptr;
  return temp;
}
inline ::clarifai::api::ConceptTypeCount* DetailConceptCount::_internal_mutable_processed() {
  
  if (_impl_.processed_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::ConceptTypeCount>(GetArenaForAllocation());
    _impl_.processed_ = p;
  }
  return _impl_.processed_;
}
inline ::clarifai::api::ConceptTypeCount* DetailConceptCount::mutable_processed() {
  ::clarifai::api::ConceptTypeCount* _msg = _internal_mutable_processed();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DetailConceptCount.processed)
  return _msg;
}
inline void DetailConceptCount::set_allocated_processed(::clarifai::api::ConceptTypeCount* processed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.processed_;
  }
  if (processed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(processed);
    if (message_arena != submessage_arena) {
      processed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, processed, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.processed_ = processed;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DetailConceptCount.processed)
}

// .clarifai.api.ConceptTypeCount to_process = 2;
inline bool DetailConceptCount::_internal_has_to_process() const {
  return this != internal_default_instance() && _impl_.to_process_ != nullptr;
}
inline bool DetailConceptCount::has_to_process() const {
  return _internal_has_to_process();
}
inline void DetailConceptCount::clear_to_process() {
  if (GetArenaForAllocation() == nullptr && _impl_.to_process_ != nullptr) {
    delete _impl_.to_process_;
  }
  _impl_.to_process_ = nullptr;
}
inline const ::clarifai::api::ConceptTypeCount& DetailConceptCount::_internal_to_process() const {
  const ::clarifai::api::ConceptTypeCount* p = _impl_.to_process_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::ConceptTypeCount&>(
      ::clarifai::api::_ConceptTypeCount_default_instance_);
}
inline const ::clarifai::api::ConceptTypeCount& DetailConceptCount::to_process() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DetailConceptCount.to_process)
  return _internal_to_process();
}
inline void DetailConceptCount::unsafe_arena_set_allocated_to_process(
    ::clarifai::api::ConceptTypeCount* to_process) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.to_process_);
  }
  _impl_.to_process_ = to_process;
  if (to_process) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DetailConceptCount.to_process)
}
inline ::clarifai::api::ConceptTypeCount* DetailConceptCount::release_to_process() {
  
  ::clarifai::api::ConceptTypeCount* temp = _impl_.to_process_;
  _impl_.to_process_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::ConceptTypeCount* DetailConceptCount::unsafe_arena_release_to_process() {
  // @@protoc_insertion_point(field_release:clarifai.api.DetailConceptCount.to_process)
  
  ::clarifai::api::ConceptTypeCount* temp = _impl_.to_process_;
  _impl_.to_process_ = nullptr;
  return temp;
}
inline ::clarifai::api::ConceptTypeCount* DetailConceptCount::_internal_mutable_to_process() {
  
  if (_impl_.to_process_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::ConceptTypeCount>(GetArenaForAllocation());
    _impl_.to_process_ = p;
  }
  return _impl_.to_process_;
}
inline ::clarifai::api::ConceptTypeCount* DetailConceptCount::mutable_to_process() {
  ::clarifai::api::ConceptTypeCount* _msg = _internal_mutable_to_process();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DetailConceptCount.to_process)
  return _msg;
}
inline void DetailConceptCount::set_allocated_to_process(::clarifai::api::ConceptTypeCount* to_process) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.to_process_;
  }
  if (to_process) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(to_process);
    if (message_arena != submessage_arena) {
      to_process = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, to_process, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.to_process_ = to_process;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DetailConceptCount.to_process)
}

// .clarifai.api.ConceptTypeCount errors = 3;
inline bool DetailConceptCount::_internal_has_errors() const {
  return this != internal_default_instance() && _impl_.errors_ != nullptr;
}
inline bool DetailConceptCount::has_errors() const {
  return _internal_has_errors();
}
inline void DetailConceptCount::clear_errors() {
  if (GetArenaForAllocation() == nullptr && _impl_.errors_ != nullptr) {
    delete _impl_.errors_;
  }
  _impl_.errors_ = nullptr;
}
inline const ::clarifai::api::ConceptTypeCount& DetailConceptCount::_internal_errors() const {
  const ::clarifai::api::ConceptTypeCount* p = _impl_.errors_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::ConceptTypeCount&>(
      ::clarifai::api::_ConceptTypeCount_default_instance_);
}
inline const ::clarifai::api::ConceptTypeCount& DetailConceptCount::errors() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DetailConceptCount.errors)
  return _internal_errors();
}
inline void DetailConceptCount::unsafe_arena_set_allocated_errors(
    ::clarifai::api::ConceptTypeCount* errors) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.errors_);
  }
  _impl_.errors_ = errors;
  if (errors) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DetailConceptCount.errors)
}
inline ::clarifai::api::ConceptTypeCount* DetailConceptCount::release_errors() {
  
  ::clarifai::api::ConceptTypeCount* temp = _impl_.errors_;
  _impl_.errors_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::ConceptTypeCount* DetailConceptCount::unsafe_arena_release_errors() {
  // @@protoc_insertion_point(field_release:clarifai.api.DetailConceptCount.errors)
  
  ::clarifai::api::ConceptTypeCount* temp = _impl_.errors_;
  _impl_.errors_ = nullptr;
  return temp;
}
inline ::clarifai::api::ConceptTypeCount* DetailConceptCount::_internal_mutable_errors() {
  
  if (_impl_.errors_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::ConceptTypeCount>(GetArenaForAllocation());
    _impl_.errors_ = p;
  }
  return _impl_.errors_;
}
inline ::clarifai::api::ConceptTypeCount* DetailConceptCount::mutable_errors() {
  ::clarifai::api::ConceptTypeCount* _msg = _internal_mutable_errors();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DetailConceptCount.errors)
  return _msg;
}
inline void DetailConceptCount::set_allocated_errors(::clarifai::api::ConceptTypeCount* errors) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.errors_;
  }
  if (errors) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(errors);
    if (message_arena != submessage_arena) {
      errors = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, errors, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.errors_ = errors;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DetailConceptCount.errors)
}

// .clarifai.api.ConceptTypeCount processing = 4;
inline bool DetailConceptCount::_internal_has_processing() const {
  return this != internal_default_instance() && _impl_.processing_ != nullptr;
}
inline bool DetailConceptCount::has_processing() const {
  return _internal_has_processing();
}
inline void DetailConceptCount::clear_processing() {
  if (GetArenaForAllocation() == nullptr && _impl_.processing_ != nullptr) {
    delete _impl_.processing_;
  }
  _impl_.processing_ = nullptr;
}
inline const ::clarifai::api::ConceptTypeCount& DetailConceptCount::_internal_processing() const {
  const ::clarifai::api::ConceptTypeCount* p = _impl_.processing_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::ConceptTypeCount&>(
      ::clarifai::api::_ConceptTypeCount_default_instance_);
}
inline const ::clarifai::api::ConceptTypeCount& DetailConceptCount::processing() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DetailConceptCount.processing)
  return _internal_processing();
}
inline void DetailConceptCount::unsafe_arena_set_allocated_processing(
    ::clarifai::api::ConceptTypeCount* processing) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.processing_);
  }
  _impl_.processing_ = processing;
  if (processing) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DetailConceptCount.processing)
}
inline ::clarifai::api::ConceptTypeCount* DetailConceptCount::release_processing() {
  
  ::clarifai::api::ConceptTypeCount* temp = _impl_.processing_;
  _impl_.processing_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::ConceptTypeCount* DetailConceptCount::unsafe_arena_release_processing() {
  // @@protoc_insertion_point(field_release:clarifai.api.DetailConceptCount.processing)
  
  ::clarifai::api::ConceptTypeCount* temp = _impl_.processing_;
  _impl_.processing_ = nullptr;
  return temp;
}
inline ::clarifai::api::ConceptTypeCount* DetailConceptCount::_internal_mutable_processing() {
  
  if (_impl_.processing_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::ConceptTypeCount>(GetArenaForAllocation());
    _impl_.processing_ = p;
  }
  return _impl_.processing_;
}
inline ::clarifai::api::ConceptTypeCount* DetailConceptCount::mutable_processing() {
  ::clarifai::api::ConceptTypeCount* _msg = _internal_mutable_processing();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DetailConceptCount.processing)
  return _msg;
}
inline void DetailConceptCount::set_allocated_processing(::clarifai::api::ConceptTypeCount* processing) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.processing_;
  }
  if (processing) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(processing);
    if (message_arena != submessage_arena) {
      processing = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, processing, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.processing_ = processing;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DetailConceptCount.processing)
}

// -------------------------------------------------------------------

// ConceptQuery

// string name = 1;
inline void ConceptQuery::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ConceptQuery::name() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ConceptQuery.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConceptQuery::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ConceptQuery.name)
}
inline std::string* ConceptQuery::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ConceptQuery.name)
  return _s;
}
inline const std::string& ConceptQuery::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ConceptQuery::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ConceptQuery::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ConceptQuery::release_name() {
  // @@protoc_insertion_point(field_release:clarifai.api.ConceptQuery.name)
  return _impl_.name_.Release();
}
inline void ConceptQuery::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ConceptQuery.name)
}

// string language = 2;
inline void ConceptQuery::clear_language() {
  _impl_.language_.ClearToEmpty();
}
inline const std::string& ConceptQuery::language() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ConceptQuery.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConceptQuery::set_language(ArgT0&& arg0, ArgT... args) {
 
 _impl_.language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ConceptQuery.language)
}
inline std::string* ConceptQuery::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ConceptQuery.language)
  return _s;
}
inline const std::string& ConceptQuery::_internal_language() const {
  return _impl_.language_.Get();
}
inline void ConceptQuery::_internal_set_language(const std::string& value) {
  
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* ConceptQuery::_internal_mutable_language() {
  
  return _impl_.language_.Mutable(GetArenaForAllocation());
}
inline std::string* ConceptQuery::release_language() {
  // @@protoc_insertion_point(field_release:clarifai.api.ConceptQuery.language)
  return _impl_.language_.Release();
}
inline void ConceptQuery::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    
  } else {
    
  }
  _impl_.language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ConceptQuery.language)
}

// string workflow_id = 3;
inline void ConceptQuery::clear_workflow_id() {
  _impl_.workflow_id_.ClearToEmpty();
}
inline const std::string& ConceptQuery::workflow_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ConceptQuery.workflow_id)
  return _internal_workflow_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConceptQuery::set_workflow_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.workflow_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ConceptQuery.workflow_id)
}
inline std::string* ConceptQuery::mutable_workflow_id() {
  std::string* _s = _internal_mutable_workflow_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ConceptQuery.workflow_id)
  return _s;
}
inline const std::string& ConceptQuery::_internal_workflow_id() const {
  return _impl_.workflow_id_.Get();
}
inline void ConceptQuery::_internal_set_workflow_id(const std::string& value) {
  
  _impl_.workflow_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ConceptQuery::_internal_mutable_workflow_id() {
  
  return _impl_.workflow_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ConceptQuery::release_workflow_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.ConceptQuery.workflow_id)
  return _impl_.workflow_id_.Release();
}
inline void ConceptQuery::set_allocated_workflow_id(std::string* workflow_id) {
  if (workflow_id != nullptr) {
    
  } else {
    
  }
  _impl_.workflow_id_.SetAllocated(workflow_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.workflow_id_.IsDefault()) {
    _impl_.workflow_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ConceptQuery.workflow_id)
}

// -------------------------------------------------------------------

// ConceptRelation

// string id = 1;
inline void ConceptRelation::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ConceptRelation::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ConceptRelation.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConceptRelation::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ConceptRelation.id)
}
inline std::string* ConceptRelation::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ConceptRelation.id)
  return _s;
}
inline const std::string& ConceptRelation::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ConceptRelation::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ConceptRelation::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ConceptRelation::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.ConceptRelation.id)
  return _impl_.id_.Release();
}
inline void ConceptRelation::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ConceptRelation.id)
}

// .clarifai.api.Concept subject_concept = 2;
inline bool ConceptRelation::_internal_has_subject_concept() const {
  return this != internal_default_instance() && _impl_.subject_concept_ != nullptr;
}
inline bool ConceptRelation::has_subject_concept() const {
  return _internal_has_subject_concept();
}
inline void ConceptRelation::clear_subject_concept() {
  if (GetArenaForAllocation() == nullptr && _impl_.subject_concept_ != nullptr) {
    delete _impl_.subject_concept_;
  }
  _impl_.subject_concept_ = nullptr;
}
inline const ::clarifai::api::Concept& ConceptRelation::_internal_subject_concept() const {
  const ::clarifai::api::Concept* p = _impl_.subject_concept_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Concept&>(
      ::clarifai::api::_Concept_default_instance_);
}
inline const ::clarifai::api::Concept& ConceptRelation::subject_concept() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ConceptRelation.subject_concept)
  return _internal_subject_concept();
}
inline void ConceptRelation::unsafe_arena_set_allocated_subject_concept(
    ::clarifai::api::Concept* subject_concept) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subject_concept_);
  }
  _impl_.subject_concept_ = subject_concept;
  if (subject_concept) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.ConceptRelation.subject_concept)
}
inline ::clarifai::api::Concept* ConceptRelation::release_subject_concept() {
  
  ::clarifai::api::Concept* temp = _impl_.subject_concept_;
  _impl_.subject_concept_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Concept* ConceptRelation::unsafe_arena_release_subject_concept() {
  // @@protoc_insertion_point(field_release:clarifai.api.ConceptRelation.subject_concept)
  
  ::clarifai::api::Concept* temp = _impl_.subject_concept_;
  _impl_.subject_concept_ = nullptr;
  return temp;
}
inline ::clarifai::api::Concept* ConceptRelation::_internal_mutable_subject_concept() {
  
  if (_impl_.subject_concept_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Concept>(GetArenaForAllocation());
    _impl_.subject_concept_ = p;
  }
  return _impl_.subject_concept_;
}
inline ::clarifai::api::Concept* ConceptRelation::mutable_subject_concept() {
  ::clarifai::api::Concept* _msg = _internal_mutable_subject_concept();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ConceptRelation.subject_concept)
  return _msg;
}
inline void ConceptRelation::set_allocated_subject_concept(::clarifai::api::Concept* subject_concept) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.subject_concept_;
  }
  if (subject_concept) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(subject_concept);
    if (message_arena != submessage_arena) {
      subject_concept = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subject_concept, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.subject_concept_ = subject_concept;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ConceptRelation.subject_concept)
}

// .clarifai.api.Concept object_concept = 3;
inline bool ConceptRelation::_internal_has_object_concept() const {
  return this != internal_default_instance() && _impl_.object_concept_ != nullptr;
}
inline bool ConceptRelation::has_object_concept() const {
  return _internal_has_object_concept();
}
inline void ConceptRelation::clear_object_concept() {
  if (GetArenaForAllocation() == nullptr && _impl_.object_concept_ != nullptr) {
    delete _impl_.object_concept_;
  }
  _impl_.object_concept_ = nullptr;
}
inline const ::clarifai::api::Concept& ConceptRelation::_internal_object_concept() const {
  const ::clarifai::api::Concept* p = _impl_.object_concept_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Concept&>(
      ::clarifai::api::_Concept_default_instance_);
}
inline const ::clarifai::api::Concept& ConceptRelation::object_concept() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ConceptRelation.object_concept)
  return _internal_object_concept();
}
inline void ConceptRelation::unsafe_arena_set_allocated_object_concept(
    ::clarifai::api::Concept* object_concept) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.object_concept_);
  }
  _impl_.object_concept_ = object_concept;
  if (object_concept) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.ConceptRelation.object_concept)
}
inline ::clarifai::api::Concept* ConceptRelation::release_object_concept() {
  
  ::clarifai::api::Concept* temp = _impl_.object_concept_;
  _impl_.object_concept_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Concept* ConceptRelation::unsafe_arena_release_object_concept() {
  // @@protoc_insertion_point(field_release:clarifai.api.ConceptRelation.object_concept)
  
  ::clarifai::api::Concept* temp = _impl_.object_concept_;
  _impl_.object_concept_ = nullptr;
  return temp;
}
inline ::clarifai::api::Concept* ConceptRelation::_internal_mutable_object_concept() {
  
  if (_impl_.object_concept_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Concept>(GetArenaForAllocation());
    _impl_.object_concept_ = p;
  }
  return _impl_.object_concept_;
}
inline ::clarifai::api::Concept* ConceptRelation::mutable_object_concept() {
  ::clarifai::api::Concept* _msg = _internal_mutable_object_concept();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ConceptRelation.object_concept)
  return _msg;
}
inline void ConceptRelation::set_allocated_object_concept(::clarifai::api::Concept* object_concept) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.object_concept_;
  }
  if (object_concept) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(object_concept);
    if (message_arena != submessage_arena) {
      object_concept = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object_concept, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.object_concept_ = object_concept;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ConceptRelation.object_concept)
}

// string predicate = 4;
inline void ConceptRelation::clear_predicate() {
  _impl_.predicate_.ClearToEmpty();
}
inline const std::string& ConceptRelation::predicate() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ConceptRelation.predicate)
  return _internal_predicate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConceptRelation::set_predicate(ArgT0&& arg0, ArgT... args) {
 
 _impl_.predicate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ConceptRelation.predicate)
}
inline std::string* ConceptRelation::mutable_predicate() {
  std::string* _s = _internal_mutable_predicate();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ConceptRelation.predicate)
  return _s;
}
inline const std::string& ConceptRelation::_internal_predicate() const {
  return _impl_.predicate_.Get();
}
inline void ConceptRelation::_internal_set_predicate(const std::string& value) {
  
  _impl_.predicate_.Set(value, GetArenaForAllocation());
}
inline std::string* ConceptRelation::_internal_mutable_predicate() {
  
  return _impl_.predicate_.Mutable(GetArenaForAllocation());
}
inline std::string* ConceptRelation::release_predicate() {
  // @@protoc_insertion_point(field_release:clarifai.api.ConceptRelation.predicate)
  return _impl_.predicate_.Release();
}
inline void ConceptRelation::set_allocated_predicate(std::string* predicate) {
  if (predicate != nullptr) {
    
  } else {
    
  }
  _impl_.predicate_.SetAllocated(predicate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.predicate_.IsDefault()) {
    _impl_.predicate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ConceptRelation.predicate)
}

// string knowledge_graph_id = 5;
inline void ConceptRelation::clear_knowledge_graph_id() {
  _impl_.knowledge_graph_id_.ClearToEmpty();
}
inline const std::string& ConceptRelation::knowledge_graph_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ConceptRelation.knowledge_graph_id)
  return _internal_knowledge_graph_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConceptRelation::set_knowledge_graph_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.knowledge_graph_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ConceptRelation.knowledge_graph_id)
}
inline std::string* ConceptRelation::mutable_knowledge_graph_id() {
  std::string* _s = _internal_mutable_knowledge_graph_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ConceptRelation.knowledge_graph_id)
  return _s;
}
inline const std::string& ConceptRelation::_internal_knowledge_graph_id() const {
  return _impl_.knowledge_graph_id_.Get();
}
inline void ConceptRelation::_internal_set_knowledge_graph_id(const std::string& value) {
  
  _impl_.knowledge_graph_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ConceptRelation::_internal_mutable_knowledge_graph_id() {
  
  return _impl_.knowledge_graph_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ConceptRelation::release_knowledge_graph_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.ConceptRelation.knowledge_graph_id)
  return _impl_.knowledge_graph_id_.Release();
}
inline void ConceptRelation::set_allocated_knowledge_graph_id(std::string* knowledge_graph_id) {
  if (knowledge_graph_id != nullptr) {
    
  } else {
    
  }
  _impl_.knowledge_graph_id_.SetAllocated(knowledge_graph_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.knowledge_graph_id_.IsDefault()) {
    _impl_.knowledge_graph_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ConceptRelation.knowledge_graph_id)
}

// .clarifai.api.Visibility visibility = 6;
inline bool ConceptRelation::_internal_has_visibility() const {
  return this != internal_default_instance() && _impl_.visibility_ != nullptr;
}
inline bool ConceptRelation::has_visibility() const {
  return _internal_has_visibility();
}
inline void ConceptRelation::clear_visibility() {
  if (GetArenaForAllocation() == nullptr && _impl_.visibility_ != nullptr) {
    delete _impl_.visibility_;
  }
  _impl_.visibility_ = nullptr;
}
inline const ::clarifai::api::Visibility& ConceptRelation::_internal_visibility() const {
  const ::clarifai::api::Visibility* p = _impl_.visibility_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Visibility&>(
      ::clarifai::api::_Visibility_default_instance_);
}
inline const ::clarifai::api::Visibility& ConceptRelation::visibility() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ConceptRelation.visibility)
  return _internal_visibility();
}
inline void ConceptRelation::unsafe_arena_set_allocated_visibility(
    ::clarifai::api::Visibility* visibility) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visibility_);
  }
  _impl_.visibility_ = visibility;
  if (visibility) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.ConceptRelation.visibility)
}
inline ::clarifai::api::Visibility* ConceptRelation::release_visibility() {
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Visibility* ConceptRelation::unsafe_arena_release_visibility() {
  // @@protoc_insertion_point(field_release:clarifai.api.ConceptRelation.visibility)
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
  return temp;
}
inline ::clarifai::api::Visibility* ConceptRelation::_internal_mutable_visibility() {
  
  if (_impl_.visibility_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Visibility>(GetArenaForAllocation());
    _impl_.visibility_ = p;
  }
  return _impl_.visibility_;
}
inline ::clarifai::api::Visibility* ConceptRelation::mutable_visibility() {
  ::clarifai::api::Visibility* _msg = _internal_mutable_visibility();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ConceptRelation.visibility)
  return _msg;
}
inline void ConceptRelation::set_allocated_visibility(::clarifai::api::Visibility* visibility) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.visibility_;
  }
  if (visibility) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(visibility);
    if (message_arena != submessage_arena) {
      visibility = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visibility, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.visibility_ = visibility;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ConceptRelation.visibility)
}

// -------------------------------------------------------------------

// KnowledgeGraph

// string id = 1;
inline void KnowledgeGraph::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& KnowledgeGraph::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.KnowledgeGraph.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KnowledgeGraph::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.KnowledgeGraph.id)
}
inline std::string* KnowledgeGraph::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.KnowledgeGraph.id)
  return _s;
}
inline const std::string& KnowledgeGraph::_internal_id() const {
  return _impl_.id_.Get();
}
inline void KnowledgeGraph::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* KnowledgeGraph::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* KnowledgeGraph::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.KnowledgeGraph.id)
  return _impl_.id_.Release();
}
inline void KnowledgeGraph::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.KnowledgeGraph.id)
}

// string name = 2;
inline void KnowledgeGraph::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& KnowledgeGraph::name() const {
  // @@protoc_insertion_point(field_get:clarifai.api.KnowledgeGraph.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KnowledgeGraph::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.KnowledgeGraph.name)
}
inline std::string* KnowledgeGraph::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:clarifai.api.KnowledgeGraph.name)
  return _s;
}
inline const std::string& KnowledgeGraph::_internal_name() const {
  return _impl_.name_.Get();
}
inline void KnowledgeGraph::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* KnowledgeGraph::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* KnowledgeGraph::release_name() {
  // @@protoc_insertion_point(field_release:clarifai.api.KnowledgeGraph.name)
  return _impl_.name_.Release();
}
inline void KnowledgeGraph::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.KnowledgeGraph.name)
}

// string description = 3;
inline void KnowledgeGraph::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& KnowledgeGraph::description() const {
  // @@protoc_insertion_point(field_get:clarifai.api.KnowledgeGraph.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KnowledgeGraph::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.KnowledgeGraph.description)
}
inline std::string* KnowledgeGraph::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:clarifai.api.KnowledgeGraph.description)
  return _s;
}
inline const std::string& KnowledgeGraph::_internal_description() const {
  return _impl_.description_.Get();
}
inline void KnowledgeGraph::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* KnowledgeGraph::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* KnowledgeGraph::release_description() {
  // @@protoc_insertion_point(field_release:clarifai.api.KnowledgeGraph.description)
  return _impl_.description_.Release();
}
inline void KnowledgeGraph::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.KnowledgeGraph.description)
}

// string examples_app_id = 4;
inline void KnowledgeGraph::clear_examples_app_id() {
  _impl_.examples_app_id_.ClearToEmpty();
}
inline const std::string& KnowledgeGraph::examples_app_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.KnowledgeGraph.examples_app_id)
  return _internal_examples_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KnowledgeGraph::set_examples_app_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.examples_app_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.KnowledgeGraph.examples_app_id)
}
inline std::string* KnowledgeGraph::mutable_examples_app_id() {
  std::string* _s = _internal_mutable_examples_app_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.KnowledgeGraph.examples_app_id)
  return _s;
}
inline const std::string& KnowledgeGraph::_internal_examples_app_id() const {
  return _impl_.examples_app_id_.Get();
}
inline void KnowledgeGraph::_internal_set_examples_app_id(const std::string& value) {
  
  _impl_.examples_app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* KnowledgeGraph::_internal_mutable_examples_app_id() {
  
  return _impl_.examples_app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* KnowledgeGraph::release_examples_app_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.KnowledgeGraph.examples_app_id)
  return _impl_.examples_app_id_.Release();
}
inline void KnowledgeGraph::set_allocated_examples_app_id(std::string* examples_app_id) {
  if (examples_app_id != nullptr) {
    
  } else {
    
  }
  _impl_.examples_app_id_.SetAllocated(examples_app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.examples_app_id_.IsDefault()) {
    _impl_.examples_app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.KnowledgeGraph.examples_app_id)
}

// string sampled_examples_app_id = 5;
inline void KnowledgeGraph::clear_sampled_examples_app_id() {
  _impl_.sampled_examples_app_id_.ClearToEmpty();
}
inline const std::string& KnowledgeGraph::sampled_examples_app_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.KnowledgeGraph.sampled_examples_app_id)
  return _internal_sampled_examples_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KnowledgeGraph::set_sampled_examples_app_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sampled_examples_app_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.KnowledgeGraph.sampled_examples_app_id)
}
inline std::string* KnowledgeGraph::mutable_sampled_examples_app_id() {
  std::string* _s = _internal_mutable_sampled_examples_app_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.KnowledgeGraph.sampled_examples_app_id)
  return _s;
}
inline const std::string& KnowledgeGraph::_internal_sampled_examples_app_id() const {
  return _impl_.sampled_examples_app_id_.Get();
}
inline void KnowledgeGraph::_internal_set_sampled_examples_app_id(const std::string& value) {
  
  _impl_.sampled_examples_app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* KnowledgeGraph::_internal_mutable_sampled_examples_app_id() {
  
  return _impl_.sampled_examples_app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* KnowledgeGraph::release_sampled_examples_app_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.KnowledgeGraph.sampled_examples_app_id)
  return _impl_.sampled_examples_app_id_.Release();
}
inline void KnowledgeGraph::set_allocated_sampled_examples_app_id(std::string* sampled_examples_app_id) {
  if (sampled_examples_app_id != nullptr) {
    
  } else {
    
  }
  _impl_.sampled_examples_app_id_.SetAllocated(sampled_examples_app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sampled_examples_app_id_.IsDefault()) {
    _impl_.sampled_examples_app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.KnowledgeGraph.sampled_examples_app_id)
}

// -------------------------------------------------------------------

// ConceptMappingJob

// string knowledge_graph_id = 1;
inline void ConceptMappingJob::clear_knowledge_graph_id() {
  _impl_.knowledge_graph_id_.ClearToEmpty();
}
inline const std::string& ConceptMappingJob::knowledge_graph_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ConceptMappingJob.knowledge_graph_id)
  return _internal_knowledge_graph_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConceptMappingJob::set_knowledge_graph_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.knowledge_graph_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ConceptMappingJob.knowledge_graph_id)
}
inline std::string* ConceptMappingJob::mutable_knowledge_graph_id() {
  std::string* _s = _internal_mutable_knowledge_graph_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ConceptMappingJob.knowledge_graph_id)
  return _s;
}
inline const std::string& ConceptMappingJob::_internal_knowledge_graph_id() const {
  return _impl_.knowledge_graph_id_.Get();
}
inline void ConceptMappingJob::_internal_set_knowledge_graph_id(const std::string& value) {
  
  _impl_.knowledge_graph_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ConceptMappingJob::_internal_mutable_knowledge_graph_id() {
  
  return _impl_.knowledge_graph_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ConceptMappingJob::release_knowledge_graph_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.ConceptMappingJob.knowledge_graph_id)
  return _impl_.knowledge_graph_id_.Release();
}
inline void ConceptMappingJob::set_allocated_knowledge_graph_id(std::string* knowledge_graph_id) {
  if (knowledge_graph_id != nullptr) {
    
  } else {
    
  }
  _impl_.knowledge_graph_id_.SetAllocated(knowledge_graph_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.knowledge_graph_id_.IsDefault()) {
    _impl_.knowledge_graph_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ConceptMappingJob.knowledge_graph_id)
}

// repeated string concept_ids = 2;
inline int ConceptMappingJob::_internal_concept_ids_size() const {
  return _impl_.concept_ids_.size();
}
inline int ConceptMappingJob::concept_ids_size() const {
  return _internal_concept_ids_size();
}
inline void ConceptMappingJob::clear_concept_ids() {
  _impl_.concept_ids_.Clear();
}
inline std::string* ConceptMappingJob::add_concept_ids() {
  std::string* _s = _internal_add_concept_ids();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.ConceptMappingJob.concept_ids)
  return _s;
}
inline const std::string& ConceptMappingJob::_internal_concept_ids(int index) const {
  return _impl_.concept_ids_.Get(index);
}
inline const std::string& ConceptMappingJob::concept_ids(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.ConceptMappingJob.concept_ids)
  return _internal_concept_ids(index);
}
inline std::string* ConceptMappingJob::mutable_concept_ids(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.ConceptMappingJob.concept_ids)
  return _impl_.concept_ids_.Mutable(index);
}
inline void ConceptMappingJob::set_concept_ids(int index, const std::string& value) {
  _impl_.concept_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.ConceptMappingJob.concept_ids)
}
inline void ConceptMappingJob::set_concept_ids(int index, std::string&& value) {
  _impl_.concept_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.ConceptMappingJob.concept_ids)
}
inline void ConceptMappingJob::set_concept_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.concept_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.ConceptMappingJob.concept_ids)
}
inline void ConceptMappingJob::set_concept_ids(int index, const char* value, size_t size) {
  _impl_.concept_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.ConceptMappingJob.concept_ids)
}
inline std::string* ConceptMappingJob::_internal_add_concept_ids() {
  return _impl_.concept_ids_.Add();
}
inline void ConceptMappingJob::add_concept_ids(const std::string& value) {
  _impl_.concept_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.ConceptMappingJob.concept_ids)
}
inline void ConceptMappingJob::add_concept_ids(std::string&& value) {
  _impl_.concept_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.ConceptMappingJob.concept_ids)
}
inline void ConceptMappingJob::add_concept_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.concept_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.ConceptMappingJob.concept_ids)
}
inline void ConceptMappingJob::add_concept_ids(const char* value, size_t size) {
  _impl_.concept_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.ConceptMappingJob.concept_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ConceptMappingJob::concept_ids() const {
  // @@protoc_insertion_point(field_list:clarifai.api.ConceptMappingJob.concept_ids)
  return _impl_.concept_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ConceptMappingJob::mutable_concept_ids() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.ConceptMappingJob.concept_ids)
  return &_impl_.concept_ids_;
}

// -------------------------------------------------------------------

// ConceptLanguage

// string id = 1;
inline void ConceptLanguage::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ConceptLanguage::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ConceptLanguage.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConceptLanguage::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ConceptLanguage.id)
}
inline std::string* ConceptLanguage::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ConceptLanguage.id)
  return _s;
}
inline const std::string& ConceptLanguage::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ConceptLanguage::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ConceptLanguage::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ConceptLanguage::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.ConceptLanguage.id)
  return _impl_.id_.Release();
}
inline void ConceptLanguage::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ConceptLanguage.id)
}

// string name = 2;
inline void ConceptLanguage::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ConceptLanguage::name() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ConceptLanguage.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConceptLanguage::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ConceptLanguage.name)
}
inline std::string* ConceptLanguage::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ConceptLanguage.name)
  return _s;
}
inline const std::string& ConceptLanguage::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ConceptLanguage::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ConceptLanguage::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ConceptLanguage::release_name() {
  // @@protoc_insertion_point(field_release:clarifai.api.ConceptLanguage.name)
  return _impl_.name_.Release();
}
inline void ConceptLanguage::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ConceptLanguage.name)
}

// string definition = 3;
inline void ConceptLanguage::clear_definition() {
  _impl_.definition_.ClearToEmpty();
}
inline const std::string& ConceptLanguage::definition() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ConceptLanguage.definition)
  return _internal_definition();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConceptLanguage::set_definition(ArgT0&& arg0, ArgT... args) {
 
 _impl_.definition_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ConceptLanguage.definition)
}
inline std::string* ConceptLanguage::mutable_definition() {
  std::string* _s = _internal_mutable_definition();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ConceptLanguage.definition)
  return _s;
}
inline const std::string& ConceptLanguage::_internal_definition() const {
  return _impl_.definition_.Get();
}
inline void ConceptLanguage::_internal_set_definition(const std::string& value) {
  
  _impl_.definition_.Set(value, GetArenaForAllocation());
}
inline std::string* ConceptLanguage::_internal_mutable_definition() {
  
  return _impl_.definition_.Mutable(GetArenaForAllocation());
}
inline std::string* ConceptLanguage::release_definition() {
  // @@protoc_insertion_point(field_release:clarifai.api.ConceptLanguage.definition)
  return _impl_.definition_.Release();
}
inline void ConceptLanguage::set_allocated_definition(std::string* definition) {
  if (definition != nullptr) {
    
  } else {
    
  }
  _impl_.definition_.SetAllocated(definition, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.definition_.IsDefault()) {
    _impl_.definition_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ConceptLanguage.definition)
}

// -------------------------------------------------------------------

// Data

// .clarifai.api.Image image = 1;
inline bool Data::_internal_has_image() const {
  return this != internal_default_instance() && _impl_.image_ != nullptr;
}
inline bool Data::has_image() const {
  return _internal_has_image();
}
inline void Data::clear_image() {
  if (GetArenaForAllocation() == nullptr && _impl_.image_ != nullptr) {
    delete _impl_.image_;
  }
  _impl_.image_ = nullptr;
}
inline const ::clarifai::api::Image& Data::_internal_image() const {
  const ::clarifai::api::Image* p = _impl_.image_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Image&>(
      ::clarifai::api::_Image_default_instance_);
}
inline const ::clarifai::api::Image& Data::image() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Data.image)
  return _internal_image();
}
inline void Data::unsafe_arena_set_allocated_image(
    ::clarifai::api::Image* image) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_);
  }
  _impl_.image_ = image;
  if (image) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Data.image)
}
inline ::clarifai::api::Image* Data::release_image() {
  
  ::clarifai::api::Image* temp = _impl_.image_;
  _impl_.image_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Image* Data::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_release:clarifai.api.Data.image)
  
  ::clarifai::api::Image* temp = _impl_.image_;
  _impl_.image_ = nullptr;
  return temp;
}
inline ::clarifai::api::Image* Data::_internal_mutable_image() {
  
  if (_impl_.image_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Image>(GetArenaForAllocation());
    _impl_.image_ = p;
  }
  return _impl_.image_;
}
inline ::clarifai::api::Image* Data::mutable_image() {
  ::clarifai::api::Image* _msg = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Data.image)
  return _msg;
}
inline void Data::set_allocated_image(::clarifai::api::Image* image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.image_;
  }
  if (image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(image);
    if (message_arena != submessage_arena) {
      image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.image_ = image;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Data.image)
}

// .clarifai.api.Video video = 2;
inline bool Data::_internal_has_video() const {
  return this != internal_default_instance() && _impl_.video_ != nullptr;
}
inline bool Data::has_video() const {
  return _internal_has_video();
}
inline void Data::clear_video() {
  if (GetArenaForAllocation() == nullptr && _impl_.video_ != nullptr) {
    delete _impl_.video_;
  }
  _impl_.video_ = nullptr;
}
inline const ::clarifai::api::Video& Data::_internal_video() const {
  const ::clarifai::api::Video* p = _impl_.video_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Video&>(
      ::clarifai::api::_Video_default_instance_);
}
inline const ::clarifai::api::Video& Data::video() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Data.video)
  return _internal_video();
}
inline void Data::unsafe_arena_set_allocated_video(
    ::clarifai::api::Video* video) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.video_);
  }
  _impl_.video_ = video;
  if (video) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Data.video)
}
inline ::clarifai::api::Video* Data::release_video() {
  
  ::clarifai::api::Video* temp = _impl_.video_;
  _impl_.video_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Video* Data::unsafe_arena_release_video() {
  // @@protoc_insertion_point(field_release:clarifai.api.Data.video)
  
  ::clarifai::api::Video* temp = _impl_.video_;
  _impl_.video_ = nullptr;
  return temp;
}
inline ::clarifai::api::Video* Data::_internal_mutable_video() {
  
  if (_impl_.video_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Video>(GetArenaForAllocation());
    _impl_.video_ = p;
  }
  return _impl_.video_;
}
inline ::clarifai::api::Video* Data::mutable_video() {
  ::clarifai::api::Video* _msg = _internal_mutable_video();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Data.video)
  return _msg;
}
inline void Data::set_allocated_video(::clarifai::api::Video* video) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.video_;
  }
  if (video) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(video);
    if (message_arena != submessage_arena) {
      video = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, video, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.video_ = video;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Data.video)
}

// repeated .clarifai.api.Concept concepts = 3;
inline int Data::_internal_concepts_size() const {
  return _impl_.concepts_.size();
}
inline int Data::concepts_size() const {
  return _internal_concepts_size();
}
inline void Data::clear_concepts() {
  _impl_.concepts_.Clear();
}
inline ::clarifai::api::Concept* Data::mutable_concepts(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Data.concepts)
  return _impl_.concepts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept >*
Data::mutable_concepts() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Data.concepts)
  return &_impl_.concepts_;
}
inline const ::clarifai::api::Concept& Data::_internal_concepts(int index) const {
  return _impl_.concepts_.Get(index);
}
inline const ::clarifai::api::Concept& Data::concepts(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Data.concepts)
  return _internal_concepts(index);
}
inline ::clarifai::api::Concept* Data::_internal_add_concepts() {
  return _impl_.concepts_.Add();
}
inline ::clarifai::api::Concept* Data::add_concepts() {
  ::clarifai::api::Concept* _add = _internal_add_concepts();
  // @@protoc_insertion_point(field_add:clarifai.api.Data.concepts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept >&
Data::concepts() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Data.concepts)
  return _impl_.concepts_;
}

// .google.protobuf.Struct metadata = 5;
inline bool Data::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool Data::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Data::_internal_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Data::metadata() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Data.metadata)
  return _internal_metadata();
}
inline void Data::unsafe_arena_set_allocated_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Data.metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Data::release_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Data::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:clarifai.api.Data.metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Data::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Data::mutable_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Data.metadata)
  return _msg;
}
inline void Data::set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Data.metadata)
}

// .clarifai.api.Geo geo = 6;
inline bool Data::_internal_has_geo() const {
  return this != internal_default_instance() && _impl_.geo_ != nullptr;
}
inline bool Data::has_geo() const {
  return _internal_has_geo();
}
inline void Data::clear_geo() {
  if (GetArenaForAllocation() == nullptr && _impl_.geo_ != nullptr) {
    delete _impl_.geo_;
  }
  _impl_.geo_ = nullptr;
}
inline const ::clarifai::api::Geo& Data::_internal_geo() const {
  const ::clarifai::api::Geo* p = _impl_.geo_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Geo&>(
      ::clarifai::api::_Geo_default_instance_);
}
inline const ::clarifai::api::Geo& Data::geo() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Data.geo)
  return _internal_geo();
}
inline void Data::unsafe_arena_set_allocated_geo(
    ::clarifai::api::Geo* geo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.geo_);
  }
  _impl_.geo_ = geo;
  if (geo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Data.geo)
}
inline ::clarifai::api::Geo* Data::release_geo() {
  
  ::clarifai::api::Geo* temp = _impl_.geo_;
  _impl_.geo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Geo* Data::unsafe_arena_release_geo() {
  // @@protoc_insertion_point(field_release:clarifai.api.Data.geo)
  
  ::clarifai::api::Geo* temp = _impl_.geo_;
  _impl_.geo_ = nullptr;
  return temp;
}
inline ::clarifai::api::Geo* Data::_internal_mutable_geo() {
  
  if (_impl_.geo_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Geo>(GetArenaForAllocation());
    _impl_.geo_ = p;
  }
  return _impl_.geo_;
}
inline ::clarifai::api::Geo* Data::mutable_geo() {
  ::clarifai::api::Geo* _msg = _internal_mutable_geo();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Data.geo)
  return _msg;
}
inline void Data::set_allocated_geo(::clarifai::api::Geo* geo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.geo_;
  }
  if (geo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(geo);
    if (message_arena != submessage_arena) {
      geo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.geo_ = geo;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Data.geo)
}

// repeated .clarifai.api.Color colors = 7;
inline int Data::_internal_colors_size() const {
  return _impl_.colors_.size();
}
inline int Data::colors_size() const {
  return _internal_colors_size();
}
inline void Data::clear_colors() {
  _impl_.colors_.Clear();
}
inline ::clarifai::api::Color* Data::mutable_colors(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Data.colors)
  return _impl_.colors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Color >*
Data::mutable_colors() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Data.colors)
  return &_impl_.colors_;
}
inline const ::clarifai::api::Color& Data::_internal_colors(int index) const {
  return _impl_.colors_.Get(index);
}
inline const ::clarifai::api::Color& Data::colors(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Data.colors)
  return _internal_colors(index);
}
inline ::clarifai::api::Color* Data::_internal_add_colors() {
  return _impl_.colors_.Add();
}
inline ::clarifai::api::Color* Data::add_colors() {
  ::clarifai::api::Color* _add = _internal_add_colors();
  // @@protoc_insertion_point(field_add:clarifai.api.Data.colors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Color >&
Data::colors() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Data.colors)
  return _impl_.colors_;
}

// repeated .clarifai.api.Cluster clusters = 8;
inline int Data::_internal_clusters_size() const {
  return _impl_.clusters_.size();
}
inline int Data::clusters_size() const {
  return _internal_clusters_size();
}
inline void Data::clear_clusters() {
  _impl_.clusters_.Clear();
}
inline ::clarifai::api::Cluster* Data::mutable_clusters(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Data.clusters)
  return _impl_.clusters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Cluster >*
Data::mutable_clusters() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Data.clusters)
  return &_impl_.clusters_;
}
inline const ::clarifai::api::Cluster& Data::_internal_clusters(int index) const {
  return _impl_.clusters_.Get(index);
}
inline const ::clarifai::api::Cluster& Data::clusters(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Data.clusters)
  return _internal_clusters(index);
}
inline ::clarifai::api::Cluster* Data::_internal_add_clusters() {
  return _impl_.clusters_.Add();
}
inline ::clarifai::api::Cluster* Data::add_clusters() {
  ::clarifai::api::Cluster* _add = _internal_add_clusters();
  // @@protoc_insertion_point(field_add:clarifai.api.Data.clusters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Cluster >&
Data::clusters() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Data.clusters)
  return _impl_.clusters_;
}

// repeated .clarifai.api.Embedding embeddings = 9;
inline int Data::_internal_embeddings_size() const {
  return _impl_.embeddings_.size();
}
inline int Data::embeddings_size() const {
  return _internal_embeddings_size();
}
inline void Data::clear_embeddings() {
  _impl_.embeddings_.Clear();
}
inline ::clarifai::api::Embedding* Data::mutable_embeddings(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Data.embeddings)
  return _impl_.embeddings_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Embedding >*
Data::mutable_embeddings() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Data.embeddings)
  return &_impl_.embeddings_;
}
inline const ::clarifai::api::Embedding& Data::_internal_embeddings(int index) const {
  return _impl_.embeddings_.Get(index);
}
inline const ::clarifai::api::Embedding& Data::embeddings(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Data.embeddings)
  return _internal_embeddings(index);
}
inline ::clarifai::api::Embedding* Data::_internal_add_embeddings() {
  return _impl_.embeddings_.Add();
}
inline ::clarifai::api::Embedding* Data::add_embeddings() {
  ::clarifai::api::Embedding* _add = _internal_add_embeddings();
  // @@protoc_insertion_point(field_add:clarifai.api.Data.embeddings)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Embedding >&
Data::embeddings() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Data.embeddings)
  return _impl_.embeddings_;
}

// repeated .clarifai.api.Region regions = 11;
inline int Data::_internal_regions_size() const {
  return _impl_.regions_.size();
}
inline int Data::regions_size() const {
  return _internal_regions_size();
}
inline void Data::clear_regions() {
  _impl_.regions_.Clear();
}
inline ::clarifai::api::Region* Data::mutable_regions(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Data.regions)
  return _impl_.regions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Region >*
Data::mutable_regions() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Data.regions)
  return &_impl_.regions_;
}
inline const ::clarifai::api::Region& Data::_internal_regions(int index) const {
  return _impl_.regions_.Get(index);
}
inline const ::clarifai::api::Region& Data::regions(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Data.regions)
  return _internal_regions(index);
}
inline ::clarifai::api::Region* Data::_internal_add_regions() {
  return _impl_.regions_.Add();
}
inline ::clarifai::api::Region* Data::add_regions() {
  ::clarifai::api::Region* _add = _internal_add_regions();
  // @@protoc_insertion_point(field_add:clarifai.api.Data.regions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Region >&
Data::regions() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Data.regions)
  return _impl_.regions_;
}

// repeated .clarifai.api.Frame frames = 12;
inline int Data::_internal_frames_size() const {
  return _impl_.frames_.size();
}
inline int Data::frames_size() const {
  return _internal_frames_size();
}
inline void Data::clear_frames() {
  _impl_.frames_.Clear();
}
inline ::clarifai::api::Frame* Data::mutable_frames(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Data.frames)
  return _impl_.frames_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Frame >*
Data::mutable_frames() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Data.frames)
  return &_impl_.frames_;
}
inline const ::clarifai::api::Frame& Data::_internal_frames(int index) const {
  return _impl_.frames_.Get(index);
}
inline const ::clarifai::api::Frame& Data::frames(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Data.frames)
  return _internal_frames(index);
}
inline ::clarifai::api::Frame* Data::_internal_add_frames() {
  return _impl_.frames_.Add();
}
inline ::clarifai::api::Frame* Data::add_frames() {
  ::clarifai::api::Frame* _add = _internal_add_frames();
  // @@protoc_insertion_point(field_add:clarifai.api.Data.frames)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Frame >&
Data::frames() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Data.frames)
  return _impl_.frames_;
}

// .clarifai.api.Text text = 13;
inline bool Data::_internal_has_text() const {
  return this != internal_default_instance() && _impl_.text_ != nullptr;
}
inline bool Data::has_text() const {
  return _internal_has_text();
}
inline void Data::clear_text() {
  if (GetArenaForAllocation() == nullptr && _impl_.text_ != nullptr) {
    delete _impl_.text_;
  }
  _impl_.text_ = nullptr;
}
inline const ::clarifai::api::Text& Data::_internal_text() const {
  const ::clarifai::api::Text* p = _impl_.text_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Text&>(
      ::clarifai::api::_Text_default_instance_);
}
inline const ::clarifai::api::Text& Data::text() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Data.text)
  return _internal_text();
}
inline void Data::unsafe_arena_set_allocated_text(
    ::clarifai::api::Text* text) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.text_);
  }
  _impl_.text_ = text;
  if (text) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Data.text)
}
inline ::clarifai::api::Text* Data::release_text() {
  
  ::clarifai::api::Text* temp = _impl_.text_;
  _impl_.text_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Text* Data::unsafe_arena_release_text() {
  // @@protoc_insertion_point(field_release:clarifai.api.Data.text)
  
  ::clarifai::api::Text* temp = _impl_.text_;
  _impl_.text_ = nullptr;
  return temp;
}
inline ::clarifai::api::Text* Data::_internal_mutable_text() {
  
  if (_impl_.text_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Text>(GetArenaForAllocation());
    _impl_.text_ = p;
  }
  return _impl_.text_;
}
inline ::clarifai::api::Text* Data::mutable_text() {
  ::clarifai::api::Text* _msg = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Data.text)
  return _msg;
}
inline void Data::set_allocated_text(::clarifai::api::Text* text) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.text_;
  }
  if (text) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(text);
    if (message_arena != submessage_arena) {
      text = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.text_ = text;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Data.text)
}

// .clarifai.api.Audio audio = 14;
inline bool Data::_internal_has_audio() const {
  return this != internal_default_instance() && _impl_.audio_ != nullptr;
}
inline bool Data::has_audio() const {
  return _internal_has_audio();
}
inline void Data::clear_audio() {
  if (GetArenaForAllocation() == nullptr && _impl_.audio_ != nullptr) {
    delete _impl_.audio_;
  }
  _impl_.audio_ = nullptr;
}
inline const ::clarifai::api::Audio& Data::_internal_audio() const {
  const ::clarifai::api::Audio* p = _impl_.audio_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Audio&>(
      ::clarifai::api::_Audio_default_instance_);
}
inline const ::clarifai::api::Audio& Data::audio() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Data.audio)
  return _internal_audio();
}
inline void Data::unsafe_arena_set_allocated_audio(
    ::clarifai::api::Audio* audio) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audio_);
  }
  _impl_.audio_ = audio;
  if (audio) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Data.audio)
}
inline ::clarifai::api::Audio* Data::release_audio() {
  
  ::clarifai::api::Audio* temp = _impl_.audio_;
  _impl_.audio_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Audio* Data::unsafe_arena_release_audio() {
  // @@protoc_insertion_point(field_release:clarifai.api.Data.audio)
  
  ::clarifai::api::Audio* temp = _impl_.audio_;
  _impl_.audio_ = nullptr;
  return temp;
}
inline ::clarifai::api::Audio* Data::_internal_mutable_audio() {
  
  if (_impl_.audio_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Audio>(GetArenaForAllocation());
    _impl_.audio_ = p;
  }
  return _impl_.audio_;
}
inline ::clarifai::api::Audio* Data::mutable_audio() {
  ::clarifai::api::Audio* _msg = _internal_mutable_audio();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Data.audio)
  return _msg;
}
inline void Data::set_allocated_audio(::clarifai::api::Audio* audio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.audio_;
  }
  if (audio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(audio);
    if (message_arena != submessage_arena) {
      audio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.audio_ = audio;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Data.audio)
}

// repeated .clarifai.api.Track tracks = 15;
inline int Data::_internal_tracks_size() const {
  return _impl_.tracks_.size();
}
inline int Data::tracks_size() const {
  return _internal_tracks_size();
}
inline void Data::clear_tracks() {
  _impl_.tracks_.Clear();
}
inline ::clarifai::api::Track* Data::mutable_tracks(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Data.tracks)
  return _impl_.tracks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Track >*
Data::mutable_tracks() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Data.tracks)
  return &_impl_.tracks_;
}
inline const ::clarifai::api::Track& Data::_internal_tracks(int index) const {
  return _impl_.tracks_.Get(index);
}
inline const ::clarifai::api::Track& Data::tracks(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Data.tracks)
  return _internal_tracks(index);
}
inline ::clarifai::api::Track* Data::_internal_add_tracks() {
  return _impl_.tracks_.Add();
}
inline ::clarifai::api::Track* Data::add_tracks() {
  ::clarifai::api::Track* _add = _internal_add_tracks();
  // @@protoc_insertion_point(field_add:clarifai.api.Data.tracks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Track >&
Data::tracks() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Data.tracks)
  return _impl_.tracks_;
}

// repeated .clarifai.api.TimeSegment time_segments = 16;
inline int Data::_internal_time_segments_size() const {
  return _impl_.time_segments_.size();
}
inline int Data::time_segments_size() const {
  return _internal_time_segments_size();
}
inline void Data::clear_time_segments() {
  _impl_.time_segments_.Clear();
}
inline ::clarifai::api::TimeSegment* Data::mutable_time_segments(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Data.time_segments)
  return _impl_.time_segments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::TimeSegment >*
Data::mutable_time_segments() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Data.time_segments)
  return &_impl_.time_segments_;
}
inline const ::clarifai::api::TimeSegment& Data::_internal_time_segments(int index) const {
  return _impl_.time_segments_.Get(index);
}
inline const ::clarifai::api::TimeSegment& Data::time_segments(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Data.time_segments)
  return _internal_time_segments(index);
}
inline ::clarifai::api::TimeSegment* Data::_internal_add_time_segments() {
  return _impl_.time_segments_.Add();
}
inline ::clarifai::api::TimeSegment* Data::add_time_segments() {
  ::clarifai::api::TimeSegment* _add = _internal_add_time_segments();
  // @@protoc_insertion_point(field_add:clarifai.api.Data.time_segments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::TimeSegment >&
Data::time_segments() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Data.time_segments)
  return _impl_.time_segments_;
}

// repeated .clarifai.api.Hit hits = 17;
inline int Data::_internal_hits_size() const {
  return _impl_.hits_.size();
}
inline int Data::hits_size() const {
  return _internal_hits_size();
}
inline void Data::clear_hits() {
  _impl_.hits_.Clear();
}
inline ::clarifai::api::Hit* Data::mutable_hits(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Data.hits)
  return _impl_.hits_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Hit >*
Data::mutable_hits() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Data.hits)
  return &_impl_.hits_;
}
inline const ::clarifai::api::Hit& Data::_internal_hits(int index) const {
  return _impl_.hits_.Get(index);
}
inline const ::clarifai::api::Hit& Data::hits(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Data.hits)
  return _internal_hits(index);
}
inline ::clarifai::api::Hit* Data::_internal_add_hits() {
  return _impl_.hits_.Add();
}
inline ::clarifai::api::Hit* Data::add_hits() {
  ::clarifai::api::Hit* _add = _internal_add_hits();
  // @@protoc_insertion_point(field_add:clarifai.api.Data.hits)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Hit >&
Data::hits() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Data.hits)
  return _impl_.hits_;
}

// repeated .clarifai.api.Image heatmaps = 18;
inline int Data::_internal_heatmaps_size() const {
  return _impl_.heatmaps_.size();
}
inline int Data::heatmaps_size() const {
  return _internal_heatmaps_size();
}
inline void Data::clear_heatmaps() {
  _impl_.heatmaps_.Clear();
}
inline ::clarifai::api::Image* Data::mutable_heatmaps(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Data.heatmaps)
  return _impl_.heatmaps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Image >*
Data::mutable_heatmaps() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Data.heatmaps)
  return &_impl_.heatmaps_;
}
inline const ::clarifai::api::Image& Data::_internal_heatmaps(int index) const {
  return _impl_.heatmaps_.Get(index);
}
inline const ::clarifai::api::Image& Data::heatmaps(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Data.heatmaps)
  return _internal_heatmaps(index);
}
inline ::clarifai::api::Image* Data::_internal_add_heatmaps() {
  return _impl_.heatmaps_.Add();
}
inline ::clarifai::api::Image* Data::add_heatmaps() {
  ::clarifai::api::Image* _add = _internal_add_heatmaps();
  // @@protoc_insertion_point(field_add:clarifai.api.Data.heatmaps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Image >&
Data::heatmaps() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Data.heatmaps)
  return _impl_.heatmaps_;
}

// -------------------------------------------------------------------

// Region

// string id = 1;
inline void Region::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Region::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Region.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Region::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Region.id)
}
inline std::string* Region::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Region.id)
  return _s;
}
inline const std::string& Region::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Region::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Region::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Region::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Region.id)
  return _impl_.id_.Release();
}
inline void Region::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Region.id)
}

// .clarifai.api.RegionInfo region_info = 2;
inline bool Region::_internal_has_region_info() const {
  return this != internal_default_instance() && _impl_.region_info_ != nullptr;
}
inline bool Region::has_region_info() const {
  return _internal_has_region_info();
}
inline void Region::clear_region_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.region_info_ != nullptr) {
    delete _impl_.region_info_;
  }
  _impl_.region_info_ = nullptr;
}
inline const ::clarifai::api::RegionInfo& Region::_internal_region_info() const {
  const ::clarifai::api::RegionInfo* p = _impl_.region_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::RegionInfo&>(
      ::clarifai::api::_RegionInfo_default_instance_);
}
inline const ::clarifai::api::RegionInfo& Region::region_info() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Region.region_info)
  return _internal_region_info();
}
inline void Region::unsafe_arena_set_allocated_region_info(
    ::clarifai::api::RegionInfo* region_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.region_info_);
  }
  _impl_.region_info_ = region_info;
  if (region_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Region.region_info)
}
inline ::clarifai::api::RegionInfo* Region::release_region_info() {
  
  ::clarifai::api::RegionInfo* temp = _impl_.region_info_;
  _impl_.region_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::RegionInfo* Region::unsafe_arena_release_region_info() {
  // @@protoc_insertion_point(field_release:clarifai.api.Region.region_info)
  
  ::clarifai::api::RegionInfo* temp = _impl_.region_info_;
  _impl_.region_info_ = nullptr;
  return temp;
}
inline ::clarifai::api::RegionInfo* Region::_internal_mutable_region_info() {
  
  if (_impl_.region_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::RegionInfo>(GetArenaForAllocation());
    _impl_.region_info_ = p;
  }
  return _impl_.region_info_;
}
inline ::clarifai::api::RegionInfo* Region::mutable_region_info() {
  ::clarifai::api::RegionInfo* _msg = _internal_mutable_region_info();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Region.region_info)
  return _msg;
}
inline void Region::set_allocated_region_info(::clarifai::api::RegionInfo* region_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.region_info_;
  }
  if (region_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(region_info);
    if (message_arena != submessage_arena) {
      region_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.region_info_ = region_info;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Region.region_info)
}

// .clarifai.api.Data data = 3;
inline bool Region::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool Region::has_data() const {
  return _internal_has_data();
}
inline void Region::clear_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.data_ != nullptr) {
    delete _impl_.data_;
  }
  _impl_.data_ = nullptr;
}
inline const ::clarifai::api::Data& Region::_internal_data() const {
  const ::clarifai::api::Data* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Data&>(
      ::clarifai::api::_Data_default_instance_);
}
inline const ::clarifai::api::Data& Region::data() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Region.data)
  return _internal_data();
}
inline void Region::unsafe_arena_set_allocated_data(
    ::clarifai::api::Data* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Region.data)
}
inline ::clarifai::api::Data* Region::release_data() {
  
  ::clarifai::api::Data* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Data* Region::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:clarifai.api.Region.data)
  
  ::clarifai::api::Data* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::clarifai::api::Data* Region::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Data>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::clarifai::api::Data* Region::mutable_data() {
  ::clarifai::api::Data* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Region.data)
  return _msg;
}
inline void Region::set_allocated_data(::clarifai::api::Data* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Region.data)
}

// float value = 4;
inline void Region::clear_value() {
  _impl_.value_ = 0;
}
inline float Region::_internal_value() const {
  return _impl_.value_;
}
inline float Region::value() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Region.value)
  return _internal_value();
}
inline void Region::_internal_set_value(float value) {
  
  _impl_.value_ = value;
}
inline void Region::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Region.value)
}

// string track_id = 5;
inline void Region::clear_track_id() {
  _impl_.track_id_.ClearToEmpty();
}
inline const std::string& Region::track_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Region.track_id)
  return _internal_track_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Region::set_track_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.track_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Region.track_id)
}
inline std::string* Region::mutable_track_id() {
  std::string* _s = _internal_mutable_track_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Region.track_id)
  return _s;
}
inline const std::string& Region::_internal_track_id() const {
  return _impl_.track_id_.Get();
}
inline void Region::_internal_set_track_id(const std::string& value) {
  
  _impl_.track_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Region::_internal_mutable_track_id() {
  
  return _impl_.track_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Region::release_track_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Region.track_id)
  return _impl_.track_id_.Release();
}
inline void Region::set_allocated_track_id(std::string* track_id) {
  if (track_id != nullptr) {
    
  } else {
    
  }
  _impl_.track_id_.SetAllocated(track_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_id_.IsDefault()) {
    _impl_.track_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Region.track_id)
}

// -------------------------------------------------------------------

// RegionInfo

// .clarifai.api.BoundingBox bounding_box = 1;
inline bool RegionInfo::_internal_has_bounding_box() const {
  return this != internal_default_instance() && _impl_.bounding_box_ != nullptr;
}
inline bool RegionInfo::has_bounding_box() const {
  return _internal_has_bounding_box();
}
inline void RegionInfo::clear_bounding_box() {
  if (GetArenaForAllocation() == nullptr && _impl_.bounding_box_ != nullptr) {
    delete _impl_.bounding_box_;
  }
  _impl_.bounding_box_ = nullptr;
}
inline const ::clarifai::api::BoundingBox& RegionInfo::_internal_bounding_box() const {
  const ::clarifai::api::BoundingBox* p = _impl_.bounding_box_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::BoundingBox&>(
      ::clarifai::api::_BoundingBox_default_instance_);
}
inline const ::clarifai::api::BoundingBox& RegionInfo::bounding_box() const {
  // @@protoc_insertion_point(field_get:clarifai.api.RegionInfo.bounding_box)
  return _internal_bounding_box();
}
inline void RegionInfo::unsafe_arena_set_allocated_bounding_box(
    ::clarifai::api::BoundingBox* bounding_box) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bounding_box_);
  }
  _impl_.bounding_box_ = bounding_box;
  if (bounding_box) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.RegionInfo.bounding_box)
}
inline ::clarifai::api::BoundingBox* RegionInfo::release_bounding_box() {
  
  ::clarifai::api::BoundingBox* temp = _impl_.bounding_box_;
  _impl_.bounding_box_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::BoundingBox* RegionInfo::unsafe_arena_release_bounding_box() {
  // @@protoc_insertion_point(field_release:clarifai.api.RegionInfo.bounding_box)
  
  ::clarifai::api::BoundingBox* temp = _impl_.bounding_box_;
  _impl_.bounding_box_ = nullptr;
  return temp;
}
inline ::clarifai::api::BoundingBox* RegionInfo::_internal_mutable_bounding_box() {
  
  if (_impl_.bounding_box_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::BoundingBox>(GetArenaForAllocation());
    _impl_.bounding_box_ = p;
  }
  return _impl_.bounding_box_;
}
inline ::clarifai::api::BoundingBox* RegionInfo::mutable_bounding_box() {
  ::clarifai::api::BoundingBox* _msg = _internal_mutable_bounding_box();
  // @@protoc_insertion_point(field_mutable:clarifai.api.RegionInfo.bounding_box)
  return _msg;
}
inline void RegionInfo::set_allocated_bounding_box(::clarifai::api::BoundingBox* bounding_box) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.bounding_box_;
  }
  if (bounding_box) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bounding_box);
    if (message_arena != submessage_arena) {
      bounding_box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bounding_box, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.bounding_box_ = bounding_box;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.RegionInfo.bounding_box)
}

// .clarifai.api.Mask mask = 4;
inline bool RegionInfo::_internal_has_mask() const {
  return this != internal_default_instance() && _impl_.mask_ != nullptr;
}
inline bool RegionInfo::has_mask() const {
  return _internal_has_mask();
}
inline void RegionInfo::clear_mask() {
  if (GetArenaForAllocation() == nullptr && _impl_.mask_ != nullptr) {
    delete _impl_.mask_;
  }
  _impl_.mask_ = nullptr;
}
inline const ::clarifai::api::Mask& RegionInfo::_internal_mask() const {
  const ::clarifai::api::Mask* p = _impl_.mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Mask&>(
      ::clarifai::api::_Mask_default_instance_);
}
inline const ::clarifai::api::Mask& RegionInfo::mask() const {
  // @@protoc_insertion_point(field_get:clarifai.api.RegionInfo.mask)
  return _internal_mask();
}
inline void RegionInfo::unsafe_arena_set_allocated_mask(
    ::clarifai::api::Mask* mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mask_);
  }
  _impl_.mask_ = mask;
  if (mask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.RegionInfo.mask)
}
inline ::clarifai::api::Mask* RegionInfo::release_mask() {
  
  ::clarifai::api::Mask* temp = _impl_.mask_;
  _impl_.mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Mask* RegionInfo::unsafe_arena_release_mask() {
  // @@protoc_insertion_point(field_release:clarifai.api.RegionInfo.mask)
  
  ::clarifai::api::Mask* temp = _impl_.mask_;
  _impl_.mask_ = nullptr;
  return temp;
}
inline ::clarifai::api::Mask* RegionInfo::_internal_mutable_mask() {
  
  if (_impl_.mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Mask>(GetArenaForAllocation());
    _impl_.mask_ = p;
  }
  return _impl_.mask_;
}
inline ::clarifai::api::Mask* RegionInfo::mutable_mask() {
  ::clarifai::api::Mask* _msg = _internal_mutable_mask();
  // @@protoc_insertion_point(field_mutable:clarifai.api.RegionInfo.mask)
  return _msg;
}
inline void RegionInfo::set_allocated_mask(::clarifai::api::Mask* mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mask_;
  }
  if (mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mask);
    if (message_arena != submessage_arena) {
      mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mask, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mask_ = mask;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.RegionInfo.mask)
}

// .clarifai.api.Polygon polygon = 5;
inline bool RegionInfo::_internal_has_polygon() const {
  return this != internal_default_instance() && _impl_.polygon_ != nullptr;
}
inline bool RegionInfo::has_polygon() const {
  return _internal_has_polygon();
}
inline void RegionInfo::clear_polygon() {
  if (GetArenaForAllocation() == nullptr && _impl_.polygon_ != nullptr) {
    delete _impl_.polygon_;
  }
  _impl_.polygon_ = nullptr;
}
inline const ::clarifai::api::Polygon& RegionInfo::_internal_polygon() const {
  const ::clarifai::api::Polygon* p = _impl_.polygon_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Polygon&>(
      ::clarifai::api::_Polygon_default_instance_);
}
inline const ::clarifai::api::Polygon& RegionInfo::polygon() const {
  // @@protoc_insertion_point(field_get:clarifai.api.RegionInfo.polygon)
  return _internal_polygon();
}
inline void RegionInfo::unsafe_arena_set_allocated_polygon(
    ::clarifai::api::Polygon* polygon) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.polygon_);
  }
  _impl_.polygon_ = polygon;
  if (polygon) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.RegionInfo.polygon)
}
inline ::clarifai::api::Polygon* RegionInfo::release_polygon() {
  
  ::clarifai::api::Polygon* temp = _impl_.polygon_;
  _impl_.polygon_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Polygon* RegionInfo::unsafe_arena_release_polygon() {
  // @@protoc_insertion_point(field_release:clarifai.api.RegionInfo.polygon)
  
  ::clarifai::api::Polygon* temp = _impl_.polygon_;
  _impl_.polygon_ = nullptr;
  return temp;
}
inline ::clarifai::api::Polygon* RegionInfo::_internal_mutable_polygon() {
  
  if (_impl_.polygon_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Polygon>(GetArenaForAllocation());
    _impl_.polygon_ = p;
  }
  return _impl_.polygon_;
}
inline ::clarifai::api::Polygon* RegionInfo::mutable_polygon() {
  ::clarifai::api::Polygon* _msg = _internal_mutable_polygon();
  // @@protoc_insertion_point(field_mutable:clarifai.api.RegionInfo.polygon)
  return _msg;
}
inline void RegionInfo::set_allocated_polygon(::clarifai::api::Polygon* polygon) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.polygon_;
  }
  if (polygon) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(polygon);
    if (message_arena != submessage_arena) {
      polygon = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, polygon, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.polygon_ = polygon;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.RegionInfo.polygon)
}

// .clarifai.api.Point point = 6;
inline bool RegionInfo::_internal_has_point() const {
  return this != internal_default_instance() && _impl_.point_ != nullptr;
}
inline bool RegionInfo::has_point() const {
  return _internal_has_point();
}
inline void RegionInfo::clear_point() {
  if (GetArenaForAllocation() == nullptr && _impl_.point_ != nullptr) {
    delete _impl_.point_;
  }
  _impl_.point_ = nullptr;
}
inline const ::clarifai::api::Point& RegionInfo::_internal_point() const {
  const ::clarifai::api::Point* p = _impl_.point_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Point&>(
      ::clarifai::api::_Point_default_instance_);
}
inline const ::clarifai::api::Point& RegionInfo::point() const {
  // @@protoc_insertion_point(field_get:clarifai.api.RegionInfo.point)
  return _internal_point();
}
inline void RegionInfo::unsafe_arena_set_allocated_point(
    ::clarifai::api::Point* point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.point_);
  }
  _impl_.point_ = point;
  if (point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.RegionInfo.point)
}
inline ::clarifai::api::Point* RegionInfo::release_point() {
  
  ::clarifai::api::Point* temp = _impl_.point_;
  _impl_.point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Point* RegionInfo::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:clarifai.api.RegionInfo.point)
  
  ::clarifai::api::Point* temp = _impl_.point_;
  _impl_.point_ = nullptr;
  return temp;
}
inline ::clarifai::api::Point* RegionInfo::_internal_mutable_point() {
  
  if (_impl_.point_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Point>(GetArenaForAllocation());
    _impl_.point_ = p;
  }
  return _impl_.point_;
}
inline ::clarifai::api::Point* RegionInfo::mutable_point() {
  ::clarifai::api::Point* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:clarifai.api.RegionInfo.point)
  return _msg;
}
inline void RegionInfo::set_allocated_point(::clarifai::api::Point* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.point_;
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(point);
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.point_ = point;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.RegionInfo.point)
}

// .clarifai.api.Span span = 7;
inline bool RegionInfo::_internal_has_span() const {
  return this != internal_default_instance() && _impl_.span_ != nullptr;
}
inline bool RegionInfo::has_span() const {
  return _internal_has_span();
}
inline void RegionInfo::clear_span() {
  if (GetArenaForAllocation() == nullptr && _impl_.span_ != nullptr) {
    delete _impl_.span_;
  }
  _impl_.span_ = nullptr;
}
inline const ::clarifai::api::Span& RegionInfo::_internal_span() const {
  const ::clarifai::api::Span* p = _impl_.span_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Span&>(
      ::clarifai::api::_Span_default_instance_);
}
inline const ::clarifai::api::Span& RegionInfo::span() const {
  // @@protoc_insertion_point(field_get:clarifai.api.RegionInfo.span)
  return _internal_span();
}
inline void RegionInfo::unsafe_arena_set_allocated_span(
    ::clarifai::api::Span* span) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.span_);
  }
  _impl_.span_ = span;
  if (span) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.RegionInfo.span)
}
inline ::clarifai::api::Span* RegionInfo::release_span() {
  
  ::clarifai::api::Span* temp = _impl_.span_;
  _impl_.span_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Span* RegionInfo::unsafe_arena_release_span() {
  // @@protoc_insertion_point(field_release:clarifai.api.RegionInfo.span)
  
  ::clarifai::api::Span* temp = _impl_.span_;
  _impl_.span_ = nullptr;
  return temp;
}
inline ::clarifai::api::Span* RegionInfo::_internal_mutable_span() {
  
  if (_impl_.span_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Span>(GetArenaForAllocation());
    _impl_.span_ = p;
  }
  return _impl_.span_;
}
inline ::clarifai::api::Span* RegionInfo::mutable_span() {
  ::clarifai::api::Span* _msg = _internal_mutable_span();
  // @@protoc_insertion_point(field_mutable:clarifai.api.RegionInfo.span)
  return _msg;
}
inline void RegionInfo::set_allocated_span(::clarifai::api::Span* span) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.span_;
  }
  if (span) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(span);
    if (message_arena != submessage_arena) {
      span = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, span, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.span_ = span;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.RegionInfo.span)
}

// .clarifai.api.Token token = 8;
inline bool RegionInfo::_internal_has_token() const {
  return this != internal_default_instance() && _impl_.token_ != nullptr;
}
inline bool RegionInfo::has_token() const {
  return _internal_has_token();
}
inline void RegionInfo::clear_token() {
  if (GetArenaForAllocation() == nullptr && _impl_.token_ != nullptr) {
    delete _impl_.token_;
  }
  _impl_.token_ = nullptr;
}
inline const ::clarifai::api::Token& RegionInfo::_internal_token() const {
  const ::clarifai::api::Token* p = _impl_.token_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Token&>(
      ::clarifai::api::_Token_default_instance_);
}
inline const ::clarifai::api::Token& RegionInfo::token() const {
  // @@protoc_insertion_point(field_get:clarifai.api.RegionInfo.token)
  return _internal_token();
}
inline void RegionInfo::unsafe_arena_set_allocated_token(
    ::clarifai::api::Token* token) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.token_);
  }
  _impl_.token_ = token;
  if (token) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.RegionInfo.token)
}
inline ::clarifai::api::Token* RegionInfo::release_token() {
  
  ::clarifai::api::Token* temp = _impl_.token_;
  _impl_.token_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Token* RegionInfo::unsafe_arena_release_token() {
  // @@protoc_insertion_point(field_release:clarifai.api.RegionInfo.token)
  
  ::clarifai::api::Token* temp = _impl_.token_;
  _impl_.token_ = nullptr;
  return temp;
}
inline ::clarifai::api::Token* RegionInfo::_internal_mutable_token() {
  
  if (_impl_.token_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Token>(GetArenaForAllocation());
    _impl_.token_ = p;
  }
  return _impl_.token_;
}
inline ::clarifai::api::Token* RegionInfo::mutable_token() {
  ::clarifai::api::Token* _msg = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:clarifai.api.RegionInfo.token)
  return _msg;
}
inline void RegionInfo::set_allocated_token(::clarifai::api::Token* token) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.token_;
  }
  if (token) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(token);
    if (message_arena != submessage_arena) {
      token = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, token, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.token_ = token;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.RegionInfo.token)
}

// repeated .clarifai.api.Point keypoint_locations = 9;
inline int RegionInfo::_internal_keypoint_locations_size() const {
  return _impl_.keypoint_locations_.size();
}
inline int RegionInfo::keypoint_locations_size() const {
  return _internal_keypoint_locations_size();
}
inline void RegionInfo::clear_keypoint_locations() {
  _impl_.keypoint_locations_.Clear();
}
inline ::clarifai::api::Point* RegionInfo::mutable_keypoint_locations(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.RegionInfo.keypoint_locations)
  return _impl_.keypoint_locations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Point >*
RegionInfo::mutable_keypoint_locations() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.RegionInfo.keypoint_locations)
  return &_impl_.keypoint_locations_;
}
inline const ::clarifai::api::Point& RegionInfo::_internal_keypoint_locations(int index) const {
  return _impl_.keypoint_locations_.Get(index);
}
inline const ::clarifai::api::Point& RegionInfo::keypoint_locations(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.RegionInfo.keypoint_locations)
  return _internal_keypoint_locations(index);
}
inline ::clarifai::api::Point* RegionInfo::_internal_add_keypoint_locations() {
  return _impl_.keypoint_locations_.Add();
}
inline ::clarifai::api::Point* RegionInfo::add_keypoint_locations() {
  ::clarifai::api::Point* _add = _internal_add_keypoint_locations();
  // @@protoc_insertion_point(field_add:clarifai.api.RegionInfo.keypoint_locations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Point >&
RegionInfo::keypoint_locations() const {
  // @@protoc_insertion_point(field_list:clarifai.api.RegionInfo.keypoint_locations)
  return _impl_.keypoint_locations_;
}

// -------------------------------------------------------------------

// BoundingBox

// float top_row = 1 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void BoundingBox::clear_top_row() {
  _impl_.top_row_ = 0;
}
inline float BoundingBox::_internal_top_row() const {
  return _impl_.top_row_;
}
inline float BoundingBox::top_row() const {
  // @@protoc_insertion_point(field_get:clarifai.api.BoundingBox.top_row)
  return _internal_top_row();
}
inline void BoundingBox::_internal_set_top_row(float value) {
  
  _impl_.top_row_ = value;
}
inline void BoundingBox::set_top_row(float value) {
  _internal_set_top_row(value);
  // @@protoc_insertion_point(field_set:clarifai.api.BoundingBox.top_row)
}

// float left_col = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void BoundingBox::clear_left_col() {
  _impl_.left_col_ = 0;
}
inline float BoundingBox::_internal_left_col() const {
  return _impl_.left_col_;
}
inline float BoundingBox::left_col() const {
  // @@protoc_insertion_point(field_get:clarifai.api.BoundingBox.left_col)
  return _internal_left_col();
}
inline void BoundingBox::_internal_set_left_col(float value) {
  
  _impl_.left_col_ = value;
}
inline void BoundingBox::set_left_col(float value) {
  _internal_set_left_col(value);
  // @@protoc_insertion_point(field_set:clarifai.api.BoundingBox.left_col)
}

// float bottom_row = 3 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void BoundingBox::clear_bottom_row() {
  _impl_.bottom_row_ = 0;
}
inline float BoundingBox::_internal_bottom_row() const {
  return _impl_.bottom_row_;
}
inline float BoundingBox::bottom_row() const {
  // @@protoc_insertion_point(field_get:clarifai.api.BoundingBox.bottom_row)
  return _internal_bottom_row();
}
inline void BoundingBox::_internal_set_bottom_row(float value) {
  
  _impl_.bottom_row_ = value;
}
inline void BoundingBox::set_bottom_row(float value) {
  _internal_set_bottom_row(value);
  // @@protoc_insertion_point(field_set:clarifai.api.BoundingBox.bottom_row)
}

// float right_col = 4 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void BoundingBox::clear_right_col() {
  _impl_.right_col_ = 0;
}
inline float BoundingBox::_internal_right_col() const {
  return _impl_.right_col_;
}
inline float BoundingBox::right_col() const {
  // @@protoc_insertion_point(field_get:clarifai.api.BoundingBox.right_col)
  return _internal_right_col();
}
inline void BoundingBox::_internal_set_right_col(float value) {
  
  _impl_.right_col_ = value;
}
inline void BoundingBox::set_right_col(float value) {
  _internal_set_right_col(value);
  // @@protoc_insertion_point(field_set:clarifai.api.BoundingBox.right_col)
}

// -------------------------------------------------------------------

// FrameInfo

// uint32 index = 1 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void FrameInfo::clear_index() {
  _impl_.index_ = 0u;
}
inline uint32_t FrameInfo::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t FrameInfo::index() const {
  // @@protoc_insertion_point(field_get:clarifai.api.FrameInfo.index)
  return _internal_index();
}
inline void FrameInfo::_internal_set_index(uint32_t value) {
  
  _impl_.index_ = value;
}
inline void FrameInfo::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:clarifai.api.FrameInfo.index)
}

// uint32 time = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void FrameInfo::clear_time() {
  _impl_.time_ = 0u;
}
inline uint32_t FrameInfo::_internal_time() const {
  return _impl_.time_;
}
inline uint32_t FrameInfo::time() const {
  // @@protoc_insertion_point(field_get:clarifai.api.FrameInfo.time)
  return _internal_time();
}
inline void FrameInfo::_internal_set_time(uint32_t value) {
  
  _impl_.time_ = value;
}
inline void FrameInfo::set_time(uint32_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:clarifai.api.FrameInfo.time)
}

// -------------------------------------------------------------------

// Frame

// .clarifai.api.FrameInfo frame_info = 1;
inline bool Frame::_internal_has_frame_info() const {
  return this != internal_default_instance() && _impl_.frame_info_ != nullptr;
}
inline bool Frame::has_frame_info() const {
  return _internal_has_frame_info();
}
inline void Frame::clear_frame_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.frame_info_ != nullptr) {
    delete _impl_.frame_info_;
  }
  _impl_.frame_info_ = nullptr;
}
inline const ::clarifai::api::FrameInfo& Frame::_internal_frame_info() const {
  const ::clarifai::api::FrameInfo* p = _impl_.frame_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::FrameInfo&>(
      ::clarifai::api::_FrameInfo_default_instance_);
}
inline const ::clarifai::api::FrameInfo& Frame::frame_info() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Frame.frame_info)
  return _internal_frame_info();
}
inline void Frame::unsafe_arena_set_allocated_frame_info(
    ::clarifai::api::FrameInfo* frame_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frame_info_);
  }
  _impl_.frame_info_ = frame_info;
  if (frame_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Frame.frame_info)
}
inline ::clarifai::api::FrameInfo* Frame::release_frame_info() {
  
  ::clarifai::api::FrameInfo* temp = _impl_.frame_info_;
  _impl_.frame_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::FrameInfo* Frame::unsafe_arena_release_frame_info() {
  // @@protoc_insertion_point(field_release:clarifai.api.Frame.frame_info)
  
  ::clarifai::api::FrameInfo* temp = _impl_.frame_info_;
  _impl_.frame_info_ = nullptr;
  return temp;
}
inline ::clarifai::api::FrameInfo* Frame::_internal_mutable_frame_info() {
  
  if (_impl_.frame_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::FrameInfo>(GetArenaForAllocation());
    _impl_.frame_info_ = p;
  }
  return _impl_.frame_info_;
}
inline ::clarifai::api::FrameInfo* Frame::mutable_frame_info() {
  ::clarifai::api::FrameInfo* _msg = _internal_mutable_frame_info();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Frame.frame_info)
  return _msg;
}
inline void Frame::set_allocated_frame_info(::clarifai::api::FrameInfo* frame_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.frame_info_;
  }
  if (frame_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(frame_info);
    if (message_arena != submessage_arena) {
      frame_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.frame_info_ = frame_info;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Frame.frame_info)
}

// .clarifai.api.Data data = 2;
inline bool Frame::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool Frame::has_data() const {
  return _internal_has_data();
}
inline void Frame::clear_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.data_ != nullptr) {
    delete _impl_.data_;
  }
  _impl_.data_ = nullptr;
}
inline const ::clarifai::api::Data& Frame::_internal_data() const {
  const ::clarifai::api::Data* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Data&>(
      ::clarifai::api::_Data_default_instance_);
}
inline const ::clarifai::api::Data& Frame::data() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Frame.data)
  return _internal_data();
}
inline void Frame::unsafe_arena_set_allocated_data(
    ::clarifai::api::Data* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Frame.data)
}
inline ::clarifai::api::Data* Frame::release_data() {
  
  ::clarifai::api::Data* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Data* Frame::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:clarifai.api.Frame.data)
  
  ::clarifai::api::Data* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::clarifai::api::Data* Frame::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Data>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::clarifai::api::Data* Frame::mutable_data() {
  ::clarifai::api::Data* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Frame.data)
  return _msg;
}
inline void Frame::set_allocated_data(::clarifai::api::Data* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Frame.data)
}

// string id = 3;
inline void Frame::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Frame::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Frame.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Frame::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Frame.id)
}
inline std::string* Frame::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Frame.id)
  return _s;
}
inline const std::string& Frame::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Frame::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Frame::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Frame::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Frame.id)
  return _impl_.id_.Release();
}
inline void Frame::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Frame.id)
}

// -------------------------------------------------------------------

// Mask

// .clarifai.api.Image image = 2;
inline bool Mask::_internal_has_image() const {
  return this != internal_default_instance() && _impl_.image_ != nullptr;
}
inline bool Mask::has_image() const {
  return _internal_has_image();
}
inline void Mask::clear_image() {
  if (GetArenaForAllocation() == nullptr && _impl_.image_ != nullptr) {
    delete _impl_.image_;
  }
  _impl_.image_ = nullptr;
}
inline const ::clarifai::api::Image& Mask::_internal_image() const {
  const ::clarifai::api::Image* p = _impl_.image_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Image&>(
      ::clarifai::api::_Image_default_instance_);
}
inline const ::clarifai::api::Image& Mask::image() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Mask.image)
  return _internal_image();
}
inline void Mask::unsafe_arena_set_allocated_image(
    ::clarifai::api::Image* image) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_);
  }
  _impl_.image_ = image;
  if (image) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Mask.image)
}
inline ::clarifai::api::Image* Mask::release_image() {
  
  ::clarifai::api::Image* temp = _impl_.image_;
  _impl_.image_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Image* Mask::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_release:clarifai.api.Mask.image)
  
  ::clarifai::api::Image* temp = _impl_.image_;
  _impl_.image_ = nullptr;
  return temp;
}
inline ::clarifai::api::Image* Mask::_internal_mutable_image() {
  
  if (_impl_.image_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Image>(GetArenaForAllocation());
    _impl_.image_ = p;
  }
  return _impl_.image_;
}
inline ::clarifai::api::Image* Mask::mutable_image() {
  ::clarifai::api::Image* _msg = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Mask.image)
  return _msg;
}
inline void Mask::set_allocated_image(::clarifai::api::Image* image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.image_;
  }
  if (image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(image);
    if (message_arena != submessage_arena) {
      image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.image_ = image;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Mask.image)
}

// -------------------------------------------------------------------

// Polygon

// repeated .clarifai.api.Point points = 1;
inline int Polygon::_internal_points_size() const {
  return _impl_.points_.size();
}
inline int Polygon::points_size() const {
  return _internal_points_size();
}
inline void Polygon::clear_points() {
  _impl_.points_.Clear();
}
inline ::clarifai::api::Point* Polygon::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Polygon.points)
  return _impl_.points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Point >*
Polygon::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Polygon.points)
  return &_impl_.points_;
}
inline const ::clarifai::api::Point& Polygon::_internal_points(int index) const {
  return _impl_.points_.Get(index);
}
inline const ::clarifai::api::Point& Polygon::points(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Polygon.points)
  return _internal_points(index);
}
inline ::clarifai::api::Point* Polygon::_internal_add_points() {
  return _impl_.points_.Add();
}
inline ::clarifai::api::Point* Polygon::add_points() {
  ::clarifai::api::Point* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:clarifai.api.Polygon.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Point >&
Polygon::points() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Polygon.points)
  return _impl_.points_;
}

// -------------------------------------------------------------------

// Point

// float row = 1 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void Point::clear_row() {
  _impl_.row_ = 0;
}
inline float Point::_internal_row() const {
  return _impl_.row_;
}
inline float Point::row() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Point.row)
  return _internal_row();
}
inline void Point::_internal_set_row(float value) {
  
  _impl_.row_ = value;
}
inline void Point::set_row(float value) {
  _internal_set_row(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Point.row)
}

// float col = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void Point::clear_col() {
  _impl_.col_ = 0;
}
inline float Point::_internal_col() const {
  return _impl_.col_;
}
inline float Point::col() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Point.col)
  return _internal_col();
}
inline void Point::_internal_set_col(float value) {
  
  _impl_.col_ = value;
}
inline void Point::set_col(float value) {
  _internal_set_col(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Point.col)
}

// float z = 3;
inline void Point::clear_z() {
  _impl_.z_ = 0;
}
inline float Point::_internal_z() const {
  return _impl_.z_;
}
inline float Point::z() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Point.z)
  return _internal_z();
}
inline void Point::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void Point::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Point.z)
}

// .clarifai.api.Point.Visibility visibility = 4;
inline void Point::clear_visibility() {
  _impl_.visibility_ = 0;
}
inline ::clarifai::api::Point_Visibility Point::_internal_visibility() const {
  return static_cast< ::clarifai::api::Point_Visibility >(_impl_.visibility_);
}
inline ::clarifai::api::Point_Visibility Point::visibility() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Point.visibility)
  return _internal_visibility();
}
inline void Point::_internal_set_visibility(::clarifai::api::Point_Visibility value) {
  
  _impl_.visibility_ = value;
}
inline void Point::set_visibility(::clarifai::api::Point_Visibility value) {
  _internal_set_visibility(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Point.visibility)
}

// -------------------------------------------------------------------

// Span

// uint32 char_start = 1 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void Span::clear_char_start() {
  _impl_.char_start_ = 0u;
}
inline uint32_t Span::_internal_char_start() const {
  return _impl_.char_start_;
}
inline uint32_t Span::char_start() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Span.char_start)
  return _internal_char_start();
}
inline void Span::_internal_set_char_start(uint32_t value) {
  
  _impl_.char_start_ = value;
}
inline void Span::set_char_start(uint32_t value) {
  _internal_set_char_start(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Span.char_start)
}

// uint32 char_end = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void Span::clear_char_end() {
  _impl_.char_end_ = 0u;
}
inline uint32_t Span::_internal_char_end() const {
  return _impl_.char_end_;
}
inline uint32_t Span::char_end() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Span.char_end)
  return _internal_char_end();
}
inline void Span::_internal_set_char_end(uint32_t value) {
  
  _impl_.char_end_ = value;
}
inline void Span::set_char_end(uint32_t value) {
  _internal_set_char_end(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Span.char_end)
}

// string raw_text = 3;
inline void Span::clear_raw_text() {
  _impl_.raw_text_.ClearToEmpty();
}
inline const std::string& Span::raw_text() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Span.raw_text)
  return _internal_raw_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Span::set_raw_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.raw_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Span.raw_text)
}
inline std::string* Span::mutable_raw_text() {
  std::string* _s = _internal_mutable_raw_text();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Span.raw_text)
  return _s;
}
inline const std::string& Span::_internal_raw_text() const {
  return _impl_.raw_text_.Get();
}
inline void Span::_internal_set_raw_text(const std::string& value) {
  
  _impl_.raw_text_.Set(value, GetArenaForAllocation());
}
inline std::string* Span::_internal_mutable_raw_text() {
  
  return _impl_.raw_text_.Mutable(GetArenaForAllocation());
}
inline std::string* Span::release_raw_text() {
  // @@protoc_insertion_point(field_release:clarifai.api.Span.raw_text)
  return _impl_.raw_text_.Release();
}
inline void Span::set_allocated_raw_text(std::string* raw_text) {
  if (raw_text != nullptr) {
    
  } else {
    
  }
  _impl_.raw_text_.SetAllocated(raw_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.raw_text_.IsDefault()) {
    _impl_.raw_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Span.raw_text)
}

// -------------------------------------------------------------------

// Token

// uint32 char_start = 1 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void Token::clear_char_start() {
  _impl_.char_start_ = 0u;
}
inline uint32_t Token::_internal_char_start() const {
  return _impl_.char_start_;
}
inline uint32_t Token::char_start() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Token.char_start)
  return _internal_char_start();
}
inline void Token::_internal_set_char_start(uint32_t value) {
  
  _impl_.char_start_ = value;
}
inline void Token::set_char_start(uint32_t value) {
  _internal_set_char_start(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Token.char_start)
}

// uint32 char_end = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void Token::clear_char_end() {
  _impl_.char_end_ = 0u;
}
inline uint32_t Token::_internal_char_end() const {
  return _impl_.char_end_;
}
inline uint32_t Token::char_end() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Token.char_end)
  return _internal_char_end();
}
inline void Token::_internal_set_char_end(uint32_t value) {
  
  _impl_.char_end_ = value;
}
inline void Token::set_char_end(uint32_t value) {
  _internal_set_char_end(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Token.char_end)
}

// string raw_text = 3;
inline void Token::clear_raw_text() {
  _impl_.raw_text_.ClearToEmpty();
}
inline const std::string& Token::raw_text() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Token.raw_text)
  return _internal_raw_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Token::set_raw_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.raw_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Token.raw_text)
}
inline std::string* Token::mutable_raw_text() {
  std::string* _s = _internal_mutable_raw_text();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Token.raw_text)
  return _s;
}
inline const std::string& Token::_internal_raw_text() const {
  return _impl_.raw_text_.Get();
}
inline void Token::_internal_set_raw_text(const std::string& value) {
  
  _impl_.raw_text_.Set(value, GetArenaForAllocation());
}
inline std::string* Token::_internal_mutable_raw_text() {
  
  return _impl_.raw_text_.Mutable(GetArenaForAllocation());
}
inline std::string* Token::release_raw_text() {
  // @@protoc_insertion_point(field_release:clarifai.api.Token.raw_text)
  return _impl_.raw_text_.Release();
}
inline void Token::set_allocated_raw_text(std::string* raw_text) {
  if (raw_text != nullptr) {
    
  } else {
    
  }
  _impl_.raw_text_.SetAllocated(raw_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.raw_text_.IsDefault()) {
    _impl_.raw_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Token.raw_text)
}

// -------------------------------------------------------------------

// Embedding

// repeated float vector = 1 [packed = true];
inline int Embedding::_internal_vector_size() const {
  return _impl_.vector_.size();
}
inline int Embedding::vector_size() const {
  return _internal_vector_size();
}
inline void Embedding::clear_vector() {
  _impl_.vector_.Clear();
}
inline float Embedding::_internal_vector(int index) const {
  return _impl_.vector_.Get(index);
}
inline float Embedding::vector(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Embedding.vector)
  return _internal_vector(index);
}
inline void Embedding::set_vector(int index, float value) {
  _impl_.vector_.Set(index, value);
  // @@protoc_insertion_point(field_set:clarifai.api.Embedding.vector)
}
inline void Embedding::_internal_add_vector(float value) {
  _impl_.vector_.Add(value);
}
inline void Embedding::add_vector(float value) {
  _internal_add_vector(value);
  // @@protoc_insertion_point(field_add:clarifai.api.Embedding.vector)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Embedding::_internal_vector() const {
  return _impl_.vector_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Embedding::vector() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Embedding.vector)
  return _internal_vector();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Embedding::_internal_mutable_vector() {
  return &_impl_.vector_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Embedding::mutable_vector() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Embedding.vector)
  return _internal_mutable_vector();
}

// uint32 num_dimensions = 2;
inline void Embedding::clear_num_dimensions() {
  _impl_.num_dimensions_ = 0u;
}
inline uint32_t Embedding::_internal_num_dimensions() const {
  return _impl_.num_dimensions_;
}
inline uint32_t Embedding::num_dimensions() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Embedding.num_dimensions)
  return _internal_num_dimensions();
}
inline void Embedding::_internal_set_num_dimensions(uint32_t value) {
  
  _impl_.num_dimensions_ = value;
}
inline void Embedding::set_num_dimensions(uint32_t value) {
  _internal_set_num_dimensions(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Embedding.num_dimensions)
}

// -------------------------------------------------------------------

// GeoPoint

// float longitude = 1 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void GeoPoint::clear_longitude() {
  _impl_.longitude_ = 0;
}
inline float GeoPoint::_internal_longitude() const {
  return _impl_.longitude_;
}
inline float GeoPoint::longitude() const {
  // @@protoc_insertion_point(field_get:clarifai.api.GeoPoint.longitude)
  return _internal_longitude();
}
inline void GeoPoint::_internal_set_longitude(float value) {
  
  _impl_.longitude_ = value;
}
inline void GeoPoint::set_longitude(float value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:clarifai.api.GeoPoint.longitude)
}

// float latitude = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void GeoPoint::clear_latitude() {
  _impl_.latitude_ = 0;
}
inline float GeoPoint::_internal_latitude() const {
  return _impl_.latitude_;
}
inline float GeoPoint::latitude() const {
  // @@protoc_insertion_point(field_get:clarifai.api.GeoPoint.latitude)
  return _internal_latitude();
}
inline void GeoPoint::_internal_set_latitude(float value) {
  
  _impl_.latitude_ = value;
}
inline void GeoPoint::set_latitude(float value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:clarifai.api.GeoPoint.latitude)
}

// -------------------------------------------------------------------

// GeoLimit

// string type = 1;
inline void GeoLimit::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& GeoLimit::type() const {
  // @@protoc_insertion_point(field_get:clarifai.api.GeoLimit.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GeoLimit::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.GeoLimit.type)
}
inline std::string* GeoLimit::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:clarifai.api.GeoLimit.type)
  return _s;
}
inline const std::string& GeoLimit::_internal_type() const {
  return _impl_.type_.Get();
}
inline void GeoLimit::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* GeoLimit::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* GeoLimit::release_type() {
  // @@protoc_insertion_point(field_release:clarifai.api.GeoLimit.type)
  return _impl_.type_.Release();
}
inline void GeoLimit::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.GeoLimit.type)
}

// float value = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void GeoLimit::clear_value() {
  _impl_.value_ = 0;
}
inline float GeoLimit::_internal_value() const {
  return _impl_.value_;
}
inline float GeoLimit::value() const {
  // @@protoc_insertion_point(field_get:clarifai.api.GeoLimit.value)
  return _internal_value();
}
inline void GeoLimit::_internal_set_value(float value) {
  
  _impl_.value_ = value;
}
inline void GeoLimit::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:clarifai.api.GeoLimit.value)
}

// -------------------------------------------------------------------

// GeoBoxedPoint

// .clarifai.api.GeoPoint geo_point = 1;
inline bool GeoBoxedPoint::_internal_has_geo_point() const {
  return this != internal_default_instance() && _impl_.geo_point_ != nullptr;
}
inline bool GeoBoxedPoint::has_geo_point() const {
  return _internal_has_geo_point();
}
inline void GeoBoxedPoint::clear_geo_point() {
  if (GetArenaForAllocation() == nullptr && _impl_.geo_point_ != nullptr) {
    delete _impl_.geo_point_;
  }
  _impl_.geo_point_ = nullptr;
}
inline const ::clarifai::api::GeoPoint& GeoBoxedPoint::_internal_geo_point() const {
  const ::clarifai::api::GeoPoint* p = _impl_.geo_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::GeoPoint&>(
      ::clarifai::api::_GeoPoint_default_instance_);
}
inline const ::clarifai::api::GeoPoint& GeoBoxedPoint::geo_point() const {
  // @@protoc_insertion_point(field_get:clarifai.api.GeoBoxedPoint.geo_point)
  return _internal_geo_point();
}
inline void GeoBoxedPoint::unsafe_arena_set_allocated_geo_point(
    ::clarifai::api::GeoPoint* geo_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.geo_point_);
  }
  _impl_.geo_point_ = geo_point;
  if (geo_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.GeoBoxedPoint.geo_point)
}
inline ::clarifai::api::GeoPoint* GeoBoxedPoint::release_geo_point() {
  
  ::clarifai::api::GeoPoint* temp = _impl_.geo_point_;
  _impl_.geo_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::GeoPoint* GeoBoxedPoint::unsafe_arena_release_geo_point() {
  // @@protoc_insertion_point(field_release:clarifai.api.GeoBoxedPoint.geo_point)
  
  ::clarifai::api::GeoPoint* temp = _impl_.geo_point_;
  _impl_.geo_point_ = nullptr;
  return temp;
}
inline ::clarifai::api::GeoPoint* GeoBoxedPoint::_internal_mutable_geo_point() {
  
  if (_impl_.geo_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::GeoPoint>(GetArenaForAllocation());
    _impl_.geo_point_ = p;
  }
  return _impl_.geo_point_;
}
inline ::clarifai::api::GeoPoint* GeoBoxedPoint::mutable_geo_point() {
  ::clarifai::api::GeoPoint* _msg = _internal_mutable_geo_point();
  // @@protoc_insertion_point(field_mutable:clarifai.api.GeoBoxedPoint.geo_point)
  return _msg;
}
inline void GeoBoxedPoint::set_allocated_geo_point(::clarifai::api::GeoPoint* geo_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.geo_point_;
  }
  if (geo_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(geo_point);
    if (message_arena != submessage_arena) {
      geo_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geo_point, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.geo_point_ = geo_point;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.GeoBoxedPoint.geo_point)
}

// -------------------------------------------------------------------

// Geo

// .clarifai.api.GeoPoint geo_point = 1;
inline bool Geo::_internal_has_geo_point() const {
  return this != internal_default_instance() && _impl_.geo_point_ != nullptr;
}
inline bool Geo::has_geo_point() const {
  return _internal_has_geo_point();
}
inline void Geo::clear_geo_point() {
  if (GetArenaForAllocation() == nullptr && _impl_.geo_point_ != nullptr) {
    delete _impl_.geo_point_;
  }
  _impl_.geo_point_ = nullptr;
}
inline const ::clarifai::api::GeoPoint& Geo::_internal_geo_point() const {
  const ::clarifai::api::GeoPoint* p = _impl_.geo_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::GeoPoint&>(
      ::clarifai::api::_GeoPoint_default_instance_);
}
inline const ::clarifai::api::GeoPoint& Geo::geo_point() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Geo.geo_point)
  return _internal_geo_point();
}
inline void Geo::unsafe_arena_set_allocated_geo_point(
    ::clarifai::api::GeoPoint* geo_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.geo_point_);
  }
  _impl_.geo_point_ = geo_point;
  if (geo_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Geo.geo_point)
}
inline ::clarifai::api::GeoPoint* Geo::release_geo_point() {
  
  ::clarifai::api::GeoPoint* temp = _impl_.geo_point_;
  _impl_.geo_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::GeoPoint* Geo::unsafe_arena_release_geo_point() {
  // @@protoc_insertion_point(field_release:clarifai.api.Geo.geo_point)
  
  ::clarifai::api::GeoPoint* temp = _impl_.geo_point_;
  _impl_.geo_point_ = nullptr;
  return temp;
}
inline ::clarifai::api::GeoPoint* Geo::_internal_mutable_geo_point() {
  
  if (_impl_.geo_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::GeoPoint>(GetArenaForAllocation());
    _impl_.geo_point_ = p;
  }
  return _impl_.geo_point_;
}
inline ::clarifai::api::GeoPoint* Geo::mutable_geo_point() {
  ::clarifai::api::GeoPoint* _msg = _internal_mutable_geo_point();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Geo.geo_point)
  return _msg;
}
inline void Geo::set_allocated_geo_point(::clarifai::api::GeoPoint* geo_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.geo_point_;
  }
  if (geo_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(geo_point);
    if (message_arena != submessage_arena) {
      geo_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geo_point, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.geo_point_ = geo_point;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Geo.geo_point)
}

// .clarifai.api.GeoLimit geo_limit = 2;
inline bool Geo::_internal_has_geo_limit() const {
  return this != internal_default_instance() && _impl_.geo_limit_ != nullptr;
}
inline bool Geo::has_geo_limit() const {
  return _internal_has_geo_limit();
}
inline void Geo::clear_geo_limit() {
  if (GetArenaForAllocation() == nullptr && _impl_.geo_limit_ != nullptr) {
    delete _impl_.geo_limit_;
  }
  _impl_.geo_limit_ = nullptr;
}
inline const ::clarifai::api::GeoLimit& Geo::_internal_geo_limit() const {
  const ::clarifai::api::GeoLimit* p = _impl_.geo_limit_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::GeoLimit&>(
      ::clarifai::api::_GeoLimit_default_instance_);
}
inline const ::clarifai::api::GeoLimit& Geo::geo_limit() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Geo.geo_limit)
  return _internal_geo_limit();
}
inline void Geo::unsafe_arena_set_allocated_geo_limit(
    ::clarifai::api::GeoLimit* geo_limit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.geo_limit_);
  }
  _impl_.geo_limit_ = geo_limit;
  if (geo_limit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Geo.geo_limit)
}
inline ::clarifai::api::GeoLimit* Geo::release_geo_limit() {
  
  ::clarifai::api::GeoLimit* temp = _impl_.geo_limit_;
  _impl_.geo_limit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::GeoLimit* Geo::unsafe_arena_release_geo_limit() {
  // @@protoc_insertion_point(field_release:clarifai.api.Geo.geo_limit)
  
  ::clarifai::api::GeoLimit* temp = _impl_.geo_limit_;
  _impl_.geo_limit_ = nullptr;
  return temp;
}
inline ::clarifai::api::GeoLimit* Geo::_internal_mutable_geo_limit() {
  
  if (_impl_.geo_limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::GeoLimit>(GetArenaForAllocation());
    _impl_.geo_limit_ = p;
  }
  return _impl_.geo_limit_;
}
inline ::clarifai::api::GeoLimit* Geo::mutable_geo_limit() {
  ::clarifai::api::GeoLimit* _msg = _internal_mutable_geo_limit();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Geo.geo_limit)
  return _msg;
}
inline void Geo::set_allocated_geo_limit(::clarifai::api::GeoLimit* geo_limit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.geo_limit_;
  }
  if (geo_limit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(geo_limit);
    if (message_arena != submessage_arena) {
      geo_limit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geo_limit, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.geo_limit_ = geo_limit;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Geo.geo_limit)
}

// repeated .clarifai.api.GeoBoxedPoint geo_box = 3;
inline int Geo::_internal_geo_box_size() const {
  return _impl_.geo_box_.size();
}
inline int Geo::geo_box_size() const {
  return _internal_geo_box_size();
}
inline void Geo::clear_geo_box() {
  _impl_.geo_box_.Clear();
}
inline ::clarifai::api::GeoBoxedPoint* Geo::mutable_geo_box(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Geo.geo_box)
  return _impl_.geo_box_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::GeoBoxedPoint >*
Geo::mutable_geo_box() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Geo.geo_box)
  return &_impl_.geo_box_;
}
inline const ::clarifai::api::GeoBoxedPoint& Geo::_internal_geo_box(int index) const {
  return _impl_.geo_box_.Get(index);
}
inline const ::clarifai::api::GeoBoxedPoint& Geo::geo_box(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Geo.geo_box)
  return _internal_geo_box(index);
}
inline ::clarifai::api::GeoBoxedPoint* Geo::_internal_add_geo_box() {
  return _impl_.geo_box_.Add();
}
inline ::clarifai::api::GeoBoxedPoint* Geo::add_geo_box() {
  ::clarifai::api::GeoBoxedPoint* _add = _internal_add_geo_box();
  // @@protoc_insertion_point(field_add:clarifai.api.Geo.geo_box)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::GeoBoxedPoint >&
Geo::geo_box() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Geo.geo_box)
  return _impl_.geo_box_;
}

// -------------------------------------------------------------------

// Image

// string url = 1;
inline void Image::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& Image::url() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Image.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Image::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Image.url)
}
inline std::string* Image::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Image.url)
  return _s;
}
inline const std::string& Image::_internal_url() const {
  return _impl_.url_.Get();
}
inline void Image::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* Image::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* Image::release_url() {
  // @@protoc_insertion_point(field_release:clarifai.api.Image.url)
  return _impl_.url_.Release();
}
inline void Image::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Image.url)
}

// bytes base64 = 2;
inline void Image::clear_base64() {
  _impl_.base64_.ClearToEmpty();
}
inline const std::string& Image::base64() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Image.base64)
  return _internal_base64();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Image::set_base64(ArgT0&& arg0, ArgT... args) {
 
 _impl_.base64_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Image.base64)
}
inline std::string* Image::mutable_base64() {
  std::string* _s = _internal_mutable_base64();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Image.base64)
  return _s;
}
inline const std::string& Image::_internal_base64() const {
  return _impl_.base64_.Get();
}
inline void Image::_internal_set_base64(const std::string& value) {
  
  _impl_.base64_.Set(value, GetArenaForAllocation());
}
inline std::string* Image::_internal_mutable_base64() {
  
  return _impl_.base64_.Mutable(GetArenaForAllocation());
}
inline std::string* Image::release_base64() {
  // @@protoc_insertion_point(field_release:clarifai.api.Image.base64)
  return _impl_.base64_.Release();
}
inline void Image::set_allocated_base64(std::string* base64) {
  if (base64 != nullptr) {
    
  } else {
    
  }
  _impl_.base64_.SetAllocated(base64, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.base64_.IsDefault()) {
    _impl_.base64_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Image.base64)
}

// bool allow_duplicate_url = 4;
inline void Image::clear_allow_duplicate_url() {
  _impl_.allow_duplicate_url_ = false;
}
inline bool Image::_internal_allow_duplicate_url() const {
  return _impl_.allow_duplicate_url_;
}
inline bool Image::allow_duplicate_url() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Image.allow_duplicate_url)
  return _internal_allow_duplicate_url();
}
inline void Image::_internal_set_allow_duplicate_url(bool value) {
  
  _impl_.allow_duplicate_url_ = value;
}
inline void Image::set_allow_duplicate_url(bool value) {
  _internal_set_allow_duplicate_url(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Image.allow_duplicate_url)
}

// .clarifai.api.HostedURL hosted = 5;
inline bool Image::_internal_has_hosted() const {
  return this != internal_default_instance() && _impl_.hosted_ != nullptr;
}
inline bool Image::has_hosted() const {
  return _internal_has_hosted();
}
inline void Image::clear_hosted() {
  if (GetArenaForAllocation() == nullptr && _impl_.hosted_ != nullptr) {
    delete _impl_.hosted_;
  }
  _impl_.hosted_ = nullptr;
}
inline const ::clarifai::api::HostedURL& Image::_internal_hosted() const {
  const ::clarifai::api::HostedURL* p = _impl_.hosted_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::HostedURL&>(
      ::clarifai::api::_HostedURL_default_instance_);
}
inline const ::clarifai::api::HostedURL& Image::hosted() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Image.hosted)
  return _internal_hosted();
}
inline void Image::unsafe_arena_set_allocated_hosted(
    ::clarifai::api::HostedURL* hosted) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hosted_);
  }
  _impl_.hosted_ = hosted;
  if (hosted) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Image.hosted)
}
inline ::clarifai::api::HostedURL* Image::release_hosted() {
  
  ::clarifai::api::HostedURL* temp = _impl_.hosted_;
  _impl_.hosted_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::HostedURL* Image::unsafe_arena_release_hosted() {
  // @@protoc_insertion_point(field_release:clarifai.api.Image.hosted)
  
  ::clarifai::api::HostedURL* temp = _impl_.hosted_;
  _impl_.hosted_ = nullptr;
  return temp;
}
inline ::clarifai::api::HostedURL* Image::_internal_mutable_hosted() {
  
  if (_impl_.hosted_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::HostedURL>(GetArenaForAllocation());
    _impl_.hosted_ = p;
  }
  return _impl_.hosted_;
}
inline ::clarifai::api::HostedURL* Image::mutable_hosted() {
  ::clarifai::api::HostedURL* _msg = _internal_mutable_hosted();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Image.hosted)
  return _msg;
}
inline void Image::set_allocated_hosted(::clarifai::api::HostedURL* hosted) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hosted_;
  }
  if (hosted) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hosted);
    if (message_arena != submessage_arena) {
      hosted = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hosted, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.hosted_ = hosted;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Image.hosted)
}

// .clarifai.api.ImageInfo image_info = 6;
inline bool Image::_internal_has_image_info() const {
  return this != internal_default_instance() && _impl_.image_info_ != nullptr;
}
inline bool Image::has_image_info() const {
  return _internal_has_image_info();
}
inline void Image::clear_image_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.image_info_ != nullptr) {
    delete _impl_.image_info_;
  }
  _impl_.image_info_ = nullptr;
}
inline const ::clarifai::api::ImageInfo& Image::_internal_image_info() const {
  const ::clarifai::api::ImageInfo* p = _impl_.image_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::ImageInfo&>(
      ::clarifai::api::_ImageInfo_default_instance_);
}
inline const ::clarifai::api::ImageInfo& Image::image_info() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Image.image_info)
  return _internal_image_info();
}
inline void Image::unsafe_arena_set_allocated_image_info(
    ::clarifai::api::ImageInfo* image_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_info_);
  }
  _impl_.image_info_ = image_info;
  if (image_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Image.image_info)
}
inline ::clarifai::api::ImageInfo* Image::release_image_info() {
  
  ::clarifai::api::ImageInfo* temp = _impl_.image_info_;
  _impl_.image_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::ImageInfo* Image::unsafe_arena_release_image_info() {
  // @@protoc_insertion_point(field_release:clarifai.api.Image.image_info)
  
  ::clarifai::api::ImageInfo* temp = _impl_.image_info_;
  _impl_.image_info_ = nullptr;
  return temp;
}
inline ::clarifai::api::ImageInfo* Image::_internal_mutable_image_info() {
  
  if (_impl_.image_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::ImageInfo>(GetArenaForAllocation());
    _impl_.image_info_ = p;
  }
  return _impl_.image_info_;
}
inline ::clarifai::api::ImageInfo* Image::mutable_image_info() {
  ::clarifai::api::ImageInfo* _msg = _internal_mutable_image_info();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Image.image_info)
  return _msg;
}
inline void Image::set_allocated_image_info(::clarifai::api::ImageInfo* image_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.image_info_;
  }
  if (image_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(image_info);
    if (message_arena != submessage_arena) {
      image_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.image_info_ = image_info;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Image.image_info)
}

// -------------------------------------------------------------------

// ImageInfo

// int32 width = 1;
inline void ImageInfo::clear_width() {
  _impl_.width_ = 0;
}
inline int32_t ImageInfo::_internal_width() const {
  return _impl_.width_;
}
inline int32_t ImageInfo::width() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ImageInfo.width)
  return _internal_width();
}
inline void ImageInfo::_internal_set_width(int32_t value) {
  
  _impl_.width_ = value;
}
inline void ImageInfo::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:clarifai.api.ImageInfo.width)
}

// int32 height = 2;
inline void ImageInfo::clear_height() {
  _impl_.height_ = 0;
}
inline int32_t ImageInfo::_internal_height() const {
  return _impl_.height_;
}
inline int32_t ImageInfo::height() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ImageInfo.height)
  return _internal_height();
}
inline void ImageInfo::_internal_set_height(int32_t value) {
  
  _impl_.height_ = value;
}
inline void ImageInfo::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:clarifai.api.ImageInfo.height)
}

// string format = 3;
inline void ImageInfo::clear_format() {
  _impl_.format_.ClearToEmpty();
}
inline const std::string& ImageInfo::format() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ImageInfo.format)
  return _internal_format();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageInfo::set_format(ArgT0&& arg0, ArgT... args) {
 
 _impl_.format_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ImageInfo.format)
}
inline std::string* ImageInfo::mutable_format() {
  std::string* _s = _internal_mutable_format();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ImageInfo.format)
  return _s;
}
inline const std::string& ImageInfo::_internal_format() const {
  return _impl_.format_.Get();
}
inline void ImageInfo::_internal_set_format(const std::string& value) {
  
  _impl_.format_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageInfo::_internal_mutable_format() {
  
  return _impl_.format_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageInfo::release_format() {
  // @@protoc_insertion_point(field_release:clarifai.api.ImageInfo.format)
  return _impl_.format_.Release();
}
inline void ImageInfo::set_allocated_format(std::string* format) {
  if (format != nullptr) {
    
  } else {
    
  }
  _impl_.format_.SetAllocated(format, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.format_.IsDefault()) {
    _impl_.format_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ImageInfo.format)
}

// string color_mode = 4;
inline void ImageInfo::clear_color_mode() {
  _impl_.color_mode_.ClearToEmpty();
}
inline const std::string& ImageInfo::color_mode() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ImageInfo.color_mode)
  return _internal_color_mode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageInfo::set_color_mode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.color_mode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ImageInfo.color_mode)
}
inline std::string* ImageInfo::mutable_color_mode() {
  std::string* _s = _internal_mutable_color_mode();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ImageInfo.color_mode)
  return _s;
}
inline const std::string& ImageInfo::_internal_color_mode() const {
  return _impl_.color_mode_.Get();
}
inline void ImageInfo::_internal_set_color_mode(const std::string& value) {
  
  _impl_.color_mode_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageInfo::_internal_mutable_color_mode() {
  
  return _impl_.color_mode_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageInfo::release_color_mode() {
  // @@protoc_insertion_point(field_release:clarifai.api.ImageInfo.color_mode)
  return _impl_.color_mode_.Release();
}
inline void ImageInfo::set_allocated_color_mode(std::string* color_mode) {
  if (color_mode != nullptr) {
    
  } else {
    
  }
  _impl_.color_mode_.SetAllocated(color_mode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.color_mode_.IsDefault()) {
    _impl_.color_mode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ImageInfo.color_mode)
}

// -------------------------------------------------------------------

// HostedURL

// string prefix = 1;
inline void HostedURL::clear_prefix() {
  _impl_.prefix_.ClearToEmpty();
}
inline const std::string& HostedURL::prefix() const {
  // @@protoc_insertion_point(field_get:clarifai.api.HostedURL.prefix)
  return _internal_prefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HostedURL::set_prefix(ArgT0&& arg0, ArgT... args) {
 
 _impl_.prefix_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.HostedURL.prefix)
}
inline std::string* HostedURL::mutable_prefix() {
  std::string* _s = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:clarifai.api.HostedURL.prefix)
  return _s;
}
inline const std::string& HostedURL::_internal_prefix() const {
  return _impl_.prefix_.Get();
}
inline void HostedURL::_internal_set_prefix(const std::string& value) {
  
  _impl_.prefix_.Set(value, GetArenaForAllocation());
}
inline std::string* HostedURL::_internal_mutable_prefix() {
  
  return _impl_.prefix_.Mutable(GetArenaForAllocation());
}
inline std::string* HostedURL::release_prefix() {
  // @@protoc_insertion_point(field_release:clarifai.api.HostedURL.prefix)
  return _impl_.prefix_.Release();
}
inline void HostedURL::set_allocated_prefix(std::string* prefix) {
  if (prefix != nullptr) {
    
  } else {
    
  }
  _impl_.prefix_.SetAllocated(prefix, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.prefix_.IsDefault()) {
    _impl_.prefix_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.HostedURL.prefix)
}

// string suffix = 2;
inline void HostedURL::clear_suffix() {
  _impl_.suffix_.ClearToEmpty();
}
inline const std::string& HostedURL::suffix() const {
  // @@protoc_insertion_point(field_get:clarifai.api.HostedURL.suffix)
  return _internal_suffix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HostedURL::set_suffix(ArgT0&& arg0, ArgT... args) {
 
 _impl_.suffix_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.HostedURL.suffix)
}
inline std::string* HostedURL::mutable_suffix() {
  std::string* _s = _internal_mutable_suffix();
  // @@protoc_insertion_point(field_mutable:clarifai.api.HostedURL.suffix)
  return _s;
}
inline const std::string& HostedURL::_internal_suffix() const {
  return _impl_.suffix_.Get();
}
inline void HostedURL::_internal_set_suffix(const std::string& value) {
  
  _impl_.suffix_.Set(value, GetArenaForAllocation());
}
inline std::string* HostedURL::_internal_mutable_suffix() {
  
  return _impl_.suffix_.Mutable(GetArenaForAllocation());
}
inline std::string* HostedURL::release_suffix() {
  // @@protoc_insertion_point(field_release:clarifai.api.HostedURL.suffix)
  return _impl_.suffix_.Release();
}
inline void HostedURL::set_allocated_suffix(std::string* suffix) {
  if (suffix != nullptr) {
    
  } else {
    
  }
  _impl_.suffix_.SetAllocated(suffix, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.suffix_.IsDefault()) {
    _impl_.suffix_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.HostedURL.suffix)
}

// repeated string sizes = 3;
inline int HostedURL::_internal_sizes_size() const {
  return _impl_.sizes_.size();
}
inline int HostedURL::sizes_size() const {
  return _internal_sizes_size();
}
inline void HostedURL::clear_sizes() {
  _impl_.sizes_.Clear();
}
inline std::string* HostedURL::add_sizes() {
  std::string* _s = _internal_add_sizes();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.HostedURL.sizes)
  return _s;
}
inline const std::string& HostedURL::_internal_sizes(int index) const {
  return _impl_.sizes_.Get(index);
}
inline const std::string& HostedURL::sizes(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.HostedURL.sizes)
  return _internal_sizes(index);
}
inline std::string* HostedURL::mutable_sizes(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.HostedURL.sizes)
  return _impl_.sizes_.Mutable(index);
}
inline void HostedURL::set_sizes(int index, const std::string& value) {
  _impl_.sizes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.HostedURL.sizes)
}
inline void HostedURL::set_sizes(int index, std::string&& value) {
  _impl_.sizes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.HostedURL.sizes)
}
inline void HostedURL::set_sizes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.sizes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.HostedURL.sizes)
}
inline void HostedURL::set_sizes(int index, const char* value, size_t size) {
  _impl_.sizes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.HostedURL.sizes)
}
inline std::string* HostedURL::_internal_add_sizes() {
  return _impl_.sizes_.Add();
}
inline void HostedURL::add_sizes(const std::string& value) {
  _impl_.sizes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.HostedURL.sizes)
}
inline void HostedURL::add_sizes(std::string&& value) {
  _impl_.sizes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.HostedURL.sizes)
}
inline void HostedURL::add_sizes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.sizes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.HostedURL.sizes)
}
inline void HostedURL::add_sizes(const char* value, size_t size) {
  _impl_.sizes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.HostedURL.sizes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
HostedURL::sizes() const {
  // @@protoc_insertion_point(field_list:clarifai.api.HostedURL.sizes)
  return _impl_.sizes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
HostedURL::mutable_sizes() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.HostedURL.sizes)
  return &_impl_.sizes_;
}

// string crossorigin = 4;
inline void HostedURL::clear_crossorigin() {
  _impl_.crossorigin_.ClearToEmpty();
}
inline const std::string& HostedURL::crossorigin() const {
  // @@protoc_insertion_point(field_get:clarifai.api.HostedURL.crossorigin)
  return _internal_crossorigin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HostedURL::set_crossorigin(ArgT0&& arg0, ArgT... args) {
 
 _impl_.crossorigin_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.HostedURL.crossorigin)
}
inline std::string* HostedURL::mutable_crossorigin() {
  std::string* _s = _internal_mutable_crossorigin();
  // @@protoc_insertion_point(field_mutable:clarifai.api.HostedURL.crossorigin)
  return _s;
}
inline const std::string& HostedURL::_internal_crossorigin() const {
  return _impl_.crossorigin_.Get();
}
inline void HostedURL::_internal_set_crossorigin(const std::string& value) {
  
  _impl_.crossorigin_.Set(value, GetArenaForAllocation());
}
inline std::string* HostedURL::_internal_mutable_crossorigin() {
  
  return _impl_.crossorigin_.Mutable(GetArenaForAllocation());
}
inline std::string* HostedURL::release_crossorigin() {
  // @@protoc_insertion_point(field_release:clarifai.api.HostedURL.crossorigin)
  return _impl_.crossorigin_.Release();
}
inline void HostedURL::set_allocated_crossorigin(std::string* crossorigin) {
  if (crossorigin != nullptr) {
    
  } else {
    
  }
  _impl_.crossorigin_.SetAllocated(crossorigin, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.crossorigin_.IsDefault()) {
    _impl_.crossorigin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.HostedURL.crossorigin)
}

// -------------------------------------------------------------------

// Input

// string id = 1;
inline void Input::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Input::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Input.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Input::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Input.id)
}
inline std::string* Input::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Input.id)
  return _s;
}
inline const std::string& Input::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Input::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Input::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Input::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Input.id)
  return _impl_.id_.Release();
}
inline void Input::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Input.id)
}

// .clarifai.api.Data data = 2;
inline bool Input::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool Input::has_data() const {
  return _internal_has_data();
}
inline void Input::clear_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.data_ != nullptr) {
    delete _impl_.data_;
  }
  _impl_.data_ = nullptr;
}
inline const ::clarifai::api::Data& Input::_internal_data() const {
  const ::clarifai::api::Data* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Data&>(
      ::clarifai::api::_Data_default_instance_);
}
inline const ::clarifai::api::Data& Input::data() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Input.data)
  return _internal_data();
}
inline void Input::unsafe_arena_set_allocated_data(
    ::clarifai::api::Data* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Input.data)
}
inline ::clarifai::api::Data* Input::release_data() {
  
  ::clarifai::api::Data* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Data* Input::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:clarifai.api.Input.data)
  
  ::clarifai::api::Data* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::clarifai::api::Data* Input::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Data>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::clarifai::api::Data* Input::mutable_data() {
  ::clarifai::api::Data* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Input.data)
  return _msg;
}
inline void Input::set_allocated_data(::clarifai::api::Data* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Input.data)
}

// .google.protobuf.Timestamp created_at = 4;
inline bool Input::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool Input::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Input::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Input::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Input.created_at)
  return _internal_created_at();
}
inline void Input::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Input.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Input::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Input::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.Input.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Input::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Input::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Input.created_at)
  return _msg;
}
inline void Input::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Input.created_at)
}

// .google.protobuf.Timestamp modified_at = 5;
inline bool Input::_internal_has_modified_at() const {
  return this != internal_default_instance() && _impl_.modified_at_ != nullptr;
}
inline bool Input::has_modified_at() const {
  return _internal_has_modified_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Input::_internal_modified_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.modified_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Input::modified_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Input.modified_at)
  return _internal_modified_at();
}
inline void Input::unsafe_arena_set_allocated_modified_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  _impl_.modified_at_ = modified_at;
  if (modified_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Input.modified_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Input::release_modified_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Input::unsafe_arena_release_modified_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.Input.modified_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Input::_internal_mutable_modified_at() {
  
  if (_impl_.modified_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.modified_at_ = p;
  }
  return _impl_.modified_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Input::mutable_modified_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_modified_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Input.modified_at)
  return _msg;
}
inline void Input::set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  if (modified_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(modified_at));
    if (message_arena != submessage_arena) {
      modified_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modified_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.modified_at_ = modified_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Input.modified_at)
}

// .clarifai.api.status.Status status = 6;
inline bool Input::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool Input::has_status() const {
  return _internal_has_status();
}
inline const ::clarifai::api::status::Status& Input::_internal_status() const {
  const ::clarifai::api::status::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::status::Status&>(
      ::clarifai::api::status::_Status_default_instance_);
}
inline const ::clarifai::api::status::Status& Input::status() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Input.status)
  return _internal_status();
}
inline void Input::unsafe_arena_set_allocated_status(
    ::clarifai::api::status::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Input.status)
}
inline ::clarifai::api::status::Status* Input::release_status() {
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::status::Status* Input::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:clarifai.api.Input.status)
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::clarifai::api::status::Status* Input::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::status::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::clarifai::api::status::Status* Input::mutable_status() {
  ::clarifai::api::status::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Input.status)
  return _msg;
}
inline void Input::set_allocated_status(::clarifai::api::status::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Input.status)
}

// repeated string dataset_ids = 7;
inline int Input::_internal_dataset_ids_size() const {
  return _impl_.dataset_ids_.size();
}
inline int Input::dataset_ids_size() const {
  return _internal_dataset_ids_size();
}
inline void Input::clear_dataset_ids() {
  _impl_.dataset_ids_.Clear();
}
inline std::string* Input::add_dataset_ids() {
  std::string* _s = _internal_add_dataset_ids();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.Input.dataset_ids)
  return _s;
}
inline const std::string& Input::_internal_dataset_ids(int index) const {
  return _impl_.dataset_ids_.Get(index);
}
inline const std::string& Input::dataset_ids(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Input.dataset_ids)
  return _internal_dataset_ids(index);
}
inline std::string* Input::mutable_dataset_ids(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Input.dataset_ids)
  return _impl_.dataset_ids_.Mutable(index);
}
inline void Input::set_dataset_ids(int index, const std::string& value) {
  _impl_.dataset_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Input.dataset_ids)
}
inline void Input::set_dataset_ids(int index, std::string&& value) {
  _impl_.dataset_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.Input.dataset_ids)
}
inline void Input::set_dataset_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.dataset_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.Input.dataset_ids)
}
inline void Input::set_dataset_ids(int index, const char* value, size_t size) {
  _impl_.dataset_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.Input.dataset_ids)
}
inline std::string* Input::_internal_add_dataset_ids() {
  return _impl_.dataset_ids_.Add();
}
inline void Input::add_dataset_ids(const std::string& value) {
  _impl_.dataset_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.Input.dataset_ids)
}
inline void Input::add_dataset_ids(std::string&& value) {
  _impl_.dataset_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.Input.dataset_ids)
}
inline void Input::add_dataset_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.dataset_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.Input.dataset_ids)
}
inline void Input::add_dataset_ids(const char* value, size_t size) {
  _impl_.dataset_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.Input.dataset_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Input::dataset_ids() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Input.dataset_ids)
  return _impl_.dataset_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Input::mutable_dataset_ids() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Input.dataset_ids)
  return &_impl_.dataset_ids_;
}

// -------------------------------------------------------------------

// InputCount

// uint32 processed = 1 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void InputCount::clear_processed() {
  _impl_.processed_ = 0u;
}
inline uint32_t InputCount::_internal_processed() const {
  return _impl_.processed_;
}
inline uint32_t InputCount::processed() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputCount.processed)
  return _internal_processed();
}
inline void InputCount::_internal_set_processed(uint32_t value) {
  
  _impl_.processed_ = value;
}
inline void InputCount::set_processed(uint32_t value) {
  _internal_set_processed(value);
  // @@protoc_insertion_point(field_set:clarifai.api.InputCount.processed)
}

// uint32 to_process = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void InputCount::clear_to_process() {
  _impl_.to_process_ = 0u;
}
inline uint32_t InputCount::_internal_to_process() const {
  return _impl_.to_process_;
}
inline uint32_t InputCount::to_process() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputCount.to_process)
  return _internal_to_process();
}
inline void InputCount::_internal_set_to_process(uint32_t value) {
  
  _impl_.to_process_ = value;
}
inline void InputCount::set_to_process(uint32_t value) {
  _internal_set_to_process(value);
  // @@protoc_insertion_point(field_set:clarifai.api.InputCount.to_process)
}

// uint32 errors = 3 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void InputCount::clear_errors() {
  _impl_.errors_ = 0u;
}
inline uint32_t InputCount::_internal_errors() const {
  return _impl_.errors_;
}
inline uint32_t InputCount::errors() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputCount.errors)
  return _internal_errors();
}
inline void InputCount::_internal_set_errors(uint32_t value) {
  
  _impl_.errors_ = value;
}
inline void InputCount::set_errors(uint32_t value) {
  _internal_set_errors(value);
  // @@protoc_insertion_point(field_set:clarifai.api.InputCount.errors)
}

// uint32 processing = 4 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void InputCount::clear_processing() {
  _impl_.processing_ = 0u;
}
inline uint32_t InputCount::_internal_processing() const {
  return _impl_.processing_;
}
inline uint32_t InputCount::processing() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputCount.processing)
  return _internal_processing();
}
inline void InputCount::_internal_set_processing(uint32_t value) {
  
  _impl_.processing_ = value;
}
inline void InputCount::set_processing(uint32_t value) {
  _internal_set_processing(value);
  // @@protoc_insertion_point(field_set:clarifai.api.InputCount.processing)
}

// uint32 reindexed = 5 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void InputCount::clear_reindexed() {
  _impl_.reindexed_ = 0u;
}
inline uint32_t InputCount::_internal_reindexed() const {
  return _impl_.reindexed_;
}
inline uint32_t InputCount::reindexed() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputCount.reindexed)
  return _internal_reindexed();
}
inline void InputCount::_internal_set_reindexed(uint32_t value) {
  
  _impl_.reindexed_ = value;
}
inline void InputCount::set_reindexed(uint32_t value) {
  _internal_set_reindexed(value);
  // @@protoc_insertion_point(field_set:clarifai.api.InputCount.reindexed)
}

// uint32 to_reindex = 6 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void InputCount::clear_to_reindex() {
  _impl_.to_reindex_ = 0u;
}
inline uint32_t InputCount::_internal_to_reindex() const {
  return _impl_.to_reindex_;
}
inline uint32_t InputCount::to_reindex() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputCount.to_reindex)
  return _internal_to_reindex();
}
inline void InputCount::_internal_set_to_reindex(uint32_t value) {
  
  _impl_.to_reindex_ = value;
}
inline void InputCount::set_to_reindex(uint32_t value) {
  _internal_set_to_reindex(value);
  // @@protoc_insertion_point(field_set:clarifai.api.InputCount.to_reindex)
}

// uint32 reindex_errors = 7 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void InputCount::clear_reindex_errors() {
  _impl_.reindex_errors_ = 0u;
}
inline uint32_t InputCount::_internal_reindex_errors() const {
  return _impl_.reindex_errors_;
}
inline uint32_t InputCount::reindex_errors() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputCount.reindex_errors)
  return _internal_reindex_errors();
}
inline void InputCount::_internal_set_reindex_errors(uint32_t value) {
  
  _impl_.reindex_errors_ = value;
}
inline void InputCount::set_reindex_errors(uint32_t value) {
  _internal_set_reindex_errors(value);
  // @@protoc_insertion_point(field_set:clarifai.api.InputCount.reindex_errors)
}

// uint32 reindexing = 8 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void InputCount::clear_reindexing() {
  _impl_.reindexing_ = 0u;
}
inline uint32_t InputCount::_internal_reindexing() const {
  return _impl_.reindexing_;
}
inline uint32_t InputCount::reindexing() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputCount.reindexing)
  return _internal_reindexing();
}
inline void InputCount::_internal_set_reindexing(uint32_t value) {
  
  _impl_.reindexing_ = value;
}
inline void InputCount::set_reindexing(uint32_t value) {
  _internal_set_reindexing(value);
  // @@protoc_insertion_point(field_set:clarifai.api.InputCount.reindexing)
}

// -------------------------------------------------------------------

// Dataset

// string id = 1;
inline void Dataset::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Dataset::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Dataset.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Dataset::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Dataset.id)
}
inline std::string* Dataset::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Dataset.id)
  return _s;
}
inline const std::string& Dataset::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Dataset::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Dataset::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Dataset::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Dataset.id)
  return _impl_.id_.Release();
}
inline void Dataset::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Dataset.id)
}

// .google.protobuf.Timestamp created_at = 2;
inline bool Dataset::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool Dataset::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Dataset::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Dataset::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Dataset.created_at)
  return _internal_created_at();
}
inline void Dataset::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Dataset.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Dataset::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Dataset::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.Dataset.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Dataset::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Dataset::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Dataset.created_at)
  return _msg;
}
inline void Dataset::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Dataset.created_at)
}

// .google.protobuf.Timestamp modified_at = 3;
inline bool Dataset::_internal_has_modified_at() const {
  return this != internal_default_instance() && _impl_.modified_at_ != nullptr;
}
inline bool Dataset::has_modified_at() const {
  return _internal_has_modified_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Dataset::_internal_modified_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.modified_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Dataset::modified_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Dataset.modified_at)
  return _internal_modified_at();
}
inline void Dataset::unsafe_arena_set_allocated_modified_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  _impl_.modified_at_ = modified_at;
  if (modified_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Dataset.modified_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Dataset::release_modified_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Dataset::unsafe_arena_release_modified_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.Dataset.modified_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Dataset::_internal_mutable_modified_at() {
  
  if (_impl_.modified_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.modified_at_ = p;
  }
  return _impl_.modified_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Dataset::mutable_modified_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_modified_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Dataset.modified_at)
  return _msg;
}
inline void Dataset::set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  if (modified_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(modified_at));
    if (message_arena != submessage_arena) {
      modified_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modified_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.modified_at_ = modified_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Dataset.modified_at)
}

// string app_id = 4;
inline void Dataset::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& Dataset::app_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Dataset.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Dataset::set_app_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.app_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Dataset.app_id)
}
inline std::string* Dataset::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Dataset.app_id)
  return _s;
}
inline const std::string& Dataset::_internal_app_id() const {
  return _impl_.app_id_.Get();
}
inline void Dataset::_internal_set_app_id(const std::string& value) {
  
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Dataset::_internal_mutable_app_id() {
  
  return _impl_.app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Dataset::release_app_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Dataset.app_id)
  return _impl_.app_id_.Release();
}
inline void Dataset::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    
  } else {
    
  }
  _impl_.app_id_.SetAllocated(app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Dataset.app_id)
}

// string user_id = 5;
inline void Dataset::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& Dataset::user_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Dataset.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Dataset::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Dataset.user_id)
}
inline std::string* Dataset::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Dataset.user_id)
  return _s;
}
inline const std::string& Dataset::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void Dataset::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Dataset::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Dataset::release_user_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Dataset.user_id)
  return _impl_.user_id_.Release();
}
inline void Dataset::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Dataset.user_id)
}

// string description = 7;
inline void Dataset::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Dataset::description() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Dataset.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Dataset::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Dataset.description)
}
inline std::string* Dataset::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Dataset.description)
  return _s;
}
inline const std::string& Dataset::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Dataset::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Dataset::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Dataset::release_description() {
  // @@protoc_insertion_point(field_release:clarifai.api.Dataset.description)
  return _impl_.description_.Release();
}
inline void Dataset::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Dataset.description)
}

// .google.protobuf.Struct metadata = 8;
inline bool Dataset::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool Dataset::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Dataset::_internal_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Dataset::metadata() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Dataset.metadata)
  return _internal_metadata();
}
inline void Dataset::unsafe_arena_set_allocated_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Dataset.metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Dataset::release_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Dataset::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:clarifai.api.Dataset.metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Dataset::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Dataset::mutable_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Dataset.metadata)
  return _msg;
}
inline void Dataset::set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Dataset.metadata)
}

// .clarifai.api.Visibility visibility = 9;
inline bool Dataset::_internal_has_visibility() const {
  return this != internal_default_instance() && _impl_.visibility_ != nullptr;
}
inline bool Dataset::has_visibility() const {
  return _internal_has_visibility();
}
inline void Dataset::clear_visibility() {
  if (GetArenaForAllocation() == nullptr && _impl_.visibility_ != nullptr) {
    delete _impl_.visibility_;
  }
  _impl_.visibility_ = nullptr;
}
inline const ::clarifai::api::Visibility& Dataset::_internal_visibility() const {
  const ::clarifai::api::Visibility* p = _impl_.visibility_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Visibility&>(
      ::clarifai::api::_Visibility_default_instance_);
}
inline const ::clarifai::api::Visibility& Dataset::visibility() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Dataset.visibility)
  return _internal_visibility();
}
inline void Dataset::unsafe_arena_set_allocated_visibility(
    ::clarifai::api::Visibility* visibility) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visibility_);
  }
  _impl_.visibility_ = visibility;
  if (visibility) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Dataset.visibility)
}
inline ::clarifai::api::Visibility* Dataset::release_visibility() {
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Visibility* Dataset::unsafe_arena_release_visibility() {
  // @@protoc_insertion_point(field_release:clarifai.api.Dataset.visibility)
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
  return temp;
}
inline ::clarifai::api::Visibility* Dataset::_internal_mutable_visibility() {
  
  if (_impl_.visibility_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Visibility>(GetArenaForAllocation());
    _impl_.visibility_ = p;
  }
  return _impl_.visibility_;
}
inline ::clarifai::api::Visibility* Dataset::mutable_visibility() {
  ::clarifai::api::Visibility* _msg = _internal_mutable_visibility();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Dataset.visibility)
  return _msg;
}
inline void Dataset::set_allocated_visibility(::clarifai::api::Visibility* visibility) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.visibility_;
  }
  if (visibility) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(visibility);
    if (message_arena != submessage_arena) {
      visibility = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visibility, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.visibility_ = visibility;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Dataset.visibility)
}

// .clarifai.api.AnnotationFilter default_annotation_filter = 12;
inline bool Dataset::_internal_has_default_annotation_filter() const {
  return this != internal_default_instance() && _impl_.default_annotation_filter_ != nullptr;
}
inline bool Dataset::has_default_annotation_filter() const {
  return _internal_has_default_annotation_filter();
}
inline void Dataset::clear_default_annotation_filter() {
  if (GetArenaForAllocation() == nullptr && _impl_.default_annotation_filter_ != nullptr) {
    delete _impl_.default_annotation_filter_;
  }
  _impl_.default_annotation_filter_ = nullptr;
}
inline const ::clarifai::api::AnnotationFilter& Dataset::_internal_default_annotation_filter() const {
  const ::clarifai::api::AnnotationFilter* p = _impl_.default_annotation_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::AnnotationFilter&>(
      ::clarifai::api::_AnnotationFilter_default_instance_);
}
inline const ::clarifai::api::AnnotationFilter& Dataset::default_annotation_filter() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Dataset.default_annotation_filter)
  return _internal_default_annotation_filter();
}
inline void Dataset::unsafe_arena_set_allocated_default_annotation_filter(
    ::clarifai::api::AnnotationFilter* default_annotation_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.default_annotation_filter_);
  }
  _impl_.default_annotation_filter_ = default_annotation_filter;
  if (default_annotation_filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Dataset.default_annotation_filter)
}
inline ::clarifai::api::AnnotationFilter* Dataset::release_default_annotation_filter() {
  
  ::clarifai::api::AnnotationFilter* temp = _impl_.default_annotation_filter_;
  _impl_.default_annotation_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::AnnotationFilter* Dataset::unsafe_arena_release_default_annotation_filter() {
  // @@protoc_insertion_point(field_release:clarifai.api.Dataset.default_annotation_filter)
  
  ::clarifai::api::AnnotationFilter* temp = _impl_.default_annotation_filter_;
  _impl_.default_annotation_filter_ = nullptr;
  return temp;
}
inline ::clarifai::api::AnnotationFilter* Dataset::_internal_mutable_default_annotation_filter() {
  
  if (_impl_.default_annotation_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::AnnotationFilter>(GetArenaForAllocation());
    _impl_.default_annotation_filter_ = p;
  }
  return _impl_.default_annotation_filter_;
}
inline ::clarifai::api::AnnotationFilter* Dataset::mutable_default_annotation_filter() {
  ::clarifai::api::AnnotationFilter* _msg = _internal_mutable_default_annotation_filter();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Dataset.default_annotation_filter)
  return _msg;
}
inline void Dataset::set_allocated_default_annotation_filter(::clarifai::api::AnnotationFilter* default_annotation_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.default_annotation_filter_;
  }
  if (default_annotation_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(default_annotation_filter);
    if (message_arena != submessage_arena) {
      default_annotation_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, default_annotation_filter, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.default_annotation_filter_ = default_annotation_filter;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Dataset.default_annotation_filter)
}

// string notes = 11;
inline void Dataset::clear_notes() {
  _impl_.notes_.ClearToEmpty();
}
inline const std::string& Dataset::notes() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Dataset.notes)
  return _internal_notes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Dataset::set_notes(ArgT0&& arg0, ArgT... args) {
 
 _impl_.notes_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Dataset.notes)
}
inline std::string* Dataset::mutable_notes() {
  std::string* _s = _internal_mutable_notes();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Dataset.notes)
  return _s;
}
inline const std::string& Dataset::_internal_notes() const {
  return _impl_.notes_.Get();
}
inline void Dataset::_internal_set_notes(const std::string& value) {
  
  _impl_.notes_.Set(value, GetArenaForAllocation());
}
inline std::string* Dataset::_internal_mutable_notes() {
  
  return _impl_.notes_.Mutable(GetArenaForAllocation());
}
inline std::string* Dataset::release_notes() {
  // @@protoc_insertion_point(field_release:clarifai.api.Dataset.notes)
  return _impl_.notes_.Release();
}
inline void Dataset::set_allocated_notes(std::string* notes) {
  if (notes != nullptr) {
    
  } else {
    
  }
  _impl_.notes_.SetAllocated(notes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.notes_.IsDefault()) {
    _impl_.notes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Dataset.notes)
}

// .clarifai.api.DatasetVersion version = 13;
inline bool Dataset::_internal_has_version() const {
  return this != internal_default_instance() && _impl_.version_ != nullptr;
}
inline bool Dataset::has_version() const {
  return _internal_has_version();
}
inline void Dataset::clear_version() {
  if (GetArenaForAllocation() == nullptr && _impl_.version_ != nullptr) {
    delete _impl_.version_;
  }
  _impl_.version_ = nullptr;
}
inline const ::clarifai::api::DatasetVersion& Dataset::_internal_version() const {
  const ::clarifai::api::DatasetVersion* p = _impl_.version_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::DatasetVersion&>(
      ::clarifai::api::_DatasetVersion_default_instance_);
}
inline const ::clarifai::api::DatasetVersion& Dataset::version() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Dataset.version)
  return _internal_version();
}
inline void Dataset::unsafe_arena_set_allocated_version(
    ::clarifai::api::DatasetVersion* version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.version_);
  }
  _impl_.version_ = version;
  if (version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Dataset.version)
}
inline ::clarifai::api::DatasetVersion* Dataset::release_version() {
  
  ::clarifai::api::DatasetVersion* temp = _impl_.version_;
  _impl_.version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::DatasetVersion* Dataset::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_release:clarifai.api.Dataset.version)
  
  ::clarifai::api::DatasetVersion* temp = _impl_.version_;
  _impl_.version_ = nullptr;
  return temp;
}
inline ::clarifai::api::DatasetVersion* Dataset::_internal_mutable_version() {
  
  if (_impl_.version_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::DatasetVersion>(GetArenaForAllocation());
    _impl_.version_ = p;
  }
  return _impl_.version_;
}
inline ::clarifai::api::DatasetVersion* Dataset::mutable_version() {
  ::clarifai::api::DatasetVersion* _msg = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Dataset.version)
  return _msg;
}
inline void Dataset::set_allocated_version(::clarifai::api::DatasetVersion* version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.version_;
  }
  if (version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(version);
    if (message_arena != submessage_arena) {
      version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.version_ = version;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Dataset.version)
}

// -------------------------------------------------------------------

// AnnotationFilter

// string id = 1;
inline void AnnotationFilter::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& AnnotationFilter::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AnnotationFilter.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AnnotationFilter::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.AnnotationFilter.id)
}
inline std::string* AnnotationFilter::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.AnnotationFilter.id)
  return _s;
}
inline const std::string& AnnotationFilter::_internal_id() const {
  return _impl_.id_.Get();
}
inline void AnnotationFilter::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* AnnotationFilter::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* AnnotationFilter::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.AnnotationFilter.id)
  return _impl_.id_.Release();
}
inline void AnnotationFilter::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.AnnotationFilter.id)
}

// .google.protobuf.Timestamp created_at = 2;
inline bool AnnotationFilter::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool AnnotationFilter::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& AnnotationFilter::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& AnnotationFilter::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AnnotationFilter.created_at)
  return _internal_created_at();
}
inline void AnnotationFilter::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.AnnotationFilter.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AnnotationFilter::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AnnotationFilter::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.AnnotationFilter.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AnnotationFilter::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AnnotationFilter::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.AnnotationFilter.created_at)
  return _msg;
}
inline void AnnotationFilter::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.AnnotationFilter.created_at)
}

// .google.protobuf.Timestamp modified_at = 3;
inline bool AnnotationFilter::_internal_has_modified_at() const {
  return this != internal_default_instance() && _impl_.modified_at_ != nullptr;
}
inline bool AnnotationFilter::has_modified_at() const {
  return _internal_has_modified_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& AnnotationFilter::_internal_modified_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.modified_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& AnnotationFilter::modified_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AnnotationFilter.modified_at)
  return _internal_modified_at();
}
inline void AnnotationFilter::unsafe_arena_set_allocated_modified_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  _impl_.modified_at_ = modified_at;
  if (modified_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.AnnotationFilter.modified_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AnnotationFilter::release_modified_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AnnotationFilter::unsafe_arena_release_modified_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.AnnotationFilter.modified_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AnnotationFilter::_internal_mutable_modified_at() {
  
  if (_impl_.modified_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.modified_at_ = p;
  }
  return _impl_.modified_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AnnotationFilter::mutable_modified_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_modified_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.AnnotationFilter.modified_at)
  return _msg;
}
inline void AnnotationFilter::set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  if (modified_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(modified_at));
    if (message_arena != submessage_arena) {
      modified_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modified_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.modified_at_ = modified_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.AnnotationFilter.modified_at)
}

// string user_id = 4;
inline void AnnotationFilter::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& AnnotationFilter::user_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AnnotationFilter.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AnnotationFilter::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.AnnotationFilter.user_id)
}
inline std::string* AnnotationFilter::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.AnnotationFilter.user_id)
  return _s;
}
inline const std::string& AnnotationFilter::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void AnnotationFilter::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AnnotationFilter::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AnnotationFilter::release_user_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.AnnotationFilter.user_id)
  return _impl_.user_id_.Release();
}
inline void AnnotationFilter::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.AnnotationFilter.user_id)
}

// string app_id = 5;
inline void AnnotationFilter::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& AnnotationFilter::app_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AnnotationFilter.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AnnotationFilter::set_app_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.app_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.AnnotationFilter.app_id)
}
inline std::string* AnnotationFilter::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.AnnotationFilter.app_id)
  return _s;
}
inline const std::string& AnnotationFilter::_internal_app_id() const {
  return _impl_.app_id_.Get();
}
inline void AnnotationFilter::_internal_set_app_id(const std::string& value) {
  
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AnnotationFilter::_internal_mutable_app_id() {
  
  return _impl_.app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AnnotationFilter::release_app_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.AnnotationFilter.app_id)
  return _impl_.app_id_.Release();
}
inline void AnnotationFilter::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    
  } else {
    
  }
  _impl_.app_id_.SetAllocated(app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.AnnotationFilter.app_id)
}

// .clarifai.api.Search saved_search = 8;
inline bool AnnotationFilter::_internal_has_saved_search() const {
  return this != internal_default_instance() && _impl_.saved_search_ != nullptr;
}
inline bool AnnotationFilter::has_saved_search() const {
  return _internal_has_saved_search();
}
inline void AnnotationFilter::clear_saved_search() {
  if (GetArenaForAllocation() == nullptr && _impl_.saved_search_ != nullptr) {
    delete _impl_.saved_search_;
  }
  _impl_.saved_search_ = nullptr;
}
inline const ::clarifai::api::Search& AnnotationFilter::_internal_saved_search() const {
  const ::clarifai::api::Search* p = _impl_.saved_search_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Search&>(
      ::clarifai::api::_Search_default_instance_);
}
inline const ::clarifai::api::Search& AnnotationFilter::saved_search() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AnnotationFilter.saved_search)
  return _internal_saved_search();
}
inline void AnnotationFilter::unsafe_arena_set_allocated_saved_search(
    ::clarifai::api::Search* saved_search) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.saved_search_);
  }
  _impl_.saved_search_ = saved_search;
  if (saved_search) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.AnnotationFilter.saved_search)
}
inline ::clarifai::api::Search* AnnotationFilter::release_saved_search() {
  
  ::clarifai::api::Search* temp = _impl_.saved_search_;
  _impl_.saved_search_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Search* AnnotationFilter::unsafe_arena_release_saved_search() {
  // @@protoc_insertion_point(field_release:clarifai.api.AnnotationFilter.saved_search)
  
  ::clarifai::api::Search* temp = _impl_.saved_search_;
  _impl_.saved_search_ = nullptr;
  return temp;
}
inline ::clarifai::api::Search* AnnotationFilter::_internal_mutable_saved_search() {
  
  if (_impl_.saved_search_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Search>(GetArenaForAllocation());
    _impl_.saved_search_ = p;
  }
  return _impl_.saved_search_;
}
inline ::clarifai::api::Search* AnnotationFilter::mutable_saved_search() {
  ::clarifai::api::Search* _msg = _internal_mutable_saved_search();
  // @@protoc_insertion_point(field_mutable:clarifai.api.AnnotationFilter.saved_search)
  return _msg;
}
inline void AnnotationFilter::set_allocated_saved_search(::clarifai::api::Search* saved_search) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.saved_search_;
  }
  if (saved_search) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(saved_search);
    if (message_arena != submessage_arena) {
      saved_search = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, saved_search, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.saved_search_ = saved_search;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.AnnotationFilter.saved_search)
}

// -------------------------------------------------------------------

// DatasetInput

// .google.protobuf.Timestamp created_at = 1;
inline bool DatasetInput::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool DatasetInput::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DatasetInput::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DatasetInput::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetInput.created_at)
  return _internal_created_at();
}
inline void DatasetInput::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetInput.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DatasetInput::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DatasetInput::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetInput.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DatasetInput::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DatasetInput::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetInput.created_at)
  return _msg;
}
inline void DatasetInput::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetInput.created_at)
}

// .clarifai.api.Input input = 2;
inline bool DatasetInput::_internal_has_input() const {
  return this != internal_default_instance() && _impl_.input_ != nullptr;
}
inline bool DatasetInput::has_input() const {
  return _internal_has_input();
}
inline void DatasetInput::clear_input() {
  if (GetArenaForAllocation() == nullptr && _impl_.input_ != nullptr) {
    delete _impl_.input_;
  }
  _impl_.input_ = nullptr;
}
inline const ::clarifai::api::Input& DatasetInput::_internal_input() const {
  const ::clarifai::api::Input* p = _impl_.input_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Input&>(
      ::clarifai::api::_Input_default_instance_);
}
inline const ::clarifai::api::Input& DatasetInput::input() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetInput.input)
  return _internal_input();
}
inline void DatasetInput::unsafe_arena_set_allocated_input(
    ::clarifai::api::Input* input) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.input_);
  }
  _impl_.input_ = input;
  if (input) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetInput.input)
}
inline ::clarifai::api::Input* DatasetInput::release_input() {
  
  ::clarifai::api::Input* temp = _impl_.input_;
  _impl_.input_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Input* DatasetInput::unsafe_arena_release_input() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetInput.input)
  
  ::clarifai::api::Input* temp = _impl_.input_;
  _impl_.input_ = nullptr;
  return temp;
}
inline ::clarifai::api::Input* DatasetInput::_internal_mutable_input() {
  
  if (_impl_.input_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Input>(GetArenaForAllocation());
    _impl_.input_ = p;
  }
  return _impl_.input_;
}
inline ::clarifai::api::Input* DatasetInput::mutable_input() {
  ::clarifai::api::Input* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetInput.input)
  return _msg;
}
inline void DatasetInput::set_allocated_input(::clarifai::api::Input* input) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.input_;
  }
  if (input) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(input);
    if (message_arena != submessage_arena) {
      input = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.input_ = input;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetInput.input)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DatasetVersion

// string id = 1;
inline void DatasetVersion::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& DatasetVersion::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersion.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DatasetVersion::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.DatasetVersion.id)
}
inline std::string* DatasetVersion::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersion.id)
  return _s;
}
inline const std::string& DatasetVersion::_internal_id() const {
  return _impl_.id_.Get();
}
inline void DatasetVersion::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* DatasetVersion::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* DatasetVersion::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersion.id)
  return _impl_.id_.Release();
}
inline void DatasetVersion::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersion.id)
}

// .google.protobuf.Timestamp created_at = 2;
inline bool DatasetVersion::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool DatasetVersion::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DatasetVersion::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DatasetVersion::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersion.created_at)
  return _internal_created_at();
}
inline void DatasetVersion::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersion.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DatasetVersion::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DatasetVersion::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersion.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DatasetVersion::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DatasetVersion::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersion.created_at)
  return _msg;
}
inline void DatasetVersion::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersion.created_at)
}

// .google.protobuf.Timestamp modified_at = 3;
inline bool DatasetVersion::_internal_has_modified_at() const {
  return this != internal_default_instance() && _impl_.modified_at_ != nullptr;
}
inline bool DatasetVersion::has_modified_at() const {
  return _internal_has_modified_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DatasetVersion::_internal_modified_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.modified_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DatasetVersion::modified_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersion.modified_at)
  return _internal_modified_at();
}
inline void DatasetVersion::unsafe_arena_set_allocated_modified_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  _impl_.modified_at_ = modified_at;
  if (modified_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersion.modified_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DatasetVersion::release_modified_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DatasetVersion::unsafe_arena_release_modified_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersion.modified_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DatasetVersion::_internal_mutable_modified_at() {
  
  if (_impl_.modified_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.modified_at_ = p;
  }
  return _impl_.modified_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DatasetVersion::mutable_modified_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_modified_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersion.modified_at)
  return _msg;
}
inline void DatasetVersion::set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  if (modified_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(modified_at));
    if (message_arena != submessage_arena) {
      modified_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modified_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.modified_at_ = modified_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersion.modified_at)
}

// string app_id = 4;
inline void DatasetVersion::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& DatasetVersion::app_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersion.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DatasetVersion::set_app_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.app_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.DatasetVersion.app_id)
}
inline std::string* DatasetVersion::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersion.app_id)
  return _s;
}
inline const std::string& DatasetVersion::_internal_app_id() const {
  return _impl_.app_id_.Get();
}
inline void DatasetVersion::_internal_set_app_id(const std::string& value) {
  
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DatasetVersion::_internal_mutable_app_id() {
  
  return _impl_.app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DatasetVersion::release_app_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersion.app_id)
  return _impl_.app_id_.Release();
}
inline void DatasetVersion::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    
  } else {
    
  }
  _impl_.app_id_.SetAllocated(app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersion.app_id)
}

// string user_id = 5;
inline void DatasetVersion::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& DatasetVersion::user_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersion.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DatasetVersion::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.DatasetVersion.user_id)
}
inline std::string* DatasetVersion::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersion.user_id)
  return _s;
}
inline const std::string& DatasetVersion::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void DatasetVersion::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DatasetVersion::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DatasetVersion::release_user_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersion.user_id)
  return _impl_.user_id_.Release();
}
inline void DatasetVersion::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersion.user_id)
}

// string dataset_id = 6;
inline void DatasetVersion::clear_dataset_id() {
  _impl_.dataset_id_.ClearToEmpty();
}
inline const std::string& DatasetVersion::dataset_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersion.dataset_id)
  return _internal_dataset_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DatasetVersion::set_dataset_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dataset_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.DatasetVersion.dataset_id)
}
inline std::string* DatasetVersion::mutable_dataset_id() {
  std::string* _s = _internal_mutable_dataset_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersion.dataset_id)
  return _s;
}
inline const std::string& DatasetVersion::_internal_dataset_id() const {
  return _impl_.dataset_id_.Get();
}
inline void DatasetVersion::_internal_set_dataset_id(const std::string& value) {
  
  _impl_.dataset_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DatasetVersion::_internal_mutable_dataset_id() {
  
  return _impl_.dataset_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DatasetVersion::release_dataset_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersion.dataset_id)
  return _impl_.dataset_id_.Release();
}
inline void DatasetVersion::set_allocated_dataset_id(std::string* dataset_id) {
  if (dataset_id != nullptr) {
    
  } else {
    
  }
  _impl_.dataset_id_.SetAllocated(dataset_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dataset_id_.IsDefault()) {
    _impl_.dataset_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersion.dataset_id)
}

// .clarifai.api.AnnotationFilterConfig annotation_filter_config = 15;
inline bool DatasetVersion::_internal_has_annotation_filter_config() const {
  return data_config_case() == kAnnotationFilterConfig;
}
inline bool DatasetVersion::has_annotation_filter_config() const {
  return _internal_has_annotation_filter_config();
}
inline void DatasetVersion::set_has_annotation_filter_config() {
  _impl_._oneof_case_[0] = kAnnotationFilterConfig;
}
inline void DatasetVersion::clear_annotation_filter_config() {
  if (_internal_has_annotation_filter_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_config_.annotation_filter_config_;
    }
    clear_has_data_config();
  }
}
inline ::clarifai::api::AnnotationFilterConfig* DatasetVersion::release_annotation_filter_config() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersion.annotation_filter_config)
  if (_internal_has_annotation_filter_config()) {
    clear_has_data_config();
    ::clarifai::api::AnnotationFilterConfig* temp = _impl_.data_config_.annotation_filter_config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_config_.annotation_filter_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clarifai::api::AnnotationFilterConfig& DatasetVersion::_internal_annotation_filter_config() const {
  return _internal_has_annotation_filter_config()
      ? *_impl_.data_config_.annotation_filter_config_
      : reinterpret_cast< ::clarifai::api::AnnotationFilterConfig&>(::clarifai::api::_AnnotationFilterConfig_default_instance_);
}
inline const ::clarifai::api::AnnotationFilterConfig& DatasetVersion::annotation_filter_config() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersion.annotation_filter_config)
  return _internal_annotation_filter_config();
}
inline ::clarifai::api::AnnotationFilterConfig* DatasetVersion::unsafe_arena_release_annotation_filter_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clarifai.api.DatasetVersion.annotation_filter_config)
  if (_internal_has_annotation_filter_config()) {
    clear_has_data_config();
    ::clarifai::api::AnnotationFilterConfig* temp = _impl_.data_config_.annotation_filter_config_;
    _impl_.data_config_.annotation_filter_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DatasetVersion::unsafe_arena_set_allocated_annotation_filter_config(::clarifai::api::AnnotationFilterConfig* annotation_filter_config) {
  clear_data_config();
  if (annotation_filter_config) {
    set_has_annotation_filter_config();
    _impl_.data_config_.annotation_filter_config_ = annotation_filter_config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersion.annotation_filter_config)
}
inline ::clarifai::api::AnnotationFilterConfig* DatasetVersion::_internal_mutable_annotation_filter_config() {
  if (!_internal_has_annotation_filter_config()) {
    clear_data_config();
    set_has_annotation_filter_config();
    _impl_.data_config_.annotation_filter_config_ = CreateMaybeMessage< ::clarifai::api::AnnotationFilterConfig >(GetArenaForAllocation());
  }
  return _impl_.data_config_.annotation_filter_config_;
}
inline ::clarifai::api::AnnotationFilterConfig* DatasetVersion::mutable_annotation_filter_config() {
  ::clarifai::api::AnnotationFilterConfig* _msg = _internal_mutable_annotation_filter_config();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersion.annotation_filter_config)
  return _msg;
}

// .clarifai.api.ModelPredictConfig model_predict_config = 18;
inline bool DatasetVersion::_internal_has_model_predict_config() const {
  return data_config_case() == kModelPredictConfig;
}
inline bool DatasetVersion::has_model_predict_config() const {
  return _internal_has_model_predict_config();
}
inline void DatasetVersion::set_has_model_predict_config() {
  _impl_._oneof_case_[0] = kModelPredictConfig;
}
inline void DatasetVersion::clear_model_predict_config() {
  if (_internal_has_model_predict_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_config_.model_predict_config_;
    }
    clear_has_data_config();
  }
}
inline ::clarifai::api::ModelPredictConfig* DatasetVersion::release_model_predict_config() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersion.model_predict_config)
  if (_internal_has_model_predict_config()) {
    clear_has_data_config();
    ::clarifai::api::ModelPredictConfig* temp = _impl_.data_config_.model_predict_config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_config_.model_predict_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clarifai::api::ModelPredictConfig& DatasetVersion::_internal_model_predict_config() const {
  return _internal_has_model_predict_config()
      ? *_impl_.data_config_.model_predict_config_
      : reinterpret_cast< ::clarifai::api::ModelPredictConfig&>(::clarifai::api::_ModelPredictConfig_default_instance_);
}
inline const ::clarifai::api::ModelPredictConfig& DatasetVersion::model_predict_config() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersion.model_predict_config)
  return _internal_model_predict_config();
}
inline ::clarifai::api::ModelPredictConfig* DatasetVersion::unsafe_arena_release_model_predict_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clarifai.api.DatasetVersion.model_predict_config)
  if (_internal_has_model_predict_config()) {
    clear_has_data_config();
    ::clarifai::api::ModelPredictConfig* temp = _impl_.data_config_.model_predict_config_;
    _impl_.data_config_.model_predict_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DatasetVersion::unsafe_arena_set_allocated_model_predict_config(::clarifai::api::ModelPredictConfig* model_predict_config) {
  clear_data_config();
  if (model_predict_config) {
    set_has_model_predict_config();
    _impl_.data_config_.model_predict_config_ = model_predict_config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersion.model_predict_config)
}
inline ::clarifai::api::ModelPredictConfig* DatasetVersion::_internal_mutable_model_predict_config() {
  if (!_internal_has_model_predict_config()) {
    clear_data_config();
    set_has_model_predict_config();
    _impl_.data_config_.model_predict_config_ = CreateMaybeMessage< ::clarifai::api::ModelPredictConfig >(GetArenaForAllocation());
  }
  return _impl_.data_config_.model_predict_config_;
}
inline ::clarifai::api::ModelPredictConfig* DatasetVersion::mutable_model_predict_config() {
  ::clarifai::api::ModelPredictConfig* _msg = _internal_mutable_model_predict_config();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersion.model_predict_config)
  return _msg;
}

// .clarifai.api.status.Status status = 8;
inline bool DatasetVersion::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool DatasetVersion::has_status() const {
  return _internal_has_status();
}
inline const ::clarifai::api::status::Status& DatasetVersion::_internal_status() const {
  const ::clarifai::api::status::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::status::Status&>(
      ::clarifai::api::status::_Status_default_instance_);
}
inline const ::clarifai::api::status::Status& DatasetVersion::status() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersion.status)
  return _internal_status();
}
inline void DatasetVersion::unsafe_arena_set_allocated_status(
    ::clarifai::api::status::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersion.status)
}
inline ::clarifai::api::status::Status* DatasetVersion::release_status() {
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::status::Status* DatasetVersion::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersion.status)
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::clarifai::api::status::Status* DatasetVersion::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::status::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::clarifai::api::status::Status* DatasetVersion::mutable_status() {
  ::clarifai::api::status::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersion.status)
  return _msg;
}
inline void DatasetVersion::set_allocated_status(::clarifai::api::status::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersion.status)
}

// string description = 10;
inline void DatasetVersion::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& DatasetVersion::description() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersion.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DatasetVersion::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.DatasetVersion.description)
}
inline std::string* DatasetVersion::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersion.description)
  return _s;
}
inline const std::string& DatasetVersion::_internal_description() const {
  return _impl_.description_.Get();
}
inline void DatasetVersion::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* DatasetVersion::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* DatasetVersion::release_description() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersion.description)
  return _impl_.description_.Release();
}
inline void DatasetVersion::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersion.description)
}

// map<string, .clarifai.api.DatasetVersionMetrics> metrics = 16;
inline int DatasetVersion::_internal_metrics_size() const {
  return _impl_.metrics_.size();
}
inline int DatasetVersion::metrics_size() const {
  return _internal_metrics_size();
}
inline void DatasetVersion::clear_metrics() {
  _impl_.metrics_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::clarifai::api::DatasetVersionMetrics >&
DatasetVersion::_internal_metrics() const {
  return _impl_.metrics_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::clarifai::api::DatasetVersionMetrics >&
DatasetVersion::metrics() const {
  // @@protoc_insertion_point(field_map:clarifai.api.DatasetVersion.metrics)
  return _internal_metrics();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::clarifai::api::DatasetVersionMetrics >*
DatasetVersion::_internal_mutable_metrics() {
  return _impl_.metrics_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::clarifai::api::DatasetVersionMetrics >*
DatasetVersion::mutable_metrics() {
  // @@protoc_insertion_point(field_mutable_map:clarifai.api.DatasetVersion.metrics)
  return _internal_mutable_metrics();
}

// .clarifai.api.DatasetVersionExportInfo export_info = 17;
inline bool DatasetVersion::_internal_has_export_info() const {
  return this != internal_default_instance() && _impl_.export_info_ != nullptr;
}
inline bool DatasetVersion::has_export_info() const {
  return _internal_has_export_info();
}
inline void DatasetVersion::clear_export_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.export_info_ != nullptr) {
    delete _impl_.export_info_;
  }
  _impl_.export_info_ = nullptr;
}
inline const ::clarifai::api::DatasetVersionExportInfo& DatasetVersion::_internal_export_info() const {
  const ::clarifai::api::DatasetVersionExportInfo* p = _impl_.export_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::DatasetVersionExportInfo&>(
      ::clarifai::api::_DatasetVersionExportInfo_default_instance_);
}
inline const ::clarifai::api::DatasetVersionExportInfo& DatasetVersion::export_info() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersion.export_info)
  return _internal_export_info();
}
inline void DatasetVersion::unsafe_arena_set_allocated_export_info(
    ::clarifai::api::DatasetVersionExportInfo* export_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.export_info_);
  }
  _impl_.export_info_ = export_info;
  if (export_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersion.export_info)
}
inline ::clarifai::api::DatasetVersionExportInfo* DatasetVersion::release_export_info() {
  
  ::clarifai::api::DatasetVersionExportInfo* temp = _impl_.export_info_;
  _impl_.export_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::DatasetVersionExportInfo* DatasetVersion::unsafe_arena_release_export_info() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersion.export_info)
  
  ::clarifai::api::DatasetVersionExportInfo* temp = _impl_.export_info_;
  _impl_.export_info_ = nullptr;
  return temp;
}
inline ::clarifai::api::DatasetVersionExportInfo* DatasetVersion::_internal_mutable_export_info() {
  
  if (_impl_.export_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::DatasetVersionExportInfo>(GetArenaForAllocation());
    _impl_.export_info_ = p;
  }
  return _impl_.export_info_;
}
inline ::clarifai::api::DatasetVersionExportInfo* DatasetVersion::mutable_export_info() {
  ::clarifai::api::DatasetVersionExportInfo* _msg = _internal_mutable_export_info();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersion.export_info)
  return _msg;
}
inline void DatasetVersion::set_allocated_export_info(::clarifai::api::DatasetVersionExportInfo* export_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.export_info_;
  }
  if (export_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(export_info);
    if (message_arena != submessage_arena) {
      export_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, export_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.export_info_ = export_info;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersion.export_info)
}

// .google.protobuf.Struct metadata = 12;
inline bool DatasetVersion::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool DatasetVersion::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& DatasetVersion::_internal_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& DatasetVersion::metadata() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersion.metadata)
  return _internal_metadata();
}
inline void DatasetVersion::unsafe_arena_set_allocated_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersion.metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* DatasetVersion::release_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* DatasetVersion::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersion.metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* DatasetVersion::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* DatasetVersion::mutable_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersion.metadata)
  return _msg;
}
inline void DatasetVersion::set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersion.metadata)
}

// .clarifai.api.Visibility visibility = 13;
inline bool DatasetVersion::_internal_has_visibility() const {
  return this != internal_default_instance() && _impl_.visibility_ != nullptr;
}
inline bool DatasetVersion::has_visibility() const {
  return _internal_has_visibility();
}
inline void DatasetVersion::clear_visibility() {
  if (GetArenaForAllocation() == nullptr && _impl_.visibility_ != nullptr) {
    delete _impl_.visibility_;
  }
  _impl_.visibility_ = nullptr;
}
inline const ::clarifai::api::Visibility& DatasetVersion::_internal_visibility() const {
  const ::clarifai::api::Visibility* p = _impl_.visibility_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Visibility&>(
      ::clarifai::api::_Visibility_default_instance_);
}
inline const ::clarifai::api::Visibility& DatasetVersion::visibility() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersion.visibility)
  return _internal_visibility();
}
inline void DatasetVersion::unsafe_arena_set_allocated_visibility(
    ::clarifai::api::Visibility* visibility) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visibility_);
  }
  _impl_.visibility_ = visibility;
  if (visibility) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersion.visibility)
}
inline ::clarifai::api::Visibility* DatasetVersion::release_visibility() {
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Visibility* DatasetVersion::unsafe_arena_release_visibility() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersion.visibility)
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
  return temp;
}
inline ::clarifai::api::Visibility* DatasetVersion::_internal_mutable_visibility() {
  
  if (_impl_.visibility_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Visibility>(GetArenaForAllocation());
    _impl_.visibility_ = p;
  }
  return _impl_.visibility_;
}
inline ::clarifai::api::Visibility* DatasetVersion::mutable_visibility() {
  ::clarifai::api::Visibility* _msg = _internal_mutable_visibility();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersion.visibility)
  return _msg;
}
inline void DatasetVersion::set_allocated_visibility(::clarifai::api::Visibility* visibility) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.visibility_;
  }
  if (visibility) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(visibility);
    if (message_arena != submessage_arena) {
      visibility = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visibility, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.visibility_ = visibility;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersion.visibility)
}

// repeated string embed_model_version_ids = 14;
inline int DatasetVersion::_internal_embed_model_version_ids_size() const {
  return _impl_.embed_model_version_ids_.size();
}
inline int DatasetVersion::embed_model_version_ids_size() const {
  return _internal_embed_model_version_ids_size();
}
inline void DatasetVersion::clear_embed_model_version_ids() {
  _impl_.embed_model_version_ids_.Clear();
}
inline std::string* DatasetVersion::add_embed_model_version_ids() {
  std::string* _s = _internal_add_embed_model_version_ids();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.DatasetVersion.embed_model_version_ids)
  return _s;
}
inline const std::string& DatasetVersion::_internal_embed_model_version_ids(int index) const {
  return _impl_.embed_model_version_ids_.Get(index);
}
inline const std::string& DatasetVersion::embed_model_version_ids(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersion.embed_model_version_ids)
  return _internal_embed_model_version_ids(index);
}
inline std::string* DatasetVersion::mutable_embed_model_version_ids(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersion.embed_model_version_ids)
  return _impl_.embed_model_version_ids_.Mutable(index);
}
inline void DatasetVersion::set_embed_model_version_ids(int index, const std::string& value) {
  _impl_.embed_model_version_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.DatasetVersion.embed_model_version_ids)
}
inline void DatasetVersion::set_embed_model_version_ids(int index, std::string&& value) {
  _impl_.embed_model_version_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.DatasetVersion.embed_model_version_ids)
}
inline void DatasetVersion::set_embed_model_version_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.embed_model_version_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.DatasetVersion.embed_model_version_ids)
}
inline void DatasetVersion::set_embed_model_version_ids(int index, const char* value, size_t size) {
  _impl_.embed_model_version_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.DatasetVersion.embed_model_version_ids)
}
inline std::string* DatasetVersion::_internal_add_embed_model_version_ids() {
  return _impl_.embed_model_version_ids_.Add();
}
inline void DatasetVersion::add_embed_model_version_ids(const std::string& value) {
  _impl_.embed_model_version_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.DatasetVersion.embed_model_version_ids)
}
inline void DatasetVersion::add_embed_model_version_ids(std::string&& value) {
  _impl_.embed_model_version_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.DatasetVersion.embed_model_version_ids)
}
inline void DatasetVersion::add_embed_model_version_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.embed_model_version_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.DatasetVersion.embed_model_version_ids)
}
inline void DatasetVersion::add_embed_model_version_ids(const char* value, size_t size) {
  _impl_.embed_model_version_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.DatasetVersion.embed_model_version_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DatasetVersion::embed_model_version_ids() const {
  // @@protoc_insertion_point(field_list:clarifai.api.DatasetVersion.embed_model_version_ids)
  return _impl_.embed_model_version_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DatasetVersion::mutable_embed_model_version_ids() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.DatasetVersion.embed_model_version_ids)
  return &_impl_.embed_model_version_ids_;
}

inline bool DatasetVersion::has_data_config() const {
  return data_config_case() != DATA_CONFIG_NOT_SET;
}
inline void DatasetVersion::clear_has_data_config() {
  _impl_._oneof_case_[0] = DATA_CONFIG_NOT_SET;
}
inline DatasetVersion::DataConfigCase DatasetVersion::data_config_case() const {
  return DatasetVersion::DataConfigCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AnnotationFilterConfig

// .clarifai.api.AnnotationFilter annotation_filter = 1;
inline bool AnnotationFilterConfig::_internal_has_annotation_filter() const {
  return this != internal_default_instance() && _impl_.annotation_filter_ != nullptr;
}
inline bool AnnotationFilterConfig::has_annotation_filter() const {
  return _internal_has_annotation_filter();
}
inline void AnnotationFilterConfig::clear_annotation_filter() {
  if (GetArenaForAllocation() == nullptr && _impl_.annotation_filter_ != nullptr) {
    delete _impl_.annotation_filter_;
  }
  _impl_.annotation_filter_ = nullptr;
}
inline const ::clarifai::api::AnnotationFilter& AnnotationFilterConfig::_internal_annotation_filter() const {
  const ::clarifai::api::AnnotationFilter* p = _impl_.annotation_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::AnnotationFilter&>(
      ::clarifai::api::_AnnotationFilter_default_instance_);
}
inline const ::clarifai::api::AnnotationFilter& AnnotationFilterConfig::annotation_filter() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AnnotationFilterConfig.annotation_filter)
  return _internal_annotation_filter();
}
inline void AnnotationFilterConfig::unsafe_arena_set_allocated_annotation_filter(
    ::clarifai::api::AnnotationFilter* annotation_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.annotation_filter_);
  }
  _impl_.annotation_filter_ = annotation_filter;
  if (annotation_filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.AnnotationFilterConfig.annotation_filter)
}
inline ::clarifai::api::AnnotationFilter* AnnotationFilterConfig::release_annotation_filter() {
  
  ::clarifai::api::AnnotationFilter* temp = _impl_.annotation_filter_;
  _impl_.annotation_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::AnnotationFilter* AnnotationFilterConfig::unsafe_arena_release_annotation_filter() {
  // @@protoc_insertion_point(field_release:clarifai.api.AnnotationFilterConfig.annotation_filter)
  
  ::clarifai::api::AnnotationFilter* temp = _impl_.annotation_filter_;
  _impl_.annotation_filter_ = nullptr;
  return temp;
}
inline ::clarifai::api::AnnotationFilter* AnnotationFilterConfig::_internal_mutable_annotation_filter() {
  
  if (_impl_.annotation_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::AnnotationFilter>(GetArenaForAllocation());
    _impl_.annotation_filter_ = p;
  }
  return _impl_.annotation_filter_;
}
inline ::clarifai::api::AnnotationFilter* AnnotationFilterConfig::mutable_annotation_filter() {
  ::clarifai::api::AnnotationFilter* _msg = _internal_mutable_annotation_filter();
  // @@protoc_insertion_point(field_mutable:clarifai.api.AnnotationFilterConfig.annotation_filter)
  return _msg;
}
inline void AnnotationFilterConfig::set_allocated_annotation_filter(::clarifai::api::AnnotationFilter* annotation_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.annotation_filter_;
  }
  if (annotation_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(annotation_filter);
    if (message_arena != submessage_arena) {
      annotation_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, annotation_filter, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.annotation_filter_ = annotation_filter;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.AnnotationFilterConfig.annotation_filter)
}

// bool ignore_empty_inputs = 2;
inline void AnnotationFilterConfig::clear_ignore_empty_inputs() {
  _impl_.ignore_empty_inputs_ = false;
}
inline bool AnnotationFilterConfig::_internal_ignore_empty_inputs() const {
  return _impl_.ignore_empty_inputs_;
}
inline bool AnnotationFilterConfig::ignore_empty_inputs() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AnnotationFilterConfig.ignore_empty_inputs)
  return _internal_ignore_empty_inputs();
}
inline void AnnotationFilterConfig::_internal_set_ignore_empty_inputs(bool value) {
  
  _impl_.ignore_empty_inputs_ = value;
}
inline void AnnotationFilterConfig::set_ignore_empty_inputs(bool value) {
  _internal_set_ignore_empty_inputs(value);
  // @@protoc_insertion_point(field_set:clarifai.api.AnnotationFilterConfig.ignore_empty_inputs)
}

// -------------------------------------------------------------------

// ModelPredictConfig

// .clarifai.api.Model model = 1;
inline bool ModelPredictConfig::_internal_has_model() const {
  return this != internal_default_instance() && _impl_.model_ != nullptr;
}
inline bool ModelPredictConfig::has_model() const {
  return _internal_has_model();
}
inline void ModelPredictConfig::clear_model() {
  if (GetArenaForAllocation() == nullptr && _impl_.model_ != nullptr) {
    delete _impl_.model_;
  }
  _impl_.model_ = nullptr;
}
inline const ::clarifai::api::Model& ModelPredictConfig::_internal_model() const {
  const ::clarifai::api::Model* p = _impl_.model_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Model&>(
      ::clarifai::api::_Model_default_instance_);
}
inline const ::clarifai::api::Model& ModelPredictConfig::model() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelPredictConfig.model)
  return _internal_model();
}
inline void ModelPredictConfig::unsafe_arena_set_allocated_model(
    ::clarifai::api::Model* model) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.model_);
  }
  _impl_.model_ = model;
  if (model) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.ModelPredictConfig.model)
}
inline ::clarifai::api::Model* ModelPredictConfig::release_model() {
  
  ::clarifai::api::Model* temp = _impl_.model_;
  _impl_.model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Model* ModelPredictConfig::unsafe_arena_release_model() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelPredictConfig.model)
  
  ::clarifai::api::Model* temp = _impl_.model_;
  _impl_.model_ = nullptr;
  return temp;
}
inline ::clarifai::api::Model* ModelPredictConfig::_internal_mutable_model() {
  
  if (_impl_.model_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Model>(GetArenaForAllocation());
    _impl_.model_ = p;
  }
  return _impl_.model_;
}
inline ::clarifai::api::Model* ModelPredictConfig::mutable_model() {
  ::clarifai::api::Model* _msg = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelPredictConfig.model)
  return _msg;
}
inline void ModelPredictConfig::set_allocated_model(::clarifai::api::Model* model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.model_;
  }
  if (model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(model);
    if (message_arena != submessage_arena) {
      model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.model_ = model;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelPredictConfig.model)
}

// -------------------------------------------------------------------

// DatasetVersionMetrics

// .google.protobuf.UInt64Value inputs_count = 1;
inline bool DatasetVersionMetrics::_internal_has_inputs_count() const {
  return this != internal_default_instance() && _impl_.inputs_count_ != nullptr;
}
inline bool DatasetVersionMetrics::has_inputs_count() const {
  return _internal_has_inputs_count();
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::_internal_inputs_count() const {
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value* p = _impl_.inputs_count_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::UInt64Value&>(
      ::PROTOBUF_NAMESPACE_ID::_UInt64Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::inputs_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersionMetrics.inputs_count)
  return _internal_inputs_count();
}
inline void DatasetVersionMetrics::unsafe_arena_set_allocated_inputs_count(
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* inputs_count) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inputs_count_);
  }
  _impl_.inputs_count_ = inputs_count;
  if (inputs_count) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersionMetrics.inputs_count)
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::release_inputs_count() {
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.inputs_count_;
  _impl_.inputs_count_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::unsafe_arena_release_inputs_count() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersionMetrics.inputs_count)
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.inputs_count_;
  _impl_.inputs_count_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::_internal_mutable_inputs_count() {
  
  if (_impl_.inputs_count_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::UInt64Value>(GetArenaForAllocation());
    _impl_.inputs_count_ = p;
  }
  return _impl_.inputs_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::mutable_inputs_count() {
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _msg = _internal_mutable_inputs_count();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersionMetrics.inputs_count)
  return _msg;
}
inline void DatasetVersionMetrics::set_allocated_inputs_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* inputs_count) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inputs_count_);
  }
  if (inputs_count) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inputs_count));
    if (message_arena != submessage_arena) {
      inputs_count = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inputs_count, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.inputs_count_ = inputs_count;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersionMetrics.inputs_count)
}

// .google.protobuf.UInt64Value unlabeled_inputs_count = 6;
inline bool DatasetVersionMetrics::_internal_has_unlabeled_inputs_count() const {
  return this != internal_default_instance() && _impl_.unlabeled_inputs_count_ != nullptr;
}
inline bool DatasetVersionMetrics::has_unlabeled_inputs_count() const {
  return _internal_has_unlabeled_inputs_count();
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::_internal_unlabeled_inputs_count() const {
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value* p = _impl_.unlabeled_inputs_count_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::UInt64Value&>(
      ::PROTOBUF_NAMESPACE_ID::_UInt64Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::unlabeled_inputs_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersionMetrics.unlabeled_inputs_count)
  return _internal_unlabeled_inputs_count();
}
inline void DatasetVersionMetrics::unsafe_arena_set_allocated_unlabeled_inputs_count(
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* unlabeled_inputs_count) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unlabeled_inputs_count_);
  }
  _impl_.unlabeled_inputs_count_ = unlabeled_inputs_count;
  if (unlabeled_inputs_count) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersionMetrics.unlabeled_inputs_count)
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::release_unlabeled_inputs_count() {
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.unlabeled_inputs_count_;
  _impl_.unlabeled_inputs_count_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::unsafe_arena_release_unlabeled_inputs_count() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersionMetrics.unlabeled_inputs_count)
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.unlabeled_inputs_count_;
  _impl_.unlabeled_inputs_count_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::_internal_mutable_unlabeled_inputs_count() {
  
  if (_impl_.unlabeled_inputs_count_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::UInt64Value>(GetArenaForAllocation());
    _impl_.unlabeled_inputs_count_ = p;
  }
  return _impl_.unlabeled_inputs_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::mutable_unlabeled_inputs_count() {
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _msg = _internal_mutable_unlabeled_inputs_count();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersionMetrics.unlabeled_inputs_count)
  return _msg;
}
inline void DatasetVersionMetrics::set_allocated_unlabeled_inputs_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* unlabeled_inputs_count) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unlabeled_inputs_count_);
  }
  if (unlabeled_inputs_count) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(unlabeled_inputs_count));
    if (message_arena != submessage_arena) {
      unlabeled_inputs_count = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unlabeled_inputs_count, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.unlabeled_inputs_count_ = unlabeled_inputs_count;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersionMetrics.unlabeled_inputs_count)
}

// .google.protobuf.UInt64Value inputs_with_metadata_count = 8;
inline bool DatasetVersionMetrics::_internal_has_inputs_with_metadata_count() const {
  return this != internal_default_instance() && _impl_.inputs_with_metadata_count_ != nullptr;
}
inline bool DatasetVersionMetrics::has_inputs_with_metadata_count() const {
  return _internal_has_inputs_with_metadata_count();
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::_internal_inputs_with_metadata_count() const {
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value* p = _impl_.inputs_with_metadata_count_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::UInt64Value&>(
      ::PROTOBUF_NAMESPACE_ID::_UInt64Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::inputs_with_metadata_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersionMetrics.inputs_with_metadata_count)
  return _internal_inputs_with_metadata_count();
}
inline void DatasetVersionMetrics::unsafe_arena_set_allocated_inputs_with_metadata_count(
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* inputs_with_metadata_count) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inputs_with_metadata_count_);
  }
  _impl_.inputs_with_metadata_count_ = inputs_with_metadata_count;
  if (inputs_with_metadata_count) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersionMetrics.inputs_with_metadata_count)
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::release_inputs_with_metadata_count() {
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.inputs_with_metadata_count_;
  _impl_.inputs_with_metadata_count_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::unsafe_arena_release_inputs_with_metadata_count() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersionMetrics.inputs_with_metadata_count)
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.inputs_with_metadata_count_;
  _impl_.inputs_with_metadata_count_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::_internal_mutable_inputs_with_metadata_count() {
  
  if (_impl_.inputs_with_metadata_count_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::UInt64Value>(GetArenaForAllocation());
    _impl_.inputs_with_metadata_count_ = p;
  }
  return _impl_.inputs_with_metadata_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::mutable_inputs_with_metadata_count() {
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _msg = _internal_mutable_inputs_with_metadata_count();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersionMetrics.inputs_with_metadata_count)
  return _msg;
}
inline void DatasetVersionMetrics::set_allocated_inputs_with_metadata_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* inputs_with_metadata_count) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inputs_with_metadata_count_);
  }
  if (inputs_with_metadata_count) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inputs_with_metadata_count));
    if (message_arena != submessage_arena) {
      inputs_with_metadata_count = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inputs_with_metadata_count, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.inputs_with_metadata_count_ = inputs_with_metadata_count;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersionMetrics.inputs_with_metadata_count)
}

// .google.protobuf.UInt64Value inputs_with_geo_count = 9;
inline bool DatasetVersionMetrics::_internal_has_inputs_with_geo_count() const {
  return this != internal_default_instance() && _impl_.inputs_with_geo_count_ != nullptr;
}
inline bool DatasetVersionMetrics::has_inputs_with_geo_count() const {
  return _internal_has_inputs_with_geo_count();
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::_internal_inputs_with_geo_count() const {
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value* p = _impl_.inputs_with_geo_count_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::UInt64Value&>(
      ::PROTOBUF_NAMESPACE_ID::_UInt64Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::inputs_with_geo_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersionMetrics.inputs_with_geo_count)
  return _internal_inputs_with_geo_count();
}
inline void DatasetVersionMetrics::unsafe_arena_set_allocated_inputs_with_geo_count(
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* inputs_with_geo_count) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inputs_with_geo_count_);
  }
  _impl_.inputs_with_geo_count_ = inputs_with_geo_count;
  if (inputs_with_geo_count) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersionMetrics.inputs_with_geo_count)
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::release_inputs_with_geo_count() {
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.inputs_with_geo_count_;
  _impl_.inputs_with_geo_count_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::unsafe_arena_release_inputs_with_geo_count() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersionMetrics.inputs_with_geo_count)
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.inputs_with_geo_count_;
  _impl_.inputs_with_geo_count_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::_internal_mutable_inputs_with_geo_count() {
  
  if (_impl_.inputs_with_geo_count_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::UInt64Value>(GetArenaForAllocation());
    _impl_.inputs_with_geo_count_ = p;
  }
  return _impl_.inputs_with_geo_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::mutable_inputs_with_geo_count() {
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _msg = _internal_mutable_inputs_with_geo_count();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersionMetrics.inputs_with_geo_count)
  return _msg;
}
inline void DatasetVersionMetrics::set_allocated_inputs_with_geo_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* inputs_with_geo_count) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inputs_with_geo_count_);
  }
  if (inputs_with_geo_count) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inputs_with_geo_count));
    if (message_arena != submessage_arena) {
      inputs_with_geo_count = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inputs_with_geo_count, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.inputs_with_geo_count_ = inputs_with_geo_count;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersionMetrics.inputs_with_geo_count)
}

// .google.protobuf.UInt64Value regions_count = 20;
inline bool DatasetVersionMetrics::_internal_has_regions_count() const {
  return this != internal_default_instance() && _impl_.regions_count_ != nullptr;
}
inline bool DatasetVersionMetrics::has_regions_count() const {
  return _internal_has_regions_count();
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::_internal_regions_count() const {
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value* p = _impl_.regions_count_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::UInt64Value&>(
      ::PROTOBUF_NAMESPACE_ID::_UInt64Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::regions_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersionMetrics.regions_count)
  return _internal_regions_count();
}
inline void DatasetVersionMetrics::unsafe_arena_set_allocated_regions_count(
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* regions_count) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.regions_count_);
  }
  _impl_.regions_count_ = regions_count;
  if (regions_count) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersionMetrics.regions_count)
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::release_regions_count() {
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.regions_count_;
  _impl_.regions_count_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::unsafe_arena_release_regions_count() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersionMetrics.regions_count)
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.regions_count_;
  _impl_.regions_count_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::_internal_mutable_regions_count() {
  
  if (_impl_.regions_count_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::UInt64Value>(GetArenaForAllocation());
    _impl_.regions_count_ = p;
  }
  return _impl_.regions_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::mutable_regions_count() {
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _msg = _internal_mutable_regions_count();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersionMetrics.regions_count)
  return _msg;
}
inline void DatasetVersionMetrics::set_allocated_regions_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* regions_count) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.regions_count_);
  }
  if (regions_count) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(regions_count));
    if (message_arena != submessage_arena) {
      regions_count = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, regions_count, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.regions_count_ = regions_count;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersionMetrics.regions_count)
}

// .MatrixUint64 region_location_matrix = 21;
inline bool DatasetVersionMetrics::_internal_has_region_location_matrix() const {
  return this != internal_default_instance() && _impl_.region_location_matrix_ != nullptr;
}
inline bool DatasetVersionMetrics::has_region_location_matrix() const {
  return _internal_has_region_location_matrix();
}
inline const ::MatrixUint64& DatasetVersionMetrics::_internal_region_location_matrix() const {
  const ::MatrixUint64* p = _impl_.region_location_matrix_;
  return p != nullptr ? *p : reinterpret_cast<const ::MatrixUint64&>(
      ::_MatrixUint64_default_instance_);
}
inline const ::MatrixUint64& DatasetVersionMetrics::region_location_matrix() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersionMetrics.region_location_matrix)
  return _internal_region_location_matrix();
}
inline void DatasetVersionMetrics::unsafe_arena_set_allocated_region_location_matrix(
    ::MatrixUint64* region_location_matrix) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.region_location_matrix_);
  }
  _impl_.region_location_matrix_ = region_location_matrix;
  if (region_location_matrix) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersionMetrics.region_location_matrix)
}
inline ::MatrixUint64* DatasetVersionMetrics::release_region_location_matrix() {
  
  ::MatrixUint64* temp = _impl_.region_location_matrix_;
  _impl_.region_location_matrix_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MatrixUint64* DatasetVersionMetrics::unsafe_arena_release_region_location_matrix() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersionMetrics.region_location_matrix)
  
  ::MatrixUint64* temp = _impl_.region_location_matrix_;
  _impl_.region_location_matrix_ = nullptr;
  return temp;
}
inline ::MatrixUint64* DatasetVersionMetrics::_internal_mutable_region_location_matrix() {
  
  if (_impl_.region_location_matrix_ == nullptr) {
    auto* p = CreateMaybeMessage<::MatrixUint64>(GetArenaForAllocation());
    _impl_.region_location_matrix_ = p;
  }
  return _impl_.region_location_matrix_;
}
inline ::MatrixUint64* DatasetVersionMetrics::mutable_region_location_matrix() {
  ::MatrixUint64* _msg = _internal_mutable_region_location_matrix();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersionMetrics.region_location_matrix)
  return _msg;
}
inline void DatasetVersionMetrics::set_allocated_region_location_matrix(::MatrixUint64* region_location_matrix) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.region_location_matrix_);
  }
  if (region_location_matrix) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_location_matrix));
    if (message_arena != submessage_arena) {
      region_location_matrix = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region_location_matrix, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.region_location_matrix_ = region_location_matrix;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersionMetrics.region_location_matrix)
}

// .google.protobuf.UInt64Value bounding_boxes_count = 22;
inline bool DatasetVersionMetrics::_internal_has_bounding_boxes_count() const {
  return this != internal_default_instance() && _impl_.bounding_boxes_count_ != nullptr;
}
inline bool DatasetVersionMetrics::has_bounding_boxes_count() const {
  return _internal_has_bounding_boxes_count();
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::_internal_bounding_boxes_count() const {
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value* p = _impl_.bounding_boxes_count_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::UInt64Value&>(
      ::PROTOBUF_NAMESPACE_ID::_UInt64Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::bounding_boxes_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersionMetrics.bounding_boxes_count)
  return _internal_bounding_boxes_count();
}
inline void DatasetVersionMetrics::unsafe_arena_set_allocated_bounding_boxes_count(
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* bounding_boxes_count) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bounding_boxes_count_);
  }
  _impl_.bounding_boxes_count_ = bounding_boxes_count;
  if (bounding_boxes_count) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersionMetrics.bounding_boxes_count)
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::release_bounding_boxes_count() {
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.bounding_boxes_count_;
  _impl_.bounding_boxes_count_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::unsafe_arena_release_bounding_boxes_count() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersionMetrics.bounding_boxes_count)
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.bounding_boxes_count_;
  _impl_.bounding_boxes_count_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::_internal_mutable_bounding_boxes_count() {
  
  if (_impl_.bounding_boxes_count_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::UInt64Value>(GetArenaForAllocation());
    _impl_.bounding_boxes_count_ = p;
  }
  return _impl_.bounding_boxes_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::mutable_bounding_boxes_count() {
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _msg = _internal_mutable_bounding_boxes_count();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersionMetrics.bounding_boxes_count)
  return _msg;
}
inline void DatasetVersionMetrics::set_allocated_bounding_boxes_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* bounding_boxes_count) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bounding_boxes_count_);
  }
  if (bounding_boxes_count) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bounding_boxes_count));
    if (message_arena != submessage_arena) {
      bounding_boxes_count = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bounding_boxes_count, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.bounding_boxes_count_ = bounding_boxes_count;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersionMetrics.bounding_boxes_count)
}

// .google.protobuf.UInt64Value polygons_count = 23;
inline bool DatasetVersionMetrics::_internal_has_polygons_count() const {
  return this != internal_default_instance() && _impl_.polygons_count_ != nullptr;
}
inline bool DatasetVersionMetrics::has_polygons_count() const {
  return _internal_has_polygons_count();
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::_internal_polygons_count() const {
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value* p = _impl_.polygons_count_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::UInt64Value&>(
      ::PROTOBUF_NAMESPACE_ID::_UInt64Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::polygons_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersionMetrics.polygons_count)
  return _internal_polygons_count();
}
inline void DatasetVersionMetrics::unsafe_arena_set_allocated_polygons_count(
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* polygons_count) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.polygons_count_);
  }
  _impl_.polygons_count_ = polygons_count;
  if (polygons_count) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersionMetrics.polygons_count)
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::release_polygons_count() {
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.polygons_count_;
  _impl_.polygons_count_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::unsafe_arena_release_polygons_count() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersionMetrics.polygons_count)
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.polygons_count_;
  _impl_.polygons_count_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::_internal_mutable_polygons_count() {
  
  if (_impl_.polygons_count_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::UInt64Value>(GetArenaForAllocation());
    _impl_.polygons_count_ = p;
  }
  return _impl_.polygons_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::mutable_polygons_count() {
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _msg = _internal_mutable_polygons_count();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersionMetrics.polygons_count)
  return _msg;
}
inline void DatasetVersionMetrics::set_allocated_polygons_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* polygons_count) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.polygons_count_);
  }
  if (polygons_count) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(polygons_count));
    if (message_arena != submessage_arena) {
      polygons_count = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, polygons_count, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.polygons_count_ = polygons_count;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersionMetrics.polygons_count)
}

// .google.protobuf.UInt64Value points_count = 24;
inline bool DatasetVersionMetrics::_internal_has_points_count() const {
  return this != internal_default_instance() && _impl_.points_count_ != nullptr;
}
inline bool DatasetVersionMetrics::has_points_count() const {
  return _internal_has_points_count();
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::_internal_points_count() const {
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value* p = _impl_.points_count_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::UInt64Value&>(
      ::PROTOBUF_NAMESPACE_ID::_UInt64Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::points_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersionMetrics.points_count)
  return _internal_points_count();
}
inline void DatasetVersionMetrics::unsafe_arena_set_allocated_points_count(
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* points_count) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.points_count_);
  }
  _impl_.points_count_ = points_count;
  if (points_count) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersionMetrics.points_count)
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::release_points_count() {
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.points_count_;
  _impl_.points_count_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::unsafe_arena_release_points_count() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersionMetrics.points_count)
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.points_count_;
  _impl_.points_count_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::_internal_mutable_points_count() {
  
  if (_impl_.points_count_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::UInt64Value>(GetArenaForAllocation());
    _impl_.points_count_ = p;
  }
  return _impl_.points_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::mutable_points_count() {
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _msg = _internal_mutable_points_count();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersionMetrics.points_count)
  return _msg;
}
inline void DatasetVersionMetrics::set_allocated_points_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* points_count) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.points_count_);
  }
  if (points_count) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(points_count));
    if (message_arena != submessage_arena) {
      points_count = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, points_count, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.points_count_ = points_count;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersionMetrics.points_count)
}

// .google.protobuf.UInt64Value masks_count = 25;
inline bool DatasetVersionMetrics::_internal_has_masks_count() const {
  return this != internal_default_instance() && _impl_.masks_count_ != nullptr;
}
inline bool DatasetVersionMetrics::has_masks_count() const {
  return _internal_has_masks_count();
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::_internal_masks_count() const {
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value* p = _impl_.masks_count_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::UInt64Value&>(
      ::PROTOBUF_NAMESPACE_ID::_UInt64Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::masks_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersionMetrics.masks_count)
  return _internal_masks_count();
}
inline void DatasetVersionMetrics::unsafe_arena_set_allocated_masks_count(
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* masks_count) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.masks_count_);
  }
  _impl_.masks_count_ = masks_count;
  if (masks_count) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersionMetrics.masks_count)
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::release_masks_count() {
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.masks_count_;
  _impl_.masks_count_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::unsafe_arena_release_masks_count() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersionMetrics.masks_count)
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.masks_count_;
  _impl_.masks_count_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::_internal_mutable_masks_count() {
  
  if (_impl_.masks_count_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::UInt64Value>(GetArenaForAllocation());
    _impl_.masks_count_ = p;
  }
  return _impl_.masks_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::mutable_masks_count() {
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _msg = _internal_mutable_masks_count();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersionMetrics.masks_count)
  return _msg;
}
inline void DatasetVersionMetrics::set_allocated_masks_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* masks_count) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.masks_count_);
  }
  if (masks_count) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(masks_count));
    if (message_arena != submessage_arena) {
      masks_count = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, masks_count, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.masks_count_ = masks_count;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersionMetrics.masks_count)
}

// .google.protobuf.UInt64Value region_inputs_count = 60;
inline bool DatasetVersionMetrics::_internal_has_region_inputs_count() const {
  return this != internal_default_instance() && _impl_.region_inputs_count_ != nullptr;
}
inline bool DatasetVersionMetrics::has_region_inputs_count() const {
  return _internal_has_region_inputs_count();
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::_internal_region_inputs_count() const {
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value* p = _impl_.region_inputs_count_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::UInt64Value&>(
      ::PROTOBUF_NAMESPACE_ID::_UInt64Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::region_inputs_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersionMetrics.region_inputs_count)
  return _internal_region_inputs_count();
}
inline void DatasetVersionMetrics::unsafe_arena_set_allocated_region_inputs_count(
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* region_inputs_count) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.region_inputs_count_);
  }
  _impl_.region_inputs_count_ = region_inputs_count;
  if (region_inputs_count) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersionMetrics.region_inputs_count)
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::release_region_inputs_count() {
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.region_inputs_count_;
  _impl_.region_inputs_count_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::unsafe_arena_release_region_inputs_count() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersionMetrics.region_inputs_count)
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.region_inputs_count_;
  _impl_.region_inputs_count_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::_internal_mutable_region_inputs_count() {
  
  if (_impl_.region_inputs_count_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::UInt64Value>(GetArenaForAllocation());
    _impl_.region_inputs_count_ = p;
  }
  return _impl_.region_inputs_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::mutable_region_inputs_count() {
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _msg = _internal_mutable_region_inputs_count();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersionMetrics.region_inputs_count)
  return _msg;
}
inline void DatasetVersionMetrics::set_allocated_region_inputs_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* region_inputs_count) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.region_inputs_count_);
  }
  if (region_inputs_count) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_inputs_count));
    if (message_arena != submessage_arena) {
      region_inputs_count = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region_inputs_count, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.region_inputs_count_ = region_inputs_count;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersionMetrics.region_inputs_count)
}

// .google.protobuf.UInt64Value region_frames_count = 61;
inline bool DatasetVersionMetrics::_internal_has_region_frames_count() const {
  return this != internal_default_instance() && _impl_.region_frames_count_ != nullptr;
}
inline bool DatasetVersionMetrics::has_region_frames_count() const {
  return _internal_has_region_frames_count();
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::_internal_region_frames_count() const {
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value* p = _impl_.region_frames_count_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::UInt64Value&>(
      ::PROTOBUF_NAMESPACE_ID::_UInt64Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::region_frames_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersionMetrics.region_frames_count)
  return _internal_region_frames_count();
}
inline void DatasetVersionMetrics::unsafe_arena_set_allocated_region_frames_count(
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* region_frames_count) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.region_frames_count_);
  }
  _impl_.region_frames_count_ = region_frames_count;
  if (region_frames_count) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersionMetrics.region_frames_count)
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::release_region_frames_count() {
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.region_frames_count_;
  _impl_.region_frames_count_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::unsafe_arena_release_region_frames_count() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersionMetrics.region_frames_count)
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.region_frames_count_;
  _impl_.region_frames_count_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::_internal_mutable_region_frames_count() {
  
  if (_impl_.region_frames_count_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::UInt64Value>(GetArenaForAllocation());
    _impl_.region_frames_count_ = p;
  }
  return _impl_.region_frames_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::mutable_region_frames_count() {
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _msg = _internal_mutable_region_frames_count();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersionMetrics.region_frames_count)
  return _msg;
}
inline void DatasetVersionMetrics::set_allocated_region_frames_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* region_frames_count) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.region_frames_count_);
  }
  if (region_frames_count) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_frames_count));
    if (message_arena != submessage_arena) {
      region_frames_count = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region_frames_count, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.region_frames_count_ = region_frames_count;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersionMetrics.region_frames_count)
}

// .google.protobuf.UInt64Value frames_count = 30;
inline bool DatasetVersionMetrics::_internal_has_frames_count() const {
  return this != internal_default_instance() && _impl_.frames_count_ != nullptr;
}
inline bool DatasetVersionMetrics::has_frames_count() const {
  return _internal_has_frames_count();
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::_internal_frames_count() const {
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value* p = _impl_.frames_count_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::UInt64Value&>(
      ::PROTOBUF_NAMESPACE_ID::_UInt64Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::frames_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersionMetrics.frames_count)
  return _internal_frames_count();
}
inline void DatasetVersionMetrics::unsafe_arena_set_allocated_frames_count(
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* frames_count) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frames_count_);
  }
  _impl_.frames_count_ = frames_count;
  if (frames_count) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersionMetrics.frames_count)
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::release_frames_count() {
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.frames_count_;
  _impl_.frames_count_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::unsafe_arena_release_frames_count() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersionMetrics.frames_count)
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.frames_count_;
  _impl_.frames_count_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::_internal_mutable_frames_count() {
  
  if (_impl_.frames_count_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::UInt64Value>(GetArenaForAllocation());
    _impl_.frames_count_ = p;
  }
  return _impl_.frames_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::mutable_frames_count() {
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _msg = _internal_mutable_frames_count();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersionMetrics.frames_count)
  return _msg;
}
inline void DatasetVersionMetrics::set_allocated_frames_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* frames_count) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frames_count_);
  }
  if (frames_count) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frames_count));
    if (message_arena != submessage_arena) {
      frames_count = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frames_count, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.frames_count_ = frames_count;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersionMetrics.frames_count)
}

// .google.protobuf.UInt64Value frame_inputs_count = 70;
inline bool DatasetVersionMetrics::_internal_has_frame_inputs_count() const {
  return this != internal_default_instance() && _impl_.frame_inputs_count_ != nullptr;
}
inline bool DatasetVersionMetrics::has_frame_inputs_count() const {
  return _internal_has_frame_inputs_count();
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::_internal_frame_inputs_count() const {
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value* p = _impl_.frame_inputs_count_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::UInt64Value&>(
      ::PROTOBUF_NAMESPACE_ID::_UInt64Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::frame_inputs_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersionMetrics.frame_inputs_count)
  return _internal_frame_inputs_count();
}
inline void DatasetVersionMetrics::unsafe_arena_set_allocated_frame_inputs_count(
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* frame_inputs_count) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frame_inputs_count_);
  }
  _impl_.frame_inputs_count_ = frame_inputs_count;
  if (frame_inputs_count) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersionMetrics.frame_inputs_count)
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::release_frame_inputs_count() {
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.frame_inputs_count_;
  _impl_.frame_inputs_count_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::unsafe_arena_release_frame_inputs_count() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersionMetrics.frame_inputs_count)
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.frame_inputs_count_;
  _impl_.frame_inputs_count_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::_internal_mutable_frame_inputs_count() {
  
  if (_impl_.frame_inputs_count_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::UInt64Value>(GetArenaForAllocation());
    _impl_.frame_inputs_count_ = p;
  }
  return _impl_.frame_inputs_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::mutable_frame_inputs_count() {
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _msg = _internal_mutable_frame_inputs_count();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersionMetrics.frame_inputs_count)
  return _msg;
}
inline void DatasetVersionMetrics::set_allocated_frame_inputs_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* frame_inputs_count) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frame_inputs_count_);
  }
  if (frame_inputs_count) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frame_inputs_count));
    if (message_arena != submessage_arena) {
      frame_inputs_count = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame_inputs_count, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.frame_inputs_count_ = frame_inputs_count;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersionMetrics.frame_inputs_count)
}

// .google.protobuf.UInt64Value embeddings_count = 40;
inline bool DatasetVersionMetrics::_internal_has_embeddings_count() const {
  return this != internal_default_instance() && _impl_.embeddings_count_ != nullptr;
}
inline bool DatasetVersionMetrics::has_embeddings_count() const {
  return _internal_has_embeddings_count();
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::_internal_embeddings_count() const {
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value* p = _impl_.embeddings_count_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::UInt64Value&>(
      ::PROTOBUF_NAMESPACE_ID::_UInt64Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::embeddings_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersionMetrics.embeddings_count)
  return _internal_embeddings_count();
}
inline void DatasetVersionMetrics::unsafe_arena_set_allocated_embeddings_count(
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* embeddings_count) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.embeddings_count_);
  }
  _impl_.embeddings_count_ = embeddings_count;
  if (embeddings_count) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersionMetrics.embeddings_count)
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::release_embeddings_count() {
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.embeddings_count_;
  _impl_.embeddings_count_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::unsafe_arena_release_embeddings_count() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersionMetrics.embeddings_count)
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.embeddings_count_;
  _impl_.embeddings_count_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::_internal_mutable_embeddings_count() {
  
  if (_impl_.embeddings_count_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::UInt64Value>(GetArenaForAllocation());
    _impl_.embeddings_count_ = p;
  }
  return _impl_.embeddings_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::mutable_embeddings_count() {
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _msg = _internal_mutable_embeddings_count();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersionMetrics.embeddings_count)
  return _msg;
}
inline void DatasetVersionMetrics::set_allocated_embeddings_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* embeddings_count) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.embeddings_count_);
  }
  if (embeddings_count) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(embeddings_count));
    if (message_arena != submessage_arena) {
      embeddings_count = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, embeddings_count, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.embeddings_count_ = embeddings_count;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersionMetrics.embeddings_count)
}

// .google.protobuf.UInt64Value positive_input_tags_count = 50;
inline bool DatasetVersionMetrics::_internal_has_positive_input_tags_count() const {
  return this != internal_default_instance() && _impl_.positive_input_tags_count_ != nullptr;
}
inline bool DatasetVersionMetrics::has_positive_input_tags_count() const {
  return _internal_has_positive_input_tags_count();
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::_internal_positive_input_tags_count() const {
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value* p = _impl_.positive_input_tags_count_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::UInt64Value&>(
      ::PROTOBUF_NAMESPACE_ID::_UInt64Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::positive_input_tags_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersionMetrics.positive_input_tags_count)
  return _internal_positive_input_tags_count();
}
inline void DatasetVersionMetrics::unsafe_arena_set_allocated_positive_input_tags_count(
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* positive_input_tags_count) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.positive_input_tags_count_);
  }
  _impl_.positive_input_tags_count_ = positive_input_tags_count;
  if (positive_input_tags_count) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersionMetrics.positive_input_tags_count)
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::release_positive_input_tags_count() {
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.positive_input_tags_count_;
  _impl_.positive_input_tags_count_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::unsafe_arena_release_positive_input_tags_count() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersionMetrics.positive_input_tags_count)
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.positive_input_tags_count_;
  _impl_.positive_input_tags_count_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::_internal_mutable_positive_input_tags_count() {
  
  if (_impl_.positive_input_tags_count_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::UInt64Value>(GetArenaForAllocation());
    _impl_.positive_input_tags_count_ = p;
  }
  return _impl_.positive_input_tags_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::mutable_positive_input_tags_count() {
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _msg = _internal_mutable_positive_input_tags_count();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersionMetrics.positive_input_tags_count)
  return _msg;
}
inline void DatasetVersionMetrics::set_allocated_positive_input_tags_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* positive_input_tags_count) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.positive_input_tags_count_);
  }
  if (positive_input_tags_count) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(positive_input_tags_count));
    if (message_arena != submessage_arena) {
      positive_input_tags_count = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, positive_input_tags_count, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.positive_input_tags_count_ = positive_input_tags_count;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersionMetrics.positive_input_tags_count)
}

// .google.protobuf.UInt64Value positive_region_tags_count = 51;
inline bool DatasetVersionMetrics::_internal_has_positive_region_tags_count() const {
  return this != internal_default_instance() && _impl_.positive_region_tags_count_ != nullptr;
}
inline bool DatasetVersionMetrics::has_positive_region_tags_count() const {
  return _internal_has_positive_region_tags_count();
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::_internal_positive_region_tags_count() const {
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value* p = _impl_.positive_region_tags_count_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::UInt64Value&>(
      ::PROTOBUF_NAMESPACE_ID::_UInt64Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::positive_region_tags_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersionMetrics.positive_region_tags_count)
  return _internal_positive_region_tags_count();
}
inline void DatasetVersionMetrics::unsafe_arena_set_allocated_positive_region_tags_count(
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* positive_region_tags_count) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.positive_region_tags_count_);
  }
  _impl_.positive_region_tags_count_ = positive_region_tags_count;
  if (positive_region_tags_count) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersionMetrics.positive_region_tags_count)
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::release_positive_region_tags_count() {
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.positive_region_tags_count_;
  _impl_.positive_region_tags_count_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::unsafe_arena_release_positive_region_tags_count() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersionMetrics.positive_region_tags_count)
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.positive_region_tags_count_;
  _impl_.positive_region_tags_count_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::_internal_mutable_positive_region_tags_count() {
  
  if (_impl_.positive_region_tags_count_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::UInt64Value>(GetArenaForAllocation());
    _impl_.positive_region_tags_count_ = p;
  }
  return _impl_.positive_region_tags_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::mutable_positive_region_tags_count() {
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _msg = _internal_mutable_positive_region_tags_count();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersionMetrics.positive_region_tags_count)
  return _msg;
}
inline void DatasetVersionMetrics::set_allocated_positive_region_tags_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* positive_region_tags_count) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.positive_region_tags_count_);
  }
  if (positive_region_tags_count) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(positive_region_tags_count));
    if (message_arena != submessage_arena) {
      positive_region_tags_count = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, positive_region_tags_count, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.positive_region_tags_count_ = positive_region_tags_count;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersionMetrics.positive_region_tags_count)
}

// .google.protobuf.UInt64Value positive_frame_tags_count = 52;
inline bool DatasetVersionMetrics::_internal_has_positive_frame_tags_count() const {
  return this != internal_default_instance() && _impl_.positive_frame_tags_count_ != nullptr;
}
inline bool DatasetVersionMetrics::has_positive_frame_tags_count() const {
  return _internal_has_positive_frame_tags_count();
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::_internal_positive_frame_tags_count() const {
  const ::PROTOBUF_NAMESPACE_ID::UInt64Value* p = _impl_.positive_frame_tags_count_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::UInt64Value&>(
      ::PROTOBUF_NAMESPACE_ID::_UInt64Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt64Value& DatasetVersionMetrics::positive_frame_tags_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersionMetrics.positive_frame_tags_count)
  return _internal_positive_frame_tags_count();
}
inline void DatasetVersionMetrics::unsafe_arena_set_allocated_positive_frame_tags_count(
    ::PROTOBUF_NAMESPACE_ID::UInt64Value* positive_frame_tags_count) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.positive_frame_tags_count_);
  }
  _impl_.positive_frame_tags_count_ = positive_frame_tags_count;
  if (positive_frame_tags_count) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersionMetrics.positive_frame_tags_count)
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::release_positive_frame_tags_count() {
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.positive_frame_tags_count_;
  _impl_.positive_frame_tags_count_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::unsafe_arena_release_positive_frame_tags_count() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersionMetrics.positive_frame_tags_count)
  
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* temp = _impl_.positive_frame_tags_count_;
  _impl_.positive_frame_tags_count_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::_internal_mutable_positive_frame_tags_count() {
  
  if (_impl_.positive_frame_tags_count_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::UInt64Value>(GetArenaForAllocation());
    _impl_.positive_frame_tags_count_ = p;
  }
  return _impl_.positive_frame_tags_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt64Value* DatasetVersionMetrics::mutable_positive_frame_tags_count() {
  ::PROTOBUF_NAMESPACE_ID::UInt64Value* _msg = _internal_mutable_positive_frame_tags_count();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersionMetrics.positive_frame_tags_count)
  return _msg;
}
inline void DatasetVersionMetrics::set_allocated_positive_frame_tags_count(::PROTOBUF_NAMESPACE_ID::UInt64Value* positive_frame_tags_count) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.positive_frame_tags_count_);
  }
  if (positive_frame_tags_count) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(positive_frame_tags_count));
    if (message_arena != submessage_arena) {
      positive_frame_tags_count = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, positive_frame_tags_count, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.positive_frame_tags_count_ = positive_frame_tags_count;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersionMetrics.positive_frame_tags_count)
}

// -------------------------------------------------------------------

// DatasetVersionMetricsGroup

// string parent_path = 1;
inline void DatasetVersionMetricsGroup::clear_parent_path() {
  _impl_.parent_path_.ClearToEmpty();
}
inline const std::string& DatasetVersionMetricsGroup::parent_path() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersionMetricsGroup.parent_path)
  return _internal_parent_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DatasetVersionMetricsGroup::set_parent_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.DatasetVersionMetricsGroup.parent_path)
}
inline std::string* DatasetVersionMetricsGroup::mutable_parent_path() {
  std::string* _s = _internal_mutable_parent_path();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersionMetricsGroup.parent_path)
  return _s;
}
inline const std::string& DatasetVersionMetricsGroup::_internal_parent_path() const {
  return _impl_.parent_path_.Get();
}
inline void DatasetVersionMetricsGroup::_internal_set_parent_path(const std::string& value) {
  
  _impl_.parent_path_.Set(value, GetArenaForAllocation());
}
inline std::string* DatasetVersionMetricsGroup::_internal_mutable_parent_path() {
  
  return _impl_.parent_path_.Mutable(GetArenaForAllocation());
}
inline std::string* DatasetVersionMetricsGroup::release_parent_path() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersionMetricsGroup.parent_path)
  return _impl_.parent_path_.Release();
}
inline void DatasetVersionMetricsGroup::set_allocated_parent_path(std::string* parent_path) {
  if (parent_path != nullptr) {
    
  } else {
    
  }
  _impl_.parent_path_.SetAllocated(parent_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_path_.IsDefault()) {
    _impl_.parent_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersionMetricsGroup.parent_path)
}

// .clarifai.api.DatasetVersionMetricsGroupType type = 2;
inline void DatasetVersionMetricsGroup::clear_type() {
  _impl_.type_ = 0;
}
inline ::clarifai::api::DatasetVersionMetricsGroupType DatasetVersionMetricsGroup::_internal_type() const {
  return static_cast< ::clarifai::api::DatasetVersionMetricsGroupType >(_impl_.type_);
}
inline ::clarifai::api::DatasetVersionMetricsGroupType DatasetVersionMetricsGroup::type() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersionMetricsGroup.type)
  return _internal_type();
}
inline void DatasetVersionMetricsGroup::_internal_set_type(::clarifai::api::DatasetVersionMetricsGroupType value) {
  
  _impl_.type_ = value;
}
inline void DatasetVersionMetricsGroup::set_type(::clarifai::api::DatasetVersionMetricsGroupType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:clarifai.api.DatasetVersionMetricsGroup.type)
}

// .google.protobuf.Value value = 3;
inline bool DatasetVersionMetricsGroup::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool DatasetVersionMetricsGroup::has_value() const {
  return _internal_has_value();
}
inline const ::PROTOBUF_NAMESPACE_ID::Value& DatasetVersionMetricsGroup::_internal_value() const {
  const ::PROTOBUF_NAMESPACE_ID::Value* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Value&>(
      ::PROTOBUF_NAMESPACE_ID::_Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Value& DatasetVersionMetricsGroup::value() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersionMetricsGroup.value)
  return _internal_value();
}
inline void DatasetVersionMetricsGroup::unsafe_arena_set_allocated_value(
    ::PROTOBUF_NAMESPACE_ID::Value* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersionMetricsGroup.value)
}
inline ::PROTOBUF_NAMESPACE_ID::Value* DatasetVersionMetricsGroup::release_value() {
  
  ::PROTOBUF_NAMESPACE_ID::Value* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Value* DatasetVersionMetricsGroup::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersionMetricsGroup.value)
  
  ::PROTOBUF_NAMESPACE_ID::Value* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Value* DatasetVersionMetricsGroup::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Value>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::PROTOBUF_NAMESPACE_ID::Value* DatasetVersionMetricsGroup::mutable_value() {
  ::PROTOBUF_NAMESPACE_ID::Value* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersionMetricsGroup.value)
  return _msg;
}
inline void DatasetVersionMetricsGroup::set_allocated_value(::PROTOBUF_NAMESPACE_ID::Value* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersionMetricsGroup.value)
}

// .clarifai.api.DatasetVersionMetrics metrics = 4;
inline bool DatasetVersionMetricsGroup::_internal_has_metrics() const {
  return this != internal_default_instance() && _impl_.metrics_ != nullptr;
}
inline bool DatasetVersionMetricsGroup::has_metrics() const {
  return _internal_has_metrics();
}
inline void DatasetVersionMetricsGroup::clear_metrics() {
  if (GetArenaForAllocation() == nullptr && _impl_.metrics_ != nullptr) {
    delete _impl_.metrics_;
  }
  _impl_.metrics_ = nullptr;
}
inline const ::clarifai::api::DatasetVersionMetrics& DatasetVersionMetricsGroup::_internal_metrics() const {
  const ::clarifai::api::DatasetVersionMetrics* p = _impl_.metrics_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::DatasetVersionMetrics&>(
      ::clarifai::api::_DatasetVersionMetrics_default_instance_);
}
inline const ::clarifai::api::DatasetVersionMetrics& DatasetVersionMetricsGroup::metrics() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersionMetricsGroup.metrics)
  return _internal_metrics();
}
inline void DatasetVersionMetricsGroup::unsafe_arena_set_allocated_metrics(
    ::clarifai::api::DatasetVersionMetrics* metrics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metrics_);
  }
  _impl_.metrics_ = metrics;
  if (metrics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersionMetricsGroup.metrics)
}
inline ::clarifai::api::DatasetVersionMetrics* DatasetVersionMetricsGroup::release_metrics() {
  
  ::clarifai::api::DatasetVersionMetrics* temp = _impl_.metrics_;
  _impl_.metrics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::DatasetVersionMetrics* DatasetVersionMetricsGroup::unsafe_arena_release_metrics() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersionMetricsGroup.metrics)
  
  ::clarifai::api::DatasetVersionMetrics* temp = _impl_.metrics_;
  _impl_.metrics_ = nullptr;
  return temp;
}
inline ::clarifai::api::DatasetVersionMetrics* DatasetVersionMetricsGroup::_internal_mutable_metrics() {
  
  if (_impl_.metrics_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::DatasetVersionMetrics>(GetArenaForAllocation());
    _impl_.metrics_ = p;
  }
  return _impl_.metrics_;
}
inline ::clarifai::api::DatasetVersionMetrics* DatasetVersionMetricsGroup::mutable_metrics() {
  ::clarifai::api::DatasetVersionMetrics* _msg = _internal_mutable_metrics();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersionMetricsGroup.metrics)
  return _msg;
}
inline void DatasetVersionMetricsGroup::set_allocated_metrics(::clarifai::api::DatasetVersionMetrics* metrics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metrics_;
  }
  if (metrics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metrics);
    if (message_arena != submessage_arena) {
      metrics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metrics, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metrics_ = metrics;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersionMetricsGroup.metrics)
}

// -------------------------------------------------------------------

// DatasetVersionExportInfo

// .clarifai.api.DatasetVersionExport clarifai_data_protobuf = 1;
inline bool DatasetVersionExportInfo::_internal_has_clarifai_data_protobuf() const {
  return this != internal_default_instance() && _impl_.clarifai_data_protobuf_ != nullptr;
}
inline bool DatasetVersionExportInfo::has_clarifai_data_protobuf() const {
  return _internal_has_clarifai_data_protobuf();
}
inline void DatasetVersionExportInfo::clear_clarifai_data_protobuf() {
  if (GetArenaForAllocation() == nullptr && _impl_.clarifai_data_protobuf_ != nullptr) {
    delete _impl_.clarifai_data_protobuf_;
  }
  _impl_.clarifai_data_protobuf_ = nullptr;
}
inline const ::clarifai::api::DatasetVersionExport& DatasetVersionExportInfo::_internal_clarifai_data_protobuf() const {
  const ::clarifai::api::DatasetVersionExport* p = _impl_.clarifai_data_protobuf_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::DatasetVersionExport&>(
      ::clarifai::api::_DatasetVersionExport_default_instance_);
}
inline const ::clarifai::api::DatasetVersionExport& DatasetVersionExportInfo::clarifai_data_protobuf() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersionExportInfo.clarifai_data_protobuf)
  return _internal_clarifai_data_protobuf();
}
inline void DatasetVersionExportInfo::unsafe_arena_set_allocated_clarifai_data_protobuf(
    ::clarifai::api::DatasetVersionExport* clarifai_data_protobuf) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.clarifai_data_protobuf_);
  }
  _impl_.clarifai_data_protobuf_ = clarifai_data_protobuf;
  if (clarifai_data_protobuf) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersionExportInfo.clarifai_data_protobuf)
}
inline ::clarifai::api::DatasetVersionExport* DatasetVersionExportInfo::release_clarifai_data_protobuf() {
  
  ::clarifai::api::DatasetVersionExport* temp = _impl_.clarifai_data_protobuf_;
  _impl_.clarifai_data_protobuf_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::DatasetVersionExport* DatasetVersionExportInfo::unsafe_arena_release_clarifai_data_protobuf() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersionExportInfo.clarifai_data_protobuf)
  
  ::clarifai::api::DatasetVersionExport* temp = _impl_.clarifai_data_protobuf_;
  _impl_.clarifai_data_protobuf_ = nullptr;
  return temp;
}
inline ::clarifai::api::DatasetVersionExport* DatasetVersionExportInfo::_internal_mutable_clarifai_data_protobuf() {
  
  if (_impl_.clarifai_data_protobuf_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::DatasetVersionExport>(GetArenaForAllocation());
    _impl_.clarifai_data_protobuf_ = p;
  }
  return _impl_.clarifai_data_protobuf_;
}
inline ::clarifai::api::DatasetVersionExport* DatasetVersionExportInfo::mutable_clarifai_data_protobuf() {
  ::clarifai::api::DatasetVersionExport* _msg = _internal_mutable_clarifai_data_protobuf();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersionExportInfo.clarifai_data_protobuf)
  return _msg;
}
inline void DatasetVersionExportInfo::set_allocated_clarifai_data_protobuf(::clarifai::api::DatasetVersionExport* clarifai_data_protobuf) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.clarifai_data_protobuf_;
  }
  if (clarifai_data_protobuf) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(clarifai_data_protobuf);
    if (message_arena != submessage_arena) {
      clarifai_data_protobuf = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clarifai_data_protobuf, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.clarifai_data_protobuf_ = clarifai_data_protobuf;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersionExportInfo.clarifai_data_protobuf)
}

// .clarifai.api.DatasetVersionExport clarifai_data_json = 3;
inline bool DatasetVersionExportInfo::_internal_has_clarifai_data_json() const {
  return this != internal_default_instance() && _impl_.clarifai_data_json_ != nullptr;
}
inline bool DatasetVersionExportInfo::has_clarifai_data_json() const {
  return _internal_has_clarifai_data_json();
}
inline void DatasetVersionExportInfo::clear_clarifai_data_json() {
  if (GetArenaForAllocation() == nullptr && _impl_.clarifai_data_json_ != nullptr) {
    delete _impl_.clarifai_data_json_;
  }
  _impl_.clarifai_data_json_ = nullptr;
}
inline const ::clarifai::api::DatasetVersionExport& DatasetVersionExportInfo::_internal_clarifai_data_json() const {
  const ::clarifai::api::DatasetVersionExport* p = _impl_.clarifai_data_json_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::DatasetVersionExport&>(
      ::clarifai::api::_DatasetVersionExport_default_instance_);
}
inline const ::clarifai::api::DatasetVersionExport& DatasetVersionExportInfo::clarifai_data_json() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersionExportInfo.clarifai_data_json)
  return _internal_clarifai_data_json();
}
inline void DatasetVersionExportInfo::unsafe_arena_set_allocated_clarifai_data_json(
    ::clarifai::api::DatasetVersionExport* clarifai_data_json) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.clarifai_data_json_);
  }
  _impl_.clarifai_data_json_ = clarifai_data_json;
  if (clarifai_data_json) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersionExportInfo.clarifai_data_json)
}
inline ::clarifai::api::DatasetVersionExport* DatasetVersionExportInfo::release_clarifai_data_json() {
  
  ::clarifai::api::DatasetVersionExport* temp = _impl_.clarifai_data_json_;
  _impl_.clarifai_data_json_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::DatasetVersionExport* DatasetVersionExportInfo::unsafe_arena_release_clarifai_data_json() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersionExportInfo.clarifai_data_json)
  
  ::clarifai::api::DatasetVersionExport* temp = _impl_.clarifai_data_json_;
  _impl_.clarifai_data_json_ = nullptr;
  return temp;
}
inline ::clarifai::api::DatasetVersionExport* DatasetVersionExportInfo::_internal_mutable_clarifai_data_json() {
  
  if (_impl_.clarifai_data_json_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::DatasetVersionExport>(GetArenaForAllocation());
    _impl_.clarifai_data_json_ = p;
  }
  return _impl_.clarifai_data_json_;
}
inline ::clarifai::api::DatasetVersionExport* DatasetVersionExportInfo::mutable_clarifai_data_json() {
  ::clarifai::api::DatasetVersionExport* _msg = _internal_mutable_clarifai_data_json();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersionExportInfo.clarifai_data_json)
  return _msg;
}
inline void DatasetVersionExportInfo::set_allocated_clarifai_data_json(::clarifai::api::DatasetVersionExport* clarifai_data_json) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.clarifai_data_json_;
  }
  if (clarifai_data_json) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(clarifai_data_json);
    if (message_arena != submessage_arena) {
      clarifai_data_json = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clarifai_data_json, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.clarifai_data_json_ = clarifai_data_json;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersionExportInfo.clarifai_data_json)
}

// .clarifai.api.DatasetVersionExport coco = 2;
inline bool DatasetVersionExportInfo::_internal_has_coco() const {
  return this != internal_default_instance() && _impl_.coco_ != nullptr;
}
inline bool DatasetVersionExportInfo::has_coco() const {
  return _internal_has_coco();
}
inline void DatasetVersionExportInfo::clear_coco() {
  if (GetArenaForAllocation() == nullptr && _impl_.coco_ != nullptr) {
    delete _impl_.coco_;
  }
  _impl_.coco_ = nullptr;
}
inline const ::clarifai::api::DatasetVersionExport& DatasetVersionExportInfo::_internal_coco() const {
  const ::clarifai::api::DatasetVersionExport* p = _impl_.coco_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::DatasetVersionExport&>(
      ::clarifai::api::_DatasetVersionExport_default_instance_);
}
inline const ::clarifai::api::DatasetVersionExport& DatasetVersionExportInfo::coco() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersionExportInfo.coco)
  return _internal_coco();
}
inline void DatasetVersionExportInfo::unsafe_arena_set_allocated_coco(
    ::clarifai::api::DatasetVersionExport* coco) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.coco_);
  }
  _impl_.coco_ = coco;
  if (coco) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersionExportInfo.coco)
}
inline ::clarifai::api::DatasetVersionExport* DatasetVersionExportInfo::release_coco() {
  
  ::clarifai::api::DatasetVersionExport* temp = _impl_.coco_;
  _impl_.coco_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::DatasetVersionExport* DatasetVersionExportInfo::unsafe_arena_release_coco() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersionExportInfo.coco)
  
  ::clarifai::api::DatasetVersionExport* temp = _impl_.coco_;
  _impl_.coco_ = nullptr;
  return temp;
}
inline ::clarifai::api::DatasetVersionExport* DatasetVersionExportInfo::_internal_mutable_coco() {
  
  if (_impl_.coco_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::DatasetVersionExport>(GetArenaForAllocation());
    _impl_.coco_ = p;
  }
  return _impl_.coco_;
}
inline ::clarifai::api::DatasetVersionExport* DatasetVersionExportInfo::mutable_coco() {
  ::clarifai::api::DatasetVersionExport* _msg = _internal_mutable_coco();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersionExportInfo.coco)
  return _msg;
}
inline void DatasetVersionExportInfo::set_allocated_coco(::clarifai::api::DatasetVersionExport* coco) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.coco_;
  }
  if (coco) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(coco);
    if (message_arena != submessage_arena) {
      coco = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coco, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.coco_ = coco;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersionExportInfo.coco)
}

// -------------------------------------------------------------------

// DatasetVersionExport

// .clarifai.api.DatasetVersionExportFormat format = 1;
inline void DatasetVersionExport::clear_format() {
  _impl_.format_ = 0;
}
inline ::clarifai::api::DatasetVersionExportFormat DatasetVersionExport::_internal_format() const {
  return static_cast< ::clarifai::api::DatasetVersionExportFormat >(_impl_.format_);
}
inline ::clarifai::api::DatasetVersionExportFormat DatasetVersionExport::format() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersionExport.format)
  return _internal_format();
}
inline void DatasetVersionExport::_internal_set_format(::clarifai::api::DatasetVersionExportFormat value) {
  
  _impl_.format_ = value;
}
inline void DatasetVersionExport::set_format(::clarifai::api::DatasetVersionExportFormat value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:clarifai.api.DatasetVersionExport.format)
}

// .clarifai.api.status.Status status = 2;
inline bool DatasetVersionExport::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool DatasetVersionExport::has_status() const {
  return _internal_has_status();
}
inline const ::clarifai::api::status::Status& DatasetVersionExport::_internal_status() const {
  const ::clarifai::api::status::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::status::Status&>(
      ::clarifai::api::status::_Status_default_instance_);
}
inline const ::clarifai::api::status::Status& DatasetVersionExport::status() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersionExport.status)
  return _internal_status();
}
inline void DatasetVersionExport::unsafe_arena_set_allocated_status(
    ::clarifai::api::status::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetVersionExport.status)
}
inline ::clarifai::api::status::Status* DatasetVersionExport::release_status() {
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::status::Status* DatasetVersionExport::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersionExport.status)
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::clarifai::api::status::Status* DatasetVersionExport::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::status::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::clarifai::api::status::Status* DatasetVersionExport::mutable_status() {
  ::clarifai::api::status::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersionExport.status)
  return _msg;
}
inline void DatasetVersionExport::set_allocated_status(::clarifai::api::status::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersionExport.status)
}

// string url = 3;
inline void DatasetVersionExport::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& DatasetVersionExport::url() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersionExport.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DatasetVersionExport::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.DatasetVersionExport.url)
}
inline std::string* DatasetVersionExport::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetVersionExport.url)
  return _s;
}
inline const std::string& DatasetVersionExport::_internal_url() const {
  return _impl_.url_.Get();
}
inline void DatasetVersionExport::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* DatasetVersionExport::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* DatasetVersionExport::release_url() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetVersionExport.url)
  return _impl_.url_.Release();
}
inline void DatasetVersionExport::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetVersionExport.url)
}

// uint64 size = 4;
inline void DatasetVersionExport::clear_size() {
  _impl_.size_ = uint64_t{0u};
}
inline uint64_t DatasetVersionExport::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t DatasetVersionExport::size() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetVersionExport.size)
  return _internal_size();
}
inline void DatasetVersionExport::_internal_set_size(uint64_t value) {
  
  _impl_.size_ = value;
}
inline void DatasetVersionExport::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:clarifai.api.DatasetVersionExport.size)
}

// -------------------------------------------------------------------

// WorkflowResultsSimilarity

// .clarifai.api.Input probe_input = 1;
inline bool WorkflowResultsSimilarity::_internal_has_probe_input() const {
  return this != internal_default_instance() && _impl_.probe_input_ != nullptr;
}
inline bool WorkflowResultsSimilarity::has_probe_input() const {
  return _internal_has_probe_input();
}
inline void WorkflowResultsSimilarity::clear_probe_input() {
  if (GetArenaForAllocation() == nullptr && _impl_.probe_input_ != nullptr) {
    delete _impl_.probe_input_;
  }
  _impl_.probe_input_ = nullptr;
}
inline const ::clarifai::api::Input& WorkflowResultsSimilarity::_internal_probe_input() const {
  const ::clarifai::api::Input* p = _impl_.probe_input_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Input&>(
      ::clarifai::api::_Input_default_instance_);
}
inline const ::clarifai::api::Input& WorkflowResultsSimilarity::probe_input() const {
  // @@protoc_insertion_point(field_get:clarifai.api.WorkflowResultsSimilarity.probe_input)
  return _internal_probe_input();
}
inline void WorkflowResultsSimilarity::unsafe_arena_set_allocated_probe_input(
    ::clarifai::api::Input* probe_input) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.probe_input_);
  }
  _impl_.probe_input_ = probe_input;
  if (probe_input) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.WorkflowResultsSimilarity.probe_input)
}
inline ::clarifai::api::Input* WorkflowResultsSimilarity::release_probe_input() {
  
  ::clarifai::api::Input* temp = _impl_.probe_input_;
  _impl_.probe_input_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Input* WorkflowResultsSimilarity::unsafe_arena_release_probe_input() {
  // @@protoc_insertion_point(field_release:clarifai.api.WorkflowResultsSimilarity.probe_input)
  
  ::clarifai::api::Input* temp = _impl_.probe_input_;
  _impl_.probe_input_ = nullptr;
  return temp;
}
inline ::clarifai::api::Input* WorkflowResultsSimilarity::_internal_mutable_probe_input() {
  
  if (_impl_.probe_input_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Input>(GetArenaForAllocation());
    _impl_.probe_input_ = p;
  }
  return _impl_.probe_input_;
}
inline ::clarifai::api::Input* WorkflowResultsSimilarity::mutable_probe_input() {
  ::clarifai::api::Input* _msg = _internal_mutable_probe_input();
  // @@protoc_insertion_point(field_mutable:clarifai.api.WorkflowResultsSimilarity.probe_input)
  return _msg;
}
inline void WorkflowResultsSimilarity::set_allocated_probe_input(::clarifai::api::Input* probe_input) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.probe_input_;
  }
  if (probe_input) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(probe_input);
    if (message_arena != submessage_arena) {
      probe_input = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, probe_input, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.probe_input_ = probe_input;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.WorkflowResultsSimilarity.probe_input)
}

// repeated .clarifai.api.Hit pool_results = 2;
inline int WorkflowResultsSimilarity::_internal_pool_results_size() const {
  return _impl_.pool_results_.size();
}
inline int WorkflowResultsSimilarity::pool_results_size() const {
  return _internal_pool_results_size();
}
inline void WorkflowResultsSimilarity::clear_pool_results() {
  _impl_.pool_results_.Clear();
}
inline ::clarifai::api::Hit* WorkflowResultsSimilarity::mutable_pool_results(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.WorkflowResultsSimilarity.pool_results)
  return _impl_.pool_results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Hit >*
WorkflowResultsSimilarity::mutable_pool_results() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.WorkflowResultsSimilarity.pool_results)
  return &_impl_.pool_results_;
}
inline const ::clarifai::api::Hit& WorkflowResultsSimilarity::_internal_pool_results(int index) const {
  return _impl_.pool_results_.Get(index);
}
inline const ::clarifai::api::Hit& WorkflowResultsSimilarity::pool_results(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.WorkflowResultsSimilarity.pool_results)
  return _internal_pool_results(index);
}
inline ::clarifai::api::Hit* WorkflowResultsSimilarity::_internal_add_pool_results() {
  return _impl_.pool_results_.Add();
}
inline ::clarifai::api::Hit* WorkflowResultsSimilarity::add_pool_results() {
  ::clarifai::api::Hit* _add = _internal_add_pool_results();
  // @@protoc_insertion_point(field_add:clarifai.api.WorkflowResultsSimilarity.pool_results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Hit >&
WorkflowResultsSimilarity::pool_results() const {
  // @@protoc_insertion_point(field_list:clarifai.api.WorkflowResultsSimilarity.pool_results)
  return _impl_.pool_results_;
}

// -------------------------------------------------------------------

// Key

// string id = 1;
inline void Key::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Key::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Key.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Key::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Key.id)
}
inline std::string* Key::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Key.id)
  return _s;
}
inline const std::string& Key::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Key::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Key::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Key::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Key.id)
  return _impl_.id_.Release();
}
inline void Key::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Key.id)
}

// string type = 8;
inline void Key::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Key::type() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Key.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Key::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Key.type)
}
inline std::string* Key::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Key.type)
  return _s;
}
inline const std::string& Key::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Key::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Key::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Key::release_type() {
  // @@protoc_insertion_point(field_release:clarifai.api.Key.type)
  return _impl_.type_.Release();
}
inline void Key::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Key.type)
}

// string description = 2;
inline void Key::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Key::description() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Key.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Key::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Key.description)
}
inline std::string* Key::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Key.description)
  return _s;
}
inline const std::string& Key::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Key::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Key::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Key::release_description() {
  // @@protoc_insertion_point(field_release:clarifai.api.Key.description)
  return _impl_.description_.Release();
}
inline void Key::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Key.description)
}

// repeated string scopes = 3;
inline int Key::_internal_scopes_size() const {
  return _impl_.scopes_.size();
}
inline int Key::scopes_size() const {
  return _internal_scopes_size();
}
inline void Key::clear_scopes() {
  _impl_.scopes_.Clear();
}
inline std::string* Key::add_scopes() {
  std::string* _s = _internal_add_scopes();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.Key.scopes)
  return _s;
}
inline const std::string& Key::_internal_scopes(int index) const {
  return _impl_.scopes_.Get(index);
}
inline const std::string& Key::scopes(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Key.scopes)
  return _internal_scopes(index);
}
inline std::string* Key::mutable_scopes(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Key.scopes)
  return _impl_.scopes_.Mutable(index);
}
inline void Key::set_scopes(int index, const std::string& value) {
  _impl_.scopes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Key.scopes)
}
inline void Key::set_scopes(int index, std::string&& value) {
  _impl_.scopes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.Key.scopes)
}
inline void Key::set_scopes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.scopes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.Key.scopes)
}
inline void Key::set_scopes(int index, const char* value, size_t size) {
  _impl_.scopes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.Key.scopes)
}
inline std::string* Key::_internal_add_scopes() {
  return _impl_.scopes_.Add();
}
inline void Key::add_scopes(const std::string& value) {
  _impl_.scopes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.Key.scopes)
}
inline void Key::add_scopes(std::string&& value) {
  _impl_.scopes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.Key.scopes)
}
inline void Key::add_scopes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.scopes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.Key.scopes)
}
inline void Key::add_scopes(const char* value, size_t size) {
  _impl_.scopes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.Key.scopes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Key::scopes() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Key.scopes)
  return _impl_.scopes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Key::mutable_scopes() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Key.scopes)
  return &_impl_.scopes_;
}

// repeated string endpoints = 7;
inline int Key::_internal_endpoints_size() const {
  return _impl_.endpoints_.size();
}
inline int Key::endpoints_size() const {
  return _internal_endpoints_size();
}
inline void Key::clear_endpoints() {
  _impl_.endpoints_.Clear();
}
inline std::string* Key::add_endpoints() {
  std::string* _s = _internal_add_endpoints();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.Key.endpoints)
  return _s;
}
inline const std::string& Key::_internal_endpoints(int index) const {
  return _impl_.endpoints_.Get(index);
}
inline const std::string& Key::endpoints(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Key.endpoints)
  return _internal_endpoints(index);
}
inline std::string* Key::mutable_endpoints(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Key.endpoints)
  return _impl_.endpoints_.Mutable(index);
}
inline void Key::set_endpoints(int index, const std::string& value) {
  _impl_.endpoints_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Key.endpoints)
}
inline void Key::set_endpoints(int index, std::string&& value) {
  _impl_.endpoints_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.Key.endpoints)
}
inline void Key::set_endpoints(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.endpoints_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.Key.endpoints)
}
inline void Key::set_endpoints(int index, const char* value, size_t size) {
  _impl_.endpoints_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.Key.endpoints)
}
inline std::string* Key::_internal_add_endpoints() {
  return _impl_.endpoints_.Add();
}
inline void Key::add_endpoints(const std::string& value) {
  _impl_.endpoints_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.Key.endpoints)
}
inline void Key::add_endpoints(std::string&& value) {
  _impl_.endpoints_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.Key.endpoints)
}
inline void Key::add_endpoints(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.endpoints_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.Key.endpoints)
}
inline void Key::add_endpoints(const char* value, size_t size) {
  _impl_.endpoints_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.Key.endpoints)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Key::endpoints() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Key.endpoints)
  return _impl_.endpoints_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Key::mutable_endpoints() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Key.endpoints)
  return &_impl_.endpoints_;
}

// repeated .clarifai.api.App apps = 4;
inline int Key::_internal_apps_size() const {
  return _impl_.apps_.size();
}
inline int Key::apps_size() const {
  return _internal_apps_size();
}
inline void Key::clear_apps() {
  _impl_.apps_.Clear();
}
inline ::clarifai::api::App* Key::mutable_apps(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Key.apps)
  return _impl_.apps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::App >*
Key::mutable_apps() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Key.apps)
  return &_impl_.apps_;
}
inline const ::clarifai::api::App& Key::_internal_apps(int index) const {
  return _impl_.apps_.Get(index);
}
inline const ::clarifai::api::App& Key::apps(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Key.apps)
  return _internal_apps(index);
}
inline ::clarifai::api::App* Key::_internal_add_apps() {
  return _impl_.apps_.Add();
}
inline ::clarifai::api::App* Key::add_apps() {
  ::clarifai::api::App* _add = _internal_add_apps();
  // @@protoc_insertion_point(field_add:clarifai.api.Key.apps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::App >&
Key::apps() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Key.apps)
  return _impl_.apps_;
}

// .google.protobuf.Timestamp created_at = 5;
inline bool Key::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool Key::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Key::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Key::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Key.created_at)
  return _internal_created_at();
}
inline void Key::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Key.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Key::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Key::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.Key.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Key::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Key::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Key.created_at)
  return _msg;
}
inline void Key::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Key.created_at)
}

// .google.protobuf.Timestamp expires_at = 6;
inline bool Key::_internal_has_expires_at() const {
  return this != internal_default_instance() && _impl_.expires_at_ != nullptr;
}
inline bool Key::has_expires_at() const {
  return _internal_has_expires_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Key::_internal_expires_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.expires_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Key::expires_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Key.expires_at)
  return _internal_expires_at();
}
inline void Key::unsafe_arena_set_allocated_expires_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expires_at_);
  }
  _impl_.expires_at_ = expires_at;
  if (expires_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Key.expires_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Key::release_expires_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.expires_at_;
  _impl_.expires_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Key::unsafe_arena_release_expires_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.Key.expires_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.expires_at_;
  _impl_.expires_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Key::_internal_mutable_expires_at() {
  
  if (_impl_.expires_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.expires_at_ = p;
  }
  return _impl_.expires_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Key::mutable_expires_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_expires_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Key.expires_at)
  return _msg;
}
inline void Key::set_allocated_expires_at(::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expires_at_);
  }
  if (expires_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expires_at));
    if (message_arena != submessage_arena) {
      expires_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expires_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.expires_at_ = expires_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Key.expires_at)
}

// repeated string authorized_idp_ids = 9;
inline int Key::_internal_authorized_idp_ids_size() const {
  return _impl_.authorized_idp_ids_.size();
}
inline int Key::authorized_idp_ids_size() const {
  return _internal_authorized_idp_ids_size();
}
inline void Key::clear_authorized_idp_ids() {
  _impl_.authorized_idp_ids_.Clear();
}
inline std::string* Key::add_authorized_idp_ids() {
  std::string* _s = _internal_add_authorized_idp_ids();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.Key.authorized_idp_ids)
  return _s;
}
inline const std::string& Key::_internal_authorized_idp_ids(int index) const {
  return _impl_.authorized_idp_ids_.Get(index);
}
inline const std::string& Key::authorized_idp_ids(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Key.authorized_idp_ids)
  return _internal_authorized_idp_ids(index);
}
inline std::string* Key::mutable_authorized_idp_ids(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Key.authorized_idp_ids)
  return _impl_.authorized_idp_ids_.Mutable(index);
}
inline void Key::set_authorized_idp_ids(int index, const std::string& value) {
  _impl_.authorized_idp_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Key.authorized_idp_ids)
}
inline void Key::set_authorized_idp_ids(int index, std::string&& value) {
  _impl_.authorized_idp_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.Key.authorized_idp_ids)
}
inline void Key::set_authorized_idp_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.authorized_idp_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.Key.authorized_idp_ids)
}
inline void Key::set_authorized_idp_ids(int index, const char* value, size_t size) {
  _impl_.authorized_idp_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.Key.authorized_idp_ids)
}
inline std::string* Key::_internal_add_authorized_idp_ids() {
  return _impl_.authorized_idp_ids_.Add();
}
inline void Key::add_authorized_idp_ids(const std::string& value) {
  _impl_.authorized_idp_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.Key.authorized_idp_ids)
}
inline void Key::add_authorized_idp_ids(std::string&& value) {
  _impl_.authorized_idp_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.Key.authorized_idp_ids)
}
inline void Key::add_authorized_idp_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.authorized_idp_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.Key.authorized_idp_ids)
}
inline void Key::add_authorized_idp_ids(const char* value, size_t size) {
  _impl_.authorized_idp_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.Key.authorized_idp_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Key::authorized_idp_ids() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Key.authorized_idp_ids)
  return _impl_.authorized_idp_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Key::mutable_authorized_idp_ids() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Key.authorized_idp_ids)
  return &_impl_.authorized_idp_ids_;
}

// -------------------------------------------------------------------

// Model

// string id = 1;
inline void Model::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Model::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Model.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Model.id)
}
inline std::string* Model::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Model.id)
  return _s;
}
inline const std::string& Model::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Model::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Model.id)
  return _impl_.id_.Release();
}
inline void Model::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Model.id)
}

// string name = 2 [deprecated = true];
inline void Model::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Model::name() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Model.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Model.name)
}
inline std::string* Model::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Model.name)
  return _s;
}
inline const std::string& Model::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Model::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_name() {
  // @@protoc_insertion_point(field_release:clarifai.api.Model.name)
  return _impl_.name_.Release();
}
inline void Model::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Model.name)
}

// .google.protobuf.Timestamp created_at = 3;
inline bool Model::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool Model::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Model::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Model::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Model.created_at)
  return _internal_created_at();
}
inline void Model::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Model.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Model::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Model::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.Model.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Model::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Model::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Model.created_at)
  return _msg;
}
inline void Model::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Model.created_at)
}

// .google.protobuf.Timestamp modified_at = 19;
inline bool Model::_internal_has_modified_at() const {
  return this != internal_default_instance() && _impl_.modified_at_ != nullptr;
}
inline bool Model::has_modified_at() const {
  return _internal_has_modified_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Model::_internal_modified_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.modified_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Model::modified_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Model.modified_at)
  return _internal_modified_at();
}
inline void Model::unsafe_arena_set_allocated_modified_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  _impl_.modified_at_ = modified_at;
  if (modified_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Model.modified_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Model::release_modified_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Model::unsafe_arena_release_modified_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.Model.modified_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Model::_internal_mutable_modified_at() {
  
  if (_impl_.modified_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.modified_at_ = p;
  }
  return _impl_.modified_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Model::mutable_modified_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_modified_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Model.modified_at)
  return _msg;
}
inline void Model::set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  if (modified_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(modified_at));
    if (message_arena != submessage_arena) {
      modified_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modified_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.modified_at_ = modified_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Model.modified_at)
}

// string app_id = 4 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void Model::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& Model::app_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Model.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_app_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.app_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Model.app_id)
}
inline std::string* Model::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Model.app_id)
  return _s;
}
inline const std::string& Model::_internal_app_id() const {
  return _impl_.app_id_.Get();
}
inline void Model::_internal_set_app_id(const std::string& value) {
  
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_app_id() {
  
  return _impl_.app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_app_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Model.app_id)
  return _impl_.app_id_.Release();
}
inline void Model::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    
  } else {
    
  }
  _impl_.app_id_.SetAllocated(app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Model.app_id)
}

// .clarifai.api.OutputInfo output_info = 5 [deprecated = true];
inline bool Model::_internal_has_output_info() const {
  return this != internal_default_instance() && _impl_.output_info_ != nullptr;
}
inline bool Model::has_output_info() const {
  return _internal_has_output_info();
}
inline void Model::clear_output_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.output_info_ != nullptr) {
    delete _impl_.output_info_;
  }
  _impl_.output_info_ = nullptr;
}
inline const ::clarifai::api::OutputInfo& Model::_internal_output_info() const {
  const ::clarifai::api::OutputInfo* p = _impl_.output_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::OutputInfo&>(
      ::clarifai::api::_OutputInfo_default_instance_);
}
inline const ::clarifai::api::OutputInfo& Model::output_info() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Model.output_info)
  return _internal_output_info();
}
inline void Model::unsafe_arena_set_allocated_output_info(
    ::clarifai::api::OutputInfo* output_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.output_info_);
  }
  _impl_.output_info_ = output_info;
  if (output_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Model.output_info)
}
inline ::clarifai::api::OutputInfo* Model::release_output_info() {
  
  ::clarifai::api::OutputInfo* temp = _impl_.output_info_;
  _impl_.output_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::OutputInfo* Model::unsafe_arena_release_output_info() {
  // @@protoc_insertion_point(field_release:clarifai.api.Model.output_info)
  
  ::clarifai::api::OutputInfo* temp = _impl_.output_info_;
  _impl_.output_info_ = nullptr;
  return temp;
}
inline ::clarifai::api::OutputInfo* Model::_internal_mutable_output_info() {
  
  if (_impl_.output_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::OutputInfo>(GetArenaForAllocation());
    _impl_.output_info_ = p;
  }
  return _impl_.output_info_;
}
inline ::clarifai::api::OutputInfo* Model::mutable_output_info() {
  ::clarifai::api::OutputInfo* _msg = _internal_mutable_output_info();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Model.output_info)
  return _msg;
}
inline void Model::set_allocated_output_info(::clarifai::api::OutputInfo* output_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.output_info_;
  }
  if (output_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(output_info);
    if (message_arena != submessage_arena) {
      output_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, output_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.output_info_ = output_info;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Model.output_info)
}

// .clarifai.api.ModelVersion model_version = 6;
inline bool Model::_internal_has_model_version() const {
  return this != internal_default_instance() && _impl_.model_version_ != nullptr;
}
inline bool Model::has_model_version() const {
  return _internal_has_model_version();
}
inline void Model::clear_model_version() {
  if (GetArenaForAllocation() == nullptr && _impl_.model_version_ != nullptr) {
    delete _impl_.model_version_;
  }
  _impl_.model_version_ = nullptr;
}
inline const ::clarifai::api::ModelVersion& Model::_internal_model_version() const {
  const ::clarifai::api::ModelVersion* p = _impl_.model_version_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::ModelVersion&>(
      ::clarifai::api::_ModelVersion_default_instance_);
}
inline const ::clarifai::api::ModelVersion& Model::model_version() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Model.model_version)
  return _internal_model_version();
}
inline void Model::unsafe_arena_set_allocated_model_version(
    ::clarifai::api::ModelVersion* model_version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.model_version_);
  }
  _impl_.model_version_ = model_version;
  if (model_version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Model.model_version)
}
inline ::clarifai::api::ModelVersion* Model::release_model_version() {
  
  ::clarifai::api::ModelVersion* temp = _impl_.model_version_;
  _impl_.model_version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::ModelVersion* Model::unsafe_arena_release_model_version() {
  // @@protoc_insertion_point(field_release:clarifai.api.Model.model_version)
  
  ::clarifai::api::ModelVersion* temp = _impl_.model_version_;
  _impl_.model_version_ = nullptr;
  return temp;
}
inline ::clarifai::api::ModelVersion* Model::_internal_mutable_model_version() {
  
  if (_impl_.model_version_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::ModelVersion>(GetArenaForAllocation());
    _impl_.model_version_ = p;
  }
  return _impl_.model_version_;
}
inline ::clarifai::api::ModelVersion* Model::mutable_model_version() {
  ::clarifai::api::ModelVersion* _msg = _internal_mutable_model_version();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Model.model_version)
  return _msg;
}
inline void Model::set_allocated_model_version(::clarifai::api::ModelVersion* model_version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.model_version_;
  }
  if (model_version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(model_version);
    if (message_arena != submessage_arena) {
      model_version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model_version, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.model_version_ = model_version;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Model.model_version)
}

// string display_name = 7 [deprecated = true];
inline void Model::clear_display_name() {
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& Model::display_name() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Model.display_name)
  return _internal_display_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_display_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.display_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Model.display_name)
}
inline std::string* Model::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Model.display_name)
  return _s;
}
inline const std::string& Model::_internal_display_name() const {
  return _impl_.display_name_.Get();
}
inline void Model::_internal_set_display_name(const std::string& value) {
  
  _impl_.display_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_display_name() {
  
  return _impl_.display_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_display_name() {
  // @@protoc_insertion_point(field_release:clarifai.api.Model.display_name)
  return _impl_.display_name_.Release();
}
inline void Model::set_allocated_display_name(std::string* display_name) {
  if (display_name != nullptr) {
    
  } else {
    
  }
  _impl_.display_name_.SetAllocated(display_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.display_name_.IsDefault()) {
    _impl_.display_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Model.display_name)
}

// string user_id = 9;
inline void Model::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& Model::user_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Model.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Model.user_id)
}
inline std::string* Model::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Model.user_id)
  return _s;
}
inline const std::string& Model::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void Model::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_user_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Model.user_id)
  return _impl_.user_id_.Release();
}
inline void Model::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Model.user_id)
}

// .clarifai.api.InputInfo input_info = 12 [deprecated = true];
inline bool Model::_internal_has_input_info() const {
  return this != internal_default_instance() && _impl_.input_info_ != nullptr;
}
inline bool Model::has_input_info() const {
  return _internal_has_input_info();
}
inline void Model::clear_input_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.input_info_ != nullptr) {
    delete _impl_.input_info_;
  }
  _impl_.input_info_ = nullptr;
}
inline const ::clarifai::api::InputInfo& Model::_internal_input_info() const {
  const ::clarifai::api::InputInfo* p = _impl_.input_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::InputInfo&>(
      ::clarifai::api::_InputInfo_default_instance_);
}
inline const ::clarifai::api::InputInfo& Model::input_info() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Model.input_info)
  return _internal_input_info();
}
inline void Model::unsafe_arena_set_allocated_input_info(
    ::clarifai::api::InputInfo* input_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.input_info_);
  }
  _impl_.input_info_ = input_info;
  if (input_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Model.input_info)
}
inline ::clarifai::api::InputInfo* Model::release_input_info() {
  
  ::clarifai::api::InputInfo* temp = _impl_.input_info_;
  _impl_.input_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::InputInfo* Model::unsafe_arena_release_input_info() {
  // @@protoc_insertion_point(field_release:clarifai.api.Model.input_info)
  
  ::clarifai::api::InputInfo* temp = _impl_.input_info_;
  _impl_.input_info_ = nullptr;
  return temp;
}
inline ::clarifai::api::InputInfo* Model::_internal_mutable_input_info() {
  
  if (_impl_.input_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::InputInfo>(GetArenaForAllocation());
    _impl_.input_info_ = p;
  }
  return _impl_.input_info_;
}
inline ::clarifai::api::InputInfo* Model::mutable_input_info() {
  ::clarifai::api::InputInfo* _msg = _internal_mutable_input_info();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Model.input_info)
  return _msg;
}
inline void Model::set_allocated_input_info(::clarifai::api::InputInfo* input_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.input_info_;
  }
  if (input_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(input_info);
    if (message_arena != submessage_arena) {
      input_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.input_info_ = input_info;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Model.input_info)
}

// .clarifai.api.TrainInfo train_info = 13 [deprecated = true];
inline bool Model::_internal_has_train_info() const {
  return this != internal_default_instance() && _impl_.train_info_ != nullptr;
}
inline bool Model::has_train_info() const {
  return _internal_has_train_info();
}
inline void Model::clear_train_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.train_info_ != nullptr) {
    delete _impl_.train_info_;
  }
  _impl_.train_info_ = nullptr;
}
inline const ::clarifai::api::TrainInfo& Model::_internal_train_info() const {
  const ::clarifai::api::TrainInfo* p = _impl_.train_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::TrainInfo&>(
      ::clarifai::api::_TrainInfo_default_instance_);
}
inline const ::clarifai::api::TrainInfo& Model::train_info() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Model.train_info)
  return _internal_train_info();
}
inline void Model::unsafe_arena_set_allocated_train_info(
    ::clarifai::api::TrainInfo* train_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.train_info_);
  }
  _impl_.train_info_ = train_info;
  if (train_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Model.train_info)
}
inline ::clarifai::api::TrainInfo* Model::release_train_info() {
  
  ::clarifai::api::TrainInfo* temp = _impl_.train_info_;
  _impl_.train_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::TrainInfo* Model::unsafe_arena_release_train_info() {
  // @@protoc_insertion_point(field_release:clarifai.api.Model.train_info)
  
  ::clarifai::api::TrainInfo* temp = _impl_.train_info_;
  _impl_.train_info_ = nullptr;
  return temp;
}
inline ::clarifai::api::TrainInfo* Model::_internal_mutable_train_info() {
  
  if (_impl_.train_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::TrainInfo>(GetArenaForAllocation());
    _impl_.train_info_ = p;
  }
  return _impl_.train_info_;
}
inline ::clarifai::api::TrainInfo* Model::mutable_train_info() {
  ::clarifai::api::TrainInfo* _msg = _internal_mutable_train_info();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Model.train_info)
  return _msg;
}
inline void Model::set_allocated_train_info(::clarifai::api::TrainInfo* train_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.train_info_;
  }
  if (train_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(train_info);
    if (message_arena != submessage_arena) {
      train_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, train_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.train_info_ = train_info;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Model.train_info)
}

// .clarifai.api.EvalInfo default_eval_info = 30;
inline bool Model::_internal_has_default_eval_info() const {
  return this != internal_default_instance() && _impl_.default_eval_info_ != nullptr;
}
inline bool Model::has_default_eval_info() const {
  return _internal_has_default_eval_info();
}
inline void Model::clear_default_eval_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.default_eval_info_ != nullptr) {
    delete _impl_.default_eval_info_;
  }
  _impl_.default_eval_info_ = nullptr;
}
inline const ::clarifai::api::EvalInfo& Model::_internal_default_eval_info() const {
  const ::clarifai::api::EvalInfo* p = _impl_.default_eval_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::EvalInfo&>(
      ::clarifai::api::_EvalInfo_default_instance_);
}
inline const ::clarifai::api::EvalInfo& Model::default_eval_info() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Model.default_eval_info)
  return _internal_default_eval_info();
}
inline void Model::unsafe_arena_set_allocated_default_eval_info(
    ::clarifai::api::EvalInfo* default_eval_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.default_eval_info_);
  }
  _impl_.default_eval_info_ = default_eval_info;
  if (default_eval_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Model.default_eval_info)
}
inline ::clarifai::api::EvalInfo* Model::release_default_eval_info() {
  
  ::clarifai::api::EvalInfo* temp = _impl_.default_eval_info_;
  _impl_.default_eval_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::EvalInfo* Model::unsafe_arena_release_default_eval_info() {
  // @@protoc_insertion_point(field_release:clarifai.api.Model.default_eval_info)
  
  ::clarifai::api::EvalInfo* temp = _impl_.default_eval_info_;
  _impl_.default_eval_info_ = nullptr;
  return temp;
}
inline ::clarifai::api::EvalInfo* Model::_internal_mutable_default_eval_info() {
  
  if (_impl_.default_eval_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::EvalInfo>(GetArenaForAllocation());
    _impl_.default_eval_info_ = p;
  }
  return _impl_.default_eval_info_;
}
inline ::clarifai::api::EvalInfo* Model::mutable_default_eval_info() {
  ::clarifai::api::EvalInfo* _msg = _internal_mutable_default_eval_info();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Model.default_eval_info)
  return _msg;
}
inline void Model::set_allocated_default_eval_info(::clarifai::api::EvalInfo* default_eval_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.default_eval_info_;
  }
  if (default_eval_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(default_eval_info);
    if (message_arena != submessage_arena) {
      default_eval_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, default_eval_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.default_eval_info_ = default_eval_info;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Model.default_eval_info)
}

// string model_type_id = 14;
inline void Model::clear_model_type_id() {
  _impl_.model_type_id_.ClearToEmpty();
}
inline const std::string& Model::model_type_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Model.model_type_id)
  return _internal_model_type_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_model_type_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_type_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Model.model_type_id)
}
inline std::string* Model::mutable_model_type_id() {
  std::string* _s = _internal_mutable_model_type_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Model.model_type_id)
  return _s;
}
inline const std::string& Model::_internal_model_type_id() const {
  return _impl_.model_type_id_.Get();
}
inline void Model::_internal_set_model_type_id(const std::string& value) {
  
  _impl_.model_type_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_model_type_id() {
  
  return _impl_.model_type_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_model_type_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Model.model_type_id)
  return _impl_.model_type_id_.Release();
}
inline void Model::set_allocated_model_type_id(std::string* model_type_id) {
  if (model_type_id != nullptr) {
    
  } else {
    
  }
  _impl_.model_type_id_.SetAllocated(model_type_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_type_id_.IsDefault()) {
    _impl_.model_type_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Model.model_type_id)
}

// string task = 26;
inline void Model::clear_task() {
  _impl_.task_.ClearToEmpty();
}
inline const std::string& Model::task() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Model.task)
  return _internal_task();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_task(ArgT0&& arg0, ArgT... args) {
 
 _impl_.task_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Model.task)
}
inline std::string* Model::mutable_task() {
  std::string* _s = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Model.task)
  return _s;
}
inline const std::string& Model::_internal_task() const {
  return _impl_.task_.Get();
}
inline void Model::_internal_set_task(const std::string& value) {
  
  _impl_.task_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_task() {
  
  return _impl_.task_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_task() {
  // @@protoc_insertion_point(field_release:clarifai.api.Model.task)
  return _impl_.task_.Release();
}
inline void Model::set_allocated_task(std::string* task) {
  if (task != nullptr) {
    
  } else {
    
  }
  _impl_.task_.SetAllocated(task, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.task_.IsDefault()) {
    _impl_.task_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Model.task)
}

// .clarifai.api.Visibility visibility = 15;
inline bool Model::_internal_has_visibility() const {
  return this != internal_default_instance() && _impl_.visibility_ != nullptr;
}
inline bool Model::has_visibility() const {
  return _internal_has_visibility();
}
inline void Model::clear_visibility() {
  if (GetArenaForAllocation() == nullptr && _impl_.visibility_ != nullptr) {
    delete _impl_.visibility_;
  }
  _impl_.visibility_ = nullptr;
}
inline const ::clarifai::api::Visibility& Model::_internal_visibility() const {
  const ::clarifai::api::Visibility* p = _impl_.visibility_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Visibility&>(
      ::clarifai::api::_Visibility_default_instance_);
}
inline const ::clarifai::api::Visibility& Model::visibility() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Model.visibility)
  return _internal_visibility();
}
inline void Model::unsafe_arena_set_allocated_visibility(
    ::clarifai::api::Visibility* visibility) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visibility_);
  }
  _impl_.visibility_ = visibility;
  if (visibility) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Model.visibility)
}
inline ::clarifai::api::Visibility* Model::release_visibility() {
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Visibility* Model::unsafe_arena_release_visibility() {
  // @@protoc_insertion_point(field_release:clarifai.api.Model.visibility)
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
  return temp;
}
inline ::clarifai::api::Visibility* Model::_internal_mutable_visibility() {
  
  if (_impl_.visibility_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Visibility>(GetArenaForAllocation());
    _impl_.visibility_ = p;
  }
  return _impl_.visibility_;
}
inline ::clarifai::api::Visibility* Model::mutable_visibility() {
  ::clarifai::api::Visibility* _msg = _internal_mutable_visibility();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Model.visibility)
  return _msg;
}
inline void Model::set_allocated_visibility(::clarifai::api::Visibility* visibility) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.visibility_;
  }
  if (visibility) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(visibility);
    if (message_arena != submessage_arena) {
      visibility = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visibility, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.visibility_ = visibility;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Model.visibility)
}

// string description = 16;
inline void Model::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Model::description() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Model.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Model.description)
}
inline std::string* Model::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Model.description)
  return _s;
}
inline const std::string& Model::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Model::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_description() {
  // @@protoc_insertion_point(field_release:clarifai.api.Model.description)
  return _impl_.description_.Release();
}
inline void Model::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Model.description)
}

// .google.protobuf.Struct metadata = 17;
inline bool Model::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool Model::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Model::_internal_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Model::metadata() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Model.metadata)
  return _internal_metadata();
}
inline void Model::unsafe_arena_set_allocated_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Model.metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Model::release_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Model::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:clarifai.api.Model.metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Model::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Model::mutable_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Model.metadata)
  return _msg;
}
inline void Model::set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Model.metadata)
}

// .google.protobuf.Struct presets = 27;
inline bool Model::_internal_has_presets() const {
  return this != internal_default_instance() && _impl_.presets_ != nullptr;
}
inline bool Model::has_presets() const {
  return _internal_has_presets();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Model::_internal_presets() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.presets_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Model::presets() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Model.presets)
  return _internal_presets();
}
inline void Model::unsafe_arena_set_allocated_presets(
    ::PROTOBUF_NAMESPACE_ID::Struct* presets) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.presets_);
  }
  _impl_.presets_ = presets;
  if (presets) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Model.presets)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Model::release_presets() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.presets_;
  _impl_.presets_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Model::unsafe_arena_release_presets() {
  // @@protoc_insertion_point(field_release:clarifai.api.Model.presets)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.presets_;
  _impl_.presets_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Model::_internal_mutable_presets() {
  
  if (_impl_.presets_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.presets_ = p;
  }
  return _impl_.presets_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Model::mutable_presets() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_presets();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Model.presets)
  return _msg;
}
inline void Model::set_allocated_presets(::PROTOBUF_NAMESPACE_ID::Struct* presets) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.presets_);
  }
  if (presets) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(presets));
    if (message_arena != submessage_arena) {
      presets = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, presets, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.presets_ = presets;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Model.presets)
}

// string notes = 18;
inline void Model::clear_notes() {
  _impl_.notes_.ClearToEmpty();
}
inline const std::string& Model::notes() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Model.notes)
  return _internal_notes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_notes(ArgT0&& arg0, ArgT... args) {
 
 _impl_.notes_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Model.notes)
}
inline std::string* Model::mutable_notes() {
  std::string* _s = _internal_mutable_notes();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Model.notes)
  return _s;
}
inline const std::string& Model::_internal_notes() const {
  return _impl_.notes_.Get();
}
inline void Model::_internal_set_notes(const std::string& value) {
  
  _impl_.notes_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_notes() {
  
  return _impl_.notes_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_notes() {
  // @@protoc_insertion_point(field_release:clarifai.api.Model.notes)
  return _impl_.notes_.Release();
}
inline void Model::set_allocated_notes(std::string* notes) {
  if (notes != nullptr) {
    
  } else {
    
  }
  _impl_.notes_.SetAllocated(notes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.notes_.IsDefault()) {
    _impl_.notes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Model.notes)
}

// repeated string toolkits = 20 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline int Model::_internal_toolkits_size() const {
  return _impl_.toolkits_.size();
}
inline int Model::toolkits_size() const {
  return _internal_toolkits_size();
}
inline void Model::clear_toolkits() {
  _impl_.toolkits_.Clear();
}
inline std::string* Model::add_toolkits() {
  std::string* _s = _internal_add_toolkits();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.Model.toolkits)
  return _s;
}
inline const std::string& Model::_internal_toolkits(int index) const {
  return _impl_.toolkits_.Get(index);
}
inline const std::string& Model::toolkits(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Model.toolkits)
  return _internal_toolkits(index);
}
inline std::string* Model::mutable_toolkits(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Model.toolkits)
  return _impl_.toolkits_.Mutable(index);
}
inline void Model::set_toolkits(int index, const std::string& value) {
  _impl_.toolkits_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Model.toolkits)
}
inline void Model::set_toolkits(int index, std::string&& value) {
  _impl_.toolkits_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.Model.toolkits)
}
inline void Model::set_toolkits(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.toolkits_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.Model.toolkits)
}
inline void Model::set_toolkits(int index, const char* value, size_t size) {
  _impl_.toolkits_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.Model.toolkits)
}
inline std::string* Model::_internal_add_toolkits() {
  return _impl_.toolkits_.Add();
}
inline void Model::add_toolkits(const std::string& value) {
  _impl_.toolkits_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.Model.toolkits)
}
inline void Model::add_toolkits(std::string&& value) {
  _impl_.toolkits_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.Model.toolkits)
}
inline void Model::add_toolkits(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.toolkits_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.Model.toolkits)
}
inline void Model::add_toolkits(const char* value, size_t size) {
  _impl_.toolkits_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.Model.toolkits)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Model::toolkits() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Model.toolkits)
  return _impl_.toolkits_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Model::mutable_toolkits() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Model.toolkits)
  return &_impl_.toolkits_;
}

// repeated string use_cases = 21 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline int Model::_internal_use_cases_size() const {
  return _impl_.use_cases_.size();
}
inline int Model::use_cases_size() const {
  return _internal_use_cases_size();
}
inline void Model::clear_use_cases() {
  _impl_.use_cases_.Clear();
}
inline std::string* Model::add_use_cases() {
  std::string* _s = _internal_add_use_cases();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.Model.use_cases)
  return _s;
}
inline const std::string& Model::_internal_use_cases(int index) const {
  return _impl_.use_cases_.Get(index);
}
inline const std::string& Model::use_cases(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Model.use_cases)
  return _internal_use_cases(index);
}
inline std::string* Model::mutable_use_cases(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Model.use_cases)
  return _impl_.use_cases_.Mutable(index);
}
inline void Model::set_use_cases(int index, const std::string& value) {
  _impl_.use_cases_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Model.use_cases)
}
inline void Model::set_use_cases(int index, std::string&& value) {
  _impl_.use_cases_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.Model.use_cases)
}
inline void Model::set_use_cases(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.use_cases_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.Model.use_cases)
}
inline void Model::set_use_cases(int index, const char* value, size_t size) {
  _impl_.use_cases_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.Model.use_cases)
}
inline std::string* Model::_internal_add_use_cases() {
  return _impl_.use_cases_.Add();
}
inline void Model::add_use_cases(const std::string& value) {
  _impl_.use_cases_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.Model.use_cases)
}
inline void Model::add_use_cases(std::string&& value) {
  _impl_.use_cases_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.Model.use_cases)
}
inline void Model::add_use_cases(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.use_cases_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.Model.use_cases)
}
inline void Model::add_use_cases(const char* value, size_t size) {
  _impl_.use_cases_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.Model.use_cases)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Model::use_cases() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Model.use_cases)
  return _impl_.use_cases_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Model::mutable_use_cases() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Model.use_cases)
  return &_impl_.use_cases_;
}

// repeated string languages = 25 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline int Model::_internal_languages_size() const {
  return _impl_.languages_.size();
}
inline int Model::languages_size() const {
  return _internal_languages_size();
}
inline void Model::clear_languages() {
  _impl_.languages_.Clear();
}
inline std::string* Model::add_languages() {
  std::string* _s = _internal_add_languages();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.Model.languages)
  return _s;
}
inline const std::string& Model::_internal_languages(int index) const {
  return _impl_.languages_.Get(index);
}
inline const std::string& Model::languages(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Model.languages)
  return _internal_languages(index);
}
inline std::string* Model::mutable_languages(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Model.languages)
  return _impl_.languages_.Mutable(index);
}
inline void Model::set_languages(int index, const std::string& value) {
  _impl_.languages_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Model.languages)
}
inline void Model::set_languages(int index, std::string&& value) {
  _impl_.languages_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.Model.languages)
}
inline void Model::set_languages(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.languages_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.Model.languages)
}
inline void Model::set_languages(int index, const char* value, size_t size) {
  _impl_.languages_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.Model.languages)
}
inline std::string* Model::_internal_add_languages() {
  return _impl_.languages_.Add();
}
inline void Model::add_languages(const std::string& value) {
  _impl_.languages_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.Model.languages)
}
inline void Model::add_languages(std::string&& value) {
  _impl_.languages_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.Model.languages)
}
inline void Model::add_languages(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.languages_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.Model.languages)
}
inline void Model::add_languages(const char* value, size_t size) {
  _impl_.languages_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.Model.languages)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Model::languages() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Model.languages)
  return _impl_.languages_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Model::mutable_languages() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Model.languages)
  return &_impl_.languages_;
}

// repeated .clarifai.api.FullTag languages_full = 31 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline int Model::_internal_languages_full_size() const {
  return _impl_.languages_full_.size();
}
inline int Model::languages_full_size() const {
  return _internal_languages_full_size();
}
inline void Model::clear_languages_full() {
  _impl_.languages_full_.Clear();
}
inline ::clarifai::api::FullTag* Model::mutable_languages_full(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Model.languages_full)
  return _impl_.languages_full_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::FullTag >*
Model::mutable_languages_full() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Model.languages_full)
  return &_impl_.languages_full_;
}
inline const ::clarifai::api::FullTag& Model::_internal_languages_full(int index) const {
  return _impl_.languages_full_.Get(index);
}
inline const ::clarifai::api::FullTag& Model::languages_full(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Model.languages_full)
  return _internal_languages_full(index);
}
inline ::clarifai::api::FullTag* Model::_internal_add_languages_full() {
  return _impl_.languages_full_.Add();
}
inline ::clarifai::api::FullTag* Model::add_languages_full() {
  ::clarifai::api::FullTag* _add = _internal_add_languages_full();
  // @@protoc_insertion_point(field_add:clarifai.api.Model.languages_full)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::FullTag >&
Model::languages_full() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Model.languages_full)
  return _impl_.languages_full_;
}

// repeated string check_consents = 32 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline int Model::_internal_check_consents_size() const {
  return _impl_.check_consents_.size();
}
inline int Model::check_consents_size() const {
  return _internal_check_consents_size();
}
inline void Model::clear_check_consents() {
  _impl_.check_consents_.Clear();
}
inline std::string* Model::add_check_consents() {
  std::string* _s = _internal_add_check_consents();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.Model.check_consents)
  return _s;
}
inline const std::string& Model::_internal_check_consents(int index) const {
  return _impl_.check_consents_.Get(index);
}
inline const std::string& Model::check_consents(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Model.check_consents)
  return _internal_check_consents(index);
}
inline std::string* Model::mutable_check_consents(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Model.check_consents)
  return _impl_.check_consents_.Mutable(index);
}
inline void Model::set_check_consents(int index, const std::string& value) {
  _impl_.check_consents_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Model.check_consents)
}
inline void Model::set_check_consents(int index, std::string&& value) {
  _impl_.check_consents_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.Model.check_consents)
}
inline void Model::set_check_consents(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.check_consents_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.Model.check_consents)
}
inline void Model::set_check_consents(int index, const char* value, size_t size) {
  _impl_.check_consents_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.Model.check_consents)
}
inline std::string* Model::_internal_add_check_consents() {
  return _impl_.check_consents_.Add();
}
inline void Model::add_check_consents(const std::string& value) {
  _impl_.check_consents_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.Model.check_consents)
}
inline void Model::add_check_consents(std::string&& value) {
  _impl_.check_consents_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.Model.check_consents)
}
inline void Model::add_check_consents(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.check_consents_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.Model.check_consents)
}
inline void Model::add_check_consents(const char* value, size_t size) {
  _impl_.check_consents_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.Model.check_consents)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Model::check_consents() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Model.check_consents)
  return _impl_.check_consents_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Model::mutable_check_consents() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Model.check_consents)
  return &_impl_.check_consents_;
}

// bool is_starred = 22;
inline void Model::clear_is_starred() {
  _impl_.is_starred_ = false;
}
inline bool Model::_internal_is_starred() const {
  return _impl_.is_starred_;
}
inline bool Model::is_starred() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Model.is_starred)
  return _internal_is_starred();
}
inline void Model::_internal_set_is_starred(bool value) {
  
  _impl_.is_starred_ = value;
}
inline void Model::set_is_starred(bool value) {
  _internal_set_is_starred(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Model.is_starred)
}

// int32 star_count = 23;
inline void Model::clear_star_count() {
  _impl_.star_count_ = 0;
}
inline int32_t Model::_internal_star_count() const {
  return _impl_.star_count_;
}
inline int32_t Model::star_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Model.star_count)
  return _internal_star_count();
}
inline void Model::_internal_set_star_count(int32_t value) {
  
  _impl_.star_count_ = value;
}
inline void Model::set_star_count(int32_t value) {
  _internal_set_star_count(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Model.star_count)
}

// .clarifai.api.ImportInfo import_info = 24 [deprecated = true];
inline bool Model::_internal_has_import_info() const {
  return this != internal_default_instance() && _impl_.import_info_ != nullptr;
}
inline bool Model::has_import_info() const {
  return _internal_has_import_info();
}
inline void Model::clear_import_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.import_info_ != nullptr) {
    delete _impl_.import_info_;
  }
  _impl_.import_info_ = nullptr;
}
inline const ::clarifai::api::ImportInfo& Model::_internal_import_info() const {
  const ::clarifai::api::ImportInfo* p = _impl_.import_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::ImportInfo&>(
      ::clarifai::api::_ImportInfo_default_instance_);
}
inline const ::clarifai::api::ImportInfo& Model::import_info() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Model.import_info)
  return _internal_import_info();
}
inline void Model::unsafe_arena_set_allocated_import_info(
    ::clarifai::api::ImportInfo* import_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.import_info_);
  }
  _impl_.import_info_ = import_info;
  if (import_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Model.import_info)
}
inline ::clarifai::api::ImportInfo* Model::release_import_info() {
  
  ::clarifai::api::ImportInfo* temp = _impl_.import_info_;
  _impl_.import_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::ImportInfo* Model::unsafe_arena_release_import_info() {
  // @@protoc_insertion_point(field_release:clarifai.api.Model.import_info)
  
  ::clarifai::api::ImportInfo* temp = _impl_.import_info_;
  _impl_.import_info_ = nullptr;
  return temp;
}
inline ::clarifai::api::ImportInfo* Model::_internal_mutable_import_info() {
  
  if (_impl_.import_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::ImportInfo>(GetArenaForAllocation());
    _impl_.import_info_ = p;
  }
  return _impl_.import_info_;
}
inline ::clarifai::api::ImportInfo* Model::mutable_import_info() {
  ::clarifai::api::ImportInfo* _msg = _internal_mutable_import_info();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Model.import_info)
  return _msg;
}
inline void Model::set_allocated_import_info(::clarifai::api::ImportInfo* import_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.import_info_;
  }
  if (import_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(import_info);
    if (message_arena != submessage_arena) {
      import_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, import_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.import_info_ = import_info;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Model.import_info)
}

// .google.protobuf.BoolValue workflow_recommended = 29;
inline bool Model::_internal_has_workflow_recommended() const {
  return this != internal_default_instance() && _impl_.workflow_recommended_ != nullptr;
}
inline bool Model::has_workflow_recommended() const {
  return _internal_has_workflow_recommended();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& Model::_internal_workflow_recommended() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = _impl_.workflow_recommended_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& Model::workflow_recommended() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Model.workflow_recommended)
  return _internal_workflow_recommended();
}
inline void Model::unsafe_arena_set_allocated_workflow_recommended(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* workflow_recommended) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.workflow_recommended_);
  }
  _impl_.workflow_recommended_ = workflow_recommended;
  if (workflow_recommended) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Model.workflow_recommended)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* Model::release_workflow_recommended() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.workflow_recommended_;
  _impl_.workflow_recommended_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* Model::unsafe_arena_release_workflow_recommended() {
  // @@protoc_insertion_point(field_release:clarifai.api.Model.workflow_recommended)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.workflow_recommended_;
  _impl_.workflow_recommended_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* Model::_internal_mutable_workflow_recommended() {
  
  if (_impl_.workflow_recommended_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    _impl_.workflow_recommended_ = p;
  }
  return _impl_.workflow_recommended_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* Model::mutable_workflow_recommended() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_workflow_recommended();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Model.workflow_recommended)
  return _msg;
}
inline void Model::set_allocated_workflow_recommended(::PROTOBUF_NAMESPACE_ID::BoolValue* workflow_recommended) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.workflow_recommended_);
  }
  if (workflow_recommended) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(workflow_recommended));
    if (message_arena != submessage_arena) {
      workflow_recommended = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, workflow_recommended, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.workflow_recommended_ = workflow_recommended;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Model.workflow_recommended)
}

// -------------------------------------------------------------------

// ModelReference

// string id = 1;
inline void ModelReference::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ModelReference::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelReference.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelReference::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModelReference.id)
}
inline std::string* ModelReference::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelReference.id)
  return _s;
}
inline const std::string& ModelReference::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ModelReference::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelReference::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelReference::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelReference.id)
  return _impl_.id_.Release();
}
inline void ModelReference::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelReference.id)
}

// string model_id = 2;
inline void ModelReference::clear_model_id() {
  _impl_.model_id_.ClearToEmpty();
}
inline const std::string& ModelReference::model_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelReference.model_id)
  return _internal_model_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelReference::set_model_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModelReference.model_id)
}
inline std::string* ModelReference::mutable_model_id() {
  std::string* _s = _internal_mutable_model_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelReference.model_id)
  return _s;
}
inline const std::string& ModelReference::_internal_model_id() const {
  return _impl_.model_id_.Get();
}
inline void ModelReference::_internal_set_model_id(const std::string& value) {
  
  _impl_.model_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelReference::_internal_mutable_model_id() {
  
  return _impl_.model_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelReference::release_model_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelReference.model_id)
  return _impl_.model_id_.Release();
}
inline void ModelReference::set_allocated_model_id(std::string* model_id) {
  if (model_id != nullptr) {
    
  } else {
    
  }
  _impl_.model_id_.SetAllocated(model_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_id_.IsDefault()) {
    _impl_.model_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelReference.model_id)
}

// string url = 3;
inline void ModelReference::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& ModelReference::url() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelReference.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelReference::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModelReference.url)
}
inline std::string* ModelReference::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelReference.url)
  return _s;
}
inline const std::string& ModelReference::_internal_url() const {
  return _impl_.url_.Get();
}
inline void ModelReference::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelReference::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelReference::release_url() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelReference.url)
  return _impl_.url_.Release();
}
inline void ModelReference::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelReference.url)
}

// string name = 4;
inline void ModelReference::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelReference::name() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelReference.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelReference::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModelReference.name)
}
inline std::string* ModelReference::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelReference.name)
  return _s;
}
inline const std::string& ModelReference::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelReference::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelReference::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelReference::release_name() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelReference.name)
  return _impl_.name_.Release();
}
inline void ModelReference::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelReference.name)
}

// .google.protobuf.Struct metadata = 5;
inline bool ModelReference::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool ModelReference::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ModelReference::_internal_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ModelReference::metadata() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelReference.metadata)
  return _internal_metadata();
}
inline void ModelReference::unsafe_arena_set_allocated_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.ModelReference.metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ModelReference::release_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ModelReference::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelReference.metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ModelReference::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ModelReference::mutable_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelReference.metadata)
  return _msg;
}
inline void ModelReference::set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelReference.metadata)
}

// -------------------------------------------------------------------

// ModelVersionInputExample

// string id = 1;
inline void ModelVersionInputExample::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ModelVersionInputExample::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelVersionInputExample.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelVersionInputExample::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModelVersionInputExample.id)
}
inline std::string* ModelVersionInputExample::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelVersionInputExample.id)
  return _s;
}
inline const std::string& ModelVersionInputExample::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ModelVersionInputExample::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelVersionInputExample::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelVersionInputExample::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelVersionInputExample.id)
  return _impl_.id_.Release();
}
inline void ModelVersionInputExample::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelVersionInputExample.id)
}

// string model_id = 2;
inline void ModelVersionInputExample::clear_model_id() {
  _impl_.model_id_.ClearToEmpty();
}
inline const std::string& ModelVersionInputExample::model_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelVersionInputExample.model_id)
  return _internal_model_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelVersionInputExample::set_model_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModelVersionInputExample.model_id)
}
inline std::string* ModelVersionInputExample::mutable_model_id() {
  std::string* _s = _internal_mutable_model_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelVersionInputExample.model_id)
  return _s;
}
inline const std::string& ModelVersionInputExample::_internal_model_id() const {
  return _impl_.model_id_.Get();
}
inline void ModelVersionInputExample::_internal_set_model_id(const std::string& value) {
  
  _impl_.model_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelVersionInputExample::_internal_mutable_model_id() {
  
  return _impl_.model_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelVersionInputExample::release_model_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelVersionInputExample.model_id)
  return _impl_.model_id_.Release();
}
inline void ModelVersionInputExample::set_allocated_model_id(std::string* model_id) {
  if (model_id != nullptr) {
    
  } else {
    
  }
  _impl_.model_id_.SetAllocated(model_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_id_.IsDefault()) {
    _impl_.model_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelVersionInputExample.model_id)
}

// string model_version_id = 3;
inline void ModelVersionInputExample::clear_model_version_id() {
  _impl_.model_version_id_.ClearToEmpty();
}
inline const std::string& ModelVersionInputExample::model_version_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelVersionInputExample.model_version_id)
  return _internal_model_version_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelVersionInputExample::set_model_version_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_version_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModelVersionInputExample.model_version_id)
}
inline std::string* ModelVersionInputExample::mutable_model_version_id() {
  std::string* _s = _internal_mutable_model_version_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelVersionInputExample.model_version_id)
  return _s;
}
inline const std::string& ModelVersionInputExample::_internal_model_version_id() const {
  return _impl_.model_version_id_.Get();
}
inline void ModelVersionInputExample::_internal_set_model_version_id(const std::string& value) {
  
  _impl_.model_version_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelVersionInputExample::_internal_mutable_model_version_id() {
  
  return _impl_.model_version_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelVersionInputExample::release_model_version_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelVersionInputExample.model_version_id)
  return _impl_.model_version_id_.Release();
}
inline void ModelVersionInputExample::set_allocated_model_version_id(std::string* model_version_id) {
  if (model_version_id != nullptr) {
    
  } else {
    
  }
  _impl_.model_version_id_.SetAllocated(model_version_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_version_id_.IsDefault()) {
    _impl_.model_version_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelVersionInputExample.model_version_id)
}

// .clarifai.api.Data data = 4;
inline bool ModelVersionInputExample::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool ModelVersionInputExample::has_data() const {
  return _internal_has_data();
}
inline void ModelVersionInputExample::clear_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.data_ != nullptr) {
    delete _impl_.data_;
  }
  _impl_.data_ = nullptr;
}
inline const ::clarifai::api::Data& ModelVersionInputExample::_internal_data() const {
  const ::clarifai::api::Data* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Data&>(
      ::clarifai::api::_Data_default_instance_);
}
inline const ::clarifai::api::Data& ModelVersionInputExample::data() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelVersionInputExample.data)
  return _internal_data();
}
inline void ModelVersionInputExample::unsafe_arena_set_allocated_data(
    ::clarifai::api::Data* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.ModelVersionInputExample.data)
}
inline ::clarifai::api::Data* ModelVersionInputExample::release_data() {
  
  ::clarifai::api::Data* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Data* ModelVersionInputExample::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelVersionInputExample.data)
  
  ::clarifai::api::Data* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::clarifai::api::Data* ModelVersionInputExample::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Data>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::clarifai::api::Data* ModelVersionInputExample::mutable_data() {
  ::clarifai::api::Data* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelVersionInputExample.data)
  return _msg;
}
inline void ModelVersionInputExample::set_allocated_data(::clarifai::api::Data* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelVersionInputExample.data)
}

// string name = 5;
inline void ModelVersionInputExample::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelVersionInputExample::name() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelVersionInputExample.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelVersionInputExample::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModelVersionInputExample.name)
}
inline std::string* ModelVersionInputExample::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelVersionInputExample.name)
  return _s;
}
inline const std::string& ModelVersionInputExample::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelVersionInputExample::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelVersionInputExample::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelVersionInputExample::release_name() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelVersionInputExample.name)
  return _impl_.name_.Release();
}
inline void ModelVersionInputExample::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelVersionInputExample.name)
}

// string description = 6;
inline void ModelVersionInputExample::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ModelVersionInputExample::description() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelVersionInputExample.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelVersionInputExample::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModelVersionInputExample.description)
}
inline std::string* ModelVersionInputExample::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelVersionInputExample.description)
  return _s;
}
inline const std::string& ModelVersionInputExample::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ModelVersionInputExample::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelVersionInputExample::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelVersionInputExample::release_description() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelVersionInputExample.description)
  return _impl_.description_.Release();
}
inline void ModelVersionInputExample::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelVersionInputExample.description)
}

// -------------------------------------------------------------------

// OutputInfo

// .clarifai.api.Data data = 1;
inline bool OutputInfo::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool OutputInfo::has_data() const {
  return _internal_has_data();
}
inline void OutputInfo::clear_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.data_ != nullptr) {
    delete _impl_.data_;
  }
  _impl_.data_ = nullptr;
}
inline const ::clarifai::api::Data& OutputInfo::_internal_data() const {
  const ::clarifai::api::Data* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Data&>(
      ::clarifai::api::_Data_default_instance_);
}
inline const ::clarifai::api::Data& OutputInfo::data() const {
  // @@protoc_insertion_point(field_get:clarifai.api.OutputInfo.data)
  return _internal_data();
}
inline void OutputInfo::unsafe_arena_set_allocated_data(
    ::clarifai::api::Data* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.OutputInfo.data)
}
inline ::clarifai::api::Data* OutputInfo::release_data() {
  
  ::clarifai::api::Data* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Data* OutputInfo::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:clarifai.api.OutputInfo.data)
  
  ::clarifai::api::Data* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::clarifai::api::Data* OutputInfo::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Data>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::clarifai::api::Data* OutputInfo::mutable_data() {
  ::clarifai::api::Data* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:clarifai.api.OutputInfo.data)
  return _msg;
}
inline void OutputInfo::set_allocated_data(::clarifai::api::Data* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.OutputInfo.data)
}

// .clarifai.api.OutputConfig output_config = 2;
inline bool OutputInfo::_internal_has_output_config() const {
  return this != internal_default_instance() && _impl_.output_config_ != nullptr;
}
inline bool OutputInfo::has_output_config() const {
  return _internal_has_output_config();
}
inline void OutputInfo::clear_output_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.output_config_ != nullptr) {
    delete _impl_.output_config_;
  }
  _impl_.output_config_ = nullptr;
}
inline const ::clarifai::api::OutputConfig& OutputInfo::_internal_output_config() const {
  const ::clarifai::api::OutputConfig* p = _impl_.output_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::OutputConfig&>(
      ::clarifai::api::_OutputConfig_default_instance_);
}
inline const ::clarifai::api::OutputConfig& OutputInfo::output_config() const {
  // @@protoc_insertion_point(field_get:clarifai.api.OutputInfo.output_config)
  return _internal_output_config();
}
inline void OutputInfo::unsafe_arena_set_allocated_output_config(
    ::clarifai::api::OutputConfig* output_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.output_config_);
  }
  _impl_.output_config_ = output_config;
  if (output_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.OutputInfo.output_config)
}
inline ::clarifai::api::OutputConfig* OutputInfo::release_output_config() {
  
  ::clarifai::api::OutputConfig* temp = _impl_.output_config_;
  _impl_.output_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::OutputConfig* OutputInfo::unsafe_arena_release_output_config() {
  // @@protoc_insertion_point(field_release:clarifai.api.OutputInfo.output_config)
  
  ::clarifai::api::OutputConfig* temp = _impl_.output_config_;
  _impl_.output_config_ = nullptr;
  return temp;
}
inline ::clarifai::api::OutputConfig* OutputInfo::_internal_mutable_output_config() {
  
  if (_impl_.output_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::OutputConfig>(GetArenaForAllocation());
    _impl_.output_config_ = p;
  }
  return _impl_.output_config_;
}
inline ::clarifai::api::OutputConfig* OutputInfo::mutable_output_config() {
  ::clarifai::api::OutputConfig* _msg = _internal_mutable_output_config();
  // @@protoc_insertion_point(field_mutable:clarifai.api.OutputInfo.output_config)
  return _msg;
}
inline void OutputInfo::set_allocated_output_config(::clarifai::api::OutputConfig* output_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.output_config_;
  }
  if (output_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(output_config);
    if (message_arena != submessage_arena) {
      output_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, output_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.output_config_ = output_config;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.OutputInfo.output_config)
}

// string message = 3;
inline void OutputInfo::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& OutputInfo::message() const {
  // @@protoc_insertion_point(field_get:clarifai.api.OutputInfo.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OutputInfo::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.OutputInfo.message)
}
inline std::string* OutputInfo::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:clarifai.api.OutputInfo.message)
  return _s;
}
inline const std::string& OutputInfo::_internal_message() const {
  return _impl_.message_.Get();
}
inline void OutputInfo::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* OutputInfo::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* OutputInfo::release_message() {
  // @@protoc_insertion_point(field_release:clarifai.api.OutputInfo.message)
  return _impl_.message_.Release();
}
inline void OutputInfo::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.OutputInfo.message)
}

// .google.protobuf.Struct fields_map = 6;
inline bool OutputInfo::_internal_has_fields_map() const {
  return this != internal_default_instance() && _impl_.fields_map_ != nullptr;
}
inline bool OutputInfo::has_fields_map() const {
  return _internal_has_fields_map();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& OutputInfo::_internal_fields_map() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.fields_map_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& OutputInfo::fields_map() const {
  // @@protoc_insertion_point(field_get:clarifai.api.OutputInfo.fields_map)
  return _internal_fields_map();
}
inline void OutputInfo::unsafe_arena_set_allocated_fields_map(
    ::PROTOBUF_NAMESPACE_ID::Struct* fields_map) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fields_map_);
  }
  _impl_.fields_map_ = fields_map;
  if (fields_map) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.OutputInfo.fields_map)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* OutputInfo::release_fields_map() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.fields_map_;
  _impl_.fields_map_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* OutputInfo::unsafe_arena_release_fields_map() {
  // @@protoc_insertion_point(field_release:clarifai.api.OutputInfo.fields_map)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.fields_map_;
  _impl_.fields_map_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* OutputInfo::_internal_mutable_fields_map() {
  
  if (_impl_.fields_map_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.fields_map_ = p;
  }
  return _impl_.fields_map_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* OutputInfo::mutable_fields_map() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_fields_map();
  // @@protoc_insertion_point(field_mutable:clarifai.api.OutputInfo.fields_map)
  return _msg;
}
inline void OutputInfo::set_allocated_fields_map(::PROTOBUF_NAMESPACE_ID::Struct* fields_map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fields_map_);
  }
  if (fields_map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fields_map));
    if (message_arena != submessage_arena) {
      fields_map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fields_map, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fields_map_ = fields_map;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.OutputInfo.fields_map)
}

// .google.protobuf.Struct params = 7;
inline bool OutputInfo::_internal_has_params() const {
  return this != internal_default_instance() && _impl_.params_ != nullptr;
}
inline bool OutputInfo::has_params() const {
  return _internal_has_params();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& OutputInfo::_internal_params() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& OutputInfo::params() const {
  // @@protoc_insertion_point(field_get:clarifai.api.OutputInfo.params)
  return _internal_params();
}
inline void OutputInfo::unsafe_arena_set_allocated_params(
    ::PROTOBUF_NAMESPACE_ID::Struct* params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = params;
  if (params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.OutputInfo.params)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* OutputInfo::release_params() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.params_;
  _impl_.params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* OutputInfo::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_release:clarifai.api.OutputInfo.params)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* OutputInfo::_internal_mutable_params() {
  
  if (_impl_.params_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.params_ = p;
  }
  return _impl_.params_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* OutputInfo::mutable_params() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:clarifai.api.OutputInfo.params)
  return _msg;
}
inline void OutputInfo::set_allocated_params(::PROTOBUF_NAMESPACE_ID::Struct* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(params));
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.params_ = params;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.OutputInfo.params)
}

// -------------------------------------------------------------------

// InputInfo

// .google.protobuf.Struct fields_map = 1;
inline bool InputInfo::_internal_has_fields_map() const {
  return this != internal_default_instance() && _impl_.fields_map_ != nullptr;
}
inline bool InputInfo::has_fields_map() const {
  return _internal_has_fields_map();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& InputInfo::_internal_fields_map() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.fields_map_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& InputInfo::fields_map() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputInfo.fields_map)
  return _internal_fields_map();
}
inline void InputInfo::unsafe_arena_set_allocated_fields_map(
    ::PROTOBUF_NAMESPACE_ID::Struct* fields_map) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fields_map_);
  }
  _impl_.fields_map_ = fields_map;
  if (fields_map) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.InputInfo.fields_map)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* InputInfo::release_fields_map() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.fields_map_;
  _impl_.fields_map_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* InputInfo::unsafe_arena_release_fields_map() {
  // @@protoc_insertion_point(field_release:clarifai.api.InputInfo.fields_map)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.fields_map_;
  _impl_.fields_map_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* InputInfo::_internal_mutable_fields_map() {
  
  if (_impl_.fields_map_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.fields_map_ = p;
  }
  return _impl_.fields_map_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* InputInfo::mutable_fields_map() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_fields_map();
  // @@protoc_insertion_point(field_mutable:clarifai.api.InputInfo.fields_map)
  return _msg;
}
inline void InputInfo::set_allocated_fields_map(::PROTOBUF_NAMESPACE_ID::Struct* fields_map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fields_map_);
  }
  if (fields_map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fields_map));
    if (message_arena != submessage_arena) {
      fields_map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fields_map, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fields_map_ = fields_map;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.InputInfo.fields_map)
}

// .google.protobuf.Struct params = 2;
inline bool InputInfo::_internal_has_params() const {
  return this != internal_default_instance() && _impl_.params_ != nullptr;
}
inline bool InputInfo::has_params() const {
  return _internal_has_params();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& InputInfo::_internal_params() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& InputInfo::params() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputInfo.params)
  return _internal_params();
}
inline void InputInfo::unsafe_arena_set_allocated_params(
    ::PROTOBUF_NAMESPACE_ID::Struct* params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = params;
  if (params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.InputInfo.params)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* InputInfo::release_params() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.params_;
  _impl_.params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* InputInfo::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_release:clarifai.api.InputInfo.params)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* InputInfo::_internal_mutable_params() {
  
  if (_impl_.params_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.params_ = p;
  }
  return _impl_.params_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* InputInfo::mutable_params() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:clarifai.api.InputInfo.params)
  return _msg;
}
inline void InputInfo::set_allocated_params(::PROTOBUF_NAMESPACE_ID::Struct* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(params));
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.params_ = params;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.InputInfo.params)
}

// -------------------------------------------------------------------

// TrainInfo

// .google.protobuf.Struct params = 1;
inline bool TrainInfo::_internal_has_params() const {
  return this != internal_default_instance() && _impl_.params_ != nullptr;
}
inline bool TrainInfo::has_params() const {
  return _internal_has_params();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& TrainInfo::_internal_params() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& TrainInfo::params() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TrainInfo.params)
  return _internal_params();
}
inline void TrainInfo::unsafe_arena_set_allocated_params(
    ::PROTOBUF_NAMESPACE_ID::Struct* params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = params;
  if (params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.TrainInfo.params)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* TrainInfo::release_params() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.params_;
  _impl_.params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* TrainInfo::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_release:clarifai.api.TrainInfo.params)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* TrainInfo::_internal_mutable_params() {
  
  if (_impl_.params_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.params_ = p;
  }
  return _impl_.params_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* TrainInfo::mutable_params() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:clarifai.api.TrainInfo.params)
  return _msg;
}
inline void TrainInfo::set_allocated_params(::PROTOBUF_NAMESPACE_ID::Struct* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(params));
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.params_ = params;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.TrainInfo.params)
}

// -------------------------------------------------------------------

// EvalInfo

// .google.protobuf.Struct params = 1;
inline bool EvalInfo::_internal_has_params() const {
  return this != internal_default_instance() && _impl_.params_ != nullptr;
}
inline bool EvalInfo::has_params() const {
  return _internal_has_params();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& EvalInfo::_internal_params() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& EvalInfo::params() const {
  // @@protoc_insertion_point(field_get:clarifai.api.EvalInfo.params)
  return _internal_params();
}
inline void EvalInfo::unsafe_arena_set_allocated_params(
    ::PROTOBUF_NAMESPACE_ID::Struct* params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = params;
  if (params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.EvalInfo.params)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* EvalInfo::release_params() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.params_;
  _impl_.params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* EvalInfo::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_release:clarifai.api.EvalInfo.params)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* EvalInfo::_internal_mutable_params() {
  
  if (_impl_.params_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.params_ = p;
  }
  return _impl_.params_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* EvalInfo::mutable_params() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:clarifai.api.EvalInfo.params)
  return _msg;
}
inline void EvalInfo::set_allocated_params(::PROTOBUF_NAMESPACE_ID::Struct* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(params));
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.params_ = params;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.EvalInfo.params)
}

// -------------------------------------------------------------------

// ImportInfo

// .google.protobuf.Struct params = 1;
inline bool ImportInfo::_internal_has_params() const {
  return this != internal_default_instance() && _impl_.params_ != nullptr;
}
inline bool ImportInfo::has_params() const {
  return _internal_has_params();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ImportInfo::_internal_params() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ImportInfo::params() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ImportInfo.params)
  return _internal_params();
}
inline void ImportInfo::unsafe_arena_set_allocated_params(
    ::PROTOBUF_NAMESPACE_ID::Struct* params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = params;
  if (params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.ImportInfo.params)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ImportInfo::release_params() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.params_;
  _impl_.params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ImportInfo::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_release:clarifai.api.ImportInfo.params)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ImportInfo::_internal_mutable_params() {
  
  if (_impl_.params_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.params_ = p;
  }
  return _impl_.params_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ImportInfo::mutable_params() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ImportInfo.params)
  return _msg;
}
inline void ImportInfo::set_allocated_params(::PROTOBUF_NAMESPACE_ID::Struct* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(params));
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.params_ = params;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ImportInfo.params)
}

// -------------------------------------------------------------------

// OutputConfig

// bool concepts_mutually_exclusive = 1 [deprecated = true];
inline void OutputConfig::clear_concepts_mutually_exclusive() {
  _impl_.concepts_mutually_exclusive_ = false;
}
inline bool OutputConfig::_internal_concepts_mutually_exclusive() const {
  return _impl_.concepts_mutually_exclusive_;
}
inline bool OutputConfig::concepts_mutually_exclusive() const {
  // @@protoc_insertion_point(field_get:clarifai.api.OutputConfig.concepts_mutually_exclusive)
  return _internal_concepts_mutually_exclusive();
}
inline void OutputConfig::_internal_set_concepts_mutually_exclusive(bool value) {
  
  _impl_.concepts_mutually_exclusive_ = value;
}
inline void OutputConfig::set_concepts_mutually_exclusive(bool value) {
  _internal_set_concepts_mutually_exclusive(value);
  // @@protoc_insertion_point(field_set:clarifai.api.OutputConfig.concepts_mutually_exclusive)
}

// bool closed_environment = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void OutputConfig::clear_closed_environment() {
  _impl_.closed_environment_ = false;
}
inline bool OutputConfig::_internal_closed_environment() const {
  return _impl_.closed_environment_;
}
inline bool OutputConfig::closed_environment() const {
  // @@protoc_insertion_point(field_get:clarifai.api.OutputConfig.closed_environment)
  return _internal_closed_environment();
}
inline void OutputConfig::_internal_set_closed_environment(bool value) {
  
  _impl_.closed_environment_ = value;
}
inline void OutputConfig::set_closed_environment(bool value) {
  _internal_set_closed_environment(value);
  // @@protoc_insertion_point(field_set:clarifai.api.OutputConfig.closed_environment)
}

// string existing_model_id = 3 [deprecated = true];
inline void OutputConfig::clear_existing_model_id() {
  _impl_.existing_model_id_.ClearToEmpty();
}
inline const std::string& OutputConfig::existing_model_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.OutputConfig.existing_model_id)
  return _internal_existing_model_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OutputConfig::set_existing_model_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.existing_model_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.OutputConfig.existing_model_id)
}
inline std::string* OutputConfig::mutable_existing_model_id() {
  std::string* _s = _internal_mutable_existing_model_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.OutputConfig.existing_model_id)
  return _s;
}
inline const std::string& OutputConfig::_internal_existing_model_id() const {
  return _impl_.existing_model_id_.Get();
}
inline void OutputConfig::_internal_set_existing_model_id(const std::string& value) {
  
  _impl_.existing_model_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OutputConfig::_internal_mutable_existing_model_id() {
  
  return _impl_.existing_model_id_.Mutable(GetArenaForAllocation());
}
inline std::string* OutputConfig::release_existing_model_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.OutputConfig.existing_model_id)
  return _impl_.existing_model_id_.Release();
}
inline void OutputConfig::set_allocated_existing_model_id(std::string* existing_model_id) {
  if (existing_model_id != nullptr) {
    
  } else {
    
  }
  _impl_.existing_model_id_.SetAllocated(existing_model_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.existing_model_id_.IsDefault()) {
    _impl_.existing_model_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.OutputConfig.existing_model_id)
}

// string language = 4;
inline void OutputConfig::clear_language() {
  _impl_.language_.ClearToEmpty();
}
inline const std::string& OutputConfig::language() const {
  // @@protoc_insertion_point(field_get:clarifai.api.OutputConfig.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OutputConfig::set_language(ArgT0&& arg0, ArgT... args) {
 
 _impl_.language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.OutputConfig.language)
}
inline std::string* OutputConfig::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:clarifai.api.OutputConfig.language)
  return _s;
}
inline const std::string& OutputConfig::_internal_language() const {
  return _impl_.language_.Get();
}
inline void OutputConfig::_internal_set_language(const std::string& value) {
  
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* OutputConfig::_internal_mutable_language() {
  
  return _impl_.language_.Mutable(GetArenaForAllocation());
}
inline std::string* OutputConfig::release_language() {
  // @@protoc_insertion_point(field_release:clarifai.api.OutputConfig.language)
  return _impl_.language_.Release();
}
inline void OutputConfig::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    
  } else {
    
  }
  _impl_.language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.OutputConfig.language)
}

// string hyper_parameters = 5 [deprecated = true];
inline void OutputConfig::clear_hyper_parameters() {
  _impl_.hyper_parameters_.ClearToEmpty();
}
inline const std::string& OutputConfig::hyper_parameters() const {
  // @@protoc_insertion_point(field_get:clarifai.api.OutputConfig.hyper_parameters)
  return _internal_hyper_parameters();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OutputConfig::set_hyper_parameters(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hyper_parameters_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.OutputConfig.hyper_parameters)
}
inline std::string* OutputConfig::mutable_hyper_parameters() {
  std::string* _s = _internal_mutable_hyper_parameters();
  // @@protoc_insertion_point(field_mutable:clarifai.api.OutputConfig.hyper_parameters)
  return _s;
}
inline const std::string& OutputConfig::_internal_hyper_parameters() const {
  return _impl_.hyper_parameters_.Get();
}
inline void OutputConfig::_internal_set_hyper_parameters(const std::string& value) {
  
  _impl_.hyper_parameters_.Set(value, GetArenaForAllocation());
}
inline std::string* OutputConfig::_internal_mutable_hyper_parameters() {
  
  return _impl_.hyper_parameters_.Mutable(GetArenaForAllocation());
}
inline std::string* OutputConfig::release_hyper_parameters() {
  // @@protoc_insertion_point(field_release:clarifai.api.OutputConfig.hyper_parameters)
  return _impl_.hyper_parameters_.Release();
}
inline void OutputConfig::set_allocated_hyper_parameters(std::string* hyper_parameters) {
  if (hyper_parameters != nullptr) {
    
  } else {
    
  }
  _impl_.hyper_parameters_.SetAllocated(hyper_parameters, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hyper_parameters_.IsDefault()) {
    _impl_.hyper_parameters_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.OutputConfig.hyper_parameters)
}

// uint32 max_concepts = 6 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void OutputConfig::clear_max_concepts() {
  _impl_.max_concepts_ = 0u;
}
inline uint32_t OutputConfig::_internal_max_concepts() const {
  return _impl_.max_concepts_;
}
inline uint32_t OutputConfig::max_concepts() const {
  // @@protoc_insertion_point(field_get:clarifai.api.OutputConfig.max_concepts)
  return _internal_max_concepts();
}
inline void OutputConfig::_internal_set_max_concepts(uint32_t value) {
  
  _impl_.max_concepts_ = value;
}
inline void OutputConfig::set_max_concepts(uint32_t value) {
  _internal_set_max_concepts(value);
  // @@protoc_insertion_point(field_set:clarifai.api.OutputConfig.max_concepts)
}

// float min_value = 7 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void OutputConfig::clear_min_value() {
  _impl_.min_value_ = 0;
}
inline float OutputConfig::_internal_min_value() const {
  return _impl_.min_value_;
}
inline float OutputConfig::min_value() const {
  // @@protoc_insertion_point(field_get:clarifai.api.OutputConfig.min_value)
  return _internal_min_value();
}
inline void OutputConfig::_internal_set_min_value(float value) {
  
  _impl_.min_value_ = value;
}
inline void OutputConfig::set_min_value(float value) {
  _internal_set_min_value(value);
  // @@protoc_insertion_point(field_set:clarifai.api.OutputConfig.min_value)
}

// repeated .clarifai.api.Concept select_concepts = 8;
inline int OutputConfig::_internal_select_concepts_size() const {
  return _impl_.select_concepts_.size();
}
inline int OutputConfig::select_concepts_size() const {
  return _internal_select_concepts_size();
}
inline void OutputConfig::clear_select_concepts() {
  _impl_.select_concepts_.Clear();
}
inline ::clarifai::api::Concept* OutputConfig::mutable_select_concepts(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.OutputConfig.select_concepts)
  return _impl_.select_concepts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept >*
OutputConfig::mutable_select_concepts() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.OutputConfig.select_concepts)
  return &_impl_.select_concepts_;
}
inline const ::clarifai::api::Concept& OutputConfig::_internal_select_concepts(int index) const {
  return _impl_.select_concepts_.Get(index);
}
inline const ::clarifai::api::Concept& OutputConfig::select_concepts(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.OutputConfig.select_concepts)
  return _internal_select_concepts(index);
}
inline ::clarifai::api::Concept* OutputConfig::_internal_add_select_concepts() {
  return _impl_.select_concepts_.Add();
}
inline ::clarifai::api::Concept* OutputConfig::add_select_concepts() {
  ::clarifai::api::Concept* _add = _internal_add_select_concepts();
  // @@protoc_insertion_point(field_add:clarifai.api.OutputConfig.select_concepts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept >&
OutputConfig::select_concepts() const {
  // @@protoc_insertion_point(field_list:clarifai.api.OutputConfig.select_concepts)
  return _impl_.select_concepts_;
}

// uint32 training_timeout = 9;
inline void OutputConfig::clear_training_timeout() {
  _impl_.training_timeout_ = 0u;
}
inline uint32_t OutputConfig::_internal_training_timeout() const {
  return _impl_.training_timeout_;
}
inline uint32_t OutputConfig::training_timeout() const {
  // @@protoc_insertion_point(field_get:clarifai.api.OutputConfig.training_timeout)
  return _internal_training_timeout();
}
inline void OutputConfig::_internal_set_training_timeout(uint32_t value) {
  
  _impl_.training_timeout_ = value;
}
inline void OutputConfig::set_training_timeout(uint32_t value) {
  _internal_set_training_timeout(value);
  // @@protoc_insertion_point(field_set:clarifai.api.OutputConfig.training_timeout)
}

// uint32 sample_ms = 10;
inline void OutputConfig::clear_sample_ms() {
  _impl_.sample_ms_ = 0u;
}
inline uint32_t OutputConfig::_internal_sample_ms() const {
  return _impl_.sample_ms_;
}
inline uint32_t OutputConfig::sample_ms() const {
  // @@protoc_insertion_point(field_get:clarifai.api.OutputConfig.sample_ms)
  return _internal_sample_ms();
}
inline void OutputConfig::_internal_set_sample_ms(uint32_t value) {
  
  _impl_.sample_ms_ = value;
}
inline void OutputConfig::set_sample_ms(uint32_t value) {
  _internal_set_sample_ms(value);
  // @@protoc_insertion_point(field_set:clarifai.api.OutputConfig.sample_ms)
}

// .google.protobuf.Struct hyper_params = 13;
inline bool OutputConfig::_internal_has_hyper_params() const {
  return this != internal_default_instance() && _impl_.hyper_params_ != nullptr;
}
inline bool OutputConfig::has_hyper_params() const {
  return _internal_has_hyper_params();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& OutputConfig::_internal_hyper_params() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.hyper_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& OutputConfig::hyper_params() const {
  // @@protoc_insertion_point(field_get:clarifai.api.OutputConfig.hyper_params)
  return _internal_hyper_params();
}
inline void OutputConfig::unsafe_arena_set_allocated_hyper_params(
    ::PROTOBUF_NAMESPACE_ID::Struct* hyper_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hyper_params_);
  }
  _impl_.hyper_params_ = hyper_params;
  if (hyper_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.OutputConfig.hyper_params)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* OutputConfig::release_hyper_params() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.hyper_params_;
  _impl_.hyper_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* OutputConfig::unsafe_arena_release_hyper_params() {
  // @@protoc_insertion_point(field_release:clarifai.api.OutputConfig.hyper_params)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.hyper_params_;
  _impl_.hyper_params_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* OutputConfig::_internal_mutable_hyper_params() {
  
  if (_impl_.hyper_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.hyper_params_ = p;
  }
  return _impl_.hyper_params_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* OutputConfig::mutable_hyper_params() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_hyper_params();
  // @@protoc_insertion_point(field_mutable:clarifai.api.OutputConfig.hyper_params)
  return _msg;
}
inline void OutputConfig::set_allocated_hyper_params(::PROTOBUF_NAMESPACE_ID::Struct* hyper_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hyper_params_);
  }
  if (hyper_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hyper_params));
    if (message_arena != submessage_arena) {
      hyper_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hyper_params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.hyper_params_ = hyper_params;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.OutputConfig.hyper_params)
}

// string embed_model_version_id = 14;
inline void OutputConfig::clear_embed_model_version_id() {
  _impl_.embed_model_version_id_.ClearToEmpty();
}
inline const std::string& OutputConfig::embed_model_version_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.OutputConfig.embed_model_version_id)
  return _internal_embed_model_version_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OutputConfig::set_embed_model_version_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.embed_model_version_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.OutputConfig.embed_model_version_id)
}
inline std::string* OutputConfig::mutable_embed_model_version_id() {
  std::string* _s = _internal_mutable_embed_model_version_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.OutputConfig.embed_model_version_id)
  return _s;
}
inline const std::string& OutputConfig::_internal_embed_model_version_id() const {
  return _impl_.embed_model_version_id_.Get();
}
inline void OutputConfig::_internal_set_embed_model_version_id(const std::string& value) {
  
  _impl_.embed_model_version_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OutputConfig::_internal_mutable_embed_model_version_id() {
  
  return _impl_.embed_model_version_id_.Mutable(GetArenaForAllocation());
}
inline std::string* OutputConfig::release_embed_model_version_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.OutputConfig.embed_model_version_id)
  return _impl_.embed_model_version_id_.Release();
}
inline void OutputConfig::set_allocated_embed_model_version_id(std::string* embed_model_version_id) {
  if (embed_model_version_id != nullptr) {
    
  } else {
    
  }
  _impl_.embed_model_version_id_.SetAllocated(embed_model_version_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.embed_model_version_id_.IsDefault()) {
    _impl_.embed_model_version_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.OutputConfig.embed_model_version_id)
}

// bool fail_on_missing_positive_examples = 15;
inline void OutputConfig::clear_fail_on_missing_positive_examples() {
  _impl_.fail_on_missing_positive_examples_ = false;
}
inline bool OutputConfig::_internal_fail_on_missing_positive_examples() const {
  return _impl_.fail_on_missing_positive_examples_;
}
inline bool OutputConfig::fail_on_missing_positive_examples() const {
  // @@protoc_insertion_point(field_get:clarifai.api.OutputConfig.fail_on_missing_positive_examples)
  return _internal_fail_on_missing_positive_examples();
}
inline void OutputConfig::_internal_set_fail_on_missing_positive_examples(bool value) {
  
  _impl_.fail_on_missing_positive_examples_ = value;
}
inline void OutputConfig::set_fail_on_missing_positive_examples(bool value) {
  _internal_set_fail_on_missing_positive_examples(value);
  // @@protoc_insertion_point(field_set:clarifai.api.OutputConfig.fail_on_missing_positive_examples)
}

// .google.protobuf.Struct model_metadata = 17 [deprecated = true];
inline bool OutputConfig::_internal_has_model_metadata() const {
  return this != internal_default_instance() && _impl_.model_metadata_ != nullptr;
}
inline bool OutputConfig::has_model_metadata() const {
  return _internal_has_model_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& OutputConfig::_internal_model_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.model_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& OutputConfig::model_metadata() const {
  // @@protoc_insertion_point(field_get:clarifai.api.OutputConfig.model_metadata)
  return _internal_model_metadata();
}
inline void OutputConfig::unsafe_arena_set_allocated_model_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* model_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.model_metadata_);
  }
  _impl_.model_metadata_ = model_metadata;
  if (model_metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.OutputConfig.model_metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* OutputConfig::release_model_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.model_metadata_;
  _impl_.model_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* OutputConfig::unsafe_arena_release_model_metadata() {
  // @@protoc_insertion_point(field_release:clarifai.api.OutputConfig.model_metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.model_metadata_;
  _impl_.model_metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* OutputConfig::_internal_mutable_model_metadata() {
  
  if (_impl_.model_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.model_metadata_ = p;
  }
  return _impl_.model_metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* OutputConfig::mutable_model_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_model_metadata();
  // @@protoc_insertion_point(field_mutable:clarifai.api.OutputConfig.model_metadata)
  return _msg;
}
inline void OutputConfig::set_allocated_model_metadata(::PROTOBUF_NAMESPACE_ID::Struct* model_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.model_metadata_);
  }
  if (model_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(model_metadata));
    if (message_arena != submessage_arena) {
      model_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model_metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.model_metadata_ = model_metadata;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.OutputConfig.model_metadata)
}

// -------------------------------------------------------------------

// ModelType

// string id = 1;
inline void ModelType::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ModelType::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelType.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelType::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModelType.id)
}
inline std::string* ModelType::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelType.id)
  return _s;
}
inline const std::string& ModelType::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ModelType::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelType::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelType::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelType.id)
  return _impl_.id_.Release();
}
inline void ModelType::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelType.id)
}

// string title = 2;
inline void ModelType::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& ModelType::title() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelType.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelType::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModelType.title)
}
inline std::string* ModelType::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelType.title)
  return _s;
}
inline const std::string& ModelType::_internal_title() const {
  return _impl_.title_.Get();
}
inline void ModelType::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelType::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelType::release_title() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelType.title)
  return _impl_.title_.Release();
}
inline void ModelType::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelType.title)
}

// string description = 3;
inline void ModelType::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ModelType::description() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelType.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelType::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModelType.description)
}
inline std::string* ModelType::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelType.description)
  return _s;
}
inline const std::string& ModelType::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ModelType::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelType::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelType::release_description() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelType.description)
  return _impl_.description_.Release();
}
inline void ModelType::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelType.description)
}

// repeated string input_fields = 5;
inline int ModelType::_internal_input_fields_size() const {
  return _impl_.input_fields_.size();
}
inline int ModelType::input_fields_size() const {
  return _internal_input_fields_size();
}
inline void ModelType::clear_input_fields() {
  _impl_.input_fields_.Clear();
}
inline std::string* ModelType::add_input_fields() {
  std::string* _s = _internal_add_input_fields();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.ModelType.input_fields)
  return _s;
}
inline const std::string& ModelType::_internal_input_fields(int index) const {
  return _impl_.input_fields_.Get(index);
}
inline const std::string& ModelType::input_fields(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelType.input_fields)
  return _internal_input_fields(index);
}
inline std::string* ModelType::mutable_input_fields(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelType.input_fields)
  return _impl_.input_fields_.Mutable(index);
}
inline void ModelType::set_input_fields(int index, const std::string& value) {
  _impl_.input_fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.ModelType.input_fields)
}
inline void ModelType::set_input_fields(int index, std::string&& value) {
  _impl_.input_fields_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.ModelType.input_fields)
}
inline void ModelType::set_input_fields(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.input_fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.ModelType.input_fields)
}
inline void ModelType::set_input_fields(int index, const char* value, size_t size) {
  _impl_.input_fields_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.ModelType.input_fields)
}
inline std::string* ModelType::_internal_add_input_fields() {
  return _impl_.input_fields_.Add();
}
inline void ModelType::add_input_fields(const std::string& value) {
  _impl_.input_fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.ModelType.input_fields)
}
inline void ModelType::add_input_fields(std::string&& value) {
  _impl_.input_fields_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.ModelType.input_fields)
}
inline void ModelType::add_input_fields(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.input_fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.ModelType.input_fields)
}
inline void ModelType::add_input_fields(const char* value, size_t size) {
  _impl_.input_fields_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.ModelType.input_fields)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ModelType::input_fields() const {
  // @@protoc_insertion_point(field_list:clarifai.api.ModelType.input_fields)
  return _impl_.input_fields_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ModelType::mutable_input_fields() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.ModelType.input_fields)
  return &_impl_.input_fields_;
}

// repeated string output_fields = 6;
inline int ModelType::_internal_output_fields_size() const {
  return _impl_.output_fields_.size();
}
inline int ModelType::output_fields_size() const {
  return _internal_output_fields_size();
}
inline void ModelType::clear_output_fields() {
  _impl_.output_fields_.Clear();
}
inline std::string* ModelType::add_output_fields() {
  std::string* _s = _internal_add_output_fields();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.ModelType.output_fields)
  return _s;
}
inline const std::string& ModelType::_internal_output_fields(int index) const {
  return _impl_.output_fields_.Get(index);
}
inline const std::string& ModelType::output_fields(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelType.output_fields)
  return _internal_output_fields(index);
}
inline std::string* ModelType::mutable_output_fields(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelType.output_fields)
  return _impl_.output_fields_.Mutable(index);
}
inline void ModelType::set_output_fields(int index, const std::string& value) {
  _impl_.output_fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.ModelType.output_fields)
}
inline void ModelType::set_output_fields(int index, std::string&& value) {
  _impl_.output_fields_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.ModelType.output_fields)
}
inline void ModelType::set_output_fields(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.output_fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.ModelType.output_fields)
}
inline void ModelType::set_output_fields(int index, const char* value, size_t size) {
  _impl_.output_fields_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.ModelType.output_fields)
}
inline std::string* ModelType::_internal_add_output_fields() {
  return _impl_.output_fields_.Add();
}
inline void ModelType::add_output_fields(const std::string& value) {
  _impl_.output_fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.ModelType.output_fields)
}
inline void ModelType::add_output_fields(std::string&& value) {
  _impl_.output_fields_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.ModelType.output_fields)
}
inline void ModelType::add_output_fields(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.output_fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.ModelType.output_fields)
}
inline void ModelType::add_output_fields(const char* value, size_t size) {
  _impl_.output_fields_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.ModelType.output_fields)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ModelType::output_fields() const {
  // @@protoc_insertion_point(field_list:clarifai.api.ModelType.output_fields)
  return _impl_.output_fields_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ModelType::mutable_output_fields() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.ModelType.output_fields)
  return &_impl_.output_fields_;
}

// bool trainable = 8;
inline void ModelType::clear_trainable() {
  _impl_.trainable_ = false;
}
inline bool ModelType::_internal_trainable() const {
  return _impl_.trainable_;
}
inline bool ModelType::trainable() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelType.trainable)
  return _internal_trainable();
}
inline void ModelType::_internal_set_trainable(bool value) {
  
  _impl_.trainable_ = value;
}
inline void ModelType::set_trainable(bool value) {
  _internal_set_trainable(value);
  // @@protoc_insertion_point(field_set:clarifai.api.ModelType.trainable)
}

// bool creatable = 9;
inline void ModelType::clear_creatable() {
  _impl_.creatable_ = false;
}
inline bool ModelType::_internal_creatable() const {
  return _impl_.creatable_;
}
inline bool ModelType::creatable() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelType.creatable)
  return _internal_creatable();
}
inline void ModelType::_internal_set_creatable(bool value) {
  
  _impl_.creatable_ = value;
}
inline void ModelType::set_creatable(bool value) {
  _internal_set_creatable(value);
  // @@protoc_insertion_point(field_set:clarifai.api.ModelType.creatable)
}

// bool internal_only = 10;
inline void ModelType::clear_internal_only() {
  _impl_.internal_only_ = false;
}
inline bool ModelType::_internal_internal_only() const {
  return _impl_.internal_only_;
}
inline bool ModelType::internal_only() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelType.internal_only)
  return _internal_internal_only();
}
inline void ModelType::_internal_set_internal_only(bool value) {
  
  _impl_.internal_only_ = value;
}
inline void ModelType::set_internal_only(bool value) {
  _internal_set_internal_only(value);
  // @@protoc_insertion_point(field_set:clarifai.api.ModelType.internal_only)
}

// repeated .clarifai.api.ModelTypeField model_type_fields = 11;
inline int ModelType::_internal_model_type_fields_size() const {
  return _impl_.model_type_fields_.size();
}
inline int ModelType::model_type_fields_size() const {
  return _internal_model_type_fields_size();
}
inline void ModelType::clear_model_type_fields() {
  _impl_.model_type_fields_.Clear();
}
inline ::clarifai::api::ModelTypeField* ModelType::mutable_model_type_fields(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelType.model_type_fields)
  return _impl_.model_type_fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelTypeField >*
ModelType::mutable_model_type_fields() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.ModelType.model_type_fields)
  return &_impl_.model_type_fields_;
}
inline const ::clarifai::api::ModelTypeField& ModelType::_internal_model_type_fields(int index) const {
  return _impl_.model_type_fields_.Get(index);
}
inline const ::clarifai::api::ModelTypeField& ModelType::model_type_fields(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelType.model_type_fields)
  return _internal_model_type_fields(index);
}
inline ::clarifai::api::ModelTypeField* ModelType::_internal_add_model_type_fields() {
  return _impl_.model_type_fields_.Add();
}
inline ::clarifai::api::ModelTypeField* ModelType::add_model_type_fields() {
  ::clarifai::api::ModelTypeField* _add = _internal_add_model_type_fields();
  // @@protoc_insertion_point(field_add:clarifai.api.ModelType.model_type_fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelTypeField >&
ModelType::model_type_fields() const {
  // @@protoc_insertion_point(field_list:clarifai.api.ModelType.model_type_fields)
  return _impl_.model_type_fields_;
}

// bool requires_sequential_frames = 12;
inline void ModelType::clear_requires_sequential_frames() {
  _impl_.requires_sequential_frames_ = false;
}
inline bool ModelType::_internal_requires_sequential_frames() const {
  return _impl_.requires_sequential_frames_;
}
inline bool ModelType::requires_sequential_frames() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelType.requires_sequential_frames)
  return _internal_requires_sequential_frames();
}
inline void ModelType::_internal_set_requires_sequential_frames(bool value) {
  
  _impl_.requires_sequential_frames_ = value;
}
inline void ModelType::set_requires_sequential_frames(bool value) {
  _internal_set_requires_sequential_frames(value);
  // @@protoc_insertion_point(field_set:clarifai.api.ModelType.requires_sequential_frames)
}

// repeated .clarifai.api.ModelLayerInfo expected_input_layers = 16;
inline int ModelType::_internal_expected_input_layers_size() const {
  return _impl_.expected_input_layers_.size();
}
inline int ModelType::expected_input_layers_size() const {
  return _internal_expected_input_layers_size();
}
inline void ModelType::clear_expected_input_layers() {
  _impl_.expected_input_layers_.Clear();
}
inline ::clarifai::api::ModelLayerInfo* ModelType::mutable_expected_input_layers(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelType.expected_input_layers)
  return _impl_.expected_input_layers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelLayerInfo >*
ModelType::mutable_expected_input_layers() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.ModelType.expected_input_layers)
  return &_impl_.expected_input_layers_;
}
inline const ::clarifai::api::ModelLayerInfo& ModelType::_internal_expected_input_layers(int index) const {
  return _impl_.expected_input_layers_.Get(index);
}
inline const ::clarifai::api::ModelLayerInfo& ModelType::expected_input_layers(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelType.expected_input_layers)
  return _internal_expected_input_layers(index);
}
inline ::clarifai::api::ModelLayerInfo* ModelType::_internal_add_expected_input_layers() {
  return _impl_.expected_input_layers_.Add();
}
inline ::clarifai::api::ModelLayerInfo* ModelType::add_expected_input_layers() {
  ::clarifai::api::ModelLayerInfo* _add = _internal_add_expected_input_layers();
  // @@protoc_insertion_point(field_add:clarifai.api.ModelType.expected_input_layers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelLayerInfo >&
ModelType::expected_input_layers() const {
  // @@protoc_insertion_point(field_list:clarifai.api.ModelType.expected_input_layers)
  return _impl_.expected_input_layers_;
}

// repeated .clarifai.api.ModelLayerInfo expected_output_layers = 17;
inline int ModelType::_internal_expected_output_layers_size() const {
  return _impl_.expected_output_layers_.size();
}
inline int ModelType::expected_output_layers_size() const {
  return _internal_expected_output_layers_size();
}
inline void ModelType::clear_expected_output_layers() {
  _impl_.expected_output_layers_.Clear();
}
inline ::clarifai::api::ModelLayerInfo* ModelType::mutable_expected_output_layers(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelType.expected_output_layers)
  return _impl_.expected_output_layers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelLayerInfo >*
ModelType::mutable_expected_output_layers() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.ModelType.expected_output_layers)
  return &_impl_.expected_output_layers_;
}
inline const ::clarifai::api::ModelLayerInfo& ModelType::_internal_expected_output_layers(int index) const {
  return _impl_.expected_output_layers_.Get(index);
}
inline const ::clarifai::api::ModelLayerInfo& ModelType::expected_output_layers(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelType.expected_output_layers)
  return _internal_expected_output_layers(index);
}
inline ::clarifai::api::ModelLayerInfo* ModelType::_internal_add_expected_output_layers() {
  return _impl_.expected_output_layers_.Add();
}
inline ::clarifai::api::ModelLayerInfo* ModelType::add_expected_output_layers() {
  ::clarifai::api::ModelLayerInfo* _add = _internal_add_expected_output_layers();
  // @@protoc_insertion_point(field_add:clarifai.api.ModelType.expected_output_layers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelLayerInfo >&
ModelType::expected_output_layers() const {
  // @@protoc_insertion_point(field_list:clarifai.api.ModelType.expected_output_layers)
  return _impl_.expected_output_layers_;
}

// .clarifai.api.EvaluationType evaluation_type = 18;
inline void ModelType::clear_evaluation_type() {
  _impl_.evaluation_type_ = 0;
}
inline ::clarifai::api::EvaluationType ModelType::_internal_evaluation_type() const {
  return static_cast< ::clarifai::api::EvaluationType >(_impl_.evaluation_type_);
}
inline ::clarifai::api::EvaluationType ModelType::evaluation_type() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelType.evaluation_type)
  return _internal_evaluation_type();
}
inline void ModelType::_internal_set_evaluation_type(::clarifai::api::EvaluationType value) {
  
  _impl_.evaluation_type_ = value;
}
inline void ModelType::set_evaluation_type(::clarifai::api::EvaluationType value) {
  _internal_set_evaluation_type(value);
  // @@protoc_insertion_point(field_set:clarifai.api.ModelType.evaluation_type)
}

// -------------------------------------------------------------------

// ModelLayerInfo

// string data_field_name = 1;
inline void ModelLayerInfo::clear_data_field_name() {
  _impl_.data_field_name_.ClearToEmpty();
}
inline const std::string& ModelLayerInfo::data_field_name() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelLayerInfo.data_field_name)
  return _internal_data_field_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelLayerInfo::set_data_field_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_field_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModelLayerInfo.data_field_name)
}
inline std::string* ModelLayerInfo::mutable_data_field_name() {
  std::string* _s = _internal_mutable_data_field_name();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelLayerInfo.data_field_name)
  return _s;
}
inline const std::string& ModelLayerInfo::_internal_data_field_name() const {
  return _impl_.data_field_name_.Get();
}
inline void ModelLayerInfo::_internal_set_data_field_name(const std::string& value) {
  
  _impl_.data_field_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelLayerInfo::_internal_mutable_data_field_name() {
  
  return _impl_.data_field_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelLayerInfo::release_data_field_name() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelLayerInfo.data_field_name)
  return _impl_.data_field_name_.Release();
}
inline void ModelLayerInfo::set_allocated_data_field_name(std::string* data_field_name) {
  if (data_field_name != nullptr) {
    
  } else {
    
  }
  _impl_.data_field_name_.SetAllocated(data_field_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_field_name_.IsDefault()) {
    _impl_.data_field_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelLayerInfo.data_field_name)
}

// repeated .clarifai.api.LayerShape shapes = 2;
inline int ModelLayerInfo::_internal_shapes_size() const {
  return _impl_.shapes_.size();
}
inline int ModelLayerInfo::shapes_size() const {
  return _internal_shapes_size();
}
inline void ModelLayerInfo::clear_shapes() {
  _impl_.shapes_.Clear();
}
inline ::clarifai::api::LayerShape* ModelLayerInfo::mutable_shapes(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelLayerInfo.shapes)
  return _impl_.shapes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::LayerShape >*
ModelLayerInfo::mutable_shapes() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.ModelLayerInfo.shapes)
  return &_impl_.shapes_;
}
inline const ::clarifai::api::LayerShape& ModelLayerInfo::_internal_shapes(int index) const {
  return _impl_.shapes_.Get(index);
}
inline const ::clarifai::api::LayerShape& ModelLayerInfo::shapes(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelLayerInfo.shapes)
  return _internal_shapes(index);
}
inline ::clarifai::api::LayerShape* ModelLayerInfo::_internal_add_shapes() {
  return _impl_.shapes_.Add();
}
inline ::clarifai::api::LayerShape* ModelLayerInfo::add_shapes() {
  ::clarifai::api::LayerShape* _add = _internal_add_shapes();
  // @@protoc_insertion_point(field_add:clarifai.api.ModelLayerInfo.shapes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::LayerShape >&
ModelLayerInfo::shapes() const {
  // @@protoc_insertion_point(field_list:clarifai.api.ModelLayerInfo.shapes)
  return _impl_.shapes_;
}

// string description = 3;
inline void ModelLayerInfo::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ModelLayerInfo::description() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelLayerInfo.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelLayerInfo::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModelLayerInfo.description)
}
inline std::string* ModelLayerInfo::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelLayerInfo.description)
  return _s;
}
inline const std::string& ModelLayerInfo::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ModelLayerInfo::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelLayerInfo::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelLayerInfo::release_description() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelLayerInfo.description)
  return _impl_.description_.Release();
}
inline void ModelLayerInfo::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelLayerInfo.description)
}

// bool requires_label_filename = 4;
inline void ModelLayerInfo::clear_requires_label_filename() {
  _impl_.requires_label_filename_ = false;
}
inline bool ModelLayerInfo::_internal_requires_label_filename() const {
  return _impl_.requires_label_filename_;
}
inline bool ModelLayerInfo::requires_label_filename() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelLayerInfo.requires_label_filename)
  return _internal_requires_label_filename();
}
inline void ModelLayerInfo::_internal_set_requires_label_filename(bool value) {
  
  _impl_.requires_label_filename_ = value;
}
inline void ModelLayerInfo::set_requires_label_filename(bool value) {
  _internal_set_requires_label_filename(value);
  // @@protoc_insertion_point(field_set:clarifai.api.ModelLayerInfo.requires_label_filename)
}

// -------------------------------------------------------------------

// LayerShape

// repeated int32 dims = 1;
inline int LayerShape::_internal_dims_size() const {
  return _impl_.dims_.size();
}
inline int LayerShape::dims_size() const {
  return _internal_dims_size();
}
inline void LayerShape::clear_dims() {
  _impl_.dims_.Clear();
}
inline int32_t LayerShape::_internal_dims(int index) const {
  return _impl_.dims_.Get(index);
}
inline int32_t LayerShape::dims(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.LayerShape.dims)
  return _internal_dims(index);
}
inline void LayerShape::set_dims(int index, int32_t value) {
  _impl_.dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:clarifai.api.LayerShape.dims)
}
inline void LayerShape::_internal_add_dims(int32_t value) {
  _impl_.dims_.Add(value);
}
inline void LayerShape::add_dims(int32_t value) {
  _internal_add_dims(value);
  // @@protoc_insertion_point(field_add:clarifai.api.LayerShape.dims)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
LayerShape::_internal_dims() const {
  return _impl_.dims_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
LayerShape::dims() const {
  // @@protoc_insertion_point(field_list:clarifai.api.LayerShape.dims)
  return _internal_dims();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
LayerShape::_internal_mutable_dims() {
  return &_impl_.dims_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
LayerShape::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.LayerShape.dims)
  return _internal_mutable_dims();
}

// repeated int32 max_dims = 2;
inline int LayerShape::_internal_max_dims_size() const {
  return _impl_.max_dims_.size();
}
inline int LayerShape::max_dims_size() const {
  return _internal_max_dims_size();
}
inline void LayerShape::clear_max_dims() {
  _impl_.max_dims_.Clear();
}
inline int32_t LayerShape::_internal_max_dims(int index) const {
  return _impl_.max_dims_.Get(index);
}
inline int32_t LayerShape::max_dims(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.LayerShape.max_dims)
  return _internal_max_dims(index);
}
inline void LayerShape::set_max_dims(int index, int32_t value) {
  _impl_.max_dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:clarifai.api.LayerShape.max_dims)
}
inline void LayerShape::_internal_add_max_dims(int32_t value) {
  _impl_.max_dims_.Add(value);
}
inline void LayerShape::add_max_dims(int32_t value) {
  _internal_add_max_dims(value);
  // @@protoc_insertion_point(field_add:clarifai.api.LayerShape.max_dims)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
LayerShape::_internal_max_dims() const {
  return _impl_.max_dims_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
LayerShape::max_dims() const {
  // @@protoc_insertion_point(field_list:clarifai.api.LayerShape.max_dims)
  return _internal_max_dims();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
LayerShape::_internal_mutable_max_dims() {
  return &_impl_.max_dims_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
LayerShape::mutable_max_dims() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.LayerShape.max_dims)
  return _internal_mutable_max_dims();
}

// .clarifai.api.DataType data_type = 3;
inline void LayerShape::clear_data_type() {
  _impl_.data_type_ = 0;
}
inline ::clarifai::api::DataType LayerShape::_internal_data_type() const {
  return static_cast< ::clarifai::api::DataType >(_impl_.data_type_);
}
inline ::clarifai::api::DataType LayerShape::data_type() const {
  // @@protoc_insertion_point(field_get:clarifai.api.LayerShape.data_type)
  return _internal_data_type();
}
inline void LayerShape::_internal_set_data_type(::clarifai::api::DataType value) {
  
  _impl_.data_type_ = value;
}
inline void LayerShape::set_data_type(::clarifai::api::DataType value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:clarifai.api.LayerShape.data_type)
}

// string description = 4;
inline void LayerShape::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& LayerShape::description() const {
  // @@protoc_insertion_point(field_get:clarifai.api.LayerShape.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LayerShape::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.LayerShape.description)
}
inline std::string* LayerShape::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:clarifai.api.LayerShape.description)
  return _s;
}
inline const std::string& LayerShape::_internal_description() const {
  return _impl_.description_.Get();
}
inline void LayerShape::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* LayerShape::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* LayerShape::release_description() {
  // @@protoc_insertion_point(field_release:clarifai.api.LayerShape.description)
  return _impl_.description_.Release();
}
inline void LayerShape::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.LayerShape.description)
}

// -------------------------------------------------------------------

// ModelTypeField

// string path = 1;
inline void ModelTypeField::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& ModelTypeField::path() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelTypeField.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelTypeField::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModelTypeField.path)
}
inline std::string* ModelTypeField::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelTypeField.path)
  return _s;
}
inline const std::string& ModelTypeField::_internal_path() const {
  return _impl_.path_.Get();
}
inline void ModelTypeField::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelTypeField::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelTypeField::release_path() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelTypeField.path)
  return _impl_.path_.Release();
}
inline void ModelTypeField::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelTypeField.path)
}

// .clarifai.api.ModelTypeField.ModelTypeFieldType field_type = 2;
inline void ModelTypeField::clear_field_type() {
  _impl_.field_type_ = 0;
}
inline ::clarifai::api::ModelTypeField_ModelTypeFieldType ModelTypeField::_internal_field_type() const {
  return static_cast< ::clarifai::api::ModelTypeField_ModelTypeFieldType >(_impl_.field_type_);
}
inline ::clarifai::api::ModelTypeField_ModelTypeFieldType ModelTypeField::field_type() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelTypeField.field_type)
  return _internal_field_type();
}
inline void ModelTypeField::_internal_set_field_type(::clarifai::api::ModelTypeField_ModelTypeFieldType value) {
  
  _impl_.field_type_ = value;
}
inline void ModelTypeField::set_field_type(::clarifai::api::ModelTypeField_ModelTypeFieldType value) {
  _internal_set_field_type(value);
  // @@protoc_insertion_point(field_set:clarifai.api.ModelTypeField.field_type)
}

// .google.protobuf.Value default_value = 3;
inline bool ModelTypeField::_internal_has_default_value() const {
  return this != internal_default_instance() && _impl_.default_value_ != nullptr;
}
inline bool ModelTypeField::has_default_value() const {
  return _internal_has_default_value();
}
inline const ::PROTOBUF_NAMESPACE_ID::Value& ModelTypeField::_internal_default_value() const {
  const ::PROTOBUF_NAMESPACE_ID::Value* p = _impl_.default_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Value&>(
      ::PROTOBUF_NAMESPACE_ID::_Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Value& ModelTypeField::default_value() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelTypeField.default_value)
  return _internal_default_value();
}
inline void ModelTypeField::unsafe_arena_set_allocated_default_value(
    ::PROTOBUF_NAMESPACE_ID::Value* default_value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.default_value_);
  }
  _impl_.default_value_ = default_value;
  if (default_value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.ModelTypeField.default_value)
}
inline ::PROTOBUF_NAMESPACE_ID::Value* ModelTypeField::release_default_value() {
  
  ::PROTOBUF_NAMESPACE_ID::Value* temp = _impl_.default_value_;
  _impl_.default_value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Value* ModelTypeField::unsafe_arena_release_default_value() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelTypeField.default_value)
  
  ::PROTOBUF_NAMESPACE_ID::Value* temp = _impl_.default_value_;
  _impl_.default_value_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Value* ModelTypeField::_internal_mutable_default_value() {
  
  if (_impl_.default_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Value>(GetArenaForAllocation());
    _impl_.default_value_ = p;
  }
  return _impl_.default_value_;
}
inline ::PROTOBUF_NAMESPACE_ID::Value* ModelTypeField::mutable_default_value() {
  ::PROTOBUF_NAMESPACE_ID::Value* _msg = _internal_mutable_default_value();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelTypeField.default_value)
  return _msg;
}
inline void ModelTypeField::set_allocated_default_value(::PROTOBUF_NAMESPACE_ID::Value* default_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.default_value_);
  }
  if (default_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(default_value));
    if (message_arena != submessage_arena) {
      default_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, default_value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.default_value_ = default_value;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelTypeField.default_value)
}

// string description = 4;
inline void ModelTypeField::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ModelTypeField::description() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelTypeField.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelTypeField::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModelTypeField.description)
}
inline std::string* ModelTypeField::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelTypeField.description)
  return _s;
}
inline const std::string& ModelTypeField::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ModelTypeField::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelTypeField::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelTypeField::release_description() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelTypeField.description)
  return _impl_.description_.Release();
}
inline void ModelTypeField::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelTypeField.description)
}

// string placeholder = 5;
inline void ModelTypeField::clear_placeholder() {
  _impl_.placeholder_.ClearToEmpty();
}
inline const std::string& ModelTypeField::placeholder() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelTypeField.placeholder)
  return _internal_placeholder();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelTypeField::set_placeholder(ArgT0&& arg0, ArgT... args) {
 
 _impl_.placeholder_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModelTypeField.placeholder)
}
inline std::string* ModelTypeField::mutable_placeholder() {
  std::string* _s = _internal_mutable_placeholder();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelTypeField.placeholder)
  return _s;
}
inline const std::string& ModelTypeField::_internal_placeholder() const {
  return _impl_.placeholder_.Get();
}
inline void ModelTypeField::_internal_set_placeholder(const std::string& value) {
  
  _impl_.placeholder_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelTypeField::_internal_mutable_placeholder() {
  
  return _impl_.placeholder_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelTypeField::release_placeholder() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelTypeField.placeholder)
  return _impl_.placeholder_.Release();
}
inline void ModelTypeField::set_allocated_placeholder(std::string* placeholder) {
  if (placeholder != nullptr) {
    
  } else {
    
  }
  _impl_.placeholder_.SetAllocated(placeholder, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.placeholder_.IsDefault()) {
    _impl_.placeholder_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelTypeField.placeholder)
}

// repeated .clarifai.api.ModelTypeEnumOption model_type_enum_options = 6;
inline int ModelTypeField::_internal_model_type_enum_options_size() const {
  return _impl_.model_type_enum_options_.size();
}
inline int ModelTypeField::model_type_enum_options_size() const {
  return _internal_model_type_enum_options_size();
}
inline void ModelTypeField::clear_model_type_enum_options() {
  _impl_.model_type_enum_options_.Clear();
}
inline ::clarifai::api::ModelTypeEnumOption* ModelTypeField::mutable_model_type_enum_options(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelTypeField.model_type_enum_options)
  return _impl_.model_type_enum_options_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelTypeEnumOption >*
ModelTypeField::mutable_model_type_enum_options() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.ModelTypeField.model_type_enum_options)
  return &_impl_.model_type_enum_options_;
}
inline const ::clarifai::api::ModelTypeEnumOption& ModelTypeField::_internal_model_type_enum_options(int index) const {
  return _impl_.model_type_enum_options_.Get(index);
}
inline const ::clarifai::api::ModelTypeEnumOption& ModelTypeField::model_type_enum_options(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelTypeField.model_type_enum_options)
  return _internal_model_type_enum_options(index);
}
inline ::clarifai::api::ModelTypeEnumOption* ModelTypeField::_internal_add_model_type_enum_options() {
  return _impl_.model_type_enum_options_.Add();
}
inline ::clarifai::api::ModelTypeEnumOption* ModelTypeField::add_model_type_enum_options() {
  ::clarifai::api::ModelTypeEnumOption* _add = _internal_add_model_type_enum_options();
  // @@protoc_insertion_point(field_add:clarifai.api.ModelTypeField.model_type_enum_options)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelTypeEnumOption >&
ModelTypeField::model_type_enum_options() const {
  // @@protoc_insertion_point(field_list:clarifai.api.ModelTypeField.model_type_enum_options)
  return _impl_.model_type_enum_options_;
}

// bool internal_only = 7;
inline void ModelTypeField::clear_internal_only() {
  _impl_.internal_only_ = false;
}
inline bool ModelTypeField::_internal_internal_only() const {
  return _impl_.internal_only_;
}
inline bool ModelTypeField::internal_only() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelTypeField.internal_only)
  return _internal_internal_only();
}
inline void ModelTypeField::_internal_set_internal_only(bool value) {
  
  _impl_.internal_only_ = value;
}
inline void ModelTypeField::set_internal_only(bool value) {
  _internal_set_internal_only(value);
  // @@protoc_insertion_point(field_set:clarifai.api.ModelTypeField.internal_only)
}

// bool required = 8;
inline void ModelTypeField::clear_required() {
  _impl_.required_ = false;
}
inline bool ModelTypeField::_internal_required() const {
  return _impl_.required_;
}
inline bool ModelTypeField::required() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelTypeField.required)
  return _internal_required();
}
inline void ModelTypeField::_internal_set_required(bool value) {
  
  _impl_.required_ = value;
}
inline void ModelTypeField::set_required(bool value) {
  _internal_set_required(value);
  // @@protoc_insertion_point(field_set:clarifai.api.ModelTypeField.required)
}

// .clarifai.api.ModelTypeRangeInfo model_type_range_info = 9;
inline bool ModelTypeField::_internal_has_model_type_range_info() const {
  return this != internal_default_instance() && _impl_.model_type_range_info_ != nullptr;
}
inline bool ModelTypeField::has_model_type_range_info() const {
  return _internal_has_model_type_range_info();
}
inline void ModelTypeField::clear_model_type_range_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.model_type_range_info_ != nullptr) {
    delete _impl_.model_type_range_info_;
  }
  _impl_.model_type_range_info_ = nullptr;
}
inline const ::clarifai::api::ModelTypeRangeInfo& ModelTypeField::_internal_model_type_range_info() const {
  const ::clarifai::api::ModelTypeRangeInfo* p = _impl_.model_type_range_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::ModelTypeRangeInfo&>(
      ::clarifai::api::_ModelTypeRangeInfo_default_instance_);
}
inline const ::clarifai::api::ModelTypeRangeInfo& ModelTypeField::model_type_range_info() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelTypeField.model_type_range_info)
  return _internal_model_type_range_info();
}
inline void ModelTypeField::unsafe_arena_set_allocated_model_type_range_info(
    ::clarifai::api::ModelTypeRangeInfo* model_type_range_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.model_type_range_info_);
  }
  _impl_.model_type_range_info_ = model_type_range_info;
  if (model_type_range_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.ModelTypeField.model_type_range_info)
}
inline ::clarifai::api::ModelTypeRangeInfo* ModelTypeField::release_model_type_range_info() {
  
  ::clarifai::api::ModelTypeRangeInfo* temp = _impl_.model_type_range_info_;
  _impl_.model_type_range_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::ModelTypeRangeInfo* ModelTypeField::unsafe_arena_release_model_type_range_info() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelTypeField.model_type_range_info)
  
  ::clarifai::api::ModelTypeRangeInfo* temp = _impl_.model_type_range_info_;
  _impl_.model_type_range_info_ = nullptr;
  return temp;
}
inline ::clarifai::api::ModelTypeRangeInfo* ModelTypeField::_internal_mutable_model_type_range_info() {
  
  if (_impl_.model_type_range_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::ModelTypeRangeInfo>(GetArenaForAllocation());
    _impl_.model_type_range_info_ = p;
  }
  return _impl_.model_type_range_info_;
}
inline ::clarifai::api::ModelTypeRangeInfo* ModelTypeField::mutable_model_type_range_info() {
  ::clarifai::api::ModelTypeRangeInfo* _msg = _internal_mutable_model_type_range_info();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelTypeField.model_type_range_info)
  return _msg;
}
inline void ModelTypeField::set_allocated_model_type_range_info(::clarifai::api::ModelTypeRangeInfo* model_type_range_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.model_type_range_info_;
  }
  if (model_type_range_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(model_type_range_info);
    if (message_arena != submessage_arena) {
      model_type_range_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model_type_range_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.model_type_range_info_ = model_type_range_info;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelTypeField.model_type_range_info)
}

// -------------------------------------------------------------------

// ModelTypeRangeInfo

// float min = 1;
inline void ModelTypeRangeInfo::clear_min() {
  _impl_.min_ = 0;
}
inline float ModelTypeRangeInfo::_internal_min() const {
  return _impl_.min_;
}
inline float ModelTypeRangeInfo::min() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelTypeRangeInfo.min)
  return _internal_min();
}
inline void ModelTypeRangeInfo::_internal_set_min(float value) {
  
  _impl_.min_ = value;
}
inline void ModelTypeRangeInfo::set_min(float value) {
  _internal_set_min(value);
  // @@protoc_insertion_point(field_set:clarifai.api.ModelTypeRangeInfo.min)
}

// float max = 2;
inline void ModelTypeRangeInfo::clear_max() {
  _impl_.max_ = 0;
}
inline float ModelTypeRangeInfo::_internal_max() const {
  return _impl_.max_;
}
inline float ModelTypeRangeInfo::max() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelTypeRangeInfo.max)
  return _internal_max();
}
inline void ModelTypeRangeInfo::_internal_set_max(float value) {
  
  _impl_.max_ = value;
}
inline void ModelTypeRangeInfo::set_max(float value) {
  _internal_set_max(value);
  // @@protoc_insertion_point(field_set:clarifai.api.ModelTypeRangeInfo.max)
}

// float step = 3;
inline void ModelTypeRangeInfo::clear_step() {
  _impl_.step_ = 0;
}
inline float ModelTypeRangeInfo::_internal_step() const {
  return _impl_.step_;
}
inline float ModelTypeRangeInfo::step() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelTypeRangeInfo.step)
  return _internal_step();
}
inline void ModelTypeRangeInfo::_internal_set_step(float value) {
  
  _impl_.step_ = value;
}
inline void ModelTypeRangeInfo::set_step(float value) {
  _internal_set_step(value);
  // @@protoc_insertion_point(field_set:clarifai.api.ModelTypeRangeInfo.step)
}

// -------------------------------------------------------------------

// ModelTypeEnumOption

// string id = 1;
inline void ModelTypeEnumOption::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ModelTypeEnumOption::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelTypeEnumOption.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelTypeEnumOption::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModelTypeEnumOption.id)
}
inline std::string* ModelTypeEnumOption::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelTypeEnumOption.id)
  return _s;
}
inline const std::string& ModelTypeEnumOption::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ModelTypeEnumOption::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelTypeEnumOption::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelTypeEnumOption::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelTypeEnumOption.id)
  return _impl_.id_.Release();
}
inline void ModelTypeEnumOption::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelTypeEnumOption.id)
}

// repeated .clarifai.api.ModelTypeEnumOptionAlias aliases = 5;
inline int ModelTypeEnumOption::_internal_aliases_size() const {
  return _impl_.aliases_.size();
}
inline int ModelTypeEnumOption::aliases_size() const {
  return _internal_aliases_size();
}
inline void ModelTypeEnumOption::clear_aliases() {
  _impl_.aliases_.Clear();
}
inline ::clarifai::api::ModelTypeEnumOptionAlias* ModelTypeEnumOption::mutable_aliases(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelTypeEnumOption.aliases)
  return _impl_.aliases_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelTypeEnumOptionAlias >*
ModelTypeEnumOption::mutable_aliases() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.ModelTypeEnumOption.aliases)
  return &_impl_.aliases_;
}
inline const ::clarifai::api::ModelTypeEnumOptionAlias& ModelTypeEnumOption::_internal_aliases(int index) const {
  return _impl_.aliases_.Get(index);
}
inline const ::clarifai::api::ModelTypeEnumOptionAlias& ModelTypeEnumOption::aliases(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelTypeEnumOption.aliases)
  return _internal_aliases(index);
}
inline ::clarifai::api::ModelTypeEnumOptionAlias* ModelTypeEnumOption::_internal_add_aliases() {
  return _impl_.aliases_.Add();
}
inline ::clarifai::api::ModelTypeEnumOptionAlias* ModelTypeEnumOption::add_aliases() {
  ::clarifai::api::ModelTypeEnumOptionAlias* _add = _internal_add_aliases();
  // @@protoc_insertion_point(field_add:clarifai.api.ModelTypeEnumOption.aliases)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelTypeEnumOptionAlias >&
ModelTypeEnumOption::aliases() const {
  // @@protoc_insertion_point(field_list:clarifai.api.ModelTypeEnumOption.aliases)
  return _impl_.aliases_;
}

// string description = 2;
inline void ModelTypeEnumOption::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ModelTypeEnumOption::description() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelTypeEnumOption.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelTypeEnumOption::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModelTypeEnumOption.description)
}
inline std::string* ModelTypeEnumOption::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelTypeEnumOption.description)
  return _s;
}
inline const std::string& ModelTypeEnumOption::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ModelTypeEnumOption::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelTypeEnumOption::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelTypeEnumOption::release_description() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelTypeEnumOption.description)
  return _impl_.description_.Release();
}
inline void ModelTypeEnumOption::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelTypeEnumOption.description)
}

// repeated .clarifai.api.ModelTypeField model_type_fields = 3;
inline int ModelTypeEnumOption::_internal_model_type_fields_size() const {
  return _impl_.model_type_fields_.size();
}
inline int ModelTypeEnumOption::model_type_fields_size() const {
  return _internal_model_type_fields_size();
}
inline void ModelTypeEnumOption::clear_model_type_fields() {
  _impl_.model_type_fields_.Clear();
}
inline ::clarifai::api::ModelTypeField* ModelTypeEnumOption::mutable_model_type_fields(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelTypeEnumOption.model_type_fields)
  return _impl_.model_type_fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelTypeField >*
ModelTypeEnumOption::mutable_model_type_fields() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.ModelTypeEnumOption.model_type_fields)
  return &_impl_.model_type_fields_;
}
inline const ::clarifai::api::ModelTypeField& ModelTypeEnumOption::_internal_model_type_fields(int index) const {
  return _impl_.model_type_fields_.Get(index);
}
inline const ::clarifai::api::ModelTypeField& ModelTypeEnumOption::model_type_fields(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelTypeEnumOption.model_type_fields)
  return _internal_model_type_fields(index);
}
inline ::clarifai::api::ModelTypeField* ModelTypeEnumOption::_internal_add_model_type_fields() {
  return _impl_.model_type_fields_.Add();
}
inline ::clarifai::api::ModelTypeField* ModelTypeEnumOption::add_model_type_fields() {
  ::clarifai::api::ModelTypeField* _add = _internal_add_model_type_fields();
  // @@protoc_insertion_point(field_add:clarifai.api.ModelTypeEnumOption.model_type_fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModelTypeField >&
ModelTypeEnumOption::model_type_fields() const {
  // @@protoc_insertion_point(field_list:clarifai.api.ModelTypeEnumOption.model_type_fields)
  return _impl_.model_type_fields_;
}

// bool internal_only = 4;
inline void ModelTypeEnumOption::clear_internal_only() {
  _impl_.internal_only_ = false;
}
inline bool ModelTypeEnumOption::_internal_internal_only() const {
  return _impl_.internal_only_;
}
inline bool ModelTypeEnumOption::internal_only() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelTypeEnumOption.internal_only)
  return _internal_internal_only();
}
inline void ModelTypeEnumOption::_internal_set_internal_only(bool value) {
  
  _impl_.internal_only_ = value;
}
inline void ModelTypeEnumOption::set_internal_only(bool value) {
  _internal_set_internal_only(value);
  // @@protoc_insertion_point(field_set:clarifai.api.ModelTypeEnumOption.internal_only)
}

// bool recommended = 6;
inline void ModelTypeEnumOption::clear_recommended() {
  _impl_.recommended_ = false;
}
inline bool ModelTypeEnumOption::_internal_recommended() const {
  return _impl_.recommended_;
}
inline bool ModelTypeEnumOption::recommended() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelTypeEnumOption.recommended)
  return _internal_recommended();
}
inline void ModelTypeEnumOption::_internal_set_recommended(bool value) {
  
  _impl_.recommended_ = value;
}
inline void ModelTypeEnumOption::set_recommended(bool value) {
  _internal_set_recommended(value);
  // @@protoc_insertion_point(field_set:clarifai.api.ModelTypeEnumOption.recommended)
}

// -------------------------------------------------------------------

// ModelTypeEnumOptionAlias

// int64 id_int = 1;
inline void ModelTypeEnumOptionAlias::clear_id_int() {
  _impl_.id_int_ = int64_t{0};
}
inline int64_t ModelTypeEnumOptionAlias::_internal_id_int() const {
  return _impl_.id_int_;
}
inline int64_t ModelTypeEnumOptionAlias::id_int() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelTypeEnumOptionAlias.id_int)
  return _internal_id_int();
}
inline void ModelTypeEnumOptionAlias::_internal_set_id_int(int64_t value) {
  
  _impl_.id_int_ = value;
}
inline void ModelTypeEnumOptionAlias::set_id_int(int64_t value) {
  _internal_set_id_int(value);
  // @@protoc_insertion_point(field_set:clarifai.api.ModelTypeEnumOptionAlias.id_int)
}

// string wildcard_string = 2;
inline void ModelTypeEnumOptionAlias::clear_wildcard_string() {
  _impl_.wildcard_string_.ClearToEmpty();
}
inline const std::string& ModelTypeEnumOptionAlias::wildcard_string() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelTypeEnumOptionAlias.wildcard_string)
  return _internal_wildcard_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelTypeEnumOptionAlias::set_wildcard_string(ArgT0&& arg0, ArgT... args) {
 
 _impl_.wildcard_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModelTypeEnumOptionAlias.wildcard_string)
}
inline std::string* ModelTypeEnumOptionAlias::mutable_wildcard_string() {
  std::string* _s = _internal_mutable_wildcard_string();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelTypeEnumOptionAlias.wildcard_string)
  return _s;
}
inline const std::string& ModelTypeEnumOptionAlias::_internal_wildcard_string() const {
  return _impl_.wildcard_string_.Get();
}
inline void ModelTypeEnumOptionAlias::_internal_set_wildcard_string(const std::string& value) {
  
  _impl_.wildcard_string_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelTypeEnumOptionAlias::_internal_mutable_wildcard_string() {
  
  return _impl_.wildcard_string_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelTypeEnumOptionAlias::release_wildcard_string() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelTypeEnumOptionAlias.wildcard_string)
  return _impl_.wildcard_string_.Release();
}
inline void ModelTypeEnumOptionAlias::set_allocated_wildcard_string(std::string* wildcard_string) {
  if (wildcard_string != nullptr) {
    
  } else {
    
  }
  _impl_.wildcard_string_.SetAllocated(wildcard_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.wildcard_string_.IsDefault()) {
    _impl_.wildcard_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelTypeEnumOptionAlias.wildcard_string)
}

// -------------------------------------------------------------------

// ModelQuery

// string name = 1;
inline void ModelQuery::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelQuery::name() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelQuery.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelQuery::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModelQuery.name)
}
inline std::string* ModelQuery::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelQuery.name)
  return _s;
}
inline const std::string& ModelQuery::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelQuery::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelQuery::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelQuery::release_name() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelQuery.name)
  return _impl_.name_.Release();
}
inline void ModelQuery::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelQuery.name)
}

// string model_type_id = 3;
inline void ModelQuery::clear_model_type_id() {
  _impl_.model_type_id_.ClearToEmpty();
}
inline const std::string& ModelQuery::model_type_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelQuery.model_type_id)
  return _internal_model_type_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelQuery::set_model_type_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_type_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModelQuery.model_type_id)
}
inline std::string* ModelQuery::mutable_model_type_id() {
  std::string* _s = _internal_mutable_model_type_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelQuery.model_type_id)
  return _s;
}
inline const std::string& ModelQuery::_internal_model_type_id() const {
  return _impl_.model_type_id_.Get();
}
inline void ModelQuery::_internal_set_model_type_id(const std::string& value) {
  
  _impl_.model_type_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelQuery::_internal_mutable_model_type_id() {
  
  return _impl_.model_type_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelQuery::release_model_type_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelQuery.model_type_id)
  return _impl_.model_type_id_.Release();
}
inline void ModelQuery::set_allocated_model_type_id(std::string* model_type_id) {
  if (model_type_id != nullptr) {
    
  } else {
    
  }
  _impl_.model_type_id_.SetAllocated(model_type_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_type_id_.IsDefault()) {
    _impl_.model_type_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelQuery.model_type_id)
}

// -------------------------------------------------------------------

// ModelVersion

// string id = 1;
inline void ModelVersion::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ModelVersion::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelVersion.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelVersion::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModelVersion.id)
}
inline std::string* ModelVersion::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelVersion.id)
  return _s;
}
inline const std::string& ModelVersion::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ModelVersion::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelVersion::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelVersion::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelVersion.id)
  return _impl_.id_.Release();
}
inline void ModelVersion::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelVersion.id)
}

// .google.protobuf.Timestamp created_at = 2;
inline bool ModelVersion::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool ModelVersion::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ModelVersion::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ModelVersion::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelVersion.created_at)
  return _internal_created_at();
}
inline void ModelVersion::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.ModelVersion.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ModelVersion::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ModelVersion::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelVersion.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ModelVersion::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ModelVersion::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelVersion.created_at)
  return _msg;
}
inline void ModelVersion::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelVersion.created_at)
}

// .clarifai.api.status.Status status = 3;
inline bool ModelVersion::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool ModelVersion::has_status() const {
  return _internal_has_status();
}
inline const ::clarifai::api::status::Status& ModelVersion::_internal_status() const {
  const ::clarifai::api::status::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::status::Status&>(
      ::clarifai::api::status::_Status_default_instance_);
}
inline const ::clarifai::api::status::Status& ModelVersion::status() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelVersion.status)
  return _internal_status();
}
inline void ModelVersion::unsafe_arena_set_allocated_status(
    ::clarifai::api::status::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.ModelVersion.status)
}
inline ::clarifai::api::status::Status* ModelVersion::release_status() {
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::status::Status* ModelVersion::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelVersion.status)
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::clarifai::api::status::Status* ModelVersion::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::status::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::clarifai::api::status::Status* ModelVersion::mutable_status() {
  ::clarifai::api::status::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelVersion.status)
  return _msg;
}
inline void ModelVersion::set_allocated_status(::clarifai::api::status::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelVersion.status)
}

// uint32 active_concept_count = 4;
inline void ModelVersion::clear_active_concept_count() {
  _impl_.active_concept_count_ = 0u;
}
inline uint32_t ModelVersion::_internal_active_concept_count() const {
  return _impl_.active_concept_count_;
}
inline uint32_t ModelVersion::active_concept_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelVersion.active_concept_count)
  return _internal_active_concept_count();
}
inline void ModelVersion::_internal_set_active_concept_count(uint32_t value) {
  
  _impl_.active_concept_count_ = value;
}
inline void ModelVersion::set_active_concept_count(uint32_t value) {
  _internal_set_active_concept_count(value);
  // @@protoc_insertion_point(field_set:clarifai.api.ModelVersion.active_concept_count)
}

// .clarifai.api.EvalMetrics metrics = 5;
inline bool ModelVersion::_internal_has_metrics() const {
  return this != internal_default_instance() && _impl_.metrics_ != nullptr;
}
inline bool ModelVersion::has_metrics() const {
  return _internal_has_metrics();
}
inline void ModelVersion::clear_metrics() {
  if (GetArenaForAllocation() == nullptr && _impl_.metrics_ != nullptr) {
    delete _impl_.metrics_;
  }
  _impl_.metrics_ = nullptr;
}
inline const ::clarifai::api::EvalMetrics& ModelVersion::_internal_metrics() const {
  const ::clarifai::api::EvalMetrics* p = _impl_.metrics_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::EvalMetrics&>(
      ::clarifai::api::_EvalMetrics_default_instance_);
}
inline const ::clarifai::api::EvalMetrics& ModelVersion::metrics() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelVersion.metrics)
  return _internal_metrics();
}
inline void ModelVersion::unsafe_arena_set_allocated_metrics(
    ::clarifai::api::EvalMetrics* metrics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metrics_);
  }
  _impl_.metrics_ = metrics;
  if (metrics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.ModelVersion.metrics)
}
inline ::clarifai::api::EvalMetrics* ModelVersion::release_metrics() {
  
  ::clarifai::api::EvalMetrics* temp = _impl_.metrics_;
  _impl_.metrics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::EvalMetrics* ModelVersion::unsafe_arena_release_metrics() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelVersion.metrics)
  
  ::clarifai::api::EvalMetrics* temp = _impl_.metrics_;
  _impl_.metrics_ = nullptr;
  return temp;
}
inline ::clarifai::api::EvalMetrics* ModelVersion::_internal_mutable_metrics() {
  
  if (_impl_.metrics_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::EvalMetrics>(GetArenaForAllocation());
    _impl_.metrics_ = p;
  }
  return _impl_.metrics_;
}
inline ::clarifai::api::EvalMetrics* ModelVersion::mutable_metrics() {
  ::clarifai::api::EvalMetrics* _msg = _internal_mutable_metrics();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelVersion.metrics)
  return _msg;
}
inline void ModelVersion::set_allocated_metrics(::clarifai::api::EvalMetrics* metrics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metrics_;
  }
  if (metrics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metrics);
    if (message_arena != submessage_arena) {
      metrics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metrics, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metrics_ = metrics;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelVersion.metrics)
}

// uint32 total_input_count = 6;
inline void ModelVersion::clear_total_input_count() {
  _impl_.total_input_count_ = 0u;
}
inline uint32_t ModelVersion::_internal_total_input_count() const {
  return _impl_.total_input_count_;
}
inline uint32_t ModelVersion::total_input_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelVersion.total_input_count)
  return _internal_total_input_count();
}
inline void ModelVersion::_internal_set_total_input_count(uint32_t value) {
  
  _impl_.total_input_count_ = value;
}
inline void ModelVersion::set_total_input_count(uint32_t value) {
  _internal_set_total_input_count(value);
  // @@protoc_insertion_point(field_set:clarifai.api.ModelVersion.total_input_count)
}

// .clarifai.api.PretrainedModelConfig pretrained_model_config = 7;
inline bool ModelVersion::_internal_has_pretrained_model_config() const {
  return this != internal_default_instance() && _impl_.pretrained_model_config_ != nullptr;
}
inline bool ModelVersion::has_pretrained_model_config() const {
  return _internal_has_pretrained_model_config();
}
inline void ModelVersion::clear_pretrained_model_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.pretrained_model_config_ != nullptr) {
    delete _impl_.pretrained_model_config_;
  }
  _impl_.pretrained_model_config_ = nullptr;
}
inline const ::clarifai::api::PretrainedModelConfig& ModelVersion::_internal_pretrained_model_config() const {
  const ::clarifai::api::PretrainedModelConfig* p = _impl_.pretrained_model_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::PretrainedModelConfig&>(
      ::clarifai::api::_PretrainedModelConfig_default_instance_);
}
inline const ::clarifai::api::PretrainedModelConfig& ModelVersion::pretrained_model_config() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelVersion.pretrained_model_config)
  return _internal_pretrained_model_config();
}
inline void ModelVersion::unsafe_arena_set_allocated_pretrained_model_config(
    ::clarifai::api::PretrainedModelConfig* pretrained_model_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pretrained_model_config_);
  }
  _impl_.pretrained_model_config_ = pretrained_model_config;
  if (pretrained_model_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.ModelVersion.pretrained_model_config)
}
inline ::clarifai::api::PretrainedModelConfig* ModelVersion::release_pretrained_model_config() {
  
  ::clarifai::api::PretrainedModelConfig* temp = _impl_.pretrained_model_config_;
  _impl_.pretrained_model_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::PretrainedModelConfig* ModelVersion::unsafe_arena_release_pretrained_model_config() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelVersion.pretrained_model_config)
  
  ::clarifai::api::PretrainedModelConfig* temp = _impl_.pretrained_model_config_;
  _impl_.pretrained_model_config_ = nullptr;
  return temp;
}
inline ::clarifai::api::PretrainedModelConfig* ModelVersion::_internal_mutable_pretrained_model_config() {
  
  if (_impl_.pretrained_model_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::PretrainedModelConfig>(GetArenaForAllocation());
    _impl_.pretrained_model_config_ = p;
  }
  return _impl_.pretrained_model_config_;
}
inline ::clarifai::api::PretrainedModelConfig* ModelVersion::mutable_pretrained_model_config() {
  ::clarifai::api::PretrainedModelConfig* _msg = _internal_mutable_pretrained_model_config();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelVersion.pretrained_model_config)
  return _msg;
}
inline void ModelVersion::set_allocated_pretrained_model_config(::clarifai::api::PretrainedModelConfig* pretrained_model_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pretrained_model_config_;
  }
  if (pretrained_model_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pretrained_model_config);
    if (message_arena != submessage_arena) {
      pretrained_model_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pretrained_model_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pretrained_model_config_ = pretrained_model_config;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelVersion.pretrained_model_config)
}

// .google.protobuf.Timestamp completed_at = 10;
inline bool ModelVersion::_internal_has_completed_at() const {
  return this != internal_default_instance() && _impl_.completed_at_ != nullptr;
}
inline bool ModelVersion::has_completed_at() const {
  return _internal_has_completed_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ModelVersion::_internal_completed_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.completed_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ModelVersion::completed_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelVersion.completed_at)
  return _internal_completed_at();
}
inline void ModelVersion::unsafe_arena_set_allocated_completed_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* completed_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.completed_at_);
  }
  _impl_.completed_at_ = completed_at;
  if (completed_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.ModelVersion.completed_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ModelVersion::release_completed_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.completed_at_;
  _impl_.completed_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ModelVersion::unsafe_arena_release_completed_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelVersion.completed_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.completed_at_;
  _impl_.completed_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ModelVersion::_internal_mutable_completed_at() {
  
  if (_impl_.completed_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.completed_at_ = p;
  }
  return _impl_.completed_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ModelVersion::mutable_completed_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_completed_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelVersion.completed_at)
  return _msg;
}
inline void ModelVersion::set_allocated_completed_at(::PROTOBUF_NAMESPACE_ID::Timestamp* completed_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.completed_at_);
  }
  if (completed_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(completed_at));
    if (message_arena != submessage_arena) {
      completed_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, completed_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.completed_at_ = completed_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelVersion.completed_at)
}

// string description = 11;
inline void ModelVersion::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ModelVersion::description() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelVersion.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelVersion::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModelVersion.description)
}
inline std::string* ModelVersion::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelVersion.description)
  return _s;
}
inline const std::string& ModelVersion::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ModelVersion::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelVersion::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelVersion::release_description() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelVersion.description)
  return _impl_.description_.Release();
}
inline void ModelVersion::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelVersion.description)
}

// .clarifai.api.Visibility visibility = 12;
inline bool ModelVersion::_internal_has_visibility() const {
  return this != internal_default_instance() && _impl_.visibility_ != nullptr;
}
inline bool ModelVersion::has_visibility() const {
  return _internal_has_visibility();
}
inline void ModelVersion::clear_visibility() {
  if (GetArenaForAllocation() == nullptr && _impl_.visibility_ != nullptr) {
    delete _impl_.visibility_;
  }
  _impl_.visibility_ = nullptr;
}
inline const ::clarifai::api::Visibility& ModelVersion::_internal_visibility() const {
  const ::clarifai::api::Visibility* p = _impl_.visibility_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Visibility&>(
      ::clarifai::api::_Visibility_default_instance_);
}
inline const ::clarifai::api::Visibility& ModelVersion::visibility() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelVersion.visibility)
  return _internal_visibility();
}
inline void ModelVersion::unsafe_arena_set_allocated_visibility(
    ::clarifai::api::Visibility* visibility) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visibility_);
  }
  _impl_.visibility_ = visibility;
  if (visibility) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.ModelVersion.visibility)
}
inline ::clarifai::api::Visibility* ModelVersion::release_visibility() {
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Visibility* ModelVersion::unsafe_arena_release_visibility() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelVersion.visibility)
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
  return temp;
}
inline ::clarifai::api::Visibility* ModelVersion::_internal_mutable_visibility() {
  
  if (_impl_.visibility_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Visibility>(GetArenaForAllocation());
    _impl_.visibility_ = p;
  }
  return _impl_.visibility_;
}
inline ::clarifai::api::Visibility* ModelVersion::mutable_visibility() {
  ::clarifai::api::Visibility* _msg = _internal_mutable_visibility();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelVersion.visibility)
  return _msg;
}
inline void ModelVersion::set_allocated_visibility(::clarifai::api::Visibility* visibility) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.visibility_;
  }
  if (visibility) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(visibility);
    if (message_arena != submessage_arena) {
      visibility = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visibility, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.visibility_ = visibility;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelVersion.visibility)
}

// string app_id = 13;
inline void ModelVersion::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& ModelVersion::app_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelVersion.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelVersion::set_app_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.app_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModelVersion.app_id)
}
inline std::string* ModelVersion::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelVersion.app_id)
  return _s;
}
inline const std::string& ModelVersion::_internal_app_id() const {
  return _impl_.app_id_.Get();
}
inline void ModelVersion::_internal_set_app_id(const std::string& value) {
  
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelVersion::_internal_mutable_app_id() {
  
  return _impl_.app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelVersion::release_app_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelVersion.app_id)
  return _impl_.app_id_.Release();
}
inline void ModelVersion::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    
  } else {
    
  }
  _impl_.app_id_.SetAllocated(app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelVersion.app_id)
}

// string user_id = 14;
inline void ModelVersion::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& ModelVersion::user_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelVersion.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelVersion::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModelVersion.user_id)
}
inline std::string* ModelVersion::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelVersion.user_id)
  return _s;
}
inline const std::string& ModelVersion::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void ModelVersion::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelVersion::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelVersion::release_user_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelVersion.user_id)
  return _impl_.user_id_.Release();
}
inline void ModelVersion::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelVersion.user_id)
}

// .google.protobuf.Timestamp modified_at = 15;
inline bool ModelVersion::_internal_has_modified_at() const {
  return this != internal_default_instance() && _impl_.modified_at_ != nullptr;
}
inline bool ModelVersion::has_modified_at() const {
  return _internal_has_modified_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ModelVersion::_internal_modified_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.modified_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ModelVersion::modified_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelVersion.modified_at)
  return _internal_modified_at();
}
inline void ModelVersion::unsafe_arena_set_allocated_modified_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  _impl_.modified_at_ = modified_at;
  if (modified_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.ModelVersion.modified_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ModelVersion::release_modified_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ModelVersion::unsafe_arena_release_modified_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelVersion.modified_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ModelVersion::_internal_mutable_modified_at() {
  
  if (_impl_.modified_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.modified_at_ = p;
  }
  return _impl_.modified_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ModelVersion::mutable_modified_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_modified_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelVersion.modified_at)
  return _msg;
}
inline void ModelVersion::set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  if (modified_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(modified_at));
    if (message_arena != submessage_arena) {
      modified_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modified_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.modified_at_ = modified_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelVersion.modified_at)
}

// .google.protobuf.Struct metadata = 16;
inline bool ModelVersion::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool ModelVersion::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ModelVersion::_internal_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ModelVersion::metadata() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelVersion.metadata)
  return _internal_metadata();
}
inline void ModelVersion::unsafe_arena_set_allocated_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.ModelVersion.metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ModelVersion::release_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ModelVersion::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelVersion.metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ModelVersion::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ModelVersion::mutable_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelVersion.metadata)
  return _msg;
}
inline void ModelVersion::set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelVersion.metadata)
}

// string license = 17;
inline void ModelVersion::clear_license() {
  _impl_.license_.ClearToEmpty();
}
inline const std::string& ModelVersion::license() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelVersion.license)
  return _internal_license();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelVersion::set_license(ArgT0&& arg0, ArgT... args) {
 
 _impl_.license_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModelVersion.license)
}
inline std::string* ModelVersion::mutable_license() {
  std::string* _s = _internal_mutable_license();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelVersion.license)
  return _s;
}
inline const std::string& ModelVersion::_internal_license() const {
  return _impl_.license_.Get();
}
inline void ModelVersion::_internal_set_license(const std::string& value) {
  
  _impl_.license_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelVersion::_internal_mutable_license() {
  
  return _impl_.license_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelVersion::release_license() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelVersion.license)
  return _impl_.license_.Release();
}
inline void ModelVersion::set_allocated_license(std::string* license) {
  if (license != nullptr) {
    
  } else {
    
  }
  _impl_.license_.SetAllocated(license, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.license_.IsDefault()) {
    _impl_.license_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelVersion.license)
}

// .clarifai.api.DatasetVersion dataset_version = 18;
inline bool ModelVersion::_internal_has_dataset_version() const {
  return this != internal_default_instance() && _impl_.dataset_version_ != nullptr;
}
inline bool ModelVersion::has_dataset_version() const {
  return _internal_has_dataset_version();
}
inline void ModelVersion::clear_dataset_version() {
  if (GetArenaForAllocation() == nullptr && _impl_.dataset_version_ != nullptr) {
    delete _impl_.dataset_version_;
  }
  _impl_.dataset_version_ = nullptr;
}
inline const ::clarifai::api::DatasetVersion& ModelVersion::_internal_dataset_version() const {
  const ::clarifai::api::DatasetVersion* p = _impl_.dataset_version_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::DatasetVersion&>(
      ::clarifai::api::_DatasetVersion_default_instance_);
}
inline const ::clarifai::api::DatasetVersion& ModelVersion::dataset_version() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelVersion.dataset_version)
  return _internal_dataset_version();
}
inline void ModelVersion::unsafe_arena_set_allocated_dataset_version(
    ::clarifai::api::DatasetVersion* dataset_version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dataset_version_);
  }
  _impl_.dataset_version_ = dataset_version;
  if (dataset_version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.ModelVersion.dataset_version)
}
inline ::clarifai::api::DatasetVersion* ModelVersion::release_dataset_version() {
  
  ::clarifai::api::DatasetVersion* temp = _impl_.dataset_version_;
  _impl_.dataset_version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::DatasetVersion* ModelVersion::unsafe_arena_release_dataset_version() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelVersion.dataset_version)
  
  ::clarifai::api::DatasetVersion* temp = _impl_.dataset_version_;
  _impl_.dataset_version_ = nullptr;
  return temp;
}
inline ::clarifai::api::DatasetVersion* ModelVersion::_internal_mutable_dataset_version() {
  
  if (_impl_.dataset_version_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::DatasetVersion>(GetArenaForAllocation());
    _impl_.dataset_version_ = p;
  }
  return _impl_.dataset_version_;
}
inline ::clarifai::api::DatasetVersion* ModelVersion::mutable_dataset_version() {
  ::clarifai::api::DatasetVersion* _msg = _internal_mutable_dataset_version();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelVersion.dataset_version)
  return _msg;
}
inline void ModelVersion::set_allocated_dataset_version(::clarifai::api::DatasetVersion* dataset_version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dataset_version_;
  }
  if (dataset_version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dataset_version);
    if (message_arena != submessage_arena) {
      dataset_version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dataset_version, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.dataset_version_ = dataset_version;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelVersion.dataset_version)
}

// .clarifai.api.OutputInfo output_info = 19;
inline bool ModelVersion::_internal_has_output_info() const {
  return this != internal_default_instance() && _impl_.output_info_ != nullptr;
}
inline bool ModelVersion::has_output_info() const {
  return _internal_has_output_info();
}
inline void ModelVersion::clear_output_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.output_info_ != nullptr) {
    delete _impl_.output_info_;
  }
  _impl_.output_info_ = nullptr;
}
inline const ::clarifai::api::OutputInfo& ModelVersion::_internal_output_info() const {
  const ::clarifai::api::OutputInfo* p = _impl_.output_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::OutputInfo&>(
      ::clarifai::api::_OutputInfo_default_instance_);
}
inline const ::clarifai::api::OutputInfo& ModelVersion::output_info() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelVersion.output_info)
  return _internal_output_info();
}
inline void ModelVersion::unsafe_arena_set_allocated_output_info(
    ::clarifai::api::OutputInfo* output_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.output_info_);
  }
  _impl_.output_info_ = output_info;
  if (output_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.ModelVersion.output_info)
}
inline ::clarifai::api::OutputInfo* ModelVersion::release_output_info() {
  
  ::clarifai::api::OutputInfo* temp = _impl_.output_info_;
  _impl_.output_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::OutputInfo* ModelVersion::unsafe_arena_release_output_info() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelVersion.output_info)
  
  ::clarifai::api::OutputInfo* temp = _impl_.output_info_;
  _impl_.output_info_ = nullptr;
  return temp;
}
inline ::clarifai::api::OutputInfo* ModelVersion::_internal_mutable_output_info() {
  
  if (_impl_.output_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::OutputInfo>(GetArenaForAllocation());
    _impl_.output_info_ = p;
  }
  return _impl_.output_info_;
}
inline ::clarifai::api::OutputInfo* ModelVersion::mutable_output_info() {
  ::clarifai::api::OutputInfo* _msg = _internal_mutable_output_info();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelVersion.output_info)
  return _msg;
}
inline void ModelVersion::set_allocated_output_info(::clarifai::api::OutputInfo* output_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.output_info_;
  }
  if (output_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(output_info);
    if (message_arena != submessage_arena) {
      output_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, output_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.output_info_ = output_info;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelVersion.output_info)
}

// .clarifai.api.InputInfo input_info = 20;
inline bool ModelVersion::_internal_has_input_info() const {
  return this != internal_default_instance() && _impl_.input_info_ != nullptr;
}
inline bool ModelVersion::has_input_info() const {
  return _internal_has_input_info();
}
inline void ModelVersion::clear_input_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.input_info_ != nullptr) {
    delete _impl_.input_info_;
  }
  _impl_.input_info_ = nullptr;
}
inline const ::clarifai::api::InputInfo& ModelVersion::_internal_input_info() const {
  const ::clarifai::api::InputInfo* p = _impl_.input_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::InputInfo&>(
      ::clarifai::api::_InputInfo_default_instance_);
}
inline const ::clarifai::api::InputInfo& ModelVersion::input_info() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelVersion.input_info)
  return _internal_input_info();
}
inline void ModelVersion::unsafe_arena_set_allocated_input_info(
    ::clarifai::api::InputInfo* input_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.input_info_);
  }
  _impl_.input_info_ = input_info;
  if (input_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.ModelVersion.input_info)
}
inline ::clarifai::api::InputInfo* ModelVersion::release_input_info() {
  
  ::clarifai::api::InputInfo* temp = _impl_.input_info_;
  _impl_.input_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::InputInfo* ModelVersion::unsafe_arena_release_input_info() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelVersion.input_info)
  
  ::clarifai::api::InputInfo* temp = _impl_.input_info_;
  _impl_.input_info_ = nullptr;
  return temp;
}
inline ::clarifai::api::InputInfo* ModelVersion::_internal_mutable_input_info() {
  
  if (_impl_.input_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::InputInfo>(GetArenaForAllocation());
    _impl_.input_info_ = p;
  }
  return _impl_.input_info_;
}
inline ::clarifai::api::InputInfo* ModelVersion::mutable_input_info() {
  ::clarifai::api::InputInfo* _msg = _internal_mutable_input_info();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelVersion.input_info)
  return _msg;
}
inline void ModelVersion::set_allocated_input_info(::clarifai::api::InputInfo* input_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.input_info_;
  }
  if (input_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(input_info);
    if (message_arena != submessage_arena) {
      input_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.input_info_ = input_info;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelVersion.input_info)
}

// .clarifai.api.TrainInfo train_info = 21;
inline bool ModelVersion::_internal_has_train_info() const {
  return this != internal_default_instance() && _impl_.train_info_ != nullptr;
}
inline bool ModelVersion::has_train_info() const {
  return _internal_has_train_info();
}
inline void ModelVersion::clear_train_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.train_info_ != nullptr) {
    delete _impl_.train_info_;
  }
  _impl_.train_info_ = nullptr;
}
inline const ::clarifai::api::TrainInfo& ModelVersion::_internal_train_info() const {
  const ::clarifai::api::TrainInfo* p = _impl_.train_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::TrainInfo&>(
      ::clarifai::api::_TrainInfo_default_instance_);
}
inline const ::clarifai::api::TrainInfo& ModelVersion::train_info() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelVersion.train_info)
  return _internal_train_info();
}
inline void ModelVersion::unsafe_arena_set_allocated_train_info(
    ::clarifai::api::TrainInfo* train_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.train_info_);
  }
  _impl_.train_info_ = train_info;
  if (train_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.ModelVersion.train_info)
}
inline ::clarifai::api::TrainInfo* ModelVersion::release_train_info() {
  
  ::clarifai::api::TrainInfo* temp = _impl_.train_info_;
  _impl_.train_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::TrainInfo* ModelVersion::unsafe_arena_release_train_info() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelVersion.train_info)
  
  ::clarifai::api::TrainInfo* temp = _impl_.train_info_;
  _impl_.train_info_ = nullptr;
  return temp;
}
inline ::clarifai::api::TrainInfo* ModelVersion::_internal_mutable_train_info() {
  
  if (_impl_.train_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::TrainInfo>(GetArenaForAllocation());
    _impl_.train_info_ = p;
  }
  return _impl_.train_info_;
}
inline ::clarifai::api::TrainInfo* ModelVersion::mutable_train_info() {
  ::clarifai::api::TrainInfo* _msg = _internal_mutable_train_info();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelVersion.train_info)
  return _msg;
}
inline void ModelVersion::set_allocated_train_info(::clarifai::api::TrainInfo* train_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.train_info_;
  }
  if (train_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(train_info);
    if (message_arena != submessage_arena) {
      train_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, train_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.train_info_ = train_info;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelVersion.train_info)
}

// .clarifai.api.ImportInfo import_info = 22;
inline bool ModelVersion::_internal_has_import_info() const {
  return this != internal_default_instance() && _impl_.import_info_ != nullptr;
}
inline bool ModelVersion::has_import_info() const {
  return _internal_has_import_info();
}
inline void ModelVersion::clear_import_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.import_info_ != nullptr) {
    delete _impl_.import_info_;
  }
  _impl_.import_info_ = nullptr;
}
inline const ::clarifai::api::ImportInfo& ModelVersion::_internal_import_info() const {
  const ::clarifai::api::ImportInfo* p = _impl_.import_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::ImportInfo&>(
      ::clarifai::api::_ImportInfo_default_instance_);
}
inline const ::clarifai::api::ImportInfo& ModelVersion::import_info() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModelVersion.import_info)
  return _internal_import_info();
}
inline void ModelVersion::unsafe_arena_set_allocated_import_info(
    ::clarifai::api::ImportInfo* import_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.import_info_);
  }
  _impl_.import_info_ = import_info;
  if (import_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.ModelVersion.import_info)
}
inline ::clarifai::api::ImportInfo* ModelVersion::release_import_info() {
  
  ::clarifai::api::ImportInfo* temp = _impl_.import_info_;
  _impl_.import_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::ImportInfo* ModelVersion::unsafe_arena_release_import_info() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModelVersion.import_info)
  
  ::clarifai::api::ImportInfo* temp = _impl_.import_info_;
  _impl_.import_info_ = nullptr;
  return temp;
}
inline ::clarifai::api::ImportInfo* ModelVersion::_internal_mutable_import_info() {
  
  if (_impl_.import_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::ImportInfo>(GetArenaForAllocation());
    _impl_.import_info_ = p;
  }
  return _impl_.import_info_;
}
inline ::clarifai::api::ImportInfo* ModelVersion::mutable_import_info() {
  ::clarifai::api::ImportInfo* _msg = _internal_mutable_import_info();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModelVersion.import_info)
  return _msg;
}
inline void ModelVersion::set_allocated_import_info(::clarifai::api::ImportInfo* import_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.import_info_;
  }
  if (import_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(import_info);
    if (message_arena != submessage_arena) {
      import_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, import_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.import_info_ = import_info;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModelVersion.import_info)
}

// -------------------------------------------------------------------

// PretrainedModelConfig

// .google.protobuf.Struct input_fields_map = 3;
inline bool PretrainedModelConfig::_internal_has_input_fields_map() const {
  return this != internal_default_instance() && _impl_.input_fields_map_ != nullptr;
}
inline bool PretrainedModelConfig::has_input_fields_map() const {
  return _internal_has_input_fields_map();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& PretrainedModelConfig::_internal_input_fields_map() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.input_fields_map_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& PretrainedModelConfig::input_fields_map() const {
  // @@protoc_insertion_point(field_get:clarifai.api.PretrainedModelConfig.input_fields_map)
  return _internal_input_fields_map();
}
inline void PretrainedModelConfig::unsafe_arena_set_allocated_input_fields_map(
    ::PROTOBUF_NAMESPACE_ID::Struct* input_fields_map) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.input_fields_map_);
  }
  _impl_.input_fields_map_ = input_fields_map;
  if (input_fields_map) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.PretrainedModelConfig.input_fields_map)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* PretrainedModelConfig::release_input_fields_map() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.input_fields_map_;
  _impl_.input_fields_map_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* PretrainedModelConfig::unsafe_arena_release_input_fields_map() {
  // @@protoc_insertion_point(field_release:clarifai.api.PretrainedModelConfig.input_fields_map)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.input_fields_map_;
  _impl_.input_fields_map_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* PretrainedModelConfig::_internal_mutable_input_fields_map() {
  
  if (_impl_.input_fields_map_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.input_fields_map_ = p;
  }
  return _impl_.input_fields_map_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* PretrainedModelConfig::mutable_input_fields_map() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_input_fields_map();
  // @@protoc_insertion_point(field_mutable:clarifai.api.PretrainedModelConfig.input_fields_map)
  return _msg;
}
inline void PretrainedModelConfig::set_allocated_input_fields_map(::PROTOBUF_NAMESPACE_ID::Struct* input_fields_map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.input_fields_map_);
  }
  if (input_fields_map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(input_fields_map));
    if (message_arena != submessage_arena) {
      input_fields_map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input_fields_map, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.input_fields_map_ = input_fields_map;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.PretrainedModelConfig.input_fields_map)
}

// .google.protobuf.Struct output_fields_map = 4;
inline bool PretrainedModelConfig::_internal_has_output_fields_map() const {
  return this != internal_default_instance() && _impl_.output_fields_map_ != nullptr;
}
inline bool PretrainedModelConfig::has_output_fields_map() const {
  return _internal_has_output_fields_map();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& PretrainedModelConfig::_internal_output_fields_map() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.output_fields_map_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& PretrainedModelConfig::output_fields_map() const {
  // @@protoc_insertion_point(field_get:clarifai.api.PretrainedModelConfig.output_fields_map)
  return _internal_output_fields_map();
}
inline void PretrainedModelConfig::unsafe_arena_set_allocated_output_fields_map(
    ::PROTOBUF_NAMESPACE_ID::Struct* output_fields_map) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.output_fields_map_);
  }
  _impl_.output_fields_map_ = output_fields_map;
  if (output_fields_map) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.PretrainedModelConfig.output_fields_map)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* PretrainedModelConfig::release_output_fields_map() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.output_fields_map_;
  _impl_.output_fields_map_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* PretrainedModelConfig::unsafe_arena_release_output_fields_map() {
  // @@protoc_insertion_point(field_release:clarifai.api.PretrainedModelConfig.output_fields_map)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.output_fields_map_;
  _impl_.output_fields_map_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* PretrainedModelConfig::_internal_mutable_output_fields_map() {
  
  if (_impl_.output_fields_map_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.output_fields_map_ = p;
  }
  return _impl_.output_fields_map_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* PretrainedModelConfig::mutable_output_fields_map() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_output_fields_map();
  // @@protoc_insertion_point(field_mutable:clarifai.api.PretrainedModelConfig.output_fields_map)
  return _msg;
}
inline void PretrainedModelConfig::set_allocated_output_fields_map(::PROTOBUF_NAMESPACE_ID::Struct* output_fields_map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.output_fields_map_);
  }
  if (output_fields_map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(output_fields_map));
    if (message_arena != submessage_arena) {
      output_fields_map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, output_fields_map, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.output_fields_map_ = output_fields_map;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.PretrainedModelConfig.output_fields_map)
}

// string model_zip_url = 6;
inline void PretrainedModelConfig::clear_model_zip_url() {
  _impl_.model_zip_url_.ClearToEmpty();
}
inline const std::string& PretrainedModelConfig::model_zip_url() const {
  // @@protoc_insertion_point(field_get:clarifai.api.PretrainedModelConfig.model_zip_url)
  return _internal_model_zip_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PretrainedModelConfig::set_model_zip_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_zip_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.PretrainedModelConfig.model_zip_url)
}
inline std::string* PretrainedModelConfig::mutable_model_zip_url() {
  std::string* _s = _internal_mutable_model_zip_url();
  // @@protoc_insertion_point(field_mutable:clarifai.api.PretrainedModelConfig.model_zip_url)
  return _s;
}
inline const std::string& PretrainedModelConfig::_internal_model_zip_url() const {
  return _impl_.model_zip_url_.Get();
}
inline void PretrainedModelConfig::_internal_set_model_zip_url(const std::string& value) {
  
  _impl_.model_zip_url_.Set(value, GetArenaForAllocation());
}
inline std::string* PretrainedModelConfig::_internal_mutable_model_zip_url() {
  
  return _impl_.model_zip_url_.Mutable(GetArenaForAllocation());
}
inline std::string* PretrainedModelConfig::release_model_zip_url() {
  // @@protoc_insertion_point(field_release:clarifai.api.PretrainedModelConfig.model_zip_url)
  return _impl_.model_zip_url_.Release();
}
inline void PretrainedModelConfig::set_allocated_model_zip_url(std::string* model_zip_url) {
  if (model_zip_url != nullptr) {
    
  } else {
    
  }
  _impl_.model_zip_url_.SetAllocated(model_zip_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_zip_url_.IsDefault()) {
    _impl_.model_zip_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.PretrainedModelConfig.model_zip_url)
}

// -------------------------------------------------------------------

// TrainStats

// repeated .clarifai.api.LossCurveEntry loss_curve = 1;
inline int TrainStats::_internal_loss_curve_size() const {
  return _impl_.loss_curve_.size();
}
inline int TrainStats::loss_curve_size() const {
  return _internal_loss_curve_size();
}
inline void TrainStats::clear_loss_curve() {
  _impl_.loss_curve_.Clear();
}
inline ::clarifai::api::LossCurveEntry* TrainStats::mutable_loss_curve(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.TrainStats.loss_curve)
  return _impl_.loss_curve_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::LossCurveEntry >*
TrainStats::mutable_loss_curve() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.TrainStats.loss_curve)
  return &_impl_.loss_curve_;
}
inline const ::clarifai::api::LossCurveEntry& TrainStats::_internal_loss_curve(int index) const {
  return _impl_.loss_curve_.Get(index);
}
inline const ::clarifai::api::LossCurveEntry& TrainStats::loss_curve(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.TrainStats.loss_curve)
  return _internal_loss_curve(index);
}
inline ::clarifai::api::LossCurveEntry* TrainStats::_internal_add_loss_curve() {
  return _impl_.loss_curve_.Add();
}
inline ::clarifai::api::LossCurveEntry* TrainStats::add_loss_curve() {
  ::clarifai::api::LossCurveEntry* _add = _internal_add_loss_curve();
  // @@protoc_insertion_point(field_add:clarifai.api.TrainStats.loss_curve)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::LossCurveEntry >&
TrainStats::loss_curve() const {
  // @@protoc_insertion_point(field_list:clarifai.api.TrainStats.loss_curve)
  return _impl_.loss_curve_;
}

// -------------------------------------------------------------------

// LossCurveEntry

// uint32 epoch = 1;
inline void LossCurveEntry::clear_epoch() {
  _impl_.epoch_ = 0u;
}
inline uint32_t LossCurveEntry::_internal_epoch() const {
  return _impl_.epoch_;
}
inline uint32_t LossCurveEntry::epoch() const {
  // @@protoc_insertion_point(field_get:clarifai.api.LossCurveEntry.epoch)
  return _internal_epoch();
}
inline void LossCurveEntry::_internal_set_epoch(uint32_t value) {
  
  _impl_.epoch_ = value;
}
inline void LossCurveEntry::set_epoch(uint32_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:clarifai.api.LossCurveEntry.epoch)
}

// uint32 global_step = 2;
inline void LossCurveEntry::clear_global_step() {
  _impl_.global_step_ = 0u;
}
inline uint32_t LossCurveEntry::_internal_global_step() const {
  return _impl_.global_step_;
}
inline uint32_t LossCurveEntry::global_step() const {
  // @@protoc_insertion_point(field_get:clarifai.api.LossCurveEntry.global_step)
  return _internal_global_step();
}
inline void LossCurveEntry::_internal_set_global_step(uint32_t value) {
  
  _impl_.global_step_ = value;
}
inline void LossCurveEntry::set_global_step(uint32_t value) {
  _internal_set_global_step(value);
  // @@protoc_insertion_point(field_set:clarifai.api.LossCurveEntry.global_step)
}

// float cost = 3;
inline void LossCurveEntry::clear_cost() {
  _impl_.cost_ = 0;
}
inline float LossCurveEntry::_internal_cost() const {
  return _impl_.cost_;
}
inline float LossCurveEntry::cost() const {
  // @@protoc_insertion_point(field_get:clarifai.api.LossCurveEntry.cost)
  return _internal_cost();
}
inline void LossCurveEntry::_internal_set_cost(float value) {
  
  _impl_.cost_ = value;
}
inline void LossCurveEntry::set_cost(float value) {
  _internal_set_cost(value);
  // @@protoc_insertion_point(field_set:clarifai.api.LossCurveEntry.cost)
}

// -------------------------------------------------------------------

// LabelCount

// string concept_name = 1;
inline void LabelCount::clear_concept_name() {
  _impl_.concept_name_.ClearToEmpty();
}
inline const std::string& LabelCount::concept_name() const {
  // @@protoc_insertion_point(field_get:clarifai.api.LabelCount.concept_name)
  return _internal_concept_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LabelCount::set_concept_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.concept_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.LabelCount.concept_name)
}
inline std::string* LabelCount::mutable_concept_name() {
  std::string* _s = _internal_mutable_concept_name();
  // @@protoc_insertion_point(field_mutable:clarifai.api.LabelCount.concept_name)
  return _s;
}
inline const std::string& LabelCount::_internal_concept_name() const {
  return _impl_.concept_name_.Get();
}
inline void LabelCount::_internal_set_concept_name(const std::string& value) {
  
  _impl_.concept_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LabelCount::_internal_mutable_concept_name() {
  
  return _impl_.concept_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LabelCount::release_concept_name() {
  // @@protoc_insertion_point(field_release:clarifai.api.LabelCount.concept_name)
  return _impl_.concept_name_.Release();
}
inline void LabelCount::set_allocated_concept_name(std::string* concept_name) {
  if (concept_name != nullptr) {
    
  } else {
    
  }
  _impl_.concept_name_.SetAllocated(concept_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.concept_name_.IsDefault()) {
    _impl_.concept_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.LabelCount.concept_name)
}

// uint32 count = 2;
inline void LabelCount::clear_count() {
  _impl_.count_ = 0u;
}
inline uint32_t LabelCount::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t LabelCount::count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.LabelCount.count)
  return _internal_count();
}
inline void LabelCount::_internal_set_count(uint32_t value) {
  
  _impl_.count_ = value;
}
inline void LabelCount::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:clarifai.api.LabelCount.count)
}

// -------------------------------------------------------------------

// LabelDistribution

// repeated .clarifai.api.LabelCount positive_label_counts = 1;
inline int LabelDistribution::_internal_positive_label_counts_size() const {
  return _impl_.positive_label_counts_.size();
}
inline int LabelDistribution::positive_label_counts_size() const {
  return _internal_positive_label_counts_size();
}
inline void LabelDistribution::clear_positive_label_counts() {
  _impl_.positive_label_counts_.Clear();
}
inline ::clarifai::api::LabelCount* LabelDistribution::mutable_positive_label_counts(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.LabelDistribution.positive_label_counts)
  return _impl_.positive_label_counts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::LabelCount >*
LabelDistribution::mutable_positive_label_counts() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.LabelDistribution.positive_label_counts)
  return &_impl_.positive_label_counts_;
}
inline const ::clarifai::api::LabelCount& LabelDistribution::_internal_positive_label_counts(int index) const {
  return _impl_.positive_label_counts_.Get(index);
}
inline const ::clarifai::api::LabelCount& LabelDistribution::positive_label_counts(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.LabelDistribution.positive_label_counts)
  return _internal_positive_label_counts(index);
}
inline ::clarifai::api::LabelCount* LabelDistribution::_internal_add_positive_label_counts() {
  return _impl_.positive_label_counts_.Add();
}
inline ::clarifai::api::LabelCount* LabelDistribution::add_positive_label_counts() {
  ::clarifai::api::LabelCount* _add = _internal_add_positive_label_counts();
  // @@protoc_insertion_point(field_add:clarifai.api.LabelDistribution.positive_label_counts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::LabelCount >&
LabelDistribution::positive_label_counts() const {
  // @@protoc_insertion_point(field_list:clarifai.api.LabelDistribution.positive_label_counts)
  return _impl_.positive_label_counts_;
}

// -------------------------------------------------------------------

// CooccurrenceMatrixEntry

// string row = 1;
inline void CooccurrenceMatrixEntry::clear_row() {
  _impl_.row_.ClearToEmpty();
}
inline const std::string& CooccurrenceMatrixEntry::row() const {
  // @@protoc_insertion_point(field_get:clarifai.api.CooccurrenceMatrixEntry.row)
  return _internal_row();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CooccurrenceMatrixEntry::set_row(ArgT0&& arg0, ArgT... args) {
 
 _impl_.row_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.CooccurrenceMatrixEntry.row)
}
inline std::string* CooccurrenceMatrixEntry::mutable_row() {
  std::string* _s = _internal_mutable_row();
  // @@protoc_insertion_point(field_mutable:clarifai.api.CooccurrenceMatrixEntry.row)
  return _s;
}
inline const std::string& CooccurrenceMatrixEntry::_internal_row() const {
  return _impl_.row_.Get();
}
inline void CooccurrenceMatrixEntry::_internal_set_row(const std::string& value) {
  
  _impl_.row_.Set(value, GetArenaForAllocation());
}
inline std::string* CooccurrenceMatrixEntry::_internal_mutable_row() {
  
  return _impl_.row_.Mutable(GetArenaForAllocation());
}
inline std::string* CooccurrenceMatrixEntry::release_row() {
  // @@protoc_insertion_point(field_release:clarifai.api.CooccurrenceMatrixEntry.row)
  return _impl_.row_.Release();
}
inline void CooccurrenceMatrixEntry::set_allocated_row(std::string* row) {
  if (row != nullptr) {
    
  } else {
    
  }
  _impl_.row_.SetAllocated(row, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.row_.IsDefault()) {
    _impl_.row_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.CooccurrenceMatrixEntry.row)
}

// string col = 2;
inline void CooccurrenceMatrixEntry::clear_col() {
  _impl_.col_.ClearToEmpty();
}
inline const std::string& CooccurrenceMatrixEntry::col() const {
  // @@protoc_insertion_point(field_get:clarifai.api.CooccurrenceMatrixEntry.col)
  return _internal_col();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CooccurrenceMatrixEntry::set_col(ArgT0&& arg0, ArgT... args) {
 
 _impl_.col_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.CooccurrenceMatrixEntry.col)
}
inline std::string* CooccurrenceMatrixEntry::mutable_col() {
  std::string* _s = _internal_mutable_col();
  // @@protoc_insertion_point(field_mutable:clarifai.api.CooccurrenceMatrixEntry.col)
  return _s;
}
inline const std::string& CooccurrenceMatrixEntry::_internal_col() const {
  return _impl_.col_.Get();
}
inline void CooccurrenceMatrixEntry::_internal_set_col(const std::string& value) {
  
  _impl_.col_.Set(value, GetArenaForAllocation());
}
inline std::string* CooccurrenceMatrixEntry::_internal_mutable_col() {
  
  return _impl_.col_.Mutable(GetArenaForAllocation());
}
inline std::string* CooccurrenceMatrixEntry::release_col() {
  // @@protoc_insertion_point(field_release:clarifai.api.CooccurrenceMatrixEntry.col)
  return _impl_.col_.Release();
}
inline void CooccurrenceMatrixEntry::set_allocated_col(std::string* col) {
  if (col != nullptr) {
    
  } else {
    
  }
  _impl_.col_.SetAllocated(col, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_.IsDefault()) {
    _impl_.col_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.CooccurrenceMatrixEntry.col)
}

// uint32 count = 3;
inline void CooccurrenceMatrixEntry::clear_count() {
  _impl_.count_ = 0u;
}
inline uint32_t CooccurrenceMatrixEntry::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t CooccurrenceMatrixEntry::count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.CooccurrenceMatrixEntry.count)
  return _internal_count();
}
inline void CooccurrenceMatrixEntry::_internal_set_count(uint32_t value) {
  
  _impl_.count_ = value;
}
inline void CooccurrenceMatrixEntry::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:clarifai.api.CooccurrenceMatrixEntry.count)
}

// -------------------------------------------------------------------

// CooccurrenceMatrix

// repeated .clarifai.api.CooccurrenceMatrixEntry matrix = 1;
inline int CooccurrenceMatrix::_internal_matrix_size() const {
  return _impl_.matrix_.size();
}
inline int CooccurrenceMatrix::matrix_size() const {
  return _internal_matrix_size();
}
inline void CooccurrenceMatrix::clear_matrix() {
  _impl_.matrix_.Clear();
}
inline ::clarifai::api::CooccurrenceMatrixEntry* CooccurrenceMatrix::mutable_matrix(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.CooccurrenceMatrix.matrix)
  return _impl_.matrix_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::CooccurrenceMatrixEntry >*
CooccurrenceMatrix::mutable_matrix() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.CooccurrenceMatrix.matrix)
  return &_impl_.matrix_;
}
inline const ::clarifai::api::CooccurrenceMatrixEntry& CooccurrenceMatrix::_internal_matrix(int index) const {
  return _impl_.matrix_.Get(index);
}
inline const ::clarifai::api::CooccurrenceMatrixEntry& CooccurrenceMatrix::matrix(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.CooccurrenceMatrix.matrix)
  return _internal_matrix(index);
}
inline ::clarifai::api::CooccurrenceMatrixEntry* CooccurrenceMatrix::_internal_add_matrix() {
  return _impl_.matrix_.Add();
}
inline ::clarifai::api::CooccurrenceMatrixEntry* CooccurrenceMatrix::add_matrix() {
  ::clarifai::api::CooccurrenceMatrixEntry* _add = _internal_add_matrix();
  // @@protoc_insertion_point(field_add:clarifai.api.CooccurrenceMatrix.matrix)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::CooccurrenceMatrixEntry >&
CooccurrenceMatrix::matrix() const {
  // @@protoc_insertion_point(field_list:clarifai.api.CooccurrenceMatrix.matrix)
  return _impl_.matrix_;
}

// repeated string concept_ids = 2;
inline int CooccurrenceMatrix::_internal_concept_ids_size() const {
  return _impl_.concept_ids_.size();
}
inline int CooccurrenceMatrix::concept_ids_size() const {
  return _internal_concept_ids_size();
}
inline void CooccurrenceMatrix::clear_concept_ids() {
  _impl_.concept_ids_.Clear();
}
inline std::string* CooccurrenceMatrix::add_concept_ids() {
  std::string* _s = _internal_add_concept_ids();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.CooccurrenceMatrix.concept_ids)
  return _s;
}
inline const std::string& CooccurrenceMatrix::_internal_concept_ids(int index) const {
  return _impl_.concept_ids_.Get(index);
}
inline const std::string& CooccurrenceMatrix::concept_ids(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.CooccurrenceMatrix.concept_ids)
  return _internal_concept_ids(index);
}
inline std::string* CooccurrenceMatrix::mutable_concept_ids(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.CooccurrenceMatrix.concept_ids)
  return _impl_.concept_ids_.Mutable(index);
}
inline void CooccurrenceMatrix::set_concept_ids(int index, const std::string& value) {
  _impl_.concept_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.CooccurrenceMatrix.concept_ids)
}
inline void CooccurrenceMatrix::set_concept_ids(int index, std::string&& value) {
  _impl_.concept_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.CooccurrenceMatrix.concept_ids)
}
inline void CooccurrenceMatrix::set_concept_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.concept_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.CooccurrenceMatrix.concept_ids)
}
inline void CooccurrenceMatrix::set_concept_ids(int index, const char* value, size_t size) {
  _impl_.concept_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.CooccurrenceMatrix.concept_ids)
}
inline std::string* CooccurrenceMatrix::_internal_add_concept_ids() {
  return _impl_.concept_ids_.Add();
}
inline void CooccurrenceMatrix::add_concept_ids(const std::string& value) {
  _impl_.concept_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.CooccurrenceMatrix.concept_ids)
}
inline void CooccurrenceMatrix::add_concept_ids(std::string&& value) {
  _impl_.concept_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.CooccurrenceMatrix.concept_ids)
}
inline void CooccurrenceMatrix::add_concept_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.concept_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.CooccurrenceMatrix.concept_ids)
}
inline void CooccurrenceMatrix::add_concept_ids(const char* value, size_t size) {
  _impl_.concept_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.CooccurrenceMatrix.concept_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CooccurrenceMatrix::concept_ids() const {
  // @@protoc_insertion_point(field_list:clarifai.api.CooccurrenceMatrix.concept_ids)
  return _impl_.concept_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CooccurrenceMatrix::mutable_concept_ids() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.CooccurrenceMatrix.concept_ids)
  return &_impl_.concept_ids_;
}

// -------------------------------------------------------------------

// ConfusionMatrixEntry

// string predicted = 1;
inline void ConfusionMatrixEntry::clear_predicted() {
  _impl_.predicted_.ClearToEmpty();
}
inline const std::string& ConfusionMatrixEntry::predicted() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ConfusionMatrixEntry.predicted)
  return _internal_predicted();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfusionMatrixEntry::set_predicted(ArgT0&& arg0, ArgT... args) {
 
 _impl_.predicted_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ConfusionMatrixEntry.predicted)
}
inline std::string* ConfusionMatrixEntry::mutable_predicted() {
  std::string* _s = _internal_mutable_predicted();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ConfusionMatrixEntry.predicted)
  return _s;
}
inline const std::string& ConfusionMatrixEntry::_internal_predicted() const {
  return _impl_.predicted_.Get();
}
inline void ConfusionMatrixEntry::_internal_set_predicted(const std::string& value) {
  
  _impl_.predicted_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfusionMatrixEntry::_internal_mutable_predicted() {
  
  return _impl_.predicted_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfusionMatrixEntry::release_predicted() {
  // @@protoc_insertion_point(field_release:clarifai.api.ConfusionMatrixEntry.predicted)
  return _impl_.predicted_.Release();
}
inline void ConfusionMatrixEntry::set_allocated_predicted(std::string* predicted) {
  if (predicted != nullptr) {
    
  } else {
    
  }
  _impl_.predicted_.SetAllocated(predicted, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.predicted_.IsDefault()) {
    _impl_.predicted_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ConfusionMatrixEntry.predicted)
}

// string actual = 2;
inline void ConfusionMatrixEntry::clear_actual() {
  _impl_.actual_.ClearToEmpty();
}
inline const std::string& ConfusionMatrixEntry::actual() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ConfusionMatrixEntry.actual)
  return _internal_actual();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfusionMatrixEntry::set_actual(ArgT0&& arg0, ArgT... args) {
 
 _impl_.actual_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ConfusionMatrixEntry.actual)
}
inline std::string* ConfusionMatrixEntry::mutable_actual() {
  std::string* _s = _internal_mutable_actual();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ConfusionMatrixEntry.actual)
  return _s;
}
inline const std::string& ConfusionMatrixEntry::_internal_actual() const {
  return _impl_.actual_.Get();
}
inline void ConfusionMatrixEntry::_internal_set_actual(const std::string& value) {
  
  _impl_.actual_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfusionMatrixEntry::_internal_mutable_actual() {
  
  return _impl_.actual_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfusionMatrixEntry::release_actual() {
  // @@protoc_insertion_point(field_release:clarifai.api.ConfusionMatrixEntry.actual)
  return _impl_.actual_.Release();
}
inline void ConfusionMatrixEntry::set_allocated_actual(std::string* actual) {
  if (actual != nullptr) {
    
  } else {
    
  }
  _impl_.actual_.SetAllocated(actual, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.actual_.IsDefault()) {
    _impl_.actual_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ConfusionMatrixEntry.actual)
}

// float value = 4 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void ConfusionMatrixEntry::clear_value() {
  _impl_.value_ = 0;
}
inline float ConfusionMatrixEntry::_internal_value() const {
  return _impl_.value_;
}
inline float ConfusionMatrixEntry::value() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ConfusionMatrixEntry.value)
  return _internal_value();
}
inline void ConfusionMatrixEntry::_internal_set_value(float value) {
  
  _impl_.value_ = value;
}
inline void ConfusionMatrixEntry::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:clarifai.api.ConfusionMatrixEntry.value)
}

// -------------------------------------------------------------------

// ConfusionMatrix

// repeated .clarifai.api.ConfusionMatrixEntry matrix = 1;
inline int ConfusionMatrix::_internal_matrix_size() const {
  return _impl_.matrix_.size();
}
inline int ConfusionMatrix::matrix_size() const {
  return _internal_matrix_size();
}
inline void ConfusionMatrix::clear_matrix() {
  _impl_.matrix_.Clear();
}
inline ::clarifai::api::ConfusionMatrixEntry* ConfusionMatrix::mutable_matrix(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.ConfusionMatrix.matrix)
  return _impl_.matrix_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ConfusionMatrixEntry >*
ConfusionMatrix::mutable_matrix() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.ConfusionMatrix.matrix)
  return &_impl_.matrix_;
}
inline const ::clarifai::api::ConfusionMatrixEntry& ConfusionMatrix::_internal_matrix(int index) const {
  return _impl_.matrix_.Get(index);
}
inline const ::clarifai::api::ConfusionMatrixEntry& ConfusionMatrix::matrix(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.ConfusionMatrix.matrix)
  return _internal_matrix(index);
}
inline ::clarifai::api::ConfusionMatrixEntry* ConfusionMatrix::_internal_add_matrix() {
  return _impl_.matrix_.Add();
}
inline ::clarifai::api::ConfusionMatrixEntry* ConfusionMatrix::add_matrix() {
  ::clarifai::api::ConfusionMatrixEntry* _add = _internal_add_matrix();
  // @@protoc_insertion_point(field_add:clarifai.api.ConfusionMatrix.matrix)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ConfusionMatrixEntry >&
ConfusionMatrix::matrix() const {
  // @@protoc_insertion_point(field_list:clarifai.api.ConfusionMatrix.matrix)
  return _impl_.matrix_;
}

// repeated string concept_ids = 2;
inline int ConfusionMatrix::_internal_concept_ids_size() const {
  return _impl_.concept_ids_.size();
}
inline int ConfusionMatrix::concept_ids_size() const {
  return _internal_concept_ids_size();
}
inline void ConfusionMatrix::clear_concept_ids() {
  _impl_.concept_ids_.Clear();
}
inline std::string* ConfusionMatrix::add_concept_ids() {
  std::string* _s = _internal_add_concept_ids();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.ConfusionMatrix.concept_ids)
  return _s;
}
inline const std::string& ConfusionMatrix::_internal_concept_ids(int index) const {
  return _impl_.concept_ids_.Get(index);
}
inline const std::string& ConfusionMatrix::concept_ids(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.ConfusionMatrix.concept_ids)
  return _internal_concept_ids(index);
}
inline std::string* ConfusionMatrix::mutable_concept_ids(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.ConfusionMatrix.concept_ids)
  return _impl_.concept_ids_.Mutable(index);
}
inline void ConfusionMatrix::set_concept_ids(int index, const std::string& value) {
  _impl_.concept_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.ConfusionMatrix.concept_ids)
}
inline void ConfusionMatrix::set_concept_ids(int index, std::string&& value) {
  _impl_.concept_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.ConfusionMatrix.concept_ids)
}
inline void ConfusionMatrix::set_concept_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.concept_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.ConfusionMatrix.concept_ids)
}
inline void ConfusionMatrix::set_concept_ids(int index, const char* value, size_t size) {
  _impl_.concept_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.ConfusionMatrix.concept_ids)
}
inline std::string* ConfusionMatrix::_internal_add_concept_ids() {
  return _impl_.concept_ids_.Add();
}
inline void ConfusionMatrix::add_concept_ids(const std::string& value) {
  _impl_.concept_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.ConfusionMatrix.concept_ids)
}
inline void ConfusionMatrix::add_concept_ids(std::string&& value) {
  _impl_.concept_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.ConfusionMatrix.concept_ids)
}
inline void ConfusionMatrix::add_concept_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.concept_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.ConfusionMatrix.concept_ids)
}
inline void ConfusionMatrix::add_concept_ids(const char* value, size_t size) {
  _impl_.concept_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.ConfusionMatrix.concept_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ConfusionMatrix::concept_ids() const {
  // @@protoc_insertion_point(field_list:clarifai.api.ConfusionMatrix.concept_ids)
  return _impl_.concept_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ConfusionMatrix::mutable_concept_ids() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.ConfusionMatrix.concept_ids)
  return &_impl_.concept_ids_;
}

// -------------------------------------------------------------------

// ROC

// repeated float fpr = 1 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline int ROC::_internal_fpr_size() const {
  return _impl_.fpr_.size();
}
inline int ROC::fpr_size() const {
  return _internal_fpr_size();
}
inline void ROC::clear_fpr() {
  _impl_.fpr_.Clear();
}
inline float ROC::_internal_fpr(int index) const {
  return _impl_.fpr_.Get(index);
}
inline float ROC::fpr(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.ROC.fpr)
  return _internal_fpr(index);
}
inline void ROC::set_fpr(int index, float value) {
  _impl_.fpr_.Set(index, value);
  // @@protoc_insertion_point(field_set:clarifai.api.ROC.fpr)
}
inline void ROC::_internal_add_fpr(float value) {
  _impl_.fpr_.Add(value);
}
inline void ROC::add_fpr(float value) {
  _internal_add_fpr(value);
  // @@protoc_insertion_point(field_add:clarifai.api.ROC.fpr)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ROC::_internal_fpr() const {
  return _impl_.fpr_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ROC::fpr() const {
  // @@protoc_insertion_point(field_list:clarifai.api.ROC.fpr)
  return _internal_fpr();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ROC::_internal_mutable_fpr() {
  return &_impl_.fpr_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ROC::mutable_fpr() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.ROC.fpr)
  return _internal_mutable_fpr();
}

// repeated float tpr = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline int ROC::_internal_tpr_size() const {
  return _impl_.tpr_.size();
}
inline int ROC::tpr_size() const {
  return _internal_tpr_size();
}
inline void ROC::clear_tpr() {
  _impl_.tpr_.Clear();
}
inline float ROC::_internal_tpr(int index) const {
  return _impl_.tpr_.Get(index);
}
inline float ROC::tpr(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.ROC.tpr)
  return _internal_tpr(index);
}
inline void ROC::set_tpr(int index, float value) {
  _impl_.tpr_.Set(index, value);
  // @@protoc_insertion_point(field_set:clarifai.api.ROC.tpr)
}
inline void ROC::_internal_add_tpr(float value) {
  _impl_.tpr_.Add(value);
}
inline void ROC::add_tpr(float value) {
  _internal_add_tpr(value);
  // @@protoc_insertion_point(field_add:clarifai.api.ROC.tpr)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ROC::_internal_tpr() const {
  return _impl_.tpr_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ROC::tpr() const {
  // @@protoc_insertion_point(field_list:clarifai.api.ROC.tpr)
  return _internal_tpr();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ROC::_internal_mutable_tpr() {
  return &_impl_.tpr_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ROC::mutable_tpr() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.ROC.tpr)
  return _internal_mutable_tpr();
}

// repeated float thresholds = 3 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline int ROC::_internal_thresholds_size() const {
  return _impl_.thresholds_.size();
}
inline int ROC::thresholds_size() const {
  return _internal_thresholds_size();
}
inline void ROC::clear_thresholds() {
  _impl_.thresholds_.Clear();
}
inline float ROC::_internal_thresholds(int index) const {
  return _impl_.thresholds_.Get(index);
}
inline float ROC::thresholds(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.ROC.thresholds)
  return _internal_thresholds(index);
}
inline void ROC::set_thresholds(int index, float value) {
  _impl_.thresholds_.Set(index, value);
  // @@protoc_insertion_point(field_set:clarifai.api.ROC.thresholds)
}
inline void ROC::_internal_add_thresholds(float value) {
  _impl_.thresholds_.Add(value);
}
inline void ROC::add_thresholds(float value) {
  _internal_add_thresholds(value);
  // @@protoc_insertion_point(field_add:clarifai.api.ROC.thresholds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ROC::_internal_thresholds() const {
  return _impl_.thresholds_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ROC::thresholds() const {
  // @@protoc_insertion_point(field_list:clarifai.api.ROC.thresholds)
  return _internal_thresholds();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ROC::_internal_mutable_thresholds() {
  return &_impl_.thresholds_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ROC::mutable_thresholds() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.ROC.thresholds)
  return _internal_mutable_thresholds();
}

// repeated float fpr_per_image = 4;
inline int ROC::_internal_fpr_per_image_size() const {
  return _impl_.fpr_per_image_.size();
}
inline int ROC::fpr_per_image_size() const {
  return _internal_fpr_per_image_size();
}
inline void ROC::clear_fpr_per_image() {
  _impl_.fpr_per_image_.Clear();
}
inline float ROC::_internal_fpr_per_image(int index) const {
  return _impl_.fpr_per_image_.Get(index);
}
inline float ROC::fpr_per_image(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.ROC.fpr_per_image)
  return _internal_fpr_per_image(index);
}
inline void ROC::set_fpr_per_image(int index, float value) {
  _impl_.fpr_per_image_.Set(index, value);
  // @@protoc_insertion_point(field_set:clarifai.api.ROC.fpr_per_image)
}
inline void ROC::_internal_add_fpr_per_image(float value) {
  _impl_.fpr_per_image_.Add(value);
}
inline void ROC::add_fpr_per_image(float value) {
  _internal_add_fpr_per_image(value);
  // @@protoc_insertion_point(field_add:clarifai.api.ROC.fpr_per_image)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ROC::_internal_fpr_per_image() const {
  return _impl_.fpr_per_image_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ROC::fpr_per_image() const {
  // @@protoc_insertion_point(field_list:clarifai.api.ROC.fpr_per_image)
  return _internal_fpr_per_image();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ROC::_internal_mutable_fpr_per_image() {
  return &_impl_.fpr_per_image_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ROC::mutable_fpr_per_image() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.ROC.fpr_per_image)
  return _internal_mutable_fpr_per_image();
}

// repeated float fpr_per_object = 5;
inline int ROC::_internal_fpr_per_object_size() const {
  return _impl_.fpr_per_object_.size();
}
inline int ROC::fpr_per_object_size() const {
  return _internal_fpr_per_object_size();
}
inline void ROC::clear_fpr_per_object() {
  _impl_.fpr_per_object_.Clear();
}
inline float ROC::_internal_fpr_per_object(int index) const {
  return _impl_.fpr_per_object_.Get(index);
}
inline float ROC::fpr_per_object(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.ROC.fpr_per_object)
  return _internal_fpr_per_object(index);
}
inline void ROC::set_fpr_per_object(int index, float value) {
  _impl_.fpr_per_object_.Set(index, value);
  // @@protoc_insertion_point(field_set:clarifai.api.ROC.fpr_per_object)
}
inline void ROC::_internal_add_fpr_per_object(float value) {
  _impl_.fpr_per_object_.Add(value);
}
inline void ROC::add_fpr_per_object(float value) {
  _internal_add_fpr_per_object(value);
  // @@protoc_insertion_point(field_add:clarifai.api.ROC.fpr_per_object)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ROC::_internal_fpr_per_object() const {
  return _impl_.fpr_per_object_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ROC::fpr_per_object() const {
  // @@protoc_insertion_point(field_list:clarifai.api.ROC.fpr_per_object)
  return _internal_fpr_per_object();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ROC::_internal_mutable_fpr_per_object() {
  return &_impl_.fpr_per_object_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ROC::mutable_fpr_per_object() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.ROC.fpr_per_object)
  return _internal_mutable_fpr_per_object();
}

// -------------------------------------------------------------------

// PrecisionRecallCurve

// repeated float recall = 1 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline int PrecisionRecallCurve::_internal_recall_size() const {
  return _impl_.recall_.size();
}
inline int PrecisionRecallCurve::recall_size() const {
  return _internal_recall_size();
}
inline void PrecisionRecallCurve::clear_recall() {
  _impl_.recall_.Clear();
}
inline float PrecisionRecallCurve::_internal_recall(int index) const {
  return _impl_.recall_.Get(index);
}
inline float PrecisionRecallCurve::recall(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.PrecisionRecallCurve.recall)
  return _internal_recall(index);
}
inline void PrecisionRecallCurve::set_recall(int index, float value) {
  _impl_.recall_.Set(index, value);
  // @@protoc_insertion_point(field_set:clarifai.api.PrecisionRecallCurve.recall)
}
inline void PrecisionRecallCurve::_internal_add_recall(float value) {
  _impl_.recall_.Add(value);
}
inline void PrecisionRecallCurve::add_recall(float value) {
  _internal_add_recall(value);
  // @@protoc_insertion_point(field_add:clarifai.api.PrecisionRecallCurve.recall)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
PrecisionRecallCurve::_internal_recall() const {
  return _impl_.recall_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
PrecisionRecallCurve::recall() const {
  // @@protoc_insertion_point(field_list:clarifai.api.PrecisionRecallCurve.recall)
  return _internal_recall();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
PrecisionRecallCurve::_internal_mutable_recall() {
  return &_impl_.recall_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
PrecisionRecallCurve::mutable_recall() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.PrecisionRecallCurve.recall)
  return _internal_mutable_recall();
}

// repeated float precision = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline int PrecisionRecallCurve::_internal_precision_size() const {
  return _impl_.precision_.size();
}
inline int PrecisionRecallCurve::precision_size() const {
  return _internal_precision_size();
}
inline void PrecisionRecallCurve::clear_precision() {
  _impl_.precision_.Clear();
}
inline float PrecisionRecallCurve::_internal_precision(int index) const {
  return _impl_.precision_.Get(index);
}
inline float PrecisionRecallCurve::precision(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.PrecisionRecallCurve.precision)
  return _internal_precision(index);
}
inline void PrecisionRecallCurve::set_precision(int index, float value) {
  _impl_.precision_.Set(index, value);
  // @@protoc_insertion_point(field_set:clarifai.api.PrecisionRecallCurve.precision)
}
inline void PrecisionRecallCurve::_internal_add_precision(float value) {
  _impl_.precision_.Add(value);
}
inline void PrecisionRecallCurve::add_precision(float value) {
  _internal_add_precision(value);
  // @@protoc_insertion_point(field_add:clarifai.api.PrecisionRecallCurve.precision)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
PrecisionRecallCurve::_internal_precision() const {
  return _impl_.precision_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
PrecisionRecallCurve::precision() const {
  // @@protoc_insertion_point(field_list:clarifai.api.PrecisionRecallCurve.precision)
  return _internal_precision();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
PrecisionRecallCurve::_internal_mutable_precision() {
  return &_impl_.precision_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
PrecisionRecallCurve::mutable_precision() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.PrecisionRecallCurve.precision)
  return _internal_mutable_precision();
}

// repeated float thresholds = 3 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline int PrecisionRecallCurve::_internal_thresholds_size() const {
  return _impl_.thresholds_.size();
}
inline int PrecisionRecallCurve::thresholds_size() const {
  return _internal_thresholds_size();
}
inline void PrecisionRecallCurve::clear_thresholds() {
  _impl_.thresholds_.Clear();
}
inline float PrecisionRecallCurve::_internal_thresholds(int index) const {
  return _impl_.thresholds_.Get(index);
}
inline float PrecisionRecallCurve::thresholds(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.PrecisionRecallCurve.thresholds)
  return _internal_thresholds(index);
}
inline void PrecisionRecallCurve::set_thresholds(int index, float value) {
  _impl_.thresholds_.Set(index, value);
  // @@protoc_insertion_point(field_set:clarifai.api.PrecisionRecallCurve.thresholds)
}
inline void PrecisionRecallCurve::_internal_add_thresholds(float value) {
  _impl_.thresholds_.Add(value);
}
inline void PrecisionRecallCurve::add_thresholds(float value) {
  _internal_add_thresholds(value);
  // @@protoc_insertion_point(field_add:clarifai.api.PrecisionRecallCurve.thresholds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
PrecisionRecallCurve::_internal_thresholds() const {
  return _impl_.thresholds_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
PrecisionRecallCurve::thresholds() const {
  // @@protoc_insertion_point(field_list:clarifai.api.PrecisionRecallCurve.thresholds)
  return _internal_thresholds();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
PrecisionRecallCurve::_internal_mutable_thresholds() {
  return &_impl_.thresholds_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
PrecisionRecallCurve::mutable_thresholds() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.PrecisionRecallCurve.thresholds)
  return _internal_mutable_thresholds();
}

// -------------------------------------------------------------------

// BinaryMetrics

// uint32 num_pos = 1 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void BinaryMetrics::clear_num_pos() {
  _impl_.num_pos_ = 0u;
}
inline uint32_t BinaryMetrics::_internal_num_pos() const {
  return _impl_.num_pos_;
}
inline uint32_t BinaryMetrics::num_pos() const {
  // @@protoc_insertion_point(field_get:clarifai.api.BinaryMetrics.num_pos)
  return _internal_num_pos();
}
inline void BinaryMetrics::_internal_set_num_pos(uint32_t value) {
  
  _impl_.num_pos_ = value;
}
inline void BinaryMetrics::set_num_pos(uint32_t value) {
  _internal_set_num_pos(value);
  // @@protoc_insertion_point(field_set:clarifai.api.BinaryMetrics.num_pos)
}

// uint32 num_neg = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void BinaryMetrics::clear_num_neg() {
  _impl_.num_neg_ = 0u;
}
inline uint32_t BinaryMetrics::_internal_num_neg() const {
  return _impl_.num_neg_;
}
inline uint32_t BinaryMetrics::num_neg() const {
  // @@protoc_insertion_point(field_get:clarifai.api.BinaryMetrics.num_neg)
  return _internal_num_neg();
}
inline void BinaryMetrics::_internal_set_num_neg(uint32_t value) {
  
  _impl_.num_neg_ = value;
}
inline void BinaryMetrics::set_num_neg(uint32_t value) {
  _internal_set_num_neg(value);
  // @@protoc_insertion_point(field_set:clarifai.api.BinaryMetrics.num_neg)
}

// uint32 num_tot = 3 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void BinaryMetrics::clear_num_tot() {
  _impl_.num_tot_ = 0u;
}
inline uint32_t BinaryMetrics::_internal_num_tot() const {
  return _impl_.num_tot_;
}
inline uint32_t BinaryMetrics::num_tot() const {
  // @@protoc_insertion_point(field_get:clarifai.api.BinaryMetrics.num_tot)
  return _internal_num_tot();
}
inline void BinaryMetrics::_internal_set_num_tot(uint32_t value) {
  
  _impl_.num_tot_ = value;
}
inline void BinaryMetrics::set_num_tot(uint32_t value) {
  _internal_set_num_tot(value);
  // @@protoc_insertion_point(field_set:clarifai.api.BinaryMetrics.num_tot)
}

// float roc_auc = 4 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void BinaryMetrics::clear_roc_auc() {
  _impl_.roc_auc_ = 0;
}
inline float BinaryMetrics::_internal_roc_auc() const {
  return _impl_.roc_auc_;
}
inline float BinaryMetrics::roc_auc() const {
  // @@protoc_insertion_point(field_get:clarifai.api.BinaryMetrics.roc_auc)
  return _internal_roc_auc();
}
inline void BinaryMetrics::_internal_set_roc_auc(float value) {
  
  _impl_.roc_auc_ = value;
}
inline void BinaryMetrics::set_roc_auc(float value) {
  _internal_set_roc_auc(value);
  // @@protoc_insertion_point(field_set:clarifai.api.BinaryMetrics.roc_auc)
}

// float f1 = 5 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void BinaryMetrics::clear_f1() {
  _impl_.f1_ = 0;
}
inline float BinaryMetrics::_internal_f1() const {
  return _impl_.f1_;
}
inline float BinaryMetrics::f1() const {
  // @@protoc_insertion_point(field_get:clarifai.api.BinaryMetrics.f1)
  return _internal_f1();
}
inline void BinaryMetrics::_internal_set_f1(float value) {
  
  _impl_.f1_ = value;
}
inline void BinaryMetrics::set_f1(float value) {
  _internal_set_f1(value);
  // @@protoc_insertion_point(field_set:clarifai.api.BinaryMetrics.f1)
}

// .clarifai.api.Concept concept = 6;
inline bool BinaryMetrics::_internal_has_concept() const {
  return this != internal_default_instance() && _impl_.concept_ != nullptr;
}
inline bool BinaryMetrics::has_concept() const {
  return _internal_has_concept();
}
inline void BinaryMetrics::clear_concept() {
  if (GetArenaForAllocation() == nullptr && _impl_.concept_ != nullptr) {
    delete _impl_.concept_;
  }
  _impl_.concept_ = nullptr;
}
inline const ::clarifai::api::Concept& BinaryMetrics::_internal_concept() const {
  const ::clarifai::api::Concept* p = _impl_.concept_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Concept&>(
      ::clarifai::api::_Concept_default_instance_);
}
inline const ::clarifai::api::Concept& BinaryMetrics::concept() const {
  // @@protoc_insertion_point(field_get:clarifai.api.BinaryMetrics.concept)
  return _internal_concept();
}
inline void BinaryMetrics::unsafe_arena_set_allocated_concept(
    ::clarifai::api::Concept* concept) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.concept_);
  }
  _impl_.concept_ = concept;
  if (concept) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.BinaryMetrics.concept)
}
inline ::clarifai::api::Concept* BinaryMetrics::release_concept() {
  
  ::clarifai::api::Concept* temp = _impl_.concept_;
  _impl_.concept_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Concept* BinaryMetrics::unsafe_arena_release_concept() {
  // @@protoc_insertion_point(field_release:clarifai.api.BinaryMetrics.concept)
  
  ::clarifai::api::Concept* temp = _impl_.concept_;
  _impl_.concept_ = nullptr;
  return temp;
}
inline ::clarifai::api::Concept* BinaryMetrics::_internal_mutable_concept() {
  
  if (_impl_.concept_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Concept>(GetArenaForAllocation());
    _impl_.concept_ = p;
  }
  return _impl_.concept_;
}
inline ::clarifai::api::Concept* BinaryMetrics::mutable_concept() {
  ::clarifai::api::Concept* _msg = _internal_mutable_concept();
  // @@protoc_insertion_point(field_mutable:clarifai.api.BinaryMetrics.concept)
  return _msg;
}
inline void BinaryMetrics::set_allocated_concept(::clarifai::api::Concept* concept) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.concept_;
  }
  if (concept) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(concept);
    if (message_arena != submessage_arena) {
      concept = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, concept, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.concept_ = concept;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.BinaryMetrics.concept)
}

// .clarifai.api.ROC roc_curve = 7;
inline bool BinaryMetrics::_internal_has_roc_curve() const {
  return this != internal_default_instance() && _impl_.roc_curve_ != nullptr;
}
inline bool BinaryMetrics::has_roc_curve() const {
  return _internal_has_roc_curve();
}
inline void BinaryMetrics::clear_roc_curve() {
  if (GetArenaForAllocation() == nullptr && _impl_.roc_curve_ != nullptr) {
    delete _impl_.roc_curve_;
  }
  _impl_.roc_curve_ = nullptr;
}
inline const ::clarifai::api::ROC& BinaryMetrics::_internal_roc_curve() const {
  const ::clarifai::api::ROC* p = _impl_.roc_curve_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::ROC&>(
      ::clarifai::api::_ROC_default_instance_);
}
inline const ::clarifai::api::ROC& BinaryMetrics::roc_curve() const {
  // @@protoc_insertion_point(field_get:clarifai.api.BinaryMetrics.roc_curve)
  return _internal_roc_curve();
}
inline void BinaryMetrics::unsafe_arena_set_allocated_roc_curve(
    ::clarifai::api::ROC* roc_curve) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.roc_curve_);
  }
  _impl_.roc_curve_ = roc_curve;
  if (roc_curve) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.BinaryMetrics.roc_curve)
}
inline ::clarifai::api::ROC* BinaryMetrics::release_roc_curve() {
  
  ::clarifai::api::ROC* temp = _impl_.roc_curve_;
  _impl_.roc_curve_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::ROC* BinaryMetrics::unsafe_arena_release_roc_curve() {
  // @@protoc_insertion_point(field_release:clarifai.api.BinaryMetrics.roc_curve)
  
  ::clarifai::api::ROC* temp = _impl_.roc_curve_;
  _impl_.roc_curve_ = nullptr;
  return temp;
}
inline ::clarifai::api::ROC* BinaryMetrics::_internal_mutable_roc_curve() {
  
  if (_impl_.roc_curve_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::ROC>(GetArenaForAllocation());
    _impl_.roc_curve_ = p;
  }
  return _impl_.roc_curve_;
}
inline ::clarifai::api::ROC* BinaryMetrics::mutable_roc_curve() {
  ::clarifai::api::ROC* _msg = _internal_mutable_roc_curve();
  // @@protoc_insertion_point(field_mutable:clarifai.api.BinaryMetrics.roc_curve)
  return _msg;
}
inline void BinaryMetrics::set_allocated_roc_curve(::clarifai::api::ROC* roc_curve) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.roc_curve_;
  }
  if (roc_curve) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(roc_curve);
    if (message_arena != submessage_arena) {
      roc_curve = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, roc_curve, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.roc_curve_ = roc_curve;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.BinaryMetrics.roc_curve)
}

// .clarifai.api.PrecisionRecallCurve precision_recall_curve = 8;
inline bool BinaryMetrics::_internal_has_precision_recall_curve() const {
  return this != internal_default_instance() && _impl_.precision_recall_curve_ != nullptr;
}
inline bool BinaryMetrics::has_precision_recall_curve() const {
  return _internal_has_precision_recall_curve();
}
inline void BinaryMetrics::clear_precision_recall_curve() {
  if (GetArenaForAllocation() == nullptr && _impl_.precision_recall_curve_ != nullptr) {
    delete _impl_.precision_recall_curve_;
  }
  _impl_.precision_recall_curve_ = nullptr;
}
inline const ::clarifai::api::PrecisionRecallCurve& BinaryMetrics::_internal_precision_recall_curve() const {
  const ::clarifai::api::PrecisionRecallCurve* p = _impl_.precision_recall_curve_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::PrecisionRecallCurve&>(
      ::clarifai::api::_PrecisionRecallCurve_default_instance_);
}
inline const ::clarifai::api::PrecisionRecallCurve& BinaryMetrics::precision_recall_curve() const {
  // @@protoc_insertion_point(field_get:clarifai.api.BinaryMetrics.precision_recall_curve)
  return _internal_precision_recall_curve();
}
inline void BinaryMetrics::unsafe_arena_set_allocated_precision_recall_curve(
    ::clarifai::api::PrecisionRecallCurve* precision_recall_curve) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.precision_recall_curve_);
  }
  _impl_.precision_recall_curve_ = precision_recall_curve;
  if (precision_recall_curve) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.BinaryMetrics.precision_recall_curve)
}
inline ::clarifai::api::PrecisionRecallCurve* BinaryMetrics::release_precision_recall_curve() {
  
  ::clarifai::api::PrecisionRecallCurve* temp = _impl_.precision_recall_curve_;
  _impl_.precision_recall_curve_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::PrecisionRecallCurve* BinaryMetrics::unsafe_arena_release_precision_recall_curve() {
  // @@protoc_insertion_point(field_release:clarifai.api.BinaryMetrics.precision_recall_curve)
  
  ::clarifai::api::PrecisionRecallCurve* temp = _impl_.precision_recall_curve_;
  _impl_.precision_recall_curve_ = nullptr;
  return temp;
}
inline ::clarifai::api::PrecisionRecallCurve* BinaryMetrics::_internal_mutable_precision_recall_curve() {
  
  if (_impl_.precision_recall_curve_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::PrecisionRecallCurve>(GetArenaForAllocation());
    _impl_.precision_recall_curve_ = p;
  }
  return _impl_.precision_recall_curve_;
}
inline ::clarifai::api::PrecisionRecallCurve* BinaryMetrics::mutable_precision_recall_curve() {
  ::clarifai::api::PrecisionRecallCurve* _msg = _internal_mutable_precision_recall_curve();
  // @@protoc_insertion_point(field_mutable:clarifai.api.BinaryMetrics.precision_recall_curve)
  return _msg;
}
inline void BinaryMetrics::set_allocated_precision_recall_curve(::clarifai::api::PrecisionRecallCurve* precision_recall_curve) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.precision_recall_curve_;
  }
  if (precision_recall_curve) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(precision_recall_curve);
    if (message_arena != submessage_arena) {
      precision_recall_curve = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, precision_recall_curve, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.precision_recall_curve_ = precision_recall_curve;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.BinaryMetrics.precision_recall_curve)
}

// float avg_precision = 9;
inline void BinaryMetrics::clear_avg_precision() {
  _impl_.avg_precision_ = 0;
}
inline float BinaryMetrics::_internal_avg_precision() const {
  return _impl_.avg_precision_;
}
inline float BinaryMetrics::avg_precision() const {
  // @@protoc_insertion_point(field_get:clarifai.api.BinaryMetrics.avg_precision)
  return _internal_avg_precision();
}
inline void BinaryMetrics::_internal_set_avg_precision(float value) {
  
  _impl_.avg_precision_ = value;
}
inline void BinaryMetrics::set_avg_precision(float value) {
  _internal_set_avg_precision(value);
  // @@protoc_insertion_point(field_set:clarifai.api.BinaryMetrics.avg_precision)
}

// string area_name = 10;
inline void BinaryMetrics::clear_area_name() {
  _impl_.area_name_.ClearToEmpty();
}
inline const std::string& BinaryMetrics::area_name() const {
  // @@protoc_insertion_point(field_get:clarifai.api.BinaryMetrics.area_name)
  return _internal_area_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryMetrics::set_area_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.area_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.BinaryMetrics.area_name)
}
inline std::string* BinaryMetrics::mutable_area_name() {
  std::string* _s = _internal_mutable_area_name();
  // @@protoc_insertion_point(field_mutable:clarifai.api.BinaryMetrics.area_name)
  return _s;
}
inline const std::string& BinaryMetrics::_internal_area_name() const {
  return _impl_.area_name_.Get();
}
inline void BinaryMetrics::_internal_set_area_name(const std::string& value) {
  
  _impl_.area_name_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryMetrics::_internal_mutable_area_name() {
  
  return _impl_.area_name_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryMetrics::release_area_name() {
  // @@protoc_insertion_point(field_release:clarifai.api.BinaryMetrics.area_name)
  return _impl_.area_name_.Release();
}
inline void BinaryMetrics::set_allocated_area_name(std::string* area_name) {
  if (area_name != nullptr) {
    
  } else {
    
  }
  _impl_.area_name_.SetAllocated(area_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.area_name_.IsDefault()) {
    _impl_.area_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.BinaryMetrics.area_name)
}

// double area_min = 11;
inline void BinaryMetrics::clear_area_min() {
  _impl_.area_min_ = 0;
}
inline double BinaryMetrics::_internal_area_min() const {
  return _impl_.area_min_;
}
inline double BinaryMetrics::area_min() const {
  // @@protoc_insertion_point(field_get:clarifai.api.BinaryMetrics.area_min)
  return _internal_area_min();
}
inline void BinaryMetrics::_internal_set_area_min(double value) {
  
  _impl_.area_min_ = value;
}
inline void BinaryMetrics::set_area_min(double value) {
  _internal_set_area_min(value);
  // @@protoc_insertion_point(field_set:clarifai.api.BinaryMetrics.area_min)
}

// double area_max = 12;
inline void BinaryMetrics::clear_area_max() {
  _impl_.area_max_ = 0;
}
inline double BinaryMetrics::_internal_area_max() const {
  return _impl_.area_max_;
}
inline double BinaryMetrics::area_max() const {
  // @@protoc_insertion_point(field_get:clarifai.api.BinaryMetrics.area_max)
  return _internal_area_max();
}
inline void BinaryMetrics::_internal_set_area_max(double value) {
  
  _impl_.area_max_ = value;
}
inline void BinaryMetrics::set_area_max(double value) {
  _internal_set_area_max(value);
  // @@protoc_insertion_point(field_set:clarifai.api.BinaryMetrics.area_max)
}

// float iou = 13;
inline void BinaryMetrics::clear_iou() {
  _impl_.iou_ = 0;
}
inline float BinaryMetrics::_internal_iou() const {
  return _impl_.iou_;
}
inline float BinaryMetrics::iou() const {
  // @@protoc_insertion_point(field_get:clarifai.api.BinaryMetrics.iou)
  return _internal_iou();
}
inline void BinaryMetrics::_internal_set_iou(float value) {
  
  _impl_.iou_ = value;
}
inline void BinaryMetrics::set_iou(float value) {
  _internal_set_iou(value);
  // @@protoc_insertion_point(field_set:clarifai.api.BinaryMetrics.iou)
}

// -------------------------------------------------------------------

// TrackerMetrics

// float mot_mota = 1;
inline void TrackerMetrics::clear_mot_mota() {
  _impl_.mot_mota_ = 0;
}
inline float TrackerMetrics::_internal_mot_mota() const {
  return _impl_.mot_mota_;
}
inline float TrackerMetrics::mot_mota() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TrackerMetrics.mot_mota)
  return _internal_mot_mota();
}
inline void TrackerMetrics::_internal_set_mot_mota(float value) {
  
  _impl_.mot_mota_ = value;
}
inline void TrackerMetrics::set_mot_mota(float value) {
  _internal_set_mot_mota(value);
  // @@protoc_insertion_point(field_set:clarifai.api.TrackerMetrics.mot_mota)
}

// int32 mot_num_switches = 2;
inline void TrackerMetrics::clear_mot_num_switches() {
  _impl_.mot_num_switches_ = 0;
}
inline int32_t TrackerMetrics::_internal_mot_num_switches() const {
  return _impl_.mot_num_switches_;
}
inline int32_t TrackerMetrics::mot_num_switches() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TrackerMetrics.mot_num_switches)
  return _internal_mot_num_switches();
}
inline void TrackerMetrics::_internal_set_mot_num_switches(int32_t value) {
  
  _impl_.mot_num_switches_ = value;
}
inline void TrackerMetrics::set_mot_num_switches(int32_t value) {
  _internal_set_mot_num_switches(value);
  // @@protoc_insertion_point(field_set:clarifai.api.TrackerMetrics.mot_num_switches)
}

// float morse_frag = 3;
inline void TrackerMetrics::clear_morse_frag() {
  _impl_.morse_frag_ = 0;
}
inline float TrackerMetrics::_internal_morse_frag() const {
  return _impl_.morse_frag_;
}
inline float TrackerMetrics::morse_frag() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TrackerMetrics.morse_frag)
  return _internal_morse_frag();
}
inline void TrackerMetrics::_internal_set_morse_frag(float value) {
  
  _impl_.morse_frag_ = value;
}
inline void TrackerMetrics::set_morse_frag(float value) {
  _internal_set_morse_frag(value);
  // @@protoc_insertion_point(field_set:clarifai.api.TrackerMetrics.morse_frag)
}

// float avg_precision = 4;
inline void TrackerMetrics::clear_avg_precision() {
  _impl_.avg_precision_ = 0;
}
inline float TrackerMetrics::_internal_avg_precision() const {
  return _impl_.avg_precision_;
}
inline float TrackerMetrics::avg_precision() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TrackerMetrics.avg_precision)
  return _internal_avg_precision();
}
inline void TrackerMetrics::_internal_set_avg_precision(float value) {
  
  _impl_.avg_precision_ = value;
}
inline void TrackerMetrics::set_avg_precision(float value) {
  _internal_set_avg_precision(value);
  // @@protoc_insertion_point(field_set:clarifai.api.TrackerMetrics.avg_precision)
}

// string aiid = 5;
inline void TrackerMetrics::clear_aiid() {
  _impl_.aiid_.ClearToEmpty();
}
inline const std::string& TrackerMetrics::aiid() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TrackerMetrics.aiid)
  return _internal_aiid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackerMetrics::set_aiid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.aiid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.TrackerMetrics.aiid)
}
inline std::string* TrackerMetrics::mutable_aiid() {
  std::string* _s = _internal_mutable_aiid();
  // @@protoc_insertion_point(field_mutable:clarifai.api.TrackerMetrics.aiid)
  return _s;
}
inline const std::string& TrackerMetrics::_internal_aiid() const {
  return _impl_.aiid_.Get();
}
inline void TrackerMetrics::_internal_set_aiid(const std::string& value) {
  
  _impl_.aiid_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackerMetrics::_internal_mutable_aiid() {
  
  return _impl_.aiid_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackerMetrics::release_aiid() {
  // @@protoc_insertion_point(field_release:clarifai.api.TrackerMetrics.aiid)
  return _impl_.aiid_.Release();
}
inline void TrackerMetrics::set_allocated_aiid(std::string* aiid) {
  if (aiid != nullptr) {
    
  } else {
    
  }
  _impl_.aiid_.SetAllocated(aiid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.aiid_.IsDefault()) {
    _impl_.aiid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.TrackerMetrics.aiid)
}

// float unique_switch_rate = 6;
inline void TrackerMetrics::clear_unique_switch_rate() {
  _impl_.unique_switch_rate_ = 0;
}
inline float TrackerMetrics::_internal_unique_switch_rate() const {
  return _impl_.unique_switch_rate_;
}
inline float TrackerMetrics::unique_switch_rate() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TrackerMetrics.unique_switch_rate)
  return _internal_unique_switch_rate();
}
inline void TrackerMetrics::_internal_set_unique_switch_rate(float value) {
  
  _impl_.unique_switch_rate_ = value;
}
inline void TrackerMetrics::set_unique_switch_rate(float value) {
  _internal_set_unique_switch_rate(value);
  // @@protoc_insertion_point(field_set:clarifai.api.TrackerMetrics.unique_switch_rate)
}

// -------------------------------------------------------------------

// EvalTestSetEntry

// string id = 1 [deprecated = true];
inline void EvalTestSetEntry::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& EvalTestSetEntry::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.EvalTestSetEntry.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EvalTestSetEntry::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.EvalTestSetEntry.id)
}
inline std::string* EvalTestSetEntry::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.EvalTestSetEntry.id)
  return _s;
}
inline const std::string& EvalTestSetEntry::_internal_id() const {
  return _impl_.id_.Get();
}
inline void EvalTestSetEntry::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* EvalTestSetEntry::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* EvalTestSetEntry::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.EvalTestSetEntry.id)
  return _impl_.id_.Release();
}
inline void EvalTestSetEntry::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.EvalTestSetEntry.id)
}

// string url = 2 [deprecated = true];
inline void EvalTestSetEntry::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& EvalTestSetEntry::url() const {
  // @@protoc_insertion_point(field_get:clarifai.api.EvalTestSetEntry.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EvalTestSetEntry::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.EvalTestSetEntry.url)
}
inline std::string* EvalTestSetEntry::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:clarifai.api.EvalTestSetEntry.url)
  return _s;
}
inline const std::string& EvalTestSetEntry::_internal_url() const {
  return _impl_.url_.Get();
}
inline void EvalTestSetEntry::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* EvalTestSetEntry::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* EvalTestSetEntry::release_url() {
  // @@protoc_insertion_point(field_release:clarifai.api.EvalTestSetEntry.url)
  return _impl_.url_.Release();
}
inline void EvalTestSetEntry::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.EvalTestSetEntry.url)
}

// .clarifai.api.Input input = 6;
inline bool EvalTestSetEntry::_internal_has_input() const {
  return this != internal_default_instance() && _impl_.input_ != nullptr;
}
inline bool EvalTestSetEntry::has_input() const {
  return _internal_has_input();
}
inline void EvalTestSetEntry::clear_input() {
  if (GetArenaForAllocation() == nullptr && _impl_.input_ != nullptr) {
    delete _impl_.input_;
  }
  _impl_.input_ = nullptr;
}
inline const ::clarifai::api::Input& EvalTestSetEntry::_internal_input() const {
  const ::clarifai::api::Input* p = _impl_.input_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Input&>(
      ::clarifai::api::_Input_default_instance_);
}
inline const ::clarifai::api::Input& EvalTestSetEntry::input() const {
  // @@protoc_insertion_point(field_get:clarifai.api.EvalTestSetEntry.input)
  return _internal_input();
}
inline void EvalTestSetEntry::unsafe_arena_set_allocated_input(
    ::clarifai::api::Input* input) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.input_);
  }
  _impl_.input_ = input;
  if (input) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.EvalTestSetEntry.input)
}
inline ::clarifai::api::Input* EvalTestSetEntry::release_input() {
  
  ::clarifai::api::Input* temp = _impl_.input_;
  _impl_.input_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Input* EvalTestSetEntry::unsafe_arena_release_input() {
  // @@protoc_insertion_point(field_release:clarifai.api.EvalTestSetEntry.input)
  
  ::clarifai::api::Input* temp = _impl_.input_;
  _impl_.input_ = nullptr;
  return temp;
}
inline ::clarifai::api::Input* EvalTestSetEntry::_internal_mutable_input() {
  
  if (_impl_.input_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Input>(GetArenaForAllocation());
    _impl_.input_ = p;
  }
  return _impl_.input_;
}
inline ::clarifai::api::Input* EvalTestSetEntry::mutable_input() {
  ::clarifai::api::Input* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:clarifai.api.EvalTestSetEntry.input)
  return _msg;
}
inline void EvalTestSetEntry::set_allocated_input(::clarifai::api::Input* input) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.input_;
  }
  if (input) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(input);
    if (message_arena != submessage_arena) {
      input = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.input_ = input;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.EvalTestSetEntry.input)
}

// repeated .clarifai.api.Concept predicted_concepts = 3;
inline int EvalTestSetEntry::_internal_predicted_concepts_size() const {
  return _impl_.predicted_concepts_.size();
}
inline int EvalTestSetEntry::predicted_concepts_size() const {
  return _internal_predicted_concepts_size();
}
inline void EvalTestSetEntry::clear_predicted_concepts() {
  _impl_.predicted_concepts_.Clear();
}
inline ::clarifai::api::Concept* EvalTestSetEntry::mutable_predicted_concepts(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.EvalTestSetEntry.predicted_concepts)
  return _impl_.predicted_concepts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept >*
EvalTestSetEntry::mutable_predicted_concepts() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.EvalTestSetEntry.predicted_concepts)
  return &_impl_.predicted_concepts_;
}
inline const ::clarifai::api::Concept& EvalTestSetEntry::_internal_predicted_concepts(int index) const {
  return _impl_.predicted_concepts_.Get(index);
}
inline const ::clarifai::api::Concept& EvalTestSetEntry::predicted_concepts(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.EvalTestSetEntry.predicted_concepts)
  return _internal_predicted_concepts(index);
}
inline ::clarifai::api::Concept* EvalTestSetEntry::_internal_add_predicted_concepts() {
  return _impl_.predicted_concepts_.Add();
}
inline ::clarifai::api::Concept* EvalTestSetEntry::add_predicted_concepts() {
  ::clarifai::api::Concept* _add = _internal_add_predicted_concepts();
  // @@protoc_insertion_point(field_add:clarifai.api.EvalTestSetEntry.predicted_concepts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept >&
EvalTestSetEntry::predicted_concepts() const {
  // @@protoc_insertion_point(field_list:clarifai.api.EvalTestSetEntry.predicted_concepts)
  return _impl_.predicted_concepts_;
}

// repeated .clarifai.api.Concept ground_truth_concepts = 4;
inline int EvalTestSetEntry::_internal_ground_truth_concepts_size() const {
  return _impl_.ground_truth_concepts_.size();
}
inline int EvalTestSetEntry::ground_truth_concepts_size() const {
  return _internal_ground_truth_concepts_size();
}
inline void EvalTestSetEntry::clear_ground_truth_concepts() {
  _impl_.ground_truth_concepts_.Clear();
}
inline ::clarifai::api::Concept* EvalTestSetEntry::mutable_ground_truth_concepts(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.EvalTestSetEntry.ground_truth_concepts)
  return _impl_.ground_truth_concepts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept >*
EvalTestSetEntry::mutable_ground_truth_concepts() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.EvalTestSetEntry.ground_truth_concepts)
  return &_impl_.ground_truth_concepts_;
}
inline const ::clarifai::api::Concept& EvalTestSetEntry::_internal_ground_truth_concepts(int index) const {
  return _impl_.ground_truth_concepts_.Get(index);
}
inline const ::clarifai::api::Concept& EvalTestSetEntry::ground_truth_concepts(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.EvalTestSetEntry.ground_truth_concepts)
  return _internal_ground_truth_concepts(index);
}
inline ::clarifai::api::Concept* EvalTestSetEntry::_internal_add_ground_truth_concepts() {
  return _impl_.ground_truth_concepts_.Add();
}
inline ::clarifai::api::Concept* EvalTestSetEntry::add_ground_truth_concepts() {
  ::clarifai::api::Concept* _add = _internal_add_ground_truth_concepts();
  // @@protoc_insertion_point(field_add:clarifai.api.EvalTestSetEntry.ground_truth_concepts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept >&
EvalTestSetEntry::ground_truth_concepts() const {
  // @@protoc_insertion_point(field_list:clarifai.api.EvalTestSetEntry.ground_truth_concepts)
  return _impl_.ground_truth_concepts_;
}

// .clarifai.api.Annotation annotation = 5;
inline bool EvalTestSetEntry::_internal_has_annotation() const {
  return this != internal_default_instance() && _impl_.annotation_ != nullptr;
}
inline bool EvalTestSetEntry::has_annotation() const {
  return _internal_has_annotation();
}
inline void EvalTestSetEntry::clear_annotation() {
  if (GetArenaForAllocation() == nullptr && _impl_.annotation_ != nullptr) {
    delete _impl_.annotation_;
  }
  _impl_.annotation_ = nullptr;
}
inline const ::clarifai::api::Annotation& EvalTestSetEntry::_internal_annotation() const {
  const ::clarifai::api::Annotation* p = _impl_.annotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Annotation&>(
      ::clarifai::api::_Annotation_default_instance_);
}
inline const ::clarifai::api::Annotation& EvalTestSetEntry::annotation() const {
  // @@protoc_insertion_point(field_get:clarifai.api.EvalTestSetEntry.annotation)
  return _internal_annotation();
}
inline void EvalTestSetEntry::unsafe_arena_set_allocated_annotation(
    ::clarifai::api::Annotation* annotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.annotation_);
  }
  _impl_.annotation_ = annotation;
  if (annotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.EvalTestSetEntry.annotation)
}
inline ::clarifai::api::Annotation* EvalTestSetEntry::release_annotation() {
  
  ::clarifai::api::Annotation* temp = _impl_.annotation_;
  _impl_.annotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Annotation* EvalTestSetEntry::unsafe_arena_release_annotation() {
  // @@protoc_insertion_point(field_release:clarifai.api.EvalTestSetEntry.annotation)
  
  ::clarifai::api::Annotation* temp = _impl_.annotation_;
  _impl_.annotation_ = nullptr;
  return temp;
}
inline ::clarifai::api::Annotation* EvalTestSetEntry::_internal_mutable_annotation() {
  
  if (_impl_.annotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Annotation>(GetArenaForAllocation());
    _impl_.annotation_ = p;
  }
  return _impl_.annotation_;
}
inline ::clarifai::api::Annotation* EvalTestSetEntry::mutable_annotation() {
  ::clarifai::api::Annotation* _msg = _internal_mutable_annotation();
  // @@protoc_insertion_point(field_mutable:clarifai.api.EvalTestSetEntry.annotation)
  return _msg;
}
inline void EvalTestSetEntry::set_allocated_annotation(::clarifai::api::Annotation* annotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.annotation_;
  }
  if (annotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(annotation);
    if (message_arena != submessage_arena) {
      annotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, annotation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.annotation_ = annotation;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.EvalTestSetEntry.annotation)
}

// -------------------------------------------------------------------

// LOPQEvalResult

// int32 k = 1;
inline void LOPQEvalResult::clear_k() {
  _impl_.k_ = 0;
}
inline int32_t LOPQEvalResult::_internal_k() const {
  return _impl_.k_;
}
inline int32_t LOPQEvalResult::k() const {
  // @@protoc_insertion_point(field_get:clarifai.api.LOPQEvalResult.k)
  return _internal_k();
}
inline void LOPQEvalResult::_internal_set_k(int32_t value) {
  
  _impl_.k_ = value;
}
inline void LOPQEvalResult::set_k(int32_t value) {
  _internal_set_k(value);
  // @@protoc_insertion_point(field_set:clarifai.api.LOPQEvalResult.k)
}

// float recall_vs_brute_force = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void LOPQEvalResult::clear_recall_vs_brute_force() {
  _impl_.recall_vs_brute_force_ = 0;
}
inline float LOPQEvalResult::_internal_recall_vs_brute_force() const {
  return _impl_.recall_vs_brute_force_;
}
inline float LOPQEvalResult::recall_vs_brute_force() const {
  // @@protoc_insertion_point(field_get:clarifai.api.LOPQEvalResult.recall_vs_brute_force)
  return _internal_recall_vs_brute_force();
}
inline void LOPQEvalResult::_internal_set_recall_vs_brute_force(float value) {
  
  _impl_.recall_vs_brute_force_ = value;
}
inline void LOPQEvalResult::set_recall_vs_brute_force(float value) {
  _internal_set_recall_vs_brute_force(value);
  // @@protoc_insertion_point(field_set:clarifai.api.LOPQEvalResult.recall_vs_brute_force)
}

// float kendall_tau_vs_brute_force = 3 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void LOPQEvalResult::clear_kendall_tau_vs_brute_force() {
  _impl_.kendall_tau_vs_brute_force_ = 0;
}
inline float LOPQEvalResult::_internal_kendall_tau_vs_brute_force() const {
  return _impl_.kendall_tau_vs_brute_force_;
}
inline float LOPQEvalResult::kendall_tau_vs_brute_force() const {
  // @@protoc_insertion_point(field_get:clarifai.api.LOPQEvalResult.kendall_tau_vs_brute_force)
  return _internal_kendall_tau_vs_brute_force();
}
inline void LOPQEvalResult::_internal_set_kendall_tau_vs_brute_force(float value) {
  
  _impl_.kendall_tau_vs_brute_force_ = value;
}
inline void LOPQEvalResult::set_kendall_tau_vs_brute_force(float value) {
  _internal_set_kendall_tau_vs_brute_force(value);
  // @@protoc_insertion_point(field_set:clarifai.api.LOPQEvalResult.kendall_tau_vs_brute_force)
}

// float most_frequent_code_percent = 4 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void LOPQEvalResult::clear_most_frequent_code_percent() {
  _impl_.most_frequent_code_percent_ = 0;
}
inline float LOPQEvalResult::_internal_most_frequent_code_percent() const {
  return _impl_.most_frequent_code_percent_;
}
inline float LOPQEvalResult::most_frequent_code_percent() const {
  // @@protoc_insertion_point(field_get:clarifai.api.LOPQEvalResult.most_frequent_code_percent)
  return _internal_most_frequent_code_percent();
}
inline void LOPQEvalResult::_internal_set_most_frequent_code_percent(float value) {
  
  _impl_.most_frequent_code_percent_ = value;
}
inline void LOPQEvalResult::set_most_frequent_code_percent(float value) {
  _internal_set_most_frequent_code_percent(value);
  // @@protoc_insertion_point(field_set:clarifai.api.LOPQEvalResult.most_frequent_code_percent)
}

// float lopq_ndcg = 5 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void LOPQEvalResult::clear_lopq_ndcg() {
  _impl_.lopq_ndcg_ = 0;
}
inline float LOPQEvalResult::_internal_lopq_ndcg() const {
  return _impl_.lopq_ndcg_;
}
inline float LOPQEvalResult::lopq_ndcg() const {
  // @@protoc_insertion_point(field_get:clarifai.api.LOPQEvalResult.lopq_ndcg)
  return _internal_lopq_ndcg();
}
inline void LOPQEvalResult::_internal_set_lopq_ndcg(float value) {
  
  _impl_.lopq_ndcg_ = value;
}
inline void LOPQEvalResult::set_lopq_ndcg(float value) {
  _internal_set_lopq_ndcg(value);
  // @@protoc_insertion_point(field_set:clarifai.api.LOPQEvalResult.lopq_ndcg)
}

// float brute_force_ndcg = 6 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void LOPQEvalResult::clear_brute_force_ndcg() {
  _impl_.brute_force_ndcg_ = 0;
}
inline float LOPQEvalResult::_internal_brute_force_ndcg() const {
  return _impl_.brute_force_ndcg_;
}
inline float LOPQEvalResult::brute_force_ndcg() const {
  // @@protoc_insertion_point(field_get:clarifai.api.LOPQEvalResult.brute_force_ndcg)
  return _internal_brute_force_ndcg();
}
inline void LOPQEvalResult::_internal_set_brute_force_ndcg(float value) {
  
  _impl_.brute_force_ndcg_ = value;
}
inline void LOPQEvalResult::set_brute_force_ndcg(float value) {
  _internal_set_brute_force_ndcg(value);
  // @@protoc_insertion_point(field_set:clarifai.api.LOPQEvalResult.brute_force_ndcg)
}

// -------------------------------------------------------------------

// MetricsSummary

// float top1_accuracy = 1 [deprecated = true];
inline void MetricsSummary::clear_top1_accuracy() {
  _impl_.top1_accuracy_ = 0;
}
inline float MetricsSummary::_internal_top1_accuracy() const {
  return _impl_.top1_accuracy_;
}
inline float MetricsSummary::top1_accuracy() const {
  // @@protoc_insertion_point(field_get:clarifai.api.MetricsSummary.top1_accuracy)
  return _internal_top1_accuracy();
}
inline void MetricsSummary::_internal_set_top1_accuracy(float value) {
  
  _impl_.top1_accuracy_ = value;
}
inline void MetricsSummary::set_top1_accuracy(float value) {
  _internal_set_top1_accuracy(value);
  // @@protoc_insertion_point(field_set:clarifai.api.MetricsSummary.top1_accuracy)
}

// float top5_accuracy = 2 [deprecated = true];
inline void MetricsSummary::clear_top5_accuracy() {
  _impl_.top5_accuracy_ = 0;
}
inline float MetricsSummary::_internal_top5_accuracy() const {
  return _impl_.top5_accuracy_;
}
inline float MetricsSummary::top5_accuracy() const {
  // @@protoc_insertion_point(field_get:clarifai.api.MetricsSummary.top5_accuracy)
  return _internal_top5_accuracy();
}
inline void MetricsSummary::_internal_set_top5_accuracy(float value) {
  
  _impl_.top5_accuracy_ = value;
}
inline void MetricsSummary::set_top5_accuracy(float value) {
  _internal_set_top5_accuracy(value);
  // @@protoc_insertion_point(field_set:clarifai.api.MetricsSummary.top5_accuracy)
}

// float macro_avg_roc_auc = 3 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void MetricsSummary::clear_macro_avg_roc_auc() {
  _impl_.macro_avg_roc_auc_ = 0;
}
inline float MetricsSummary::_internal_macro_avg_roc_auc() const {
  return _impl_.macro_avg_roc_auc_;
}
inline float MetricsSummary::macro_avg_roc_auc() const {
  // @@protoc_insertion_point(field_get:clarifai.api.MetricsSummary.macro_avg_roc_auc)
  return _internal_macro_avg_roc_auc();
}
inline void MetricsSummary::_internal_set_macro_avg_roc_auc(float value) {
  
  _impl_.macro_avg_roc_auc_ = value;
}
inline void MetricsSummary::set_macro_avg_roc_auc(float value) {
  _internal_set_macro_avg_roc_auc(value);
  // @@protoc_insertion_point(field_set:clarifai.api.MetricsSummary.macro_avg_roc_auc)
}

// float macro_std_roc_auc = 4 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void MetricsSummary::clear_macro_std_roc_auc() {
  _impl_.macro_std_roc_auc_ = 0;
}
inline float MetricsSummary::_internal_macro_std_roc_auc() const {
  return _impl_.macro_std_roc_auc_;
}
inline float MetricsSummary::macro_std_roc_auc() const {
  // @@protoc_insertion_point(field_get:clarifai.api.MetricsSummary.macro_std_roc_auc)
  return _internal_macro_std_roc_auc();
}
inline void MetricsSummary::_internal_set_macro_std_roc_auc(float value) {
  
  _impl_.macro_std_roc_auc_ = value;
}
inline void MetricsSummary::set_macro_std_roc_auc(float value) {
  _internal_set_macro_std_roc_auc(value);
  // @@protoc_insertion_point(field_set:clarifai.api.MetricsSummary.macro_std_roc_auc)
}

// float macro_avg_f1_score = 5 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void MetricsSummary::clear_macro_avg_f1_score() {
  _impl_.macro_avg_f1_score_ = 0;
}
inline float MetricsSummary::_internal_macro_avg_f1_score() const {
  return _impl_.macro_avg_f1_score_;
}
inline float MetricsSummary::macro_avg_f1_score() const {
  // @@protoc_insertion_point(field_get:clarifai.api.MetricsSummary.macro_avg_f1_score)
  return _internal_macro_avg_f1_score();
}
inline void MetricsSummary::_internal_set_macro_avg_f1_score(float value) {
  
  _impl_.macro_avg_f1_score_ = value;
}
inline void MetricsSummary::set_macro_avg_f1_score(float value) {
  _internal_set_macro_avg_f1_score(value);
  // @@protoc_insertion_point(field_set:clarifai.api.MetricsSummary.macro_avg_f1_score)
}

// float macro_std_f1_score = 6 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void MetricsSummary::clear_macro_std_f1_score() {
  _impl_.macro_std_f1_score_ = 0;
}
inline float MetricsSummary::_internal_macro_std_f1_score() const {
  return _impl_.macro_std_f1_score_;
}
inline float MetricsSummary::macro_std_f1_score() const {
  // @@protoc_insertion_point(field_get:clarifai.api.MetricsSummary.macro_std_f1_score)
  return _internal_macro_std_f1_score();
}
inline void MetricsSummary::_internal_set_macro_std_f1_score(float value) {
  
  _impl_.macro_std_f1_score_ = value;
}
inline void MetricsSummary::set_macro_std_f1_score(float value) {
  _internal_set_macro_std_f1_score(value);
  // @@protoc_insertion_point(field_set:clarifai.api.MetricsSummary.macro_std_f1_score)
}

// float macro_avg_precision = 7 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void MetricsSummary::clear_macro_avg_precision() {
  _impl_.macro_avg_precision_ = 0;
}
inline float MetricsSummary::_internal_macro_avg_precision() const {
  return _impl_.macro_avg_precision_;
}
inline float MetricsSummary::macro_avg_precision() const {
  // @@protoc_insertion_point(field_get:clarifai.api.MetricsSummary.macro_avg_precision)
  return _internal_macro_avg_precision();
}
inline void MetricsSummary::_internal_set_macro_avg_precision(float value) {
  
  _impl_.macro_avg_precision_ = value;
}
inline void MetricsSummary::set_macro_avg_precision(float value) {
  _internal_set_macro_avg_precision(value);
  // @@protoc_insertion_point(field_set:clarifai.api.MetricsSummary.macro_avg_precision)
}

// float macro_avg_recall = 8 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void MetricsSummary::clear_macro_avg_recall() {
  _impl_.macro_avg_recall_ = 0;
}
inline float MetricsSummary::_internal_macro_avg_recall() const {
  return _impl_.macro_avg_recall_;
}
inline float MetricsSummary::macro_avg_recall() const {
  // @@protoc_insertion_point(field_get:clarifai.api.MetricsSummary.macro_avg_recall)
  return _internal_macro_avg_recall();
}
inline void MetricsSummary::_internal_set_macro_avg_recall(float value) {
  
  _impl_.macro_avg_recall_ = value;
}
inline void MetricsSummary::set_macro_avg_recall(float value) {
  _internal_set_macro_avg_recall(value);
  // @@protoc_insertion_point(field_set:clarifai.api.MetricsSummary.macro_avg_recall)
}

// float mean_avg_precision_iou_50 = 10;
inline void MetricsSummary::clear_mean_avg_precision_iou_50() {
  _impl_.mean_avg_precision_iou_50_ = 0;
}
inline float MetricsSummary::_internal_mean_avg_precision_iou_50() const {
  return _impl_.mean_avg_precision_iou_50_;
}
inline float MetricsSummary::mean_avg_precision_iou_50() const {
  // @@protoc_insertion_point(field_get:clarifai.api.MetricsSummary.mean_avg_precision_iou_50)
  return _internal_mean_avg_precision_iou_50();
}
inline void MetricsSummary::_internal_set_mean_avg_precision_iou_50(float value) {
  
  _impl_.mean_avg_precision_iou_50_ = value;
}
inline void MetricsSummary::set_mean_avg_precision_iou_50(float value) {
  _internal_set_mean_avg_precision_iou_50(value);
  // @@protoc_insertion_point(field_set:clarifai.api.MetricsSummary.mean_avg_precision_iou_50)
}

// float mean_avg_precision_iou_range = 11;
inline void MetricsSummary::clear_mean_avg_precision_iou_range() {
  _impl_.mean_avg_precision_iou_range_ = 0;
}
inline float MetricsSummary::_internal_mean_avg_precision_iou_range() const {
  return _impl_.mean_avg_precision_iou_range_;
}
inline float MetricsSummary::mean_avg_precision_iou_range() const {
  // @@protoc_insertion_point(field_get:clarifai.api.MetricsSummary.mean_avg_precision_iou_range)
  return _internal_mean_avg_precision_iou_range();
}
inline void MetricsSummary::_internal_set_mean_avg_precision_iou_range(float value) {
  
  _impl_.mean_avg_precision_iou_range_ = value;
}
inline void MetricsSummary::set_mean_avg_precision_iou_range(float value) {
  _internal_set_mean_avg_precision_iou_range(value);
  // @@protoc_insertion_point(field_set:clarifai.api.MetricsSummary.mean_avg_precision_iou_range)
}

// repeated .clarifai.api.LOPQEvalResult lopq_metrics = 9;
inline int MetricsSummary::_internal_lopq_metrics_size() const {
  return _impl_.lopq_metrics_.size();
}
inline int MetricsSummary::lopq_metrics_size() const {
  return _internal_lopq_metrics_size();
}
inline void MetricsSummary::clear_lopq_metrics() {
  _impl_.lopq_metrics_.Clear();
}
inline ::clarifai::api::LOPQEvalResult* MetricsSummary::mutable_lopq_metrics(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.MetricsSummary.lopq_metrics)
  return _impl_.lopq_metrics_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::LOPQEvalResult >*
MetricsSummary::mutable_lopq_metrics() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.MetricsSummary.lopq_metrics)
  return &_impl_.lopq_metrics_;
}
inline const ::clarifai::api::LOPQEvalResult& MetricsSummary::_internal_lopq_metrics(int index) const {
  return _impl_.lopq_metrics_.Get(index);
}
inline const ::clarifai::api::LOPQEvalResult& MetricsSummary::lopq_metrics(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.MetricsSummary.lopq_metrics)
  return _internal_lopq_metrics(index);
}
inline ::clarifai::api::LOPQEvalResult* MetricsSummary::_internal_add_lopq_metrics() {
  return _impl_.lopq_metrics_.Add();
}
inline ::clarifai::api::LOPQEvalResult* MetricsSummary::add_lopq_metrics() {
  ::clarifai::api::LOPQEvalResult* _add = _internal_add_lopq_metrics();
  // @@protoc_insertion_point(field_add:clarifai.api.MetricsSummary.lopq_metrics)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::LOPQEvalResult >&
MetricsSummary::lopq_metrics() const {
  // @@protoc_insertion_point(field_list:clarifai.api.MetricsSummary.lopq_metrics)
  return _impl_.lopq_metrics_;
}

// -------------------------------------------------------------------

// EvalMetrics

// .clarifai.api.status.Status status = 1;
inline bool EvalMetrics::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool EvalMetrics::has_status() const {
  return _internal_has_status();
}
inline const ::clarifai::api::status::Status& EvalMetrics::_internal_status() const {
  const ::clarifai::api::status::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::status::Status&>(
      ::clarifai::api::status::_Status_default_instance_);
}
inline const ::clarifai::api::status::Status& EvalMetrics::status() const {
  // @@protoc_insertion_point(field_get:clarifai.api.EvalMetrics.status)
  return _internal_status();
}
inline void EvalMetrics::unsafe_arena_set_allocated_status(
    ::clarifai::api::status::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.EvalMetrics.status)
}
inline ::clarifai::api::status::Status* EvalMetrics::release_status() {
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::status::Status* EvalMetrics::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:clarifai.api.EvalMetrics.status)
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::clarifai::api::status::Status* EvalMetrics::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::status::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::clarifai::api::status::Status* EvalMetrics::mutable_status() {
  ::clarifai::api::status::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:clarifai.api.EvalMetrics.status)
  return _msg;
}
inline void EvalMetrics::set_allocated_status(::clarifai::api::status::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.EvalMetrics.status)
}

// string id = 10;
inline void EvalMetrics::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& EvalMetrics::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.EvalMetrics.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EvalMetrics::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.EvalMetrics.id)
}
inline std::string* EvalMetrics::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.EvalMetrics.id)
  return _s;
}
inline const std::string& EvalMetrics::_internal_id() const {
  return _impl_.id_.Get();
}
inline void EvalMetrics::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* EvalMetrics::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* EvalMetrics::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.EvalMetrics.id)
  return _impl_.id_.Release();
}
inline void EvalMetrics::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.EvalMetrics.id)
}

// .clarifai.api.MetricsSummary summary = 2;
inline bool EvalMetrics::_internal_has_summary() const {
  return this != internal_default_instance() && _impl_.summary_ != nullptr;
}
inline bool EvalMetrics::has_summary() const {
  return _internal_has_summary();
}
inline void EvalMetrics::clear_summary() {
  if (GetArenaForAllocation() == nullptr && _impl_.summary_ != nullptr) {
    delete _impl_.summary_;
  }
  _impl_.summary_ = nullptr;
}
inline const ::clarifai::api::MetricsSummary& EvalMetrics::_internal_summary() const {
  const ::clarifai::api::MetricsSummary* p = _impl_.summary_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::MetricsSummary&>(
      ::clarifai::api::_MetricsSummary_default_instance_);
}
inline const ::clarifai::api::MetricsSummary& EvalMetrics::summary() const {
  // @@protoc_insertion_point(field_get:clarifai.api.EvalMetrics.summary)
  return _internal_summary();
}
inline void EvalMetrics::unsafe_arena_set_allocated_summary(
    ::clarifai::api::MetricsSummary* summary) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.summary_);
  }
  _impl_.summary_ = summary;
  if (summary) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.EvalMetrics.summary)
}
inline ::clarifai::api::MetricsSummary* EvalMetrics::release_summary() {
  
  ::clarifai::api::MetricsSummary* temp = _impl_.summary_;
  _impl_.summary_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::MetricsSummary* EvalMetrics::unsafe_arena_release_summary() {
  // @@protoc_insertion_point(field_release:clarifai.api.EvalMetrics.summary)
  
  ::clarifai::api::MetricsSummary* temp = _impl_.summary_;
  _impl_.summary_ = nullptr;
  return temp;
}
inline ::clarifai::api::MetricsSummary* EvalMetrics::_internal_mutable_summary() {
  
  if (_impl_.summary_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::MetricsSummary>(GetArenaForAllocation());
    _impl_.summary_ = p;
  }
  return _impl_.summary_;
}
inline ::clarifai::api::MetricsSummary* EvalMetrics::mutable_summary() {
  ::clarifai::api::MetricsSummary* _msg = _internal_mutable_summary();
  // @@protoc_insertion_point(field_mutable:clarifai.api.EvalMetrics.summary)
  return _msg;
}
inline void EvalMetrics::set_allocated_summary(::clarifai::api::MetricsSummary* summary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.summary_;
  }
  if (summary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(summary);
    if (message_arena != submessage_arena) {
      summary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, summary, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.summary_ = summary;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.EvalMetrics.summary)
}

// .clarifai.api.ConfusionMatrix confusion_matrix = 3;
inline bool EvalMetrics::_internal_has_confusion_matrix() const {
  return this != internal_default_instance() && _impl_.confusion_matrix_ != nullptr;
}
inline bool EvalMetrics::has_confusion_matrix() const {
  return _internal_has_confusion_matrix();
}
inline void EvalMetrics::clear_confusion_matrix() {
  if (GetArenaForAllocation() == nullptr && _impl_.confusion_matrix_ != nullptr) {
    delete _impl_.confusion_matrix_;
  }
  _impl_.confusion_matrix_ = nullptr;
}
inline const ::clarifai::api::ConfusionMatrix& EvalMetrics::_internal_confusion_matrix() const {
  const ::clarifai::api::ConfusionMatrix* p = _impl_.confusion_matrix_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::ConfusionMatrix&>(
      ::clarifai::api::_ConfusionMatrix_default_instance_);
}
inline const ::clarifai::api::ConfusionMatrix& EvalMetrics::confusion_matrix() const {
  // @@protoc_insertion_point(field_get:clarifai.api.EvalMetrics.confusion_matrix)
  return _internal_confusion_matrix();
}
inline void EvalMetrics::unsafe_arena_set_allocated_confusion_matrix(
    ::clarifai::api::ConfusionMatrix* confusion_matrix) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.confusion_matrix_);
  }
  _impl_.confusion_matrix_ = confusion_matrix;
  if (confusion_matrix) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.EvalMetrics.confusion_matrix)
}
inline ::clarifai::api::ConfusionMatrix* EvalMetrics::release_confusion_matrix() {
  
  ::clarifai::api::ConfusionMatrix* temp = _impl_.confusion_matrix_;
  _impl_.confusion_matrix_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::ConfusionMatrix* EvalMetrics::unsafe_arena_release_confusion_matrix() {
  // @@protoc_insertion_point(field_release:clarifai.api.EvalMetrics.confusion_matrix)
  
  ::clarifai::api::ConfusionMatrix* temp = _impl_.confusion_matrix_;
  _impl_.confusion_matrix_ = nullptr;
  return temp;
}
inline ::clarifai::api::ConfusionMatrix* EvalMetrics::_internal_mutable_confusion_matrix() {
  
  if (_impl_.confusion_matrix_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::ConfusionMatrix>(GetArenaForAllocation());
    _impl_.confusion_matrix_ = p;
  }
  return _impl_.confusion_matrix_;
}
inline ::clarifai::api::ConfusionMatrix* EvalMetrics::mutable_confusion_matrix() {
  ::clarifai::api::ConfusionMatrix* _msg = _internal_mutable_confusion_matrix();
  // @@protoc_insertion_point(field_mutable:clarifai.api.EvalMetrics.confusion_matrix)
  return _msg;
}
inline void EvalMetrics::set_allocated_confusion_matrix(::clarifai::api::ConfusionMatrix* confusion_matrix) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.confusion_matrix_;
  }
  if (confusion_matrix) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(confusion_matrix);
    if (message_arena != submessage_arena) {
      confusion_matrix = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, confusion_matrix, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.confusion_matrix_ = confusion_matrix;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.EvalMetrics.confusion_matrix)
}

// .clarifai.api.CooccurrenceMatrix cooccurrence_matrix = 4;
inline bool EvalMetrics::_internal_has_cooccurrence_matrix() const {
  return this != internal_default_instance() && _impl_.cooccurrence_matrix_ != nullptr;
}
inline bool EvalMetrics::has_cooccurrence_matrix() const {
  return _internal_has_cooccurrence_matrix();
}
inline void EvalMetrics::clear_cooccurrence_matrix() {
  if (GetArenaForAllocation() == nullptr && _impl_.cooccurrence_matrix_ != nullptr) {
    delete _impl_.cooccurrence_matrix_;
  }
  _impl_.cooccurrence_matrix_ = nullptr;
}
inline const ::clarifai::api::CooccurrenceMatrix& EvalMetrics::_internal_cooccurrence_matrix() const {
  const ::clarifai::api::CooccurrenceMatrix* p = _impl_.cooccurrence_matrix_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::CooccurrenceMatrix&>(
      ::clarifai::api::_CooccurrenceMatrix_default_instance_);
}
inline const ::clarifai::api::CooccurrenceMatrix& EvalMetrics::cooccurrence_matrix() const {
  // @@protoc_insertion_point(field_get:clarifai.api.EvalMetrics.cooccurrence_matrix)
  return _internal_cooccurrence_matrix();
}
inline void EvalMetrics::unsafe_arena_set_allocated_cooccurrence_matrix(
    ::clarifai::api::CooccurrenceMatrix* cooccurrence_matrix) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cooccurrence_matrix_);
  }
  _impl_.cooccurrence_matrix_ = cooccurrence_matrix;
  if (cooccurrence_matrix) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.EvalMetrics.cooccurrence_matrix)
}
inline ::clarifai::api::CooccurrenceMatrix* EvalMetrics::release_cooccurrence_matrix() {
  
  ::clarifai::api::CooccurrenceMatrix* temp = _impl_.cooccurrence_matrix_;
  _impl_.cooccurrence_matrix_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::CooccurrenceMatrix* EvalMetrics::unsafe_arena_release_cooccurrence_matrix() {
  // @@protoc_insertion_point(field_release:clarifai.api.EvalMetrics.cooccurrence_matrix)
  
  ::clarifai::api::CooccurrenceMatrix* temp = _impl_.cooccurrence_matrix_;
  _impl_.cooccurrence_matrix_ = nullptr;
  return temp;
}
inline ::clarifai::api::CooccurrenceMatrix* EvalMetrics::_internal_mutable_cooccurrence_matrix() {
  
  if (_impl_.cooccurrence_matrix_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::CooccurrenceMatrix>(GetArenaForAllocation());
    _impl_.cooccurrence_matrix_ = p;
  }
  return _impl_.cooccurrence_matrix_;
}
inline ::clarifai::api::CooccurrenceMatrix* EvalMetrics::mutable_cooccurrence_matrix() {
  ::clarifai::api::CooccurrenceMatrix* _msg = _internal_mutable_cooccurrence_matrix();
  // @@protoc_insertion_point(field_mutable:clarifai.api.EvalMetrics.cooccurrence_matrix)
  return _msg;
}
inline void EvalMetrics::set_allocated_cooccurrence_matrix(::clarifai::api::CooccurrenceMatrix* cooccurrence_matrix) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cooccurrence_matrix_;
  }
  if (cooccurrence_matrix) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cooccurrence_matrix);
    if (message_arena != submessage_arena) {
      cooccurrence_matrix = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cooccurrence_matrix, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cooccurrence_matrix_ = cooccurrence_matrix;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.EvalMetrics.cooccurrence_matrix)
}

// .clarifai.api.LabelDistribution label_counts = 5;
inline bool EvalMetrics::_internal_has_label_counts() const {
  return this != internal_default_instance() && _impl_.label_counts_ != nullptr;
}
inline bool EvalMetrics::has_label_counts() const {
  return _internal_has_label_counts();
}
inline void EvalMetrics::clear_label_counts() {
  if (GetArenaForAllocation() == nullptr && _impl_.label_counts_ != nullptr) {
    delete _impl_.label_counts_;
  }
  _impl_.label_counts_ = nullptr;
}
inline const ::clarifai::api::LabelDistribution& EvalMetrics::_internal_label_counts() const {
  const ::clarifai::api::LabelDistribution* p = _impl_.label_counts_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::LabelDistribution&>(
      ::clarifai::api::_LabelDistribution_default_instance_);
}
inline const ::clarifai::api::LabelDistribution& EvalMetrics::label_counts() const {
  // @@protoc_insertion_point(field_get:clarifai.api.EvalMetrics.label_counts)
  return _internal_label_counts();
}
inline void EvalMetrics::unsafe_arena_set_allocated_label_counts(
    ::clarifai::api::LabelDistribution* label_counts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.label_counts_);
  }
  _impl_.label_counts_ = label_counts;
  if (label_counts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.EvalMetrics.label_counts)
}
inline ::clarifai::api::LabelDistribution* EvalMetrics::release_label_counts() {
  
  ::clarifai::api::LabelDistribution* temp = _impl_.label_counts_;
  _impl_.label_counts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::LabelDistribution* EvalMetrics::unsafe_arena_release_label_counts() {
  // @@protoc_insertion_point(field_release:clarifai.api.EvalMetrics.label_counts)
  
  ::clarifai::api::LabelDistribution* temp = _impl_.label_counts_;
  _impl_.label_counts_ = nullptr;
  return temp;
}
inline ::clarifai::api::LabelDistribution* EvalMetrics::_internal_mutable_label_counts() {
  
  if (_impl_.label_counts_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::LabelDistribution>(GetArenaForAllocation());
    _impl_.label_counts_ = p;
  }
  return _impl_.label_counts_;
}
inline ::clarifai::api::LabelDistribution* EvalMetrics::mutable_label_counts() {
  ::clarifai::api::LabelDistribution* _msg = _internal_mutable_label_counts();
  // @@protoc_insertion_point(field_mutable:clarifai.api.EvalMetrics.label_counts)
  return _msg;
}
inline void EvalMetrics::set_allocated_label_counts(::clarifai::api::LabelDistribution* label_counts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.label_counts_;
  }
  if (label_counts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(label_counts);
    if (message_arena != submessage_arena) {
      label_counts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, label_counts, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.label_counts_ = label_counts;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.EvalMetrics.label_counts)
}

// repeated .clarifai.api.BinaryMetrics binary_metrics = 6;
inline int EvalMetrics::_internal_binary_metrics_size() const {
  return _impl_.binary_metrics_.size();
}
inline int EvalMetrics::binary_metrics_size() const {
  return _internal_binary_metrics_size();
}
inline void EvalMetrics::clear_binary_metrics() {
  _impl_.binary_metrics_.Clear();
}
inline ::clarifai::api::BinaryMetrics* EvalMetrics::mutable_binary_metrics(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.EvalMetrics.binary_metrics)
  return _impl_.binary_metrics_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::BinaryMetrics >*
EvalMetrics::mutable_binary_metrics() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.EvalMetrics.binary_metrics)
  return &_impl_.binary_metrics_;
}
inline const ::clarifai::api::BinaryMetrics& EvalMetrics::_internal_binary_metrics(int index) const {
  return _impl_.binary_metrics_.Get(index);
}
inline const ::clarifai::api::BinaryMetrics& EvalMetrics::binary_metrics(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.EvalMetrics.binary_metrics)
  return _internal_binary_metrics(index);
}
inline ::clarifai::api::BinaryMetrics* EvalMetrics::_internal_add_binary_metrics() {
  return _impl_.binary_metrics_.Add();
}
inline ::clarifai::api::BinaryMetrics* EvalMetrics::add_binary_metrics() {
  ::clarifai::api::BinaryMetrics* _add = _internal_add_binary_metrics();
  // @@protoc_insertion_point(field_add:clarifai.api.EvalMetrics.binary_metrics)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::BinaryMetrics >&
EvalMetrics::binary_metrics() const {
  // @@protoc_insertion_point(field_list:clarifai.api.EvalMetrics.binary_metrics)
  return _impl_.binary_metrics_;
}

// repeated .clarifai.api.EvalTestSetEntry test_set = 7;
inline int EvalMetrics::_internal_test_set_size() const {
  return _impl_.test_set_.size();
}
inline int EvalMetrics::test_set_size() const {
  return _internal_test_set_size();
}
inline void EvalMetrics::clear_test_set() {
  _impl_.test_set_.Clear();
}
inline ::clarifai::api::EvalTestSetEntry* EvalMetrics::mutable_test_set(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.EvalMetrics.test_set)
  return _impl_.test_set_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::EvalTestSetEntry >*
EvalMetrics::mutable_test_set() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.EvalMetrics.test_set)
  return &_impl_.test_set_;
}
inline const ::clarifai::api::EvalTestSetEntry& EvalMetrics::_internal_test_set(int index) const {
  return _impl_.test_set_.Get(index);
}
inline const ::clarifai::api::EvalTestSetEntry& EvalMetrics::test_set(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.EvalMetrics.test_set)
  return _internal_test_set(index);
}
inline ::clarifai::api::EvalTestSetEntry* EvalMetrics::_internal_add_test_set() {
  return _impl_.test_set_.Add();
}
inline ::clarifai::api::EvalTestSetEntry* EvalMetrics::add_test_set() {
  ::clarifai::api::EvalTestSetEntry* _add = _internal_add_test_set();
  // @@protoc_insertion_point(field_add:clarifai.api.EvalMetrics.test_set)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::EvalTestSetEntry >&
EvalMetrics::test_set() const {
  // @@protoc_insertion_point(field_list:clarifai.api.EvalMetrics.test_set)
  return _impl_.test_set_;
}

// repeated .clarifai.api.BinaryMetrics metrics_by_area = 8;
inline int EvalMetrics::_internal_metrics_by_area_size() const {
  return _impl_.metrics_by_area_.size();
}
inline int EvalMetrics::metrics_by_area_size() const {
  return _internal_metrics_by_area_size();
}
inline void EvalMetrics::clear_metrics_by_area() {
  _impl_.metrics_by_area_.Clear();
}
inline ::clarifai::api::BinaryMetrics* EvalMetrics::mutable_metrics_by_area(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.EvalMetrics.metrics_by_area)
  return _impl_.metrics_by_area_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::BinaryMetrics >*
EvalMetrics::mutable_metrics_by_area() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.EvalMetrics.metrics_by_area)
  return &_impl_.metrics_by_area_;
}
inline const ::clarifai::api::BinaryMetrics& EvalMetrics::_internal_metrics_by_area(int index) const {
  return _impl_.metrics_by_area_.Get(index);
}
inline const ::clarifai::api::BinaryMetrics& EvalMetrics::metrics_by_area(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.EvalMetrics.metrics_by_area)
  return _internal_metrics_by_area(index);
}
inline ::clarifai::api::BinaryMetrics* EvalMetrics::_internal_add_metrics_by_area() {
  return _impl_.metrics_by_area_.Add();
}
inline ::clarifai::api::BinaryMetrics* EvalMetrics::add_metrics_by_area() {
  ::clarifai::api::BinaryMetrics* _add = _internal_add_metrics_by_area();
  // @@protoc_insertion_point(field_add:clarifai.api.EvalMetrics.metrics_by_area)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::BinaryMetrics >&
EvalMetrics::metrics_by_area() const {
  // @@protoc_insertion_point(field_list:clarifai.api.EvalMetrics.metrics_by_area)
  return _impl_.metrics_by_area_;
}

// repeated .clarifai.api.BinaryMetrics metrics_by_class = 9;
inline int EvalMetrics::_internal_metrics_by_class_size() const {
  return _impl_.metrics_by_class_.size();
}
inline int EvalMetrics::metrics_by_class_size() const {
  return _internal_metrics_by_class_size();
}
inline void EvalMetrics::clear_metrics_by_class() {
  _impl_.metrics_by_class_.Clear();
}
inline ::clarifai::api::BinaryMetrics* EvalMetrics::mutable_metrics_by_class(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.EvalMetrics.metrics_by_class)
  return _impl_.metrics_by_class_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::BinaryMetrics >*
EvalMetrics::mutable_metrics_by_class() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.EvalMetrics.metrics_by_class)
  return &_impl_.metrics_by_class_;
}
inline const ::clarifai::api::BinaryMetrics& EvalMetrics::_internal_metrics_by_class(int index) const {
  return _impl_.metrics_by_class_.Get(index);
}
inline const ::clarifai::api::BinaryMetrics& EvalMetrics::metrics_by_class(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.EvalMetrics.metrics_by_class)
  return _internal_metrics_by_class(index);
}
inline ::clarifai::api::BinaryMetrics* EvalMetrics::_internal_add_metrics_by_class() {
  return _impl_.metrics_by_class_.Add();
}
inline ::clarifai::api::BinaryMetrics* EvalMetrics::add_metrics_by_class() {
  ::clarifai::api::BinaryMetrics* _add = _internal_add_metrics_by_class();
  // @@protoc_insertion_point(field_add:clarifai.api.EvalMetrics.metrics_by_class)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::BinaryMetrics >&
EvalMetrics::metrics_by_class() const {
  // @@protoc_insertion_point(field_list:clarifai.api.EvalMetrics.metrics_by_class)
  return _impl_.metrics_by_class_;
}

// repeated .clarifai.api.TrackerMetrics tracker_metrics = 11;
inline int EvalMetrics::_internal_tracker_metrics_size() const {
  return _impl_.tracker_metrics_.size();
}
inline int EvalMetrics::tracker_metrics_size() const {
  return _internal_tracker_metrics_size();
}
inline void EvalMetrics::clear_tracker_metrics() {
  _impl_.tracker_metrics_.Clear();
}
inline ::clarifai::api::TrackerMetrics* EvalMetrics::mutable_tracker_metrics(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.EvalMetrics.tracker_metrics)
  return _impl_.tracker_metrics_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::TrackerMetrics >*
EvalMetrics::mutable_tracker_metrics() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.EvalMetrics.tracker_metrics)
  return &_impl_.tracker_metrics_;
}
inline const ::clarifai::api::TrackerMetrics& EvalMetrics::_internal_tracker_metrics(int index) const {
  return _impl_.tracker_metrics_.Get(index);
}
inline const ::clarifai::api::TrackerMetrics& EvalMetrics::tracker_metrics(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.EvalMetrics.tracker_metrics)
  return _internal_tracker_metrics(index);
}
inline ::clarifai::api::TrackerMetrics* EvalMetrics::_internal_add_tracker_metrics() {
  return _impl_.tracker_metrics_.Add();
}
inline ::clarifai::api::TrackerMetrics* EvalMetrics::add_tracker_metrics() {
  ::clarifai::api::TrackerMetrics* _add = _internal_add_tracker_metrics();
  // @@protoc_insertion_point(field_add:clarifai.api.EvalMetrics.tracker_metrics)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::TrackerMetrics >&
EvalMetrics::tracker_metrics() const {
  // @@protoc_insertion_point(field_list:clarifai.api.EvalMetrics.tracker_metrics)
  return _impl_.tracker_metrics_;
}

// .clarifai.api.EvalInfo eval_info = 12;
inline bool EvalMetrics::_internal_has_eval_info() const {
  return this != internal_default_instance() && _impl_.eval_info_ != nullptr;
}
inline bool EvalMetrics::has_eval_info() const {
  return _internal_has_eval_info();
}
inline void EvalMetrics::clear_eval_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.eval_info_ != nullptr) {
    delete _impl_.eval_info_;
  }
  _impl_.eval_info_ = nullptr;
}
inline const ::clarifai::api::EvalInfo& EvalMetrics::_internal_eval_info() const {
  const ::clarifai::api::EvalInfo* p = _impl_.eval_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::EvalInfo&>(
      ::clarifai::api::_EvalInfo_default_instance_);
}
inline const ::clarifai::api::EvalInfo& EvalMetrics::eval_info() const {
  // @@protoc_insertion_point(field_get:clarifai.api.EvalMetrics.eval_info)
  return _internal_eval_info();
}
inline void EvalMetrics::unsafe_arena_set_allocated_eval_info(
    ::clarifai::api::EvalInfo* eval_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eval_info_);
  }
  _impl_.eval_info_ = eval_info;
  if (eval_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.EvalMetrics.eval_info)
}
inline ::clarifai::api::EvalInfo* EvalMetrics::release_eval_info() {
  
  ::clarifai::api::EvalInfo* temp = _impl_.eval_info_;
  _impl_.eval_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::EvalInfo* EvalMetrics::unsafe_arena_release_eval_info() {
  // @@protoc_insertion_point(field_release:clarifai.api.EvalMetrics.eval_info)
  
  ::clarifai::api::EvalInfo* temp = _impl_.eval_info_;
  _impl_.eval_info_ = nullptr;
  return temp;
}
inline ::clarifai::api::EvalInfo* EvalMetrics::_internal_mutable_eval_info() {
  
  if (_impl_.eval_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::EvalInfo>(GetArenaForAllocation());
    _impl_.eval_info_ = p;
  }
  return _impl_.eval_info_;
}
inline ::clarifai::api::EvalInfo* EvalMetrics::mutable_eval_info() {
  ::clarifai::api::EvalInfo* _msg = _internal_mutable_eval_info();
  // @@protoc_insertion_point(field_mutable:clarifai.api.EvalMetrics.eval_info)
  return _msg;
}
inline void EvalMetrics::set_allocated_eval_info(::clarifai::api::EvalInfo* eval_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.eval_info_;
  }
  if (eval_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(eval_info);
    if (message_arena != submessage_arena) {
      eval_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eval_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.eval_info_ = eval_info;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.EvalMetrics.eval_info)
}

// -------------------------------------------------------------------

// FieldsValue

// bool confusion_matrix = 1;
inline void FieldsValue::clear_confusion_matrix() {
  _impl_.confusion_matrix_ = false;
}
inline bool FieldsValue::_internal_confusion_matrix() const {
  return _impl_.confusion_matrix_;
}
inline bool FieldsValue::confusion_matrix() const {
  // @@protoc_insertion_point(field_get:clarifai.api.FieldsValue.confusion_matrix)
  return _internal_confusion_matrix();
}
inline void FieldsValue::_internal_set_confusion_matrix(bool value) {
  
  _impl_.confusion_matrix_ = value;
}
inline void FieldsValue::set_confusion_matrix(bool value) {
  _internal_set_confusion_matrix(value);
  // @@protoc_insertion_point(field_set:clarifai.api.FieldsValue.confusion_matrix)
}

// bool cooccurrence_matrix = 2;
inline void FieldsValue::clear_cooccurrence_matrix() {
  _impl_.cooccurrence_matrix_ = false;
}
inline bool FieldsValue::_internal_cooccurrence_matrix() const {
  return _impl_.cooccurrence_matrix_;
}
inline bool FieldsValue::cooccurrence_matrix() const {
  // @@protoc_insertion_point(field_get:clarifai.api.FieldsValue.cooccurrence_matrix)
  return _internal_cooccurrence_matrix();
}
inline void FieldsValue::_internal_set_cooccurrence_matrix(bool value) {
  
  _impl_.cooccurrence_matrix_ = value;
}
inline void FieldsValue::set_cooccurrence_matrix(bool value) {
  _internal_set_cooccurrence_matrix(value);
  // @@protoc_insertion_point(field_set:clarifai.api.FieldsValue.cooccurrence_matrix)
}

// bool label_counts = 3;
inline void FieldsValue::clear_label_counts() {
  _impl_.label_counts_ = false;
}
inline bool FieldsValue::_internal_label_counts() const {
  return _impl_.label_counts_;
}
inline bool FieldsValue::label_counts() const {
  // @@protoc_insertion_point(field_get:clarifai.api.FieldsValue.label_counts)
  return _internal_label_counts();
}
inline void FieldsValue::_internal_set_label_counts(bool value) {
  
  _impl_.label_counts_ = value;
}
inline void FieldsValue::set_label_counts(bool value) {
  _internal_set_label_counts(value);
  // @@protoc_insertion_point(field_set:clarifai.api.FieldsValue.label_counts)
}

// bool binary_metrics = 4;
inline void FieldsValue::clear_binary_metrics() {
  _impl_.binary_metrics_ = false;
}
inline bool FieldsValue::_internal_binary_metrics() const {
  return _impl_.binary_metrics_;
}
inline bool FieldsValue::binary_metrics() const {
  // @@protoc_insertion_point(field_get:clarifai.api.FieldsValue.binary_metrics)
  return _internal_binary_metrics();
}
inline void FieldsValue::_internal_set_binary_metrics(bool value) {
  
  _impl_.binary_metrics_ = value;
}
inline void FieldsValue::set_binary_metrics(bool value) {
  _internal_set_binary_metrics(value);
  // @@protoc_insertion_point(field_set:clarifai.api.FieldsValue.binary_metrics)
}

// bool test_set = 5;
inline void FieldsValue::clear_test_set() {
  _impl_.test_set_ = false;
}
inline bool FieldsValue::_internal_test_set() const {
  return _impl_.test_set_;
}
inline bool FieldsValue::test_set() const {
  // @@protoc_insertion_point(field_get:clarifai.api.FieldsValue.test_set)
  return _internal_test_set();
}
inline void FieldsValue::_internal_set_test_set(bool value) {
  
  _impl_.test_set_ = value;
}
inline void FieldsValue::set_test_set(bool value) {
  _internal_set_test_set(value);
  // @@protoc_insertion_point(field_set:clarifai.api.FieldsValue.test_set)
}

// bool metrics_by_area = 6;
inline void FieldsValue::clear_metrics_by_area() {
  _impl_.metrics_by_area_ = false;
}
inline bool FieldsValue::_internal_metrics_by_area() const {
  return _impl_.metrics_by_area_;
}
inline bool FieldsValue::metrics_by_area() const {
  // @@protoc_insertion_point(field_get:clarifai.api.FieldsValue.metrics_by_area)
  return _internal_metrics_by_area();
}
inline void FieldsValue::_internal_set_metrics_by_area(bool value) {
  
  _impl_.metrics_by_area_ = value;
}
inline void FieldsValue::set_metrics_by_area(bool value) {
  _internal_set_metrics_by_area(value);
  // @@protoc_insertion_point(field_set:clarifai.api.FieldsValue.metrics_by_area)
}

// bool metrics_by_class = 7;
inline void FieldsValue::clear_metrics_by_class() {
  _impl_.metrics_by_class_ = false;
}
inline bool FieldsValue::_internal_metrics_by_class() const {
  return _impl_.metrics_by_class_;
}
inline bool FieldsValue::metrics_by_class() const {
  // @@protoc_insertion_point(field_get:clarifai.api.FieldsValue.metrics_by_class)
  return _internal_metrics_by_class();
}
inline void FieldsValue::_internal_set_metrics_by_class(bool value) {
  
  _impl_.metrics_by_class_ = value;
}
inline void FieldsValue::set_metrics_by_class(bool value) {
  _internal_set_metrics_by_class(value);
  // @@protoc_insertion_point(field_set:clarifai.api.FieldsValue.metrics_by_class)
}

// -------------------------------------------------------------------

// Output

// string id = 1;
inline void Output::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Output::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Output.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Output::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Output.id)
}
inline std::string* Output::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Output.id)
  return _s;
}
inline const std::string& Output::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Output::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Output::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Output::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Output.id)
  return _impl_.id_.Release();
}
inline void Output::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Output.id)
}

// .clarifai.api.status.Status status = 2;
inline bool Output::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool Output::has_status() const {
  return _internal_has_status();
}
inline const ::clarifai::api::status::Status& Output::_internal_status() const {
  const ::clarifai::api::status::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::status::Status&>(
      ::clarifai::api::status::_Status_default_instance_);
}
inline const ::clarifai::api::status::Status& Output::status() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Output.status)
  return _internal_status();
}
inline void Output::unsafe_arena_set_allocated_status(
    ::clarifai::api::status::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Output.status)
}
inline ::clarifai::api::status::Status* Output::release_status() {
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::status::Status* Output::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:clarifai.api.Output.status)
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::clarifai::api::status::Status* Output::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::status::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::clarifai::api::status::Status* Output::mutable_status() {
  ::clarifai::api::status::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Output.status)
  return _msg;
}
inline void Output::set_allocated_status(::clarifai::api::status::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Output.status)
}

// .google.protobuf.Timestamp created_at = 3;
inline bool Output::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool Output::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Output::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Output::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Output.created_at)
  return _internal_created_at();
}
inline void Output::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Output.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Output::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Output::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.Output.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Output::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Output::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Output.created_at)
  return _msg;
}
inline void Output::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Output.created_at)
}

// .clarifai.api.Model model = 4;
inline bool Output::_internal_has_model() const {
  return this != internal_default_instance() && _impl_.model_ != nullptr;
}
inline bool Output::has_model() const {
  return _internal_has_model();
}
inline void Output::clear_model() {
  if (GetArenaForAllocation() == nullptr && _impl_.model_ != nullptr) {
    delete _impl_.model_;
  }
  _impl_.model_ = nullptr;
}
inline const ::clarifai::api::Model& Output::_internal_model() const {
  const ::clarifai::api::Model* p = _impl_.model_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Model&>(
      ::clarifai::api::_Model_default_instance_);
}
inline const ::clarifai::api::Model& Output::model() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Output.model)
  return _internal_model();
}
inline void Output::unsafe_arena_set_allocated_model(
    ::clarifai::api::Model* model) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.model_);
  }
  _impl_.model_ = model;
  if (model) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Output.model)
}
inline ::clarifai::api::Model* Output::release_model() {
  
  ::clarifai::api::Model* temp = _impl_.model_;
  _impl_.model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Model* Output::unsafe_arena_release_model() {
  // @@protoc_insertion_point(field_release:clarifai.api.Output.model)
  
  ::clarifai::api::Model* temp = _impl_.model_;
  _impl_.model_ = nullptr;
  return temp;
}
inline ::clarifai::api::Model* Output::_internal_mutable_model() {
  
  if (_impl_.model_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Model>(GetArenaForAllocation());
    _impl_.model_ = p;
  }
  return _impl_.model_;
}
inline ::clarifai::api::Model* Output::mutable_model() {
  ::clarifai::api::Model* _msg = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Output.model)
  return _msg;
}
inline void Output::set_allocated_model(::clarifai::api::Model* model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.model_;
  }
  if (model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(model);
    if (message_arena != submessage_arena) {
      model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.model_ = model;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Output.model)
}

// .clarifai.api.Input input = 5;
inline bool Output::_internal_has_input() const {
  return this != internal_default_instance() && _impl_.input_ != nullptr;
}
inline bool Output::has_input() const {
  return _internal_has_input();
}
inline void Output::clear_input() {
  if (GetArenaForAllocation() == nullptr && _impl_.input_ != nullptr) {
    delete _impl_.input_;
  }
  _impl_.input_ = nullptr;
}
inline const ::clarifai::api::Input& Output::_internal_input() const {
  const ::clarifai::api::Input* p = _impl_.input_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Input&>(
      ::clarifai::api::_Input_default_instance_);
}
inline const ::clarifai::api::Input& Output::input() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Output.input)
  return _internal_input();
}
inline void Output::unsafe_arena_set_allocated_input(
    ::clarifai::api::Input* input) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.input_);
  }
  _impl_.input_ = input;
  if (input) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Output.input)
}
inline ::clarifai::api::Input* Output::release_input() {
  
  ::clarifai::api::Input* temp = _impl_.input_;
  _impl_.input_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Input* Output::unsafe_arena_release_input() {
  // @@protoc_insertion_point(field_release:clarifai.api.Output.input)
  
  ::clarifai::api::Input* temp = _impl_.input_;
  _impl_.input_ = nullptr;
  return temp;
}
inline ::clarifai::api::Input* Output::_internal_mutable_input() {
  
  if (_impl_.input_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Input>(GetArenaForAllocation());
    _impl_.input_ = p;
  }
  return _impl_.input_;
}
inline ::clarifai::api::Input* Output::mutable_input() {
  ::clarifai::api::Input* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Output.input)
  return _msg;
}
inline void Output::set_allocated_input(::clarifai::api::Input* input) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.input_;
  }
  if (input) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(input);
    if (message_arena != submessage_arena) {
      input = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.input_ = input;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Output.input)
}

// .clarifai.api.Data data = 6;
inline bool Output::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool Output::has_data() const {
  return _internal_has_data();
}
inline void Output::clear_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.data_ != nullptr) {
    delete _impl_.data_;
  }
  _impl_.data_ = nullptr;
}
inline const ::clarifai::api::Data& Output::_internal_data() const {
  const ::clarifai::api::Data* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Data&>(
      ::clarifai::api::_Data_default_instance_);
}
inline const ::clarifai::api::Data& Output::data() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Output.data)
  return _internal_data();
}
inline void Output::unsafe_arena_set_allocated_data(
    ::clarifai::api::Data* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Output.data)
}
inline ::clarifai::api::Data* Output::release_data() {
  
  ::clarifai::api::Data* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Data* Output::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:clarifai.api.Output.data)
  
  ::clarifai::api::Data* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::clarifai::api::Data* Output::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Data>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::clarifai::api::Data* Output::mutable_data() {
  ::clarifai::api::Data* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Output.data)
  return _msg;
}
inline void Output::set_allocated_data(::clarifai::api::Data* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Output.data)
}

// -------------------------------------------------------------------

// ScopeDeps

// string scope = 1;
inline void ScopeDeps::clear_scope() {
  _impl_.scope_.ClearToEmpty();
}
inline const std::string& ScopeDeps::scope() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ScopeDeps.scope)
  return _internal_scope();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ScopeDeps::set_scope(ArgT0&& arg0, ArgT... args) {
 
 _impl_.scope_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ScopeDeps.scope)
}
inline std::string* ScopeDeps::mutable_scope() {
  std::string* _s = _internal_mutable_scope();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ScopeDeps.scope)
  return _s;
}
inline const std::string& ScopeDeps::_internal_scope() const {
  return _impl_.scope_.Get();
}
inline void ScopeDeps::_internal_set_scope(const std::string& value) {
  
  _impl_.scope_.Set(value, GetArenaForAllocation());
}
inline std::string* ScopeDeps::_internal_mutable_scope() {
  
  return _impl_.scope_.Mutable(GetArenaForAllocation());
}
inline std::string* ScopeDeps::release_scope() {
  // @@protoc_insertion_point(field_release:clarifai.api.ScopeDeps.scope)
  return _impl_.scope_.Release();
}
inline void ScopeDeps::set_allocated_scope(std::string* scope) {
  if (scope != nullptr) {
    
  } else {
    
  }
  _impl_.scope_.SetAllocated(scope, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.scope_.IsDefault()) {
    _impl_.scope_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ScopeDeps.scope)
}

// repeated string depending_scopes = 2;
inline int ScopeDeps::_internal_depending_scopes_size() const {
  return _impl_.depending_scopes_.size();
}
inline int ScopeDeps::depending_scopes_size() const {
  return _internal_depending_scopes_size();
}
inline void ScopeDeps::clear_depending_scopes() {
  _impl_.depending_scopes_.Clear();
}
inline std::string* ScopeDeps::add_depending_scopes() {
  std::string* _s = _internal_add_depending_scopes();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.ScopeDeps.depending_scopes)
  return _s;
}
inline const std::string& ScopeDeps::_internal_depending_scopes(int index) const {
  return _impl_.depending_scopes_.Get(index);
}
inline const std::string& ScopeDeps::depending_scopes(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.ScopeDeps.depending_scopes)
  return _internal_depending_scopes(index);
}
inline std::string* ScopeDeps::mutable_depending_scopes(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.ScopeDeps.depending_scopes)
  return _impl_.depending_scopes_.Mutable(index);
}
inline void ScopeDeps::set_depending_scopes(int index, const std::string& value) {
  _impl_.depending_scopes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.ScopeDeps.depending_scopes)
}
inline void ScopeDeps::set_depending_scopes(int index, std::string&& value) {
  _impl_.depending_scopes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.ScopeDeps.depending_scopes)
}
inline void ScopeDeps::set_depending_scopes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.depending_scopes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.ScopeDeps.depending_scopes)
}
inline void ScopeDeps::set_depending_scopes(int index, const char* value, size_t size) {
  _impl_.depending_scopes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.ScopeDeps.depending_scopes)
}
inline std::string* ScopeDeps::_internal_add_depending_scopes() {
  return _impl_.depending_scopes_.Add();
}
inline void ScopeDeps::add_depending_scopes(const std::string& value) {
  _impl_.depending_scopes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.ScopeDeps.depending_scopes)
}
inline void ScopeDeps::add_depending_scopes(std::string&& value) {
  _impl_.depending_scopes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.ScopeDeps.depending_scopes)
}
inline void ScopeDeps::add_depending_scopes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.depending_scopes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.ScopeDeps.depending_scopes)
}
inline void ScopeDeps::add_depending_scopes(const char* value, size_t size) {
  _impl_.depending_scopes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.ScopeDeps.depending_scopes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ScopeDeps::depending_scopes() const {
  // @@protoc_insertion_point(field_list:clarifai.api.ScopeDeps.depending_scopes)
  return _impl_.depending_scopes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ScopeDeps::mutable_depending_scopes() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.ScopeDeps.depending_scopes)
  return &_impl_.depending_scopes_;
}

// -------------------------------------------------------------------

// EndpointDeps

// string endpoint = 1;
inline void EndpointDeps::clear_endpoint() {
  _impl_.endpoint_.ClearToEmpty();
}
inline const std::string& EndpointDeps::endpoint() const {
  // @@protoc_insertion_point(field_get:clarifai.api.EndpointDeps.endpoint)
  return _internal_endpoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EndpointDeps::set_endpoint(ArgT0&& arg0, ArgT... args) {
 
 _impl_.endpoint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.EndpointDeps.endpoint)
}
inline std::string* EndpointDeps::mutable_endpoint() {
  std::string* _s = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:clarifai.api.EndpointDeps.endpoint)
  return _s;
}
inline const std::string& EndpointDeps::_internal_endpoint() const {
  return _impl_.endpoint_.Get();
}
inline void EndpointDeps::_internal_set_endpoint(const std::string& value) {
  
  _impl_.endpoint_.Set(value, GetArenaForAllocation());
}
inline std::string* EndpointDeps::_internal_mutable_endpoint() {
  
  return _impl_.endpoint_.Mutable(GetArenaForAllocation());
}
inline std::string* EndpointDeps::release_endpoint() {
  // @@protoc_insertion_point(field_release:clarifai.api.EndpointDeps.endpoint)
  return _impl_.endpoint_.Release();
}
inline void EndpointDeps::set_allocated_endpoint(std::string* endpoint) {
  if (endpoint != nullptr) {
    
  } else {
    
  }
  _impl_.endpoint_.SetAllocated(endpoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.endpoint_.IsDefault()) {
    _impl_.endpoint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.EndpointDeps.endpoint)
}

// repeated string depending_scopes = 2;
inline int EndpointDeps::_internal_depending_scopes_size() const {
  return _impl_.depending_scopes_.size();
}
inline int EndpointDeps::depending_scopes_size() const {
  return _internal_depending_scopes_size();
}
inline void EndpointDeps::clear_depending_scopes() {
  _impl_.depending_scopes_.Clear();
}
inline std::string* EndpointDeps::add_depending_scopes() {
  std::string* _s = _internal_add_depending_scopes();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.EndpointDeps.depending_scopes)
  return _s;
}
inline const std::string& EndpointDeps::_internal_depending_scopes(int index) const {
  return _impl_.depending_scopes_.Get(index);
}
inline const std::string& EndpointDeps::depending_scopes(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.EndpointDeps.depending_scopes)
  return _internal_depending_scopes(index);
}
inline std::string* EndpointDeps::mutable_depending_scopes(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.EndpointDeps.depending_scopes)
  return _impl_.depending_scopes_.Mutable(index);
}
inline void EndpointDeps::set_depending_scopes(int index, const std::string& value) {
  _impl_.depending_scopes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.EndpointDeps.depending_scopes)
}
inline void EndpointDeps::set_depending_scopes(int index, std::string&& value) {
  _impl_.depending_scopes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.EndpointDeps.depending_scopes)
}
inline void EndpointDeps::set_depending_scopes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.depending_scopes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.EndpointDeps.depending_scopes)
}
inline void EndpointDeps::set_depending_scopes(int index, const char* value, size_t size) {
  _impl_.depending_scopes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.EndpointDeps.depending_scopes)
}
inline std::string* EndpointDeps::_internal_add_depending_scopes() {
  return _impl_.depending_scopes_.Add();
}
inline void EndpointDeps::add_depending_scopes(const std::string& value) {
  _impl_.depending_scopes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.EndpointDeps.depending_scopes)
}
inline void EndpointDeps::add_depending_scopes(std::string&& value) {
  _impl_.depending_scopes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.EndpointDeps.depending_scopes)
}
inline void EndpointDeps::add_depending_scopes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.depending_scopes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.EndpointDeps.depending_scopes)
}
inline void EndpointDeps::add_depending_scopes(const char* value, size_t size) {
  _impl_.depending_scopes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.EndpointDeps.depending_scopes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
EndpointDeps::depending_scopes() const {
  // @@protoc_insertion_point(field_list:clarifai.api.EndpointDeps.depending_scopes)
  return _impl_.depending_scopes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
EndpointDeps::mutable_depending_scopes() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.EndpointDeps.depending_scopes)
  return &_impl_.depending_scopes_;
}

// -------------------------------------------------------------------

// Hit

// float score = 1 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void Hit::clear_score() {
  _impl_.score_ = 0;
}
inline float Hit::_internal_score() const {
  return _impl_.score_;
}
inline float Hit::score() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Hit.score)
  return _internal_score();
}
inline void Hit::_internal_set_score(float value) {
  
  _impl_.score_ = value;
}
inline void Hit::set_score(float value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Hit.score)
}

// .clarifai.api.Input input = 2;
inline bool Hit::_internal_has_input() const {
  return this != internal_default_instance() && _impl_.input_ != nullptr;
}
inline bool Hit::has_input() const {
  return _internal_has_input();
}
inline void Hit::clear_input() {
  if (GetArenaForAllocation() == nullptr && _impl_.input_ != nullptr) {
    delete _impl_.input_;
  }
  _impl_.input_ = nullptr;
}
inline const ::clarifai::api::Input& Hit::_internal_input() const {
  const ::clarifai::api::Input* p = _impl_.input_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Input&>(
      ::clarifai::api::_Input_default_instance_);
}
inline const ::clarifai::api::Input& Hit::input() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Hit.input)
  return _internal_input();
}
inline void Hit::unsafe_arena_set_allocated_input(
    ::clarifai::api::Input* input) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.input_);
  }
  _impl_.input_ = input;
  if (input) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Hit.input)
}
inline ::clarifai::api::Input* Hit::release_input() {
  
  ::clarifai::api::Input* temp = _impl_.input_;
  _impl_.input_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Input* Hit::unsafe_arena_release_input() {
  // @@protoc_insertion_point(field_release:clarifai.api.Hit.input)
  
  ::clarifai::api::Input* temp = _impl_.input_;
  _impl_.input_ = nullptr;
  return temp;
}
inline ::clarifai::api::Input* Hit::_internal_mutable_input() {
  
  if (_impl_.input_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Input>(GetArenaForAllocation());
    _impl_.input_ = p;
  }
  return _impl_.input_;
}
inline ::clarifai::api::Input* Hit::mutable_input() {
  ::clarifai::api::Input* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Hit.input)
  return _msg;
}
inline void Hit::set_allocated_input(::clarifai::api::Input* input) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.input_;
  }
  if (input) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(input);
    if (message_arena != submessage_arena) {
      input = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.input_ = input;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Hit.input)
}

// .clarifai.api.Annotation annotation = 3;
inline bool Hit::_internal_has_annotation() const {
  return this != internal_default_instance() && _impl_.annotation_ != nullptr;
}
inline bool Hit::has_annotation() const {
  return _internal_has_annotation();
}
inline void Hit::clear_annotation() {
  if (GetArenaForAllocation() == nullptr && _impl_.annotation_ != nullptr) {
    delete _impl_.annotation_;
  }
  _impl_.annotation_ = nullptr;
}
inline const ::clarifai::api::Annotation& Hit::_internal_annotation() const {
  const ::clarifai::api::Annotation* p = _impl_.annotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Annotation&>(
      ::clarifai::api::_Annotation_default_instance_);
}
inline const ::clarifai::api::Annotation& Hit::annotation() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Hit.annotation)
  return _internal_annotation();
}
inline void Hit::unsafe_arena_set_allocated_annotation(
    ::clarifai::api::Annotation* annotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.annotation_);
  }
  _impl_.annotation_ = annotation;
  if (annotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Hit.annotation)
}
inline ::clarifai::api::Annotation* Hit::release_annotation() {
  
  ::clarifai::api::Annotation* temp = _impl_.annotation_;
  _impl_.annotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Annotation* Hit::unsafe_arena_release_annotation() {
  // @@protoc_insertion_point(field_release:clarifai.api.Hit.annotation)
  
  ::clarifai::api::Annotation* temp = _impl_.annotation_;
  _impl_.annotation_ = nullptr;
  return temp;
}
inline ::clarifai::api::Annotation* Hit::_internal_mutable_annotation() {
  
  if (_impl_.annotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Annotation>(GetArenaForAllocation());
    _impl_.annotation_ = p;
  }
  return _impl_.annotation_;
}
inline ::clarifai::api::Annotation* Hit::mutable_annotation() {
  ::clarifai::api::Annotation* _msg = _internal_mutable_annotation();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Hit.annotation)
  return _msg;
}
inline void Hit::set_allocated_annotation(::clarifai::api::Annotation* annotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.annotation_;
  }
  if (annotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(annotation);
    if (message_arena != submessage_arena) {
      annotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, annotation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.annotation_ = annotation;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Hit.annotation)
}

// string user_id = 4;
inline void Hit::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& Hit::user_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Hit.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Hit::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Hit.user_id)
}
inline std::string* Hit::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Hit.user_id)
  return _s;
}
inline const std::string& Hit::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void Hit::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Hit::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Hit::release_user_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Hit.user_id)
  return _impl_.user_id_.Release();
}
inline void Hit::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Hit.user_id)
}

// string app_id = 5;
inline void Hit::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& Hit::app_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Hit.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Hit::set_app_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.app_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Hit.app_id)
}
inline std::string* Hit::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Hit.app_id)
  return _s;
}
inline const std::string& Hit::_internal_app_id() const {
  return _impl_.app_id_.Get();
}
inline void Hit::_internal_set_app_id(const std::string& value) {
  
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Hit::_internal_mutable_app_id() {
  
  return _impl_.app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Hit::release_app_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Hit.app_id)
  return _impl_.app_id_.Release();
}
inline void Hit::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    
  } else {
    
  }
  _impl_.app_id_.SetAllocated(app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Hit.app_id)
}

// -------------------------------------------------------------------

// And

// .clarifai.api.Input input = 1;
inline bool And::_internal_has_input() const {
  return this != internal_default_instance() && _impl_.input_ != nullptr;
}
inline bool And::has_input() const {
  return _internal_has_input();
}
inline void And::clear_input() {
  if (GetArenaForAllocation() == nullptr && _impl_.input_ != nullptr) {
    delete _impl_.input_;
  }
  _impl_.input_ = nullptr;
}
inline const ::clarifai::api::Input& And::_internal_input() const {
  const ::clarifai::api::Input* p = _impl_.input_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Input&>(
      ::clarifai::api::_Input_default_instance_);
}
inline const ::clarifai::api::Input& And::input() const {
  // @@protoc_insertion_point(field_get:clarifai.api.And.input)
  return _internal_input();
}
inline void And::unsafe_arena_set_allocated_input(
    ::clarifai::api::Input* input) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.input_);
  }
  _impl_.input_ = input;
  if (input) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.And.input)
}
inline ::clarifai::api::Input* And::release_input() {
  
  ::clarifai::api::Input* temp = _impl_.input_;
  _impl_.input_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Input* And::unsafe_arena_release_input() {
  // @@protoc_insertion_point(field_release:clarifai.api.And.input)
  
  ::clarifai::api::Input* temp = _impl_.input_;
  _impl_.input_ = nullptr;
  return temp;
}
inline ::clarifai::api::Input* And::_internal_mutable_input() {
  
  if (_impl_.input_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Input>(GetArenaForAllocation());
    _impl_.input_ = p;
  }
  return _impl_.input_;
}
inline ::clarifai::api::Input* And::mutable_input() {
  ::clarifai::api::Input* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:clarifai.api.And.input)
  return _msg;
}
inline void And::set_allocated_input(::clarifai::api::Input* input) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.input_;
  }
  if (input) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(input);
    if (message_arena != submessage_arena) {
      input = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.input_ = input;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.And.input)
}

// .clarifai.api.Output output = 2;
inline bool And::_internal_has_output() const {
  return this != internal_default_instance() && _impl_.output_ != nullptr;
}
inline bool And::has_output() const {
  return _internal_has_output();
}
inline void And::clear_output() {
  if (GetArenaForAllocation() == nullptr && _impl_.output_ != nullptr) {
    delete _impl_.output_;
  }
  _impl_.output_ = nullptr;
}
inline const ::clarifai::api::Output& And::_internal_output() const {
  const ::clarifai::api::Output* p = _impl_.output_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Output&>(
      ::clarifai::api::_Output_default_instance_);
}
inline const ::clarifai::api::Output& And::output() const {
  // @@protoc_insertion_point(field_get:clarifai.api.And.output)
  return _internal_output();
}
inline void And::unsafe_arena_set_allocated_output(
    ::clarifai::api::Output* output) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.output_);
  }
  _impl_.output_ = output;
  if (output) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.And.output)
}
inline ::clarifai::api::Output* And::release_output() {
  
  ::clarifai::api::Output* temp = _impl_.output_;
  _impl_.output_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Output* And::unsafe_arena_release_output() {
  // @@protoc_insertion_point(field_release:clarifai.api.And.output)
  
  ::clarifai::api::Output* temp = _impl_.output_;
  _impl_.output_ = nullptr;
  return temp;
}
inline ::clarifai::api::Output* And::_internal_mutable_output() {
  
  if (_impl_.output_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Output>(GetArenaForAllocation());
    _impl_.output_ = p;
  }
  return _impl_.output_;
}
inline ::clarifai::api::Output* And::mutable_output() {
  ::clarifai::api::Output* _msg = _internal_mutable_output();
  // @@protoc_insertion_point(field_mutable:clarifai.api.And.output)
  return _msg;
}
inline void And::set_allocated_output(::clarifai::api::Output* output) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.output_;
  }
  if (output) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(output);
    if (message_arena != submessage_arena) {
      output = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, output, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.output_ = output;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.And.output)
}

// bool negate = 3;
inline void And::clear_negate() {
  _impl_.negate_ = false;
}
inline bool And::_internal_negate() const {
  return _impl_.negate_;
}
inline bool And::negate() const {
  // @@protoc_insertion_point(field_get:clarifai.api.And.negate)
  return _internal_negate();
}
inline void And::_internal_set_negate(bool value) {
  
  _impl_.negate_ = value;
}
inline void And::set_negate(bool value) {
  _internal_set_negate(value);
  // @@protoc_insertion_point(field_set:clarifai.api.And.negate)
}

// .clarifai.api.Annotation annotation = 4;
inline bool And::_internal_has_annotation() const {
  return this != internal_default_instance() && _impl_.annotation_ != nullptr;
}
inline bool And::has_annotation() const {
  return _internal_has_annotation();
}
inline void And::clear_annotation() {
  if (GetArenaForAllocation() == nullptr && _impl_.annotation_ != nullptr) {
    delete _impl_.annotation_;
  }
  _impl_.annotation_ = nullptr;
}
inline const ::clarifai::api::Annotation& And::_internal_annotation() const {
  const ::clarifai::api::Annotation* p = _impl_.annotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Annotation&>(
      ::clarifai::api::_Annotation_default_instance_);
}
inline const ::clarifai::api::Annotation& And::annotation() const {
  // @@protoc_insertion_point(field_get:clarifai.api.And.annotation)
  return _internal_annotation();
}
inline void And::unsafe_arena_set_allocated_annotation(
    ::clarifai::api::Annotation* annotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.annotation_);
  }
  _impl_.annotation_ = annotation;
  if (annotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.And.annotation)
}
inline ::clarifai::api::Annotation* And::release_annotation() {
  
  ::clarifai::api::Annotation* temp = _impl_.annotation_;
  _impl_.annotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Annotation* And::unsafe_arena_release_annotation() {
  // @@protoc_insertion_point(field_release:clarifai.api.And.annotation)
  
  ::clarifai::api::Annotation* temp = _impl_.annotation_;
  _impl_.annotation_ = nullptr;
  return temp;
}
inline ::clarifai::api::Annotation* And::_internal_mutable_annotation() {
  
  if (_impl_.annotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Annotation>(GetArenaForAllocation());
    _impl_.annotation_ = p;
  }
  return _impl_.annotation_;
}
inline ::clarifai::api::Annotation* And::mutable_annotation() {
  ::clarifai::api::Annotation* _msg = _internal_mutable_annotation();
  // @@protoc_insertion_point(field_mutable:clarifai.api.And.annotation)
  return _msg;
}
inline void And::set_allocated_annotation(::clarifai::api::Annotation* annotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.annotation_;
  }
  if (annotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(annotation);
    if (message_arena != submessage_arena) {
      annotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, annotation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.annotation_ = annotation;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.And.annotation)
}

// -------------------------------------------------------------------

// Query

// repeated .clarifai.api.And ands = 1 [deprecated = true];
inline int Query::_internal_ands_size() const {
  return _impl_.ands_.size();
}
inline int Query::ands_size() const {
  return _internal_ands_size();
}
inline void Query::clear_ands() {
  _impl_.ands_.Clear();
}
inline ::clarifai::api::And* Query::mutable_ands(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Query.ands)
  return _impl_.ands_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::And >*
Query::mutable_ands() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Query.ands)
  return &_impl_.ands_;
}
inline const ::clarifai::api::And& Query::_internal_ands(int index) const {
  return _impl_.ands_.Get(index);
}
inline const ::clarifai::api::And& Query::ands(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Query.ands)
  return _internal_ands(index);
}
inline ::clarifai::api::And* Query::_internal_add_ands() {
  return _impl_.ands_.Add();
}
inline ::clarifai::api::And* Query::add_ands() {
  ::clarifai::api::And* _add = _internal_add_ands();
  // @@protoc_insertion_point(field_add:clarifai.api.Query.ands)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::And >&
Query::ands() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Query.ands)
  return _impl_.ands_;
}

// string language = 2;
inline void Query::clear_language() {
  _impl_.language_.ClearToEmpty();
}
inline const std::string& Query::language() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Query.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Query::set_language(ArgT0&& arg0, ArgT... args) {
 
 _impl_.language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Query.language)
}
inline std::string* Query::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Query.language)
  return _s;
}
inline const std::string& Query::_internal_language() const {
  return _impl_.language_.Get();
}
inline void Query::_internal_set_language(const std::string& value) {
  
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* Query::_internal_mutable_language() {
  
  return _impl_.language_.Mutable(GetArenaForAllocation());
}
inline std::string* Query::release_language() {
  // @@protoc_insertion_point(field_release:clarifai.api.Query.language)
  return _impl_.language_.Release();
}
inline void Query::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    
  } else {
    
  }
  _impl_.language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Query.language)
}

// repeated .clarifai.api.Filter filters = 3;
inline int Query::_internal_filters_size() const {
  return _impl_.filters_.size();
}
inline int Query::filters_size() const {
  return _internal_filters_size();
}
inline void Query::clear_filters() {
  _impl_.filters_.Clear();
}
inline ::clarifai::api::Filter* Query::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Query.filters)
  return _impl_.filters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Filter >*
Query::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Query.filters)
  return &_impl_.filters_;
}
inline const ::clarifai::api::Filter& Query::_internal_filters(int index) const {
  return _impl_.filters_.Get(index);
}
inline const ::clarifai::api::Filter& Query::filters(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Query.filters)
  return _internal_filters(index);
}
inline ::clarifai::api::Filter* Query::_internal_add_filters() {
  return _impl_.filters_.Add();
}
inline ::clarifai::api::Filter* Query::add_filters() {
  ::clarifai::api::Filter* _add = _internal_add_filters();
  // @@protoc_insertion_point(field_add:clarifai.api.Query.filters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Filter >&
Query::filters() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Query.filters)
  return _impl_.filters_;
}

// repeated .clarifai.api.Rank ranks = 4;
inline int Query::_internal_ranks_size() const {
  return _impl_.ranks_.size();
}
inline int Query::ranks_size() const {
  return _internal_ranks_size();
}
inline void Query::clear_ranks() {
  _impl_.ranks_.Clear();
}
inline ::clarifai::api::Rank* Query::mutable_ranks(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Query.ranks)
  return _impl_.ranks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Rank >*
Query::mutable_ranks() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Query.ranks)
  return &_impl_.ranks_;
}
inline const ::clarifai::api::Rank& Query::_internal_ranks(int index) const {
  return _impl_.ranks_.Get(index);
}
inline const ::clarifai::api::Rank& Query::ranks(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Query.ranks)
  return _internal_ranks(index);
}
inline ::clarifai::api::Rank* Query::_internal_add_ranks() {
  return _impl_.ranks_.Add();
}
inline ::clarifai::api::Rank* Query::add_ranks() {
  ::clarifai::api::Rank* _add = _internal_add_ranks();
  // @@protoc_insertion_point(field_add:clarifai.api.Query.ranks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Rank >&
Query::ranks() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Query.ranks)
  return _impl_.ranks_;
}

// -------------------------------------------------------------------

// Search

// .clarifai.api.Query query = 1;
inline bool Search::_internal_has_query() const {
  return this != internal_default_instance() && _impl_.query_ != nullptr;
}
inline bool Search::has_query() const {
  return _internal_has_query();
}
inline void Search::clear_query() {
  if (GetArenaForAllocation() == nullptr && _impl_.query_ != nullptr) {
    delete _impl_.query_;
  }
  _impl_.query_ = nullptr;
}
inline const ::clarifai::api::Query& Search::_internal_query() const {
  const ::clarifai::api::Query* p = _impl_.query_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Query&>(
      ::clarifai::api::_Query_default_instance_);
}
inline const ::clarifai::api::Query& Search::query() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Search.query)
  return _internal_query();
}
inline void Search::unsafe_arena_set_allocated_query(
    ::clarifai::api::Query* query) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_);
  }
  _impl_.query_ = query;
  if (query) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Search.query)
}
inline ::clarifai::api::Query* Search::release_query() {
  
  ::clarifai::api::Query* temp = _impl_.query_;
  _impl_.query_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Query* Search::unsafe_arena_release_query() {
  // @@protoc_insertion_point(field_release:clarifai.api.Search.query)
  
  ::clarifai::api::Query* temp = _impl_.query_;
  _impl_.query_ = nullptr;
  return temp;
}
inline ::clarifai::api::Query* Search::_internal_mutable_query() {
  
  if (_impl_.query_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Query>(GetArenaForAllocation());
    _impl_.query_ = p;
  }
  return _impl_.query_;
}
inline ::clarifai::api::Query* Search::mutable_query() {
  ::clarifai::api::Query* _msg = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Search.query)
  return _msg;
}
inline void Search::set_allocated_query(::clarifai::api::Query* query) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.query_;
  }
  if (query) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(query);
    if (message_arena != submessage_arena) {
      query = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.query_ = query;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Search.query)
}

// string id = 2;
inline void Search::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Search::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Search.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Search::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Search.id)
}
inline std::string* Search::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Search.id)
  return _s;
}
inline const std::string& Search::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Search::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Search::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Search::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Search.id)
  return _impl_.id_.Release();
}
inline void Search::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Search.id)
}

// string application_id = 3;
inline void Search::clear_application_id() {
  _impl_.application_id_.ClearToEmpty();
}
inline const std::string& Search::application_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Search.application_id)
  return _internal_application_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Search::set_application_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.application_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Search.application_id)
}
inline std::string* Search::mutable_application_id() {
  std::string* _s = _internal_mutable_application_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Search.application_id)
  return _s;
}
inline const std::string& Search::_internal_application_id() const {
  return _impl_.application_id_.Get();
}
inline void Search::_internal_set_application_id(const std::string& value) {
  
  _impl_.application_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Search::_internal_mutable_application_id() {
  
  return _impl_.application_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Search::release_application_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Search.application_id)
  return _impl_.application_id_.Release();
}
inline void Search::set_allocated_application_id(std::string* application_id) {
  if (application_id != nullptr) {
    
  } else {
    
  }
  _impl_.application_id_.SetAllocated(application_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.application_id_.IsDefault()) {
    _impl_.application_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Search.application_id)
}

// string name = 4;
inline void Search::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Search::name() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Search.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Search::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Search.name)
}
inline std::string* Search::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Search.name)
  return _s;
}
inline const std::string& Search::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Search::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Search::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Search::release_name() {
  // @@protoc_insertion_point(field_release:clarifai.api.Search.name)
  return _impl_.name_.Release();
}
inline void Search::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Search.name)
}

// .google.protobuf.Timestamp as_of = 5;
inline bool Search::_internal_has_as_of() const {
  return this != internal_default_instance() && _impl_.as_of_ != nullptr;
}
inline bool Search::has_as_of() const {
  return _internal_has_as_of();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Search::_internal_as_of() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.as_of_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Search::as_of() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Search.as_of)
  return _internal_as_of();
}
inline void Search::unsafe_arena_set_allocated_as_of(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* as_of) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.as_of_);
  }
  _impl_.as_of_ = as_of;
  if (as_of) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Search.as_of)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Search::release_as_of() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.as_of_;
  _impl_.as_of_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Search::unsafe_arena_release_as_of() {
  // @@protoc_insertion_point(field_release:clarifai.api.Search.as_of)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.as_of_;
  _impl_.as_of_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Search::_internal_mutable_as_of() {
  
  if (_impl_.as_of_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.as_of_ = p;
  }
  return _impl_.as_of_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Search::mutable_as_of() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_as_of();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Search.as_of)
  return _msg;
}
inline void Search::set_allocated_as_of(::PROTOBUF_NAMESPACE_ID::Timestamp* as_of) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.as_of_);
  }
  if (as_of) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(as_of));
    if (message_arena != submessage_arena) {
      as_of = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, as_of, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.as_of_ = as_of;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Search.as_of)
}

// string git_hash = 6;
inline void Search::clear_git_hash() {
  _impl_.git_hash_.ClearToEmpty();
}
inline const std::string& Search::git_hash() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Search.git_hash)
  return _internal_git_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Search::set_git_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.git_hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Search.git_hash)
}
inline std::string* Search::mutable_git_hash() {
  std::string* _s = _internal_mutable_git_hash();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Search.git_hash)
  return _s;
}
inline const std::string& Search::_internal_git_hash() const {
  return _impl_.git_hash_.Get();
}
inline void Search::_internal_set_git_hash(const std::string& value) {
  
  _impl_.git_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* Search::_internal_mutable_git_hash() {
  
  return _impl_.git_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* Search::release_git_hash() {
  // @@protoc_insertion_point(field_release:clarifai.api.Search.git_hash)
  return _impl_.git_hash_.Release();
}
inline void Search::set_allocated_git_hash(std::string* git_hash) {
  if (git_hash != nullptr) {
    
  } else {
    
  }
  _impl_.git_hash_.SetAllocated(git_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.git_hash_.IsDefault()) {
    _impl_.git_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Search.git_hash)
}

// .google.protobuf.Timestamp created_at = 7;
inline bool Search::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool Search::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Search::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Search::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Search.created_at)
  return _internal_created_at();
}
inline void Search::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Search.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Search::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Search::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.Search.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Search::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Search::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Search.created_at)
  return _msg;
}
inline void Search::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Search.created_at)
}

// .google.protobuf.Timestamp modified_at = 8;
inline bool Search::_internal_has_modified_at() const {
  return this != internal_default_instance() && _impl_.modified_at_ != nullptr;
}
inline bool Search::has_modified_at() const {
  return _internal_has_modified_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Search::_internal_modified_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.modified_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Search::modified_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Search.modified_at)
  return _internal_modified_at();
}
inline void Search::unsafe_arena_set_allocated_modified_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  _impl_.modified_at_ = modified_at;
  if (modified_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Search.modified_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Search::release_modified_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Search::unsafe_arena_release_modified_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.Search.modified_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Search::_internal_mutable_modified_at() {
  
  if (_impl_.modified_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.modified_at_ = p;
  }
  return _impl_.modified_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Search::mutable_modified_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_modified_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Search.modified_at)
  return _msg;
}
inline void Search::set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  if (modified_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(modified_at));
    if (message_arena != submessage_arena) {
      modified_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modified_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.modified_at_ = modified_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Search.modified_at)
}

// string algorithm = 9;
inline void Search::clear_algorithm() {
  _impl_.algorithm_.ClearToEmpty();
}
inline const std::string& Search::algorithm() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Search.algorithm)
  return _internal_algorithm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Search::set_algorithm(ArgT0&& arg0, ArgT... args) {
 
 _impl_.algorithm_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Search.algorithm)
}
inline std::string* Search::mutable_algorithm() {
  std::string* _s = _internal_mutable_algorithm();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Search.algorithm)
  return _s;
}
inline const std::string& Search::_internal_algorithm() const {
  return _impl_.algorithm_.Get();
}
inline void Search::_internal_set_algorithm(const std::string& value) {
  
  _impl_.algorithm_.Set(value, GetArenaForAllocation());
}
inline std::string* Search::_internal_mutable_algorithm() {
  
  return _impl_.algorithm_.Mutable(GetArenaForAllocation());
}
inline std::string* Search::release_algorithm() {
  // @@protoc_insertion_point(field_release:clarifai.api.Search.algorithm)
  return _impl_.algorithm_.Release();
}
inline void Search::set_allocated_algorithm(std::string* algorithm) {
  if (algorithm != nullptr) {
    
  } else {
    
  }
  _impl_.algorithm_.SetAllocated(algorithm, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.algorithm_.IsDefault()) {
    _impl_.algorithm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Search.algorithm)
}

// bool save = 10;
inline void Search::clear_save() {
  _impl_.save_ = false;
}
inline bool Search::_internal_save() const {
  return _impl_.save_;
}
inline bool Search::save() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Search.save)
  return _internal_save();
}
inline void Search::_internal_set_save(bool value) {
  
  _impl_.save_ = value;
}
inline void Search::set_save(bool value) {
  _internal_set_save(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Search.save)
}

// float min_value = 11;
inline void Search::clear_min_value() {
  _impl_.min_value_ = 0;
}
inline float Search::_internal_min_value() const {
  return _impl_.min_value_;
}
inline float Search::min_value() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Search.min_value)
  return _internal_min_value();
}
inline void Search::_internal_set_min_value(float value) {
  
  _impl_.min_value_ = value;
}
inline void Search::set_min_value(float value) {
  _internal_set_min_value(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Search.min_value)
}

// .clarifai.api.Visibility visibility = 12;
inline bool Search::_internal_has_visibility() const {
  return this != internal_default_instance() && _impl_.visibility_ != nullptr;
}
inline bool Search::has_visibility() const {
  return _internal_has_visibility();
}
inline void Search::clear_visibility() {
  if (GetArenaForAllocation() == nullptr && _impl_.visibility_ != nullptr) {
    delete _impl_.visibility_;
  }
  _impl_.visibility_ = nullptr;
}
inline const ::clarifai::api::Visibility& Search::_internal_visibility() const {
  const ::clarifai::api::Visibility* p = _impl_.visibility_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Visibility&>(
      ::clarifai::api::_Visibility_default_instance_);
}
inline const ::clarifai::api::Visibility& Search::visibility() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Search.visibility)
  return _internal_visibility();
}
inline void Search::unsafe_arena_set_allocated_visibility(
    ::clarifai::api::Visibility* visibility) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visibility_);
  }
  _impl_.visibility_ = visibility;
  if (visibility) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Search.visibility)
}
inline ::clarifai::api::Visibility* Search::release_visibility() {
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Visibility* Search::unsafe_arena_release_visibility() {
  // @@protoc_insertion_point(field_release:clarifai.api.Search.visibility)
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
  return temp;
}
inline ::clarifai::api::Visibility* Search::_internal_mutable_visibility() {
  
  if (_impl_.visibility_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Visibility>(GetArenaForAllocation());
    _impl_.visibility_ = p;
  }
  return _impl_.visibility_;
}
inline ::clarifai::api::Visibility* Search::mutable_visibility() {
  ::clarifai::api::Visibility* _msg = _internal_mutable_visibility();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Search.visibility)
  return _msg;
}
inline void Search::set_allocated_visibility(::clarifai::api::Visibility* visibility) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.visibility_;
  }
  if (visibility) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(visibility);
    if (message_arena != submessage_arena) {
      visibility = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visibility, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.visibility_ = visibility;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Search.visibility)
}

// -------------------------------------------------------------------

// Filter

// bool negate = 3;
inline void Filter::clear_negate() {
  _impl_.negate_ = false;
}
inline bool Filter::_internal_negate() const {
  return _impl_.negate_;
}
inline bool Filter::negate() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Filter.negate)
  return _internal_negate();
}
inline void Filter::_internal_set_negate(bool value) {
  
  _impl_.negate_ = value;
}
inline void Filter::set_negate(bool value) {
  _internal_set_negate(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Filter.negate)
}

// .clarifai.api.Annotation annotation = 4;
inline bool Filter::_internal_has_annotation() const {
  return this != internal_default_instance() && _impl_.annotation_ != nullptr;
}
inline bool Filter::has_annotation() const {
  return _internal_has_annotation();
}
inline void Filter::clear_annotation() {
  if (GetArenaForAllocation() == nullptr && _impl_.annotation_ != nullptr) {
    delete _impl_.annotation_;
  }
  _impl_.annotation_ = nullptr;
}
inline const ::clarifai::api::Annotation& Filter::_internal_annotation() const {
  const ::clarifai::api::Annotation* p = _impl_.annotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Annotation&>(
      ::clarifai::api::_Annotation_default_instance_);
}
inline const ::clarifai::api::Annotation& Filter::annotation() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Filter.annotation)
  return _internal_annotation();
}
inline void Filter::unsafe_arena_set_allocated_annotation(
    ::clarifai::api::Annotation* annotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.annotation_);
  }
  _impl_.annotation_ = annotation;
  if (annotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Filter.annotation)
}
inline ::clarifai::api::Annotation* Filter::release_annotation() {
  
  ::clarifai::api::Annotation* temp = _impl_.annotation_;
  _impl_.annotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Annotation* Filter::unsafe_arena_release_annotation() {
  // @@protoc_insertion_point(field_release:clarifai.api.Filter.annotation)
  
  ::clarifai::api::Annotation* temp = _impl_.annotation_;
  _impl_.annotation_ = nullptr;
  return temp;
}
inline ::clarifai::api::Annotation* Filter::_internal_mutable_annotation() {
  
  if (_impl_.annotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Annotation>(GetArenaForAllocation());
    _impl_.annotation_ = p;
  }
  return _impl_.annotation_;
}
inline ::clarifai::api::Annotation* Filter::mutable_annotation() {
  ::clarifai::api::Annotation* _msg = _internal_mutable_annotation();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Filter.annotation)
  return _msg;
}
inline void Filter::set_allocated_annotation(::clarifai::api::Annotation* annotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.annotation_;
  }
  if (annotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(annotation);
    if (message_arena != submessage_arena) {
      annotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, annotation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.annotation_ = annotation;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Filter.annotation)
}

// .clarifai.api.Input input = 5;
inline bool Filter::_internal_has_input() const {
  return this != internal_default_instance() && _impl_.input_ != nullptr;
}
inline bool Filter::has_input() const {
  return _internal_has_input();
}
inline void Filter::clear_input() {
  if (GetArenaForAllocation() == nullptr && _impl_.input_ != nullptr) {
    delete _impl_.input_;
  }
  _impl_.input_ = nullptr;
}
inline const ::clarifai::api::Input& Filter::_internal_input() const {
  const ::clarifai::api::Input* p = _impl_.input_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Input&>(
      ::clarifai::api::_Input_default_instance_);
}
inline const ::clarifai::api::Input& Filter::input() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Filter.input)
  return _internal_input();
}
inline void Filter::unsafe_arena_set_allocated_input(
    ::clarifai::api::Input* input) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.input_);
  }
  _impl_.input_ = input;
  if (input) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Filter.input)
}
inline ::clarifai::api::Input* Filter::release_input() {
  
  ::clarifai::api::Input* temp = _impl_.input_;
  _impl_.input_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Input* Filter::unsafe_arena_release_input() {
  // @@protoc_insertion_point(field_release:clarifai.api.Filter.input)
  
  ::clarifai::api::Input* temp = _impl_.input_;
  _impl_.input_ = nullptr;
  return temp;
}
inline ::clarifai::api::Input* Filter::_internal_mutable_input() {
  
  if (_impl_.input_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Input>(GetArenaForAllocation());
    _impl_.input_ = p;
  }
  return _impl_.input_;
}
inline ::clarifai::api::Input* Filter::mutable_input() {
  ::clarifai::api::Input* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Filter.input)
  return _msg;
}
inline void Filter::set_allocated_input(::clarifai::api::Input* input) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.input_;
  }
  if (input) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(input);
    if (message_arena != submessage_arena) {
      input = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.input_ = input;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Filter.input)
}

// .clarifai.api.TimeRange last_updated_time_range = 6;
inline bool Filter::_internal_has_last_updated_time_range() const {
  return this != internal_default_instance() && _impl_.last_updated_time_range_ != nullptr;
}
inline bool Filter::has_last_updated_time_range() const {
  return _internal_has_last_updated_time_range();
}
inline void Filter::clear_last_updated_time_range() {
  if (GetArenaForAllocation() == nullptr && _impl_.last_updated_time_range_ != nullptr) {
    delete _impl_.last_updated_time_range_;
  }
  _impl_.last_updated_time_range_ = nullptr;
}
inline const ::clarifai::api::TimeRange& Filter::_internal_last_updated_time_range() const {
  const ::clarifai::api::TimeRange* p = _impl_.last_updated_time_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::TimeRange&>(
      ::clarifai::api::_TimeRange_default_instance_);
}
inline const ::clarifai::api::TimeRange& Filter::last_updated_time_range() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Filter.last_updated_time_range)
  return _internal_last_updated_time_range();
}
inline void Filter::unsafe_arena_set_allocated_last_updated_time_range(
    ::clarifai::api::TimeRange* last_updated_time_range) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_updated_time_range_);
  }
  _impl_.last_updated_time_range_ = last_updated_time_range;
  if (last_updated_time_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Filter.last_updated_time_range)
}
inline ::clarifai::api::TimeRange* Filter::release_last_updated_time_range() {
  
  ::clarifai::api::TimeRange* temp = _impl_.last_updated_time_range_;
  _impl_.last_updated_time_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::TimeRange* Filter::unsafe_arena_release_last_updated_time_range() {
  // @@protoc_insertion_point(field_release:clarifai.api.Filter.last_updated_time_range)
  
  ::clarifai::api::TimeRange* temp = _impl_.last_updated_time_range_;
  _impl_.last_updated_time_range_ = nullptr;
  return temp;
}
inline ::clarifai::api::TimeRange* Filter::_internal_mutable_last_updated_time_range() {
  
  if (_impl_.last_updated_time_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::TimeRange>(GetArenaForAllocation());
    _impl_.last_updated_time_range_ = p;
  }
  return _impl_.last_updated_time_range_;
}
inline ::clarifai::api::TimeRange* Filter::mutable_last_updated_time_range() {
  ::clarifai::api::TimeRange* _msg = _internal_mutable_last_updated_time_range();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Filter.last_updated_time_range)
  return _msg;
}
inline void Filter::set_allocated_last_updated_time_range(::clarifai::api::TimeRange* last_updated_time_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.last_updated_time_range_;
  }
  if (last_updated_time_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(last_updated_time_range);
    if (message_arena != submessage_arena) {
      last_updated_time_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_updated_time_range, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_updated_time_range_ = last_updated_time_range;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Filter.last_updated_time_range)
}

// -------------------------------------------------------------------

// TimeRange

// .google.protobuf.Timestamp start_time = 1;
inline bool TimeRange::_internal_has_start_time() const {
  return this != internal_default_instance() && _impl_.start_time_ != nullptr;
}
inline bool TimeRange::has_start_time() const {
  return _internal_has_start_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TimeRange::_internal_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TimeRange::start_time() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TimeRange.start_time)
  return _internal_start_time();
}
inline void TimeRange::unsafe_arena_set_allocated_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.TimeRange.start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TimeRange::release_start_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TimeRange::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:clarifai.api.TimeRange.start_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TimeRange::_internal_mutable_start_time() {
  
  if (_impl_.start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.start_time_ = p;
  }
  return _impl_.start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TimeRange::mutable_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:clarifai.api.TimeRange.start_time)
  return _msg;
}
inline void TimeRange::set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time));
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.TimeRange.start_time)
}

// .google.protobuf.Timestamp end_time = 2;
inline bool TimeRange::_internal_has_end_time() const {
  return this != internal_default_instance() && _impl_.end_time_ != nullptr;
}
inline bool TimeRange::has_end_time() const {
  return _internal_has_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TimeRange::_internal_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TimeRange::end_time() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TimeRange.end_time)
  return _internal_end_time();
}
inline void TimeRange::unsafe_arena_set_allocated_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  _impl_.end_time_ = end_time;
  if (end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.TimeRange.end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TimeRange::release_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TimeRange::unsafe_arena_release_end_time() {
  // @@protoc_insertion_point(field_release:clarifai.api.TimeRange.end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TimeRange::_internal_mutable_end_time() {
  
  if (_impl_.end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.end_time_ = p;
  }
  return _impl_.end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TimeRange::mutable_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:clarifai.api.TimeRange.end_time)
  return _msg;
}
inline void TimeRange::set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  if (end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time));
    if (message_arena != submessage_arena) {
      end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.TimeRange.end_time)
}

// -------------------------------------------------------------------

// Rank

// bool negate = 3;
inline void Rank::clear_negate() {
  _impl_.negate_ = false;
}
inline bool Rank::_internal_negate() const {
  return _impl_.negate_;
}
inline bool Rank::negate() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Rank.negate)
  return _internal_negate();
}
inline void Rank::_internal_set_negate(bool value) {
  
  _impl_.negate_ = value;
}
inline void Rank::set_negate(bool value) {
  _internal_set_negate(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Rank.negate)
}

// .clarifai.api.Annotation annotation = 4;
inline bool Rank::_internal_has_annotation() const {
  return this != internal_default_instance() && _impl_.annotation_ != nullptr;
}
inline bool Rank::has_annotation() const {
  return _internal_has_annotation();
}
inline void Rank::clear_annotation() {
  if (GetArenaForAllocation() == nullptr && _impl_.annotation_ != nullptr) {
    delete _impl_.annotation_;
  }
  _impl_.annotation_ = nullptr;
}
inline const ::clarifai::api::Annotation& Rank::_internal_annotation() const {
  const ::clarifai::api::Annotation* p = _impl_.annotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Annotation&>(
      ::clarifai::api::_Annotation_default_instance_);
}
inline const ::clarifai::api::Annotation& Rank::annotation() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Rank.annotation)
  return _internal_annotation();
}
inline void Rank::unsafe_arena_set_allocated_annotation(
    ::clarifai::api::Annotation* annotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.annotation_);
  }
  _impl_.annotation_ = annotation;
  if (annotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Rank.annotation)
}
inline ::clarifai::api::Annotation* Rank::release_annotation() {
  
  ::clarifai::api::Annotation* temp = _impl_.annotation_;
  _impl_.annotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Annotation* Rank::unsafe_arena_release_annotation() {
  // @@protoc_insertion_point(field_release:clarifai.api.Rank.annotation)
  
  ::clarifai::api::Annotation* temp = _impl_.annotation_;
  _impl_.annotation_ = nullptr;
  return temp;
}
inline ::clarifai::api::Annotation* Rank::_internal_mutable_annotation() {
  
  if (_impl_.annotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Annotation>(GetArenaForAllocation());
    _impl_.annotation_ = p;
  }
  return _impl_.annotation_;
}
inline ::clarifai::api::Annotation* Rank::mutable_annotation() {
  ::clarifai::api::Annotation* _msg = _internal_mutable_annotation();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Rank.annotation)
  return _msg;
}
inline void Rank::set_allocated_annotation(::clarifai::api::Annotation* annotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.annotation_;
  }
  if (annotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(annotation);
    if (message_arena != submessage_arena) {
      annotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, annotation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.annotation_ = annotation;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Rank.annotation)
}

// -------------------------------------------------------------------

// AnnotationSearchMetrics

// .clarifai.api.Search ground_truth = 1;
inline bool AnnotationSearchMetrics::_internal_has_ground_truth() const {
  return this != internal_default_instance() && _impl_.ground_truth_ != nullptr;
}
inline bool AnnotationSearchMetrics::has_ground_truth() const {
  return _internal_has_ground_truth();
}
inline void AnnotationSearchMetrics::clear_ground_truth() {
  if (GetArenaForAllocation() == nullptr && _impl_.ground_truth_ != nullptr) {
    delete _impl_.ground_truth_;
  }
  _impl_.ground_truth_ = nullptr;
}
inline const ::clarifai::api::Search& AnnotationSearchMetrics::_internal_ground_truth() const {
  const ::clarifai::api::Search* p = _impl_.ground_truth_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Search&>(
      ::clarifai::api::_Search_default_instance_);
}
inline const ::clarifai::api::Search& AnnotationSearchMetrics::ground_truth() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AnnotationSearchMetrics.ground_truth)
  return _internal_ground_truth();
}
inline void AnnotationSearchMetrics::unsafe_arena_set_allocated_ground_truth(
    ::clarifai::api::Search* ground_truth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ground_truth_);
  }
  _impl_.ground_truth_ = ground_truth;
  if (ground_truth) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.AnnotationSearchMetrics.ground_truth)
}
inline ::clarifai::api::Search* AnnotationSearchMetrics::release_ground_truth() {
  
  ::clarifai::api::Search* temp = _impl_.ground_truth_;
  _impl_.ground_truth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Search* AnnotationSearchMetrics::unsafe_arena_release_ground_truth() {
  // @@protoc_insertion_point(field_release:clarifai.api.AnnotationSearchMetrics.ground_truth)
  
  ::clarifai::api::Search* temp = _impl_.ground_truth_;
  _impl_.ground_truth_ = nullptr;
  return temp;
}
inline ::clarifai::api::Search* AnnotationSearchMetrics::_internal_mutable_ground_truth() {
  
  if (_impl_.ground_truth_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Search>(GetArenaForAllocation());
    _impl_.ground_truth_ = p;
  }
  return _impl_.ground_truth_;
}
inline ::clarifai::api::Search* AnnotationSearchMetrics::mutable_ground_truth() {
  ::clarifai::api::Search* _msg = _internal_mutable_ground_truth();
  // @@protoc_insertion_point(field_mutable:clarifai.api.AnnotationSearchMetrics.ground_truth)
  return _msg;
}
inline void AnnotationSearchMetrics::set_allocated_ground_truth(::clarifai::api::Search* ground_truth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ground_truth_;
  }
  if (ground_truth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ground_truth);
    if (message_arena != submessage_arena) {
      ground_truth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ground_truth, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ground_truth_ = ground_truth;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.AnnotationSearchMetrics.ground_truth)
}

// .clarifai.api.Search search_to_eval = 2;
inline bool AnnotationSearchMetrics::_internal_has_search_to_eval() const {
  return this != internal_default_instance() && _impl_.search_to_eval_ != nullptr;
}
inline bool AnnotationSearchMetrics::has_search_to_eval() const {
  return _internal_has_search_to_eval();
}
inline void AnnotationSearchMetrics::clear_search_to_eval() {
  if (GetArenaForAllocation() == nullptr && _impl_.search_to_eval_ != nullptr) {
    delete _impl_.search_to_eval_;
  }
  _impl_.search_to_eval_ = nullptr;
}
inline const ::clarifai::api::Search& AnnotationSearchMetrics::_internal_search_to_eval() const {
  const ::clarifai::api::Search* p = _impl_.search_to_eval_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Search&>(
      ::clarifai::api::_Search_default_instance_);
}
inline const ::clarifai::api::Search& AnnotationSearchMetrics::search_to_eval() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AnnotationSearchMetrics.search_to_eval)
  return _internal_search_to_eval();
}
inline void AnnotationSearchMetrics::unsafe_arena_set_allocated_search_to_eval(
    ::clarifai::api::Search* search_to_eval) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.search_to_eval_);
  }
  _impl_.search_to_eval_ = search_to_eval;
  if (search_to_eval) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.AnnotationSearchMetrics.search_to_eval)
}
inline ::clarifai::api::Search* AnnotationSearchMetrics::release_search_to_eval() {
  
  ::clarifai::api::Search* temp = _impl_.search_to_eval_;
  _impl_.search_to_eval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Search* AnnotationSearchMetrics::unsafe_arena_release_search_to_eval() {
  // @@protoc_insertion_point(field_release:clarifai.api.AnnotationSearchMetrics.search_to_eval)
  
  ::clarifai::api::Search* temp = _impl_.search_to_eval_;
  _impl_.search_to_eval_ = nullptr;
  return temp;
}
inline ::clarifai::api::Search* AnnotationSearchMetrics::_internal_mutable_search_to_eval() {
  
  if (_impl_.search_to_eval_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Search>(GetArenaForAllocation());
    _impl_.search_to_eval_ = p;
  }
  return _impl_.search_to_eval_;
}
inline ::clarifai::api::Search* AnnotationSearchMetrics::mutable_search_to_eval() {
  ::clarifai::api::Search* _msg = _internal_mutable_search_to_eval();
  // @@protoc_insertion_point(field_mutable:clarifai.api.AnnotationSearchMetrics.search_to_eval)
  return _msg;
}
inline void AnnotationSearchMetrics::set_allocated_search_to_eval(::clarifai::api::Search* search_to_eval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.search_to_eval_;
  }
  if (search_to_eval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(search_to_eval);
    if (message_arena != submessage_arena) {
      search_to_eval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, search_to_eval, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.search_to_eval_ = search_to_eval;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.AnnotationSearchMetrics.search_to_eval)
}

// .clarifai.api.EvalMetrics metrics = 3;
inline bool AnnotationSearchMetrics::_internal_has_metrics() const {
  return this != internal_default_instance() && _impl_.metrics_ != nullptr;
}
inline bool AnnotationSearchMetrics::has_metrics() const {
  return _internal_has_metrics();
}
inline void AnnotationSearchMetrics::clear_metrics() {
  if (GetArenaForAllocation() == nullptr && _impl_.metrics_ != nullptr) {
    delete _impl_.metrics_;
  }
  _impl_.metrics_ = nullptr;
}
inline const ::clarifai::api::EvalMetrics& AnnotationSearchMetrics::_internal_metrics() const {
  const ::clarifai::api::EvalMetrics* p = _impl_.metrics_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::EvalMetrics&>(
      ::clarifai::api::_EvalMetrics_default_instance_);
}
inline const ::clarifai::api::EvalMetrics& AnnotationSearchMetrics::metrics() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AnnotationSearchMetrics.metrics)
  return _internal_metrics();
}
inline void AnnotationSearchMetrics::unsafe_arena_set_allocated_metrics(
    ::clarifai::api::EvalMetrics* metrics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metrics_);
  }
  _impl_.metrics_ = metrics;
  if (metrics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.AnnotationSearchMetrics.metrics)
}
inline ::clarifai::api::EvalMetrics* AnnotationSearchMetrics::release_metrics() {
  
  ::clarifai::api::EvalMetrics* temp = _impl_.metrics_;
  _impl_.metrics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::EvalMetrics* AnnotationSearchMetrics::unsafe_arena_release_metrics() {
  // @@protoc_insertion_point(field_release:clarifai.api.AnnotationSearchMetrics.metrics)
  
  ::clarifai::api::EvalMetrics* temp = _impl_.metrics_;
  _impl_.metrics_ = nullptr;
  return temp;
}
inline ::clarifai::api::EvalMetrics* AnnotationSearchMetrics::_internal_mutable_metrics() {
  
  if (_impl_.metrics_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::EvalMetrics>(GetArenaForAllocation());
    _impl_.metrics_ = p;
  }
  return _impl_.metrics_;
}
inline ::clarifai::api::EvalMetrics* AnnotationSearchMetrics::mutable_metrics() {
  ::clarifai::api::EvalMetrics* _msg = _internal_mutable_metrics();
  // @@protoc_insertion_point(field_mutable:clarifai.api.AnnotationSearchMetrics.metrics)
  return _msg;
}
inline void AnnotationSearchMetrics::set_allocated_metrics(::clarifai::api::EvalMetrics* metrics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metrics_;
  }
  if (metrics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metrics);
    if (message_arena != submessage_arena) {
      metrics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metrics, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metrics_ = metrics;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.AnnotationSearchMetrics.metrics)
}

// .clarifai.api.Data data = 4;
inline bool AnnotationSearchMetrics::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool AnnotationSearchMetrics::has_data() const {
  return _internal_has_data();
}
inline void AnnotationSearchMetrics::clear_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.data_ != nullptr) {
    delete _impl_.data_;
  }
  _impl_.data_ = nullptr;
}
inline const ::clarifai::api::Data& AnnotationSearchMetrics::_internal_data() const {
  const ::clarifai::api::Data* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Data&>(
      ::clarifai::api::_Data_default_instance_);
}
inline const ::clarifai::api::Data& AnnotationSearchMetrics::data() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AnnotationSearchMetrics.data)
  return _internal_data();
}
inline void AnnotationSearchMetrics::unsafe_arena_set_allocated_data(
    ::clarifai::api::Data* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.AnnotationSearchMetrics.data)
}
inline ::clarifai::api::Data* AnnotationSearchMetrics::release_data() {
  
  ::clarifai::api::Data* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Data* AnnotationSearchMetrics::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:clarifai.api.AnnotationSearchMetrics.data)
  
  ::clarifai::api::Data* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::clarifai::api::Data* AnnotationSearchMetrics::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Data>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::clarifai::api::Data* AnnotationSearchMetrics::mutable_data() {
  ::clarifai::api::Data* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:clarifai.api.AnnotationSearchMetrics.data)
  return _msg;
}
inline void AnnotationSearchMetrics::set_allocated_data(::clarifai::api::Data* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.AnnotationSearchMetrics.data)
}

// uint32 active_concept_count = 5;
inline void AnnotationSearchMetrics::clear_active_concept_count() {
  _impl_.active_concept_count_ = 0u;
}
inline uint32_t AnnotationSearchMetrics::_internal_active_concept_count() const {
  return _impl_.active_concept_count_;
}
inline uint32_t AnnotationSearchMetrics::active_concept_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AnnotationSearchMetrics.active_concept_count)
  return _internal_active_concept_count();
}
inline void AnnotationSearchMetrics::_internal_set_active_concept_count(uint32_t value) {
  
  _impl_.active_concept_count_ = value;
}
inline void AnnotationSearchMetrics::set_active_concept_count(uint32_t value) {
  _internal_set_active_concept_count(value);
  // @@protoc_insertion_point(field_set:clarifai.api.AnnotationSearchMetrics.active_concept_count)
}

// .clarifai.api.Visibility visibility = 6;
inline bool AnnotationSearchMetrics::_internal_has_visibility() const {
  return this != internal_default_instance() && _impl_.visibility_ != nullptr;
}
inline bool AnnotationSearchMetrics::has_visibility() const {
  return _internal_has_visibility();
}
inline void AnnotationSearchMetrics::clear_visibility() {
  if (GetArenaForAllocation() == nullptr && _impl_.visibility_ != nullptr) {
    delete _impl_.visibility_;
  }
  _impl_.visibility_ = nullptr;
}
inline const ::clarifai::api::Visibility& AnnotationSearchMetrics::_internal_visibility() const {
  const ::clarifai::api::Visibility* p = _impl_.visibility_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Visibility&>(
      ::clarifai::api::_Visibility_default_instance_);
}
inline const ::clarifai::api::Visibility& AnnotationSearchMetrics::visibility() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AnnotationSearchMetrics.visibility)
  return _internal_visibility();
}
inline void AnnotationSearchMetrics::unsafe_arena_set_allocated_visibility(
    ::clarifai::api::Visibility* visibility) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visibility_);
  }
  _impl_.visibility_ = visibility;
  if (visibility) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.AnnotationSearchMetrics.visibility)
}
inline ::clarifai::api::Visibility* AnnotationSearchMetrics::release_visibility() {
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Visibility* AnnotationSearchMetrics::unsafe_arena_release_visibility() {
  // @@protoc_insertion_point(field_release:clarifai.api.AnnotationSearchMetrics.visibility)
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
  return temp;
}
inline ::clarifai::api::Visibility* AnnotationSearchMetrics::_internal_mutable_visibility() {
  
  if (_impl_.visibility_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Visibility>(GetArenaForAllocation());
    _impl_.visibility_ = p;
  }
  return _impl_.visibility_;
}
inline ::clarifai::api::Visibility* AnnotationSearchMetrics::mutable_visibility() {
  ::clarifai::api::Visibility* _msg = _internal_mutable_visibility();
  // @@protoc_insertion_point(field_mutable:clarifai.api.AnnotationSearchMetrics.visibility)
  return _msg;
}
inline void AnnotationSearchMetrics::set_allocated_visibility(::clarifai::api::Visibility* visibility) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.visibility_;
  }
  if (visibility) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(visibility);
    if (message_arena != submessage_arena) {
      visibility = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visibility, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.visibility_ = visibility;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.AnnotationSearchMetrics.visibility)
}

// -------------------------------------------------------------------

// Text

// string raw = 1;
inline void Text::clear_raw() {
  _impl_.raw_.ClearToEmpty();
}
inline const std::string& Text::raw() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Text.raw)
  return _internal_raw();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Text::set_raw(ArgT0&& arg0, ArgT... args) {
 
 _impl_.raw_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Text.raw)
}
inline std::string* Text::mutable_raw() {
  std::string* _s = _internal_mutable_raw();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Text.raw)
  return _s;
}
inline const std::string& Text::_internal_raw() const {
  return _impl_.raw_.Get();
}
inline void Text::_internal_set_raw(const std::string& value) {
  
  _impl_.raw_.Set(value, GetArenaForAllocation());
}
inline std::string* Text::_internal_mutable_raw() {
  
  return _impl_.raw_.Mutable(GetArenaForAllocation());
}
inline std::string* Text::release_raw() {
  // @@protoc_insertion_point(field_release:clarifai.api.Text.raw)
  return _impl_.raw_.Release();
}
inline void Text::set_allocated_raw(std::string* raw) {
  if (raw != nullptr) {
    
  } else {
    
  }
  _impl_.raw_.SetAllocated(raw, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.raw_.IsDefault()) {
    _impl_.raw_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Text.raw)
}

// string url = 2;
inline void Text::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& Text::url() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Text.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Text::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Text.url)
}
inline std::string* Text::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Text.url)
  return _s;
}
inline const std::string& Text::_internal_url() const {
  return _impl_.url_.Get();
}
inline void Text::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* Text::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* Text::release_url() {
  // @@protoc_insertion_point(field_release:clarifai.api.Text.url)
  return _impl_.url_.Release();
}
inline void Text::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Text.url)
}

// bool allow_duplicate_url = 3;
inline void Text::clear_allow_duplicate_url() {
  _impl_.allow_duplicate_url_ = false;
}
inline bool Text::_internal_allow_duplicate_url() const {
  return _impl_.allow_duplicate_url_;
}
inline bool Text::allow_duplicate_url() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Text.allow_duplicate_url)
  return _internal_allow_duplicate_url();
}
inline void Text::_internal_set_allow_duplicate_url(bool value) {
  
  _impl_.allow_duplicate_url_ = value;
}
inline void Text::set_allow_duplicate_url(bool value) {
  _internal_set_allow_duplicate_url(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Text.allow_duplicate_url)
}

// .clarifai.api.HostedURL hosted = 4;
inline bool Text::_internal_has_hosted() const {
  return this != internal_default_instance() && _impl_.hosted_ != nullptr;
}
inline bool Text::has_hosted() const {
  return _internal_has_hosted();
}
inline void Text::clear_hosted() {
  if (GetArenaForAllocation() == nullptr && _impl_.hosted_ != nullptr) {
    delete _impl_.hosted_;
  }
  _impl_.hosted_ = nullptr;
}
inline const ::clarifai::api::HostedURL& Text::_internal_hosted() const {
  const ::clarifai::api::HostedURL* p = _impl_.hosted_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::HostedURL&>(
      ::clarifai::api::_HostedURL_default_instance_);
}
inline const ::clarifai::api::HostedURL& Text::hosted() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Text.hosted)
  return _internal_hosted();
}
inline void Text::unsafe_arena_set_allocated_hosted(
    ::clarifai::api::HostedURL* hosted) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hosted_);
  }
  _impl_.hosted_ = hosted;
  if (hosted) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Text.hosted)
}
inline ::clarifai::api::HostedURL* Text::release_hosted() {
  
  ::clarifai::api::HostedURL* temp = _impl_.hosted_;
  _impl_.hosted_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::HostedURL* Text::unsafe_arena_release_hosted() {
  // @@protoc_insertion_point(field_release:clarifai.api.Text.hosted)
  
  ::clarifai::api::HostedURL* temp = _impl_.hosted_;
  _impl_.hosted_ = nullptr;
  return temp;
}
inline ::clarifai::api::HostedURL* Text::_internal_mutable_hosted() {
  
  if (_impl_.hosted_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::HostedURL>(GetArenaForAllocation());
    _impl_.hosted_ = p;
  }
  return _impl_.hosted_;
}
inline ::clarifai::api::HostedURL* Text::mutable_hosted() {
  ::clarifai::api::HostedURL* _msg = _internal_mutable_hosted();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Text.hosted)
  return _msg;
}
inline void Text::set_allocated_hosted(::clarifai::api::HostedURL* hosted) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hosted_;
  }
  if (hosted) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hosted);
    if (message_arena != submessage_arena) {
      hosted = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hosted, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.hosted_ = hosted;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Text.hosted)
}

// .clarifai.api.TextInfo text_info = 5;
inline bool Text::_internal_has_text_info() const {
  return this != internal_default_instance() && _impl_.text_info_ != nullptr;
}
inline bool Text::has_text_info() const {
  return _internal_has_text_info();
}
inline void Text::clear_text_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.text_info_ != nullptr) {
    delete _impl_.text_info_;
  }
  _impl_.text_info_ = nullptr;
}
inline const ::clarifai::api::TextInfo& Text::_internal_text_info() const {
  const ::clarifai::api::TextInfo* p = _impl_.text_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::TextInfo&>(
      ::clarifai::api::_TextInfo_default_instance_);
}
inline const ::clarifai::api::TextInfo& Text::text_info() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Text.text_info)
  return _internal_text_info();
}
inline void Text::unsafe_arena_set_allocated_text_info(
    ::clarifai::api::TextInfo* text_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.text_info_);
  }
  _impl_.text_info_ = text_info;
  if (text_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Text.text_info)
}
inline ::clarifai::api::TextInfo* Text::release_text_info() {
  
  ::clarifai::api::TextInfo* temp = _impl_.text_info_;
  _impl_.text_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::TextInfo* Text::unsafe_arena_release_text_info() {
  // @@protoc_insertion_point(field_release:clarifai.api.Text.text_info)
  
  ::clarifai::api::TextInfo* temp = _impl_.text_info_;
  _impl_.text_info_ = nullptr;
  return temp;
}
inline ::clarifai::api::TextInfo* Text::_internal_mutable_text_info() {
  
  if (_impl_.text_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::TextInfo>(GetArenaForAllocation());
    _impl_.text_info_ = p;
  }
  return _impl_.text_info_;
}
inline ::clarifai::api::TextInfo* Text::mutable_text_info() {
  ::clarifai::api::TextInfo* _msg = _internal_mutable_text_info();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Text.text_info)
  return _msg;
}
inline void Text::set_allocated_text_info(::clarifai::api::TextInfo* text_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.text_info_;
  }
  if (text_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(text_info);
    if (message_arena != submessage_arena) {
      text_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.text_info_ = text_info;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Text.text_info)
}

// -------------------------------------------------------------------

// TextInfo

// int32 char_count = 1;
inline void TextInfo::clear_char_count() {
  _impl_.char_count_ = 0;
}
inline int32_t TextInfo::_internal_char_count() const {
  return _impl_.char_count_;
}
inline int32_t TextInfo::char_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TextInfo.char_count)
  return _internal_char_count();
}
inline void TextInfo::_internal_set_char_count(int32_t value) {
  
  _impl_.char_count_ = value;
}
inline void TextInfo::set_char_count(int32_t value) {
  _internal_set_char_count(value);
  // @@protoc_insertion_point(field_set:clarifai.api.TextInfo.char_count)
}

// string encoding = 2;
inline void TextInfo::clear_encoding() {
  _impl_.encoding_.ClearToEmpty();
}
inline const std::string& TextInfo::encoding() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TextInfo.encoding)
  return _internal_encoding();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextInfo::set_encoding(ArgT0&& arg0, ArgT... args) {
 
 _impl_.encoding_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.TextInfo.encoding)
}
inline std::string* TextInfo::mutable_encoding() {
  std::string* _s = _internal_mutable_encoding();
  // @@protoc_insertion_point(field_mutable:clarifai.api.TextInfo.encoding)
  return _s;
}
inline const std::string& TextInfo::_internal_encoding() const {
  return _impl_.encoding_.Get();
}
inline void TextInfo::_internal_set_encoding(const std::string& value) {
  
  _impl_.encoding_.Set(value, GetArenaForAllocation());
}
inline std::string* TextInfo::_internal_mutable_encoding() {
  
  return _impl_.encoding_.Mutable(GetArenaForAllocation());
}
inline std::string* TextInfo::release_encoding() {
  // @@protoc_insertion_point(field_release:clarifai.api.TextInfo.encoding)
  return _impl_.encoding_.Release();
}
inline void TextInfo::set_allocated_encoding(std::string* encoding) {
  if (encoding != nullptr) {
    
  } else {
    
  }
  _impl_.encoding_.SetAllocated(encoding, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.encoding_.IsDefault()) {
    _impl_.encoding_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.TextInfo.encoding)
}

// -------------------------------------------------------------------

// User

// string id = 1;
inline void User::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& User::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.User.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.User.id)
}
inline std::string* User::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.User.id)
  return _s;
}
inline const std::string& User::_internal_id() const {
  return _impl_.id_.Get();
}
inline void User::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.User.id)
  return _impl_.id_.Release();
}
inline void User::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.User.id)
}

// string primary_email = 2 [deprecated = true];
inline void User::clear_primary_email() {
  _impl_.primary_email_.ClearToEmpty();
}
inline const std::string& User::primary_email() const {
  // @@protoc_insertion_point(field_get:clarifai.api.User.primary_email)
  return _internal_primary_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_primary_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.primary_email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.User.primary_email)
}
inline std::string* User::mutable_primary_email() {
  std::string* _s = _internal_mutable_primary_email();
  // @@protoc_insertion_point(field_mutable:clarifai.api.User.primary_email)
  return _s;
}
inline const std::string& User::_internal_primary_email() const {
  return _impl_.primary_email_.Get();
}
inline void User::_internal_set_primary_email(const std::string& value) {
  
  _impl_.primary_email_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_primary_email() {
  
  return _impl_.primary_email_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_primary_email() {
  // @@protoc_insertion_point(field_release:clarifai.api.User.primary_email)
  return _impl_.primary_email_.Release();
}
inline void User::set_allocated_primary_email(std::string* primary_email) {
  if (primary_email != nullptr) {
    
  } else {
    
  }
  _impl_.primary_email_.SetAllocated(primary_email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.primary_email_.IsDefault()) {
    _impl_.primary_email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.User.primary_email)
}

// string first_name = 3;
inline void User::clear_first_name() {
  _impl_.first_name_.ClearToEmpty();
}
inline const std::string& User::first_name() const {
  // @@protoc_insertion_point(field_get:clarifai.api.User.first_name)
  return _internal_first_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_first_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.first_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.User.first_name)
}
inline std::string* User::mutable_first_name() {
  std::string* _s = _internal_mutable_first_name();
  // @@protoc_insertion_point(field_mutable:clarifai.api.User.first_name)
  return _s;
}
inline const std::string& User::_internal_first_name() const {
  return _impl_.first_name_.Get();
}
inline void User::_internal_set_first_name(const std::string& value) {
  
  _impl_.first_name_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_first_name() {
  
  return _impl_.first_name_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_first_name() {
  // @@protoc_insertion_point(field_release:clarifai.api.User.first_name)
  return _impl_.first_name_.Release();
}
inline void User::set_allocated_first_name(std::string* first_name) {
  if (first_name != nullptr) {
    
  } else {
    
  }
  _impl_.first_name_.SetAllocated(first_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.first_name_.IsDefault()) {
    _impl_.first_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.User.first_name)
}

// string last_name = 4;
inline void User::clear_last_name() {
  _impl_.last_name_.ClearToEmpty();
}
inline const std::string& User::last_name() const {
  // @@protoc_insertion_point(field_get:clarifai.api.User.last_name)
  return _internal_last_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_last_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.last_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.User.last_name)
}
inline std::string* User::mutable_last_name() {
  std::string* _s = _internal_mutable_last_name();
  // @@protoc_insertion_point(field_mutable:clarifai.api.User.last_name)
  return _s;
}
inline const std::string& User::_internal_last_name() const {
  return _impl_.last_name_.Get();
}
inline void User::_internal_set_last_name(const std::string& value) {
  
  _impl_.last_name_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_last_name() {
  
  return _impl_.last_name_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_last_name() {
  // @@protoc_insertion_point(field_release:clarifai.api.User.last_name)
  return _impl_.last_name_.Release();
}
inline void User::set_allocated_last_name(std::string* last_name) {
  if (last_name != nullptr) {
    
  } else {
    
  }
  _impl_.last_name_.SetAllocated(last_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.last_name_.IsDefault()) {
    _impl_.last_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.User.last_name)
}

// string company_name = 5;
inline void User::clear_company_name() {
  _impl_.company_name_.ClearToEmpty();
}
inline const std::string& User::company_name() const {
  // @@protoc_insertion_point(field_get:clarifai.api.User.company_name)
  return _internal_company_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_company_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.company_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.User.company_name)
}
inline std::string* User::mutable_company_name() {
  std::string* _s = _internal_mutable_company_name();
  // @@protoc_insertion_point(field_mutable:clarifai.api.User.company_name)
  return _s;
}
inline const std::string& User::_internal_company_name() const {
  return _impl_.company_name_.Get();
}
inline void User::_internal_set_company_name(const std::string& value) {
  
  _impl_.company_name_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_company_name() {
  
  return _impl_.company_name_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_company_name() {
  // @@protoc_insertion_point(field_release:clarifai.api.User.company_name)
  return _impl_.company_name_.Release();
}
inline void User::set_allocated_company_name(std::string* company_name) {
  if (company_name != nullptr) {
    
  } else {
    
  }
  _impl_.company_name_.SetAllocated(company_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.company_name_.IsDefault()) {
    _impl_.company_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.User.company_name)
}

// string job_title = 19;
inline void User::clear_job_title() {
  _impl_.job_title_.ClearToEmpty();
}
inline const std::string& User::job_title() const {
  // @@protoc_insertion_point(field_get:clarifai.api.User.job_title)
  return _internal_job_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_job_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.job_title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.User.job_title)
}
inline std::string* User::mutable_job_title() {
  std::string* _s = _internal_mutable_job_title();
  // @@protoc_insertion_point(field_mutable:clarifai.api.User.job_title)
  return _s;
}
inline const std::string& User::_internal_job_title() const {
  return _impl_.job_title_.Get();
}
inline void User::_internal_set_job_title(const std::string& value) {
  
  _impl_.job_title_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_job_title() {
  
  return _impl_.job_title_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_job_title() {
  // @@protoc_insertion_point(field_release:clarifai.api.User.job_title)
  return _impl_.job_title_.Release();
}
inline void User::set_allocated_job_title(std::string* job_title) {
  if (job_title != nullptr) {
    
  } else {
    
  }
  _impl_.job_title_.SetAllocated(job_title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.job_title_.IsDefault()) {
    _impl_.job_title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.User.job_title)
}

// string job_role = 20;
inline void User::clear_job_role() {
  _impl_.job_role_.ClearToEmpty();
}
inline const std::string& User::job_role() const {
  // @@protoc_insertion_point(field_get:clarifai.api.User.job_role)
  return _internal_job_role();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_job_role(ArgT0&& arg0, ArgT... args) {
 
 _impl_.job_role_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.User.job_role)
}
inline std::string* User::mutable_job_role() {
  std::string* _s = _internal_mutable_job_role();
  // @@protoc_insertion_point(field_mutable:clarifai.api.User.job_role)
  return _s;
}
inline const std::string& User::_internal_job_role() const {
  return _impl_.job_role_.Get();
}
inline void User::_internal_set_job_role(const std::string& value) {
  
  _impl_.job_role_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_job_role() {
  
  return _impl_.job_role_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_job_role() {
  // @@protoc_insertion_point(field_release:clarifai.api.User.job_role)
  return _impl_.job_role_.Release();
}
inline void User::set_allocated_job_role(std::string* job_role) {
  if (job_role != nullptr) {
    
  } else {
    
  }
  _impl_.job_role_.SetAllocated(job_role, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.job_role_.IsDefault()) {
    _impl_.job_role_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.User.job_role)
}

// string bill_type = 7 [deprecated = true];
inline void User::clear_bill_type() {
  _impl_.bill_type_.ClearToEmpty();
}
inline const std::string& User::bill_type() const {
  // @@protoc_insertion_point(field_get:clarifai.api.User.bill_type)
  return _internal_bill_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_bill_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bill_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.User.bill_type)
}
inline std::string* User::mutable_bill_type() {
  std::string* _s = _internal_mutable_bill_type();
  // @@protoc_insertion_point(field_mutable:clarifai.api.User.bill_type)
  return _s;
}
inline const std::string& User::_internal_bill_type() const {
  return _impl_.bill_type_.Get();
}
inline void User::_internal_set_bill_type(const std::string& value) {
  
  _impl_.bill_type_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_bill_type() {
  
  return _impl_.bill_type_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_bill_type() {
  // @@protoc_insertion_point(field_release:clarifai.api.User.bill_type)
  return _impl_.bill_type_.Release();
}
inline void User::set_allocated_bill_type(std::string* bill_type) {
  if (bill_type != nullptr) {
    
  } else {
    
  }
  _impl_.bill_type_.SetAllocated(bill_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bill_type_.IsDefault()) {
    _impl_.bill_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.User.bill_type)
}

// .google.protobuf.Timestamp created_at = 6;
inline bool User::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool User::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& User::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& User::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.User.created_at)
  return _internal_created_at();
}
inline void User::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.User.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* User::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* User::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.User.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* User::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* User::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.User.created_at)
  return _msg;
}
inline void User::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.User.created_at)
}

// .google.protobuf.Timestamp date_gdpr_consent = 8 [deprecated = true];
inline bool User::_internal_has_date_gdpr_consent() const {
  return this != internal_default_instance() && _impl_.date_gdpr_consent_ != nullptr;
}
inline bool User::has_date_gdpr_consent() const {
  return _internal_has_date_gdpr_consent();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& User::_internal_date_gdpr_consent() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.date_gdpr_consent_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& User::date_gdpr_consent() const {
  // @@protoc_insertion_point(field_get:clarifai.api.User.date_gdpr_consent)
  return _internal_date_gdpr_consent();
}
inline void User::unsafe_arena_set_allocated_date_gdpr_consent(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* date_gdpr_consent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.date_gdpr_consent_);
  }
  _impl_.date_gdpr_consent_ = date_gdpr_consent;
  if (date_gdpr_consent) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.User.date_gdpr_consent)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* User::release_date_gdpr_consent() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.date_gdpr_consent_;
  _impl_.date_gdpr_consent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* User::unsafe_arena_release_date_gdpr_consent() {
  // @@protoc_insertion_point(field_release:clarifai.api.User.date_gdpr_consent)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.date_gdpr_consent_;
  _impl_.date_gdpr_consent_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* User::_internal_mutable_date_gdpr_consent() {
  
  if (_impl_.date_gdpr_consent_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.date_gdpr_consent_ = p;
  }
  return _impl_.date_gdpr_consent_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* User::mutable_date_gdpr_consent() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_date_gdpr_consent();
  // @@protoc_insertion_point(field_mutable:clarifai.api.User.date_gdpr_consent)
  return _msg;
}
inline void User::set_allocated_date_gdpr_consent(::PROTOBUF_NAMESPACE_ID::Timestamp* date_gdpr_consent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.date_gdpr_consent_);
  }
  if (date_gdpr_consent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(date_gdpr_consent));
    if (message_arena != submessage_arena) {
      date_gdpr_consent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, date_gdpr_consent, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.date_gdpr_consent_ = date_gdpr_consent;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.User.date_gdpr_consent)
}

// .google.protobuf.Timestamp date_tos_consent = 9 [deprecated = true];
inline bool User::_internal_has_date_tos_consent() const {
  return this != internal_default_instance() && _impl_.date_tos_consent_ != nullptr;
}
inline bool User::has_date_tos_consent() const {
  return _internal_has_date_tos_consent();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& User::_internal_date_tos_consent() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.date_tos_consent_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& User::date_tos_consent() const {
  // @@protoc_insertion_point(field_get:clarifai.api.User.date_tos_consent)
  return _internal_date_tos_consent();
}
inline void User::unsafe_arena_set_allocated_date_tos_consent(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* date_tos_consent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.date_tos_consent_);
  }
  _impl_.date_tos_consent_ = date_tos_consent;
  if (date_tos_consent) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.User.date_tos_consent)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* User::release_date_tos_consent() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.date_tos_consent_;
  _impl_.date_tos_consent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* User::unsafe_arena_release_date_tos_consent() {
  // @@protoc_insertion_point(field_release:clarifai.api.User.date_tos_consent)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.date_tos_consent_;
  _impl_.date_tos_consent_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* User::_internal_mutable_date_tos_consent() {
  
  if (_impl_.date_tos_consent_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.date_tos_consent_ = p;
  }
  return _impl_.date_tos_consent_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* User::mutable_date_tos_consent() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_date_tos_consent();
  // @@protoc_insertion_point(field_mutable:clarifai.api.User.date_tos_consent)
  return _msg;
}
inline void User::set_allocated_date_tos_consent(::PROTOBUF_NAMESPACE_ID::Timestamp* date_tos_consent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.date_tos_consent_);
  }
  if (date_tos_consent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(date_tos_consent));
    if (message_arena != submessage_arena) {
      date_tos_consent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, date_tos_consent, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.date_tos_consent_ = date_tos_consent;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.User.date_tos_consent)
}

// .google.protobuf.Timestamp date_marketing_consent = 10 [deprecated = true];
inline bool User::_internal_has_date_marketing_consent() const {
  return this != internal_default_instance() && _impl_.date_marketing_consent_ != nullptr;
}
inline bool User::has_date_marketing_consent() const {
  return _internal_has_date_marketing_consent();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& User::_internal_date_marketing_consent() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.date_marketing_consent_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& User::date_marketing_consent() const {
  // @@protoc_insertion_point(field_get:clarifai.api.User.date_marketing_consent)
  return _internal_date_marketing_consent();
}
inline void User::unsafe_arena_set_allocated_date_marketing_consent(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* date_marketing_consent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.date_marketing_consent_);
  }
  _impl_.date_marketing_consent_ = date_marketing_consent;
  if (date_marketing_consent) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.User.date_marketing_consent)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* User::release_date_marketing_consent() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.date_marketing_consent_;
  _impl_.date_marketing_consent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* User::unsafe_arena_release_date_marketing_consent() {
  // @@protoc_insertion_point(field_release:clarifai.api.User.date_marketing_consent)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.date_marketing_consent_;
  _impl_.date_marketing_consent_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* User::_internal_mutable_date_marketing_consent() {
  
  if (_impl_.date_marketing_consent_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.date_marketing_consent_ = p;
  }
  return _impl_.date_marketing_consent_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* User::mutable_date_marketing_consent() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_date_marketing_consent();
  // @@protoc_insertion_point(field_mutable:clarifai.api.User.date_marketing_consent)
  return _msg;
}
inline void User::set_allocated_date_marketing_consent(::PROTOBUF_NAMESPACE_ID::Timestamp* date_marketing_consent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.date_marketing_consent_);
  }
  if (date_marketing_consent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(date_marketing_consent));
    if (message_arena != submessage_arena) {
      date_marketing_consent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, date_marketing_consent, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.date_marketing_consent_ = date_marketing_consent;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.User.date_marketing_consent)
}

// .google.protobuf.Timestamp date_pii_consent = 23 [deprecated = true];
inline bool User::_internal_has_date_pii_consent() const {
  return this != internal_default_instance() && _impl_.date_pii_consent_ != nullptr;
}
inline bool User::has_date_pii_consent() const {
  return _internal_has_date_pii_consent();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& User::_internal_date_pii_consent() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.date_pii_consent_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& User::date_pii_consent() const {
  // @@protoc_insertion_point(field_get:clarifai.api.User.date_pii_consent)
  return _internal_date_pii_consent();
}
inline void User::unsafe_arena_set_allocated_date_pii_consent(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* date_pii_consent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.date_pii_consent_);
  }
  _impl_.date_pii_consent_ = date_pii_consent;
  if (date_pii_consent) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.User.date_pii_consent)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* User::release_date_pii_consent() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.date_pii_consent_;
  _impl_.date_pii_consent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* User::unsafe_arena_release_date_pii_consent() {
  // @@protoc_insertion_point(field_release:clarifai.api.User.date_pii_consent)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.date_pii_consent_;
  _impl_.date_pii_consent_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* User::_internal_mutable_date_pii_consent() {
  
  if (_impl_.date_pii_consent_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.date_pii_consent_ = p;
  }
  return _impl_.date_pii_consent_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* User::mutable_date_pii_consent() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_date_pii_consent();
  // @@protoc_insertion_point(field_mutable:clarifai.api.User.date_pii_consent)
  return _msg;
}
inline void User::set_allocated_date_pii_consent(::PROTOBUF_NAMESPACE_ID::Timestamp* date_pii_consent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.date_pii_consent_);
  }
  if (date_pii_consent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(date_pii_consent));
    if (message_arena != submessage_arena) {
      date_pii_consent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, date_pii_consent, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.date_pii_consent_ = date_pii_consent;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.User.date_pii_consent)
}

// .google.protobuf.Struct metadata = 11 [deprecated = true];
inline bool User::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool User::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& User::_internal_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& User::metadata() const {
  // @@protoc_insertion_point(field_get:clarifai.api.User.metadata)
  return _internal_metadata();
}
inline void User::unsafe_arena_set_allocated_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.User.metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* User::release_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* User::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:clarifai.api.User.metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* User::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* User::mutable_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:clarifai.api.User.metadata)
  return _msg;
}
inline void User::set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.User.metadata)
}

// repeated .clarifai.api.EmailAddress email_addresses = 12 [deprecated = true];
inline int User::_internal_email_addresses_size() const {
  return _impl_.email_addresses_.size();
}
inline int User::email_addresses_size() const {
  return _internal_email_addresses_size();
}
inline void User::clear_email_addresses() {
  _impl_.email_addresses_.Clear();
}
inline ::clarifai::api::EmailAddress* User::mutable_email_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.User.email_addresses)
  return _impl_.email_addresses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::EmailAddress >*
User::mutable_email_addresses() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.User.email_addresses)
  return &_impl_.email_addresses_;
}
inline const ::clarifai::api::EmailAddress& User::_internal_email_addresses(int index) const {
  return _impl_.email_addresses_.Get(index);
}
inline const ::clarifai::api::EmailAddress& User::email_addresses(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.User.email_addresses)
  return _internal_email_addresses(index);
}
inline ::clarifai::api::EmailAddress* User::_internal_add_email_addresses() {
  return _impl_.email_addresses_.Add();
}
inline ::clarifai::api::EmailAddress* User::add_email_addresses() {
  ::clarifai::api::EmailAddress* _add = _internal_add_email_addresses();
  // @@protoc_insertion_point(field_add:clarifai.api.User.email_addresses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::EmailAddress >&
User::email_addresses() const {
  // @@protoc_insertion_point(field_list:clarifai.api.User.email_addresses)
  return _impl_.email_addresses_;
}

// bool two_factor_auth_enabled = 15 [deprecated = true];
inline void User::clear_two_factor_auth_enabled() {
  _impl_.two_factor_auth_enabled_ = false;
}
inline bool User::_internal_two_factor_auth_enabled() const {
  return _impl_.two_factor_auth_enabled_;
}
inline bool User::two_factor_auth_enabled() const {
  // @@protoc_insertion_point(field_get:clarifai.api.User.two_factor_auth_enabled)
  return _internal_two_factor_auth_enabled();
}
inline void User::_internal_set_two_factor_auth_enabled(bool value) {
  
  _impl_.two_factor_auth_enabled_ = value;
}
inline void User::set_two_factor_auth_enabled(bool value) {
  _internal_set_two_factor_auth_enabled(value);
  // @@protoc_insertion_point(field_set:clarifai.api.User.two_factor_auth_enabled)
}

// uint32 teams_count = 16 [deprecated = true];
inline void User::clear_teams_count() {
  _impl_.teams_count_ = 0u;
}
inline uint32_t User::_internal_teams_count() const {
  return _impl_.teams_count_;
}
inline uint32_t User::teams_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.User.teams_count)
  return _internal_teams_count();
}
inline void User::_internal_set_teams_count(uint32_t value) {
  
  _impl_.teams_count_ = value;
}
inline void User::set_teams_count(uint32_t value) {
  _internal_set_teams_count(value);
  // @@protoc_insertion_point(field_set:clarifai.api.User.teams_count)
}

// bool is_starred = 21;
inline void User::clear_is_starred() {
  _impl_.is_starred_ = false;
}
inline bool User::_internal_is_starred() const {
  return _impl_.is_starred_;
}
inline bool User::is_starred() const {
  // @@protoc_insertion_point(field_get:clarifai.api.User.is_starred)
  return _internal_is_starred();
}
inline void User::_internal_set_is_starred(bool value) {
  
  _impl_.is_starred_ = value;
}
inline void User::set_is_starred(bool value) {
  _internal_set_is_starred(value);
  // @@protoc_insertion_point(field_set:clarifai.api.User.is_starred)
}

// int32 star_count = 22;
inline void User::clear_star_count() {
  _impl_.star_count_ = 0;
}
inline int32_t User::_internal_star_count() const {
  return _impl_.star_count_;
}
inline int32_t User::star_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.User.star_count)
  return _internal_star_count();
}
inline void User::_internal_set_star_count(int32_t value) {
  
  _impl_.star_count_ = value;
}
inline void User::set_star_count(int32_t value) {
  _internal_set_star_count(value);
  // @@protoc_insertion_point(field_set:clarifai.api.User.star_count)
}

// .clarifai.api.Visibility visibility = 17;
inline bool User::_internal_has_visibility() const {
  return this != internal_default_instance() && _impl_.visibility_ != nullptr;
}
inline bool User::has_visibility() const {
  return _internal_has_visibility();
}
inline void User::clear_visibility() {
  if (GetArenaForAllocation() == nullptr && _impl_.visibility_ != nullptr) {
    delete _impl_.visibility_;
  }
  _impl_.visibility_ = nullptr;
}
inline const ::clarifai::api::Visibility& User::_internal_visibility() const {
  const ::clarifai::api::Visibility* p = _impl_.visibility_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Visibility&>(
      ::clarifai::api::_Visibility_default_instance_);
}
inline const ::clarifai::api::Visibility& User::visibility() const {
  // @@protoc_insertion_point(field_get:clarifai.api.User.visibility)
  return _internal_visibility();
}
inline void User::unsafe_arena_set_allocated_visibility(
    ::clarifai::api::Visibility* visibility) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visibility_);
  }
  _impl_.visibility_ = visibility;
  if (visibility) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.User.visibility)
}
inline ::clarifai::api::Visibility* User::release_visibility() {
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Visibility* User::unsafe_arena_release_visibility() {
  // @@protoc_insertion_point(field_release:clarifai.api.User.visibility)
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
  return temp;
}
inline ::clarifai::api::Visibility* User::_internal_mutable_visibility() {
  
  if (_impl_.visibility_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Visibility>(GetArenaForAllocation());
    _impl_.visibility_ = p;
  }
  return _impl_.visibility_;
}
inline ::clarifai::api::Visibility* User::mutable_visibility() {
  ::clarifai::api::Visibility* _msg = _internal_mutable_visibility();
  // @@protoc_insertion_point(field_mutable:clarifai.api.User.visibility)
  return _msg;
}
inline void User::set_allocated_visibility(::clarifai::api::Visibility* visibility) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.visibility_;
  }
  if (visibility) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(visibility);
    if (message_arena != submessage_arena) {
      visibility = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visibility, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.visibility_ = visibility;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.User.visibility)
}

// .clarifai.api.UserDetail user_detail = 18;
inline bool User::_internal_has_user_detail() const {
  return this != internal_default_instance() && _impl_.user_detail_ != nullptr;
}
inline bool User::has_user_detail() const {
  return _internal_has_user_detail();
}
inline void User::clear_user_detail() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_detail_ != nullptr) {
    delete _impl_.user_detail_;
  }
  _impl_.user_detail_ = nullptr;
}
inline const ::clarifai::api::UserDetail& User::_internal_user_detail() const {
  const ::clarifai::api::UserDetail* p = _impl_.user_detail_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::UserDetail&>(
      ::clarifai::api::_UserDetail_default_instance_);
}
inline const ::clarifai::api::UserDetail& User::user_detail() const {
  // @@protoc_insertion_point(field_get:clarifai.api.User.user_detail)
  return _internal_user_detail();
}
inline void User::unsafe_arena_set_allocated_user_detail(
    ::clarifai::api::UserDetail* user_detail) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_detail_);
  }
  _impl_.user_detail_ = user_detail;
  if (user_detail) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.User.user_detail)
}
inline ::clarifai::api::UserDetail* User::release_user_detail() {
  
  ::clarifai::api::UserDetail* temp = _impl_.user_detail_;
  _impl_.user_detail_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::UserDetail* User::unsafe_arena_release_user_detail() {
  // @@protoc_insertion_point(field_release:clarifai.api.User.user_detail)
  
  ::clarifai::api::UserDetail* temp = _impl_.user_detail_;
  _impl_.user_detail_ = nullptr;
  return temp;
}
inline ::clarifai::api::UserDetail* User::_internal_mutable_user_detail() {
  
  if (_impl_.user_detail_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::UserDetail>(GetArenaForAllocation());
    _impl_.user_detail_ = p;
  }
  return _impl_.user_detail_;
}
inline ::clarifai::api::UserDetail* User::mutable_user_detail() {
  ::clarifai::api::UserDetail* _msg = _internal_mutable_user_detail();
  // @@protoc_insertion_point(field_mutable:clarifai.api.User.user_detail)
  return _msg;
}
inline void User::set_allocated_user_detail(::clarifai::api::UserDetail* user_detail) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_detail_;
  }
  if (user_detail) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_detail);
    if (message_arena != submessage_arena) {
      user_detail = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_detail, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_detail_ = user_detail;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.User.user_detail)
}

// -------------------------------------------------------------------

// UserDetail

// string primary_email = 1;
inline void UserDetail::clear_primary_email() {
  _impl_.primary_email_.ClearToEmpty();
}
inline const std::string& UserDetail::primary_email() const {
  // @@protoc_insertion_point(field_get:clarifai.api.UserDetail.primary_email)
  return _internal_primary_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserDetail::set_primary_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.primary_email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.UserDetail.primary_email)
}
inline std::string* UserDetail::mutable_primary_email() {
  std::string* _s = _internal_mutable_primary_email();
  // @@protoc_insertion_point(field_mutable:clarifai.api.UserDetail.primary_email)
  return _s;
}
inline const std::string& UserDetail::_internal_primary_email() const {
  return _impl_.primary_email_.Get();
}
inline void UserDetail::_internal_set_primary_email(const std::string& value) {
  
  _impl_.primary_email_.Set(value, GetArenaForAllocation());
}
inline std::string* UserDetail::_internal_mutable_primary_email() {
  
  return _impl_.primary_email_.Mutable(GetArenaForAllocation());
}
inline std::string* UserDetail::release_primary_email() {
  // @@protoc_insertion_point(field_release:clarifai.api.UserDetail.primary_email)
  return _impl_.primary_email_.Release();
}
inline void UserDetail::set_allocated_primary_email(std::string* primary_email) {
  if (primary_email != nullptr) {
    
  } else {
    
  }
  _impl_.primary_email_.SetAllocated(primary_email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.primary_email_.IsDefault()) {
    _impl_.primary_email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.UserDetail.primary_email)
}

// string bill_type = 2;
inline void UserDetail::clear_bill_type() {
  _impl_.bill_type_.ClearToEmpty();
}
inline const std::string& UserDetail::bill_type() const {
  // @@protoc_insertion_point(field_get:clarifai.api.UserDetail.bill_type)
  return _internal_bill_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserDetail::set_bill_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bill_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.UserDetail.bill_type)
}
inline std::string* UserDetail::mutable_bill_type() {
  std::string* _s = _internal_mutable_bill_type();
  // @@protoc_insertion_point(field_mutable:clarifai.api.UserDetail.bill_type)
  return _s;
}
inline const std::string& UserDetail::_internal_bill_type() const {
  return _impl_.bill_type_.Get();
}
inline void UserDetail::_internal_set_bill_type(const std::string& value) {
  
  _impl_.bill_type_.Set(value, GetArenaForAllocation());
}
inline std::string* UserDetail::_internal_mutable_bill_type() {
  
  return _impl_.bill_type_.Mutable(GetArenaForAllocation());
}
inline std::string* UserDetail::release_bill_type() {
  // @@protoc_insertion_point(field_release:clarifai.api.UserDetail.bill_type)
  return _impl_.bill_type_.Release();
}
inline void UserDetail::set_allocated_bill_type(std::string* bill_type) {
  if (bill_type != nullptr) {
    
  } else {
    
  }
  _impl_.bill_type_.SetAllocated(bill_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bill_type_.IsDefault()) {
    _impl_.bill_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.UserDetail.bill_type)
}

// .google.protobuf.Timestamp date_gdpr_consent = 3;
inline bool UserDetail::_internal_has_date_gdpr_consent() const {
  return this != internal_default_instance() && _impl_.date_gdpr_consent_ != nullptr;
}
inline bool UserDetail::has_date_gdpr_consent() const {
  return _internal_has_date_gdpr_consent();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UserDetail::_internal_date_gdpr_consent() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.date_gdpr_consent_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UserDetail::date_gdpr_consent() const {
  // @@protoc_insertion_point(field_get:clarifai.api.UserDetail.date_gdpr_consent)
  return _internal_date_gdpr_consent();
}
inline void UserDetail::unsafe_arena_set_allocated_date_gdpr_consent(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* date_gdpr_consent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.date_gdpr_consent_);
  }
  _impl_.date_gdpr_consent_ = date_gdpr_consent;
  if (date_gdpr_consent) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.UserDetail.date_gdpr_consent)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserDetail::release_date_gdpr_consent() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.date_gdpr_consent_;
  _impl_.date_gdpr_consent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserDetail::unsafe_arena_release_date_gdpr_consent() {
  // @@protoc_insertion_point(field_release:clarifai.api.UserDetail.date_gdpr_consent)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.date_gdpr_consent_;
  _impl_.date_gdpr_consent_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserDetail::_internal_mutable_date_gdpr_consent() {
  
  if (_impl_.date_gdpr_consent_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.date_gdpr_consent_ = p;
  }
  return _impl_.date_gdpr_consent_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserDetail::mutable_date_gdpr_consent() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_date_gdpr_consent();
  // @@protoc_insertion_point(field_mutable:clarifai.api.UserDetail.date_gdpr_consent)
  return _msg;
}
inline void UserDetail::set_allocated_date_gdpr_consent(::PROTOBUF_NAMESPACE_ID::Timestamp* date_gdpr_consent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.date_gdpr_consent_);
  }
  if (date_gdpr_consent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(date_gdpr_consent));
    if (message_arena != submessage_arena) {
      date_gdpr_consent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, date_gdpr_consent, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.date_gdpr_consent_ = date_gdpr_consent;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.UserDetail.date_gdpr_consent)
}

// .google.protobuf.Timestamp date_tos_consent = 4;
inline bool UserDetail::_internal_has_date_tos_consent() const {
  return this != internal_default_instance() && _impl_.date_tos_consent_ != nullptr;
}
inline bool UserDetail::has_date_tos_consent() const {
  return _internal_has_date_tos_consent();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UserDetail::_internal_date_tos_consent() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.date_tos_consent_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UserDetail::date_tos_consent() const {
  // @@protoc_insertion_point(field_get:clarifai.api.UserDetail.date_tos_consent)
  return _internal_date_tos_consent();
}
inline void UserDetail::unsafe_arena_set_allocated_date_tos_consent(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* date_tos_consent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.date_tos_consent_);
  }
  _impl_.date_tos_consent_ = date_tos_consent;
  if (date_tos_consent) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.UserDetail.date_tos_consent)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserDetail::release_date_tos_consent() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.date_tos_consent_;
  _impl_.date_tos_consent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserDetail::unsafe_arena_release_date_tos_consent() {
  // @@protoc_insertion_point(field_release:clarifai.api.UserDetail.date_tos_consent)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.date_tos_consent_;
  _impl_.date_tos_consent_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserDetail::_internal_mutable_date_tos_consent() {
  
  if (_impl_.date_tos_consent_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.date_tos_consent_ = p;
  }
  return _impl_.date_tos_consent_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserDetail::mutable_date_tos_consent() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_date_tos_consent();
  // @@protoc_insertion_point(field_mutable:clarifai.api.UserDetail.date_tos_consent)
  return _msg;
}
inline void UserDetail::set_allocated_date_tos_consent(::PROTOBUF_NAMESPACE_ID::Timestamp* date_tos_consent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.date_tos_consent_);
  }
  if (date_tos_consent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(date_tos_consent));
    if (message_arena != submessage_arena) {
      date_tos_consent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, date_tos_consent, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.date_tos_consent_ = date_tos_consent;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.UserDetail.date_tos_consent)
}

// .google.protobuf.Timestamp date_marketing_consent = 5;
inline bool UserDetail::_internal_has_date_marketing_consent() const {
  return this != internal_default_instance() && _impl_.date_marketing_consent_ != nullptr;
}
inline bool UserDetail::has_date_marketing_consent() const {
  return _internal_has_date_marketing_consent();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UserDetail::_internal_date_marketing_consent() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.date_marketing_consent_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UserDetail::date_marketing_consent() const {
  // @@protoc_insertion_point(field_get:clarifai.api.UserDetail.date_marketing_consent)
  return _internal_date_marketing_consent();
}
inline void UserDetail::unsafe_arena_set_allocated_date_marketing_consent(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* date_marketing_consent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.date_marketing_consent_);
  }
  _impl_.date_marketing_consent_ = date_marketing_consent;
  if (date_marketing_consent) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.UserDetail.date_marketing_consent)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserDetail::release_date_marketing_consent() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.date_marketing_consent_;
  _impl_.date_marketing_consent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserDetail::unsafe_arena_release_date_marketing_consent() {
  // @@protoc_insertion_point(field_release:clarifai.api.UserDetail.date_marketing_consent)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.date_marketing_consent_;
  _impl_.date_marketing_consent_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserDetail::_internal_mutable_date_marketing_consent() {
  
  if (_impl_.date_marketing_consent_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.date_marketing_consent_ = p;
  }
  return _impl_.date_marketing_consent_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserDetail::mutable_date_marketing_consent() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_date_marketing_consent();
  // @@protoc_insertion_point(field_mutable:clarifai.api.UserDetail.date_marketing_consent)
  return _msg;
}
inline void UserDetail::set_allocated_date_marketing_consent(::PROTOBUF_NAMESPACE_ID::Timestamp* date_marketing_consent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.date_marketing_consent_);
  }
  if (date_marketing_consent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(date_marketing_consent));
    if (message_arena != submessage_arena) {
      date_marketing_consent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, date_marketing_consent, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.date_marketing_consent_ = date_marketing_consent;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.UserDetail.date_marketing_consent)
}

// .google.protobuf.Timestamp date_pii_consent = 13;
inline bool UserDetail::_internal_has_date_pii_consent() const {
  return this != internal_default_instance() && _impl_.date_pii_consent_ != nullptr;
}
inline bool UserDetail::has_date_pii_consent() const {
  return _internal_has_date_pii_consent();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UserDetail::_internal_date_pii_consent() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.date_pii_consent_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UserDetail::date_pii_consent() const {
  // @@protoc_insertion_point(field_get:clarifai.api.UserDetail.date_pii_consent)
  return _internal_date_pii_consent();
}
inline void UserDetail::unsafe_arena_set_allocated_date_pii_consent(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* date_pii_consent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.date_pii_consent_);
  }
  _impl_.date_pii_consent_ = date_pii_consent;
  if (date_pii_consent) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.UserDetail.date_pii_consent)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserDetail::release_date_pii_consent() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.date_pii_consent_;
  _impl_.date_pii_consent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserDetail::unsafe_arena_release_date_pii_consent() {
  // @@protoc_insertion_point(field_release:clarifai.api.UserDetail.date_pii_consent)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.date_pii_consent_;
  _impl_.date_pii_consent_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserDetail::_internal_mutable_date_pii_consent() {
  
  if (_impl_.date_pii_consent_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.date_pii_consent_ = p;
  }
  return _impl_.date_pii_consent_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserDetail::mutable_date_pii_consent() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_date_pii_consent();
  // @@protoc_insertion_point(field_mutable:clarifai.api.UserDetail.date_pii_consent)
  return _msg;
}
inline void UserDetail::set_allocated_date_pii_consent(::PROTOBUF_NAMESPACE_ID::Timestamp* date_pii_consent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.date_pii_consent_);
  }
  if (date_pii_consent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(date_pii_consent));
    if (message_arena != submessage_arena) {
      date_pii_consent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, date_pii_consent, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.date_pii_consent_ = date_pii_consent;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.UserDetail.date_pii_consent)
}

// .google.protobuf.Struct metadata = 6;
inline bool UserDetail::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool UserDetail::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& UserDetail::_internal_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& UserDetail::metadata() const {
  // @@protoc_insertion_point(field_get:clarifai.api.UserDetail.metadata)
  return _internal_metadata();
}
inline void UserDetail::unsafe_arena_set_allocated_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.UserDetail.metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UserDetail::release_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UserDetail::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:clarifai.api.UserDetail.metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UserDetail::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UserDetail::mutable_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:clarifai.api.UserDetail.metadata)
  return _msg;
}
inline void UserDetail::set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.UserDetail.metadata)
}

// repeated .clarifai.api.EmailAddress email_addresses = 7;
inline int UserDetail::_internal_email_addresses_size() const {
  return _impl_.email_addresses_.size();
}
inline int UserDetail::email_addresses_size() const {
  return _internal_email_addresses_size();
}
inline void UserDetail::clear_email_addresses() {
  _impl_.email_addresses_.Clear();
}
inline ::clarifai::api::EmailAddress* UserDetail::mutable_email_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.UserDetail.email_addresses)
  return _impl_.email_addresses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::EmailAddress >*
UserDetail::mutable_email_addresses() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.UserDetail.email_addresses)
  return &_impl_.email_addresses_;
}
inline const ::clarifai::api::EmailAddress& UserDetail::_internal_email_addresses(int index) const {
  return _impl_.email_addresses_.Get(index);
}
inline const ::clarifai::api::EmailAddress& UserDetail::email_addresses(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.UserDetail.email_addresses)
  return _internal_email_addresses(index);
}
inline ::clarifai::api::EmailAddress* UserDetail::_internal_add_email_addresses() {
  return _impl_.email_addresses_.Add();
}
inline ::clarifai::api::EmailAddress* UserDetail::add_email_addresses() {
  ::clarifai::api::EmailAddress* _add = _internal_add_email_addresses();
  // @@protoc_insertion_point(field_add:clarifai.api.UserDetail.email_addresses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::EmailAddress >&
UserDetail::email_addresses() const {
  // @@protoc_insertion_point(field_list:clarifai.api.UserDetail.email_addresses)
  return _impl_.email_addresses_;
}

// bool two_factor_auth_enabled = 9;
inline void UserDetail::clear_two_factor_auth_enabled() {
  _impl_.two_factor_auth_enabled_ = false;
}
inline bool UserDetail::_internal_two_factor_auth_enabled() const {
  return _impl_.two_factor_auth_enabled_;
}
inline bool UserDetail::two_factor_auth_enabled() const {
  // @@protoc_insertion_point(field_get:clarifai.api.UserDetail.two_factor_auth_enabled)
  return _internal_two_factor_auth_enabled();
}
inline void UserDetail::_internal_set_two_factor_auth_enabled(bool value) {
  
  _impl_.two_factor_auth_enabled_ = value;
}
inline void UserDetail::set_two_factor_auth_enabled(bool value) {
  _internal_set_two_factor_auth_enabled(value);
  // @@protoc_insertion_point(field_set:clarifai.api.UserDetail.two_factor_auth_enabled)
}

// uint32 teams_count = 10;
inline void UserDetail::clear_teams_count() {
  _impl_.teams_count_ = 0u;
}
inline uint32_t UserDetail::_internal_teams_count() const {
  return _impl_.teams_count_;
}
inline uint32_t UserDetail::teams_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.UserDetail.teams_count)
  return _internal_teams_count();
}
inline void UserDetail::_internal_set_teams_count(uint32_t value) {
  
  _impl_.teams_count_ = value;
}
inline void UserDetail::set_teams_count(uint32_t value) {
  _internal_set_teams_count(value);
  // @@protoc_insertion_point(field_set:clarifai.api.UserDetail.teams_count)
}

// string country = 11;
inline void UserDetail::clear_country() {
  _impl_.country_.ClearToEmpty();
}
inline const std::string& UserDetail::country() const {
  // @@protoc_insertion_point(field_get:clarifai.api.UserDetail.country)
  return _internal_country();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserDetail::set_country(ArgT0&& arg0, ArgT... args) {
 
 _impl_.country_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.UserDetail.country)
}
inline std::string* UserDetail::mutable_country() {
  std::string* _s = _internal_mutable_country();
  // @@protoc_insertion_point(field_mutable:clarifai.api.UserDetail.country)
  return _s;
}
inline const std::string& UserDetail::_internal_country() const {
  return _impl_.country_.Get();
}
inline void UserDetail::_internal_set_country(const std::string& value) {
  
  _impl_.country_.Set(value, GetArenaForAllocation());
}
inline std::string* UserDetail::_internal_mutable_country() {
  
  return _impl_.country_.Mutable(GetArenaForAllocation());
}
inline std::string* UserDetail::release_country() {
  // @@protoc_insertion_point(field_release:clarifai.api.UserDetail.country)
  return _impl_.country_.Release();
}
inline void UserDetail::set_allocated_country(std::string* country) {
  if (country != nullptr) {
    
  } else {
    
  }
  _impl_.country_.SetAllocated(country, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.country_.IsDefault()) {
    _impl_.country_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.UserDetail.country)
}

// string state = 12;
inline void UserDetail::clear_state() {
  _impl_.state_.ClearToEmpty();
}
inline const std::string& UserDetail::state() const {
  // @@protoc_insertion_point(field_get:clarifai.api.UserDetail.state)
  return _internal_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserDetail::set_state(ArgT0&& arg0, ArgT... args) {
 
 _impl_.state_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.UserDetail.state)
}
inline std::string* UserDetail::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:clarifai.api.UserDetail.state)
  return _s;
}
inline const std::string& UserDetail::_internal_state() const {
  return _impl_.state_.Get();
}
inline void UserDetail::_internal_set_state(const std::string& value) {
  
  _impl_.state_.Set(value, GetArenaForAllocation());
}
inline std::string* UserDetail::_internal_mutable_state() {
  
  return _impl_.state_.Mutable(GetArenaForAllocation());
}
inline std::string* UserDetail::release_state() {
  // @@protoc_insertion_point(field_release:clarifai.api.UserDetail.state)
  return _impl_.state_.Release();
}
inline void UserDetail::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    
  } else {
    
  }
  _impl_.state_.SetAllocated(state, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.state_.IsDefault()) {
    _impl_.state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.UserDetail.state)
}

// -------------------------------------------------------------------

// EmailAddress

// string email = 1 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void EmailAddress::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& EmailAddress::email() const {
  // @@protoc_insertion_point(field_get:clarifai.api.EmailAddress.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EmailAddress::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.EmailAddress.email)
}
inline std::string* EmailAddress::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:clarifai.api.EmailAddress.email)
  return _s;
}
inline const std::string& EmailAddress::_internal_email() const {
  return _impl_.email_.Get();
}
inline void EmailAddress::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* EmailAddress::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* EmailAddress::release_email() {
  // @@protoc_insertion_point(field_release:clarifai.api.EmailAddress.email)
  return _impl_.email_.Release();
}
inline void EmailAddress::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.EmailAddress.email)
}

// bool primary = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void EmailAddress::clear_primary() {
  _impl_.primary_ = false;
}
inline bool EmailAddress::_internal_primary() const {
  return _impl_.primary_;
}
inline bool EmailAddress::primary() const {
  // @@protoc_insertion_point(field_get:clarifai.api.EmailAddress.primary)
  return _internal_primary();
}
inline void EmailAddress::_internal_set_primary(bool value) {
  
  _impl_.primary_ = value;
}
inline void EmailAddress::set_primary(bool value) {
  _internal_set_primary(value);
  // @@protoc_insertion_point(field_set:clarifai.api.EmailAddress.primary)
}

// bool verified = 3 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void EmailAddress::clear_verified() {
  _impl_.verified_ = false;
}
inline bool EmailAddress::_internal_verified() const {
  return _impl_.verified_;
}
inline bool EmailAddress::verified() const {
  // @@protoc_insertion_point(field_get:clarifai.api.EmailAddress.verified)
  return _internal_verified();
}
inline void EmailAddress::_internal_set_verified(bool value) {
  
  _impl_.verified_ = value;
}
inline void EmailAddress::set_verified(bool value) {
  _internal_set_verified(value);
  // @@protoc_insertion_point(field_set:clarifai.api.EmailAddress.verified)
}

// -------------------------------------------------------------------

// Password

// string plaintext = 1;
inline void Password::clear_plaintext() {
  _impl_.plaintext_.ClearToEmpty();
}
inline const std::string& Password::plaintext() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Password.plaintext)
  return _internal_plaintext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Password::set_plaintext(ArgT0&& arg0, ArgT... args) {
 
 _impl_.plaintext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Password.plaintext)
}
inline std::string* Password::mutable_plaintext() {
  std::string* _s = _internal_mutable_plaintext();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Password.plaintext)
  return _s;
}
inline const std::string& Password::_internal_plaintext() const {
  return _impl_.plaintext_.Get();
}
inline void Password::_internal_set_plaintext(const std::string& value) {
  
  _impl_.plaintext_.Set(value, GetArenaForAllocation());
}
inline std::string* Password::_internal_mutable_plaintext() {
  
  return _impl_.plaintext_.Mutable(GetArenaForAllocation());
}
inline std::string* Password::release_plaintext() {
  // @@protoc_insertion_point(field_release:clarifai.api.Password.plaintext)
  return _impl_.plaintext_.Release();
}
inline void Password::set_allocated_plaintext(std::string* plaintext) {
  if (plaintext != nullptr) {
    
  } else {
    
  }
  _impl_.plaintext_.SetAllocated(plaintext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.plaintext_.IsDefault()) {
    _impl_.plaintext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Password.plaintext)
}

// -------------------------------------------------------------------

// PasswordViolations

// bool minimum_length = 1;
inline void PasswordViolations::clear_minimum_length() {
  _impl_.minimum_length_ = false;
}
inline bool PasswordViolations::_internal_minimum_length() const {
  return _impl_.minimum_length_;
}
inline bool PasswordViolations::minimum_length() const {
  // @@protoc_insertion_point(field_get:clarifai.api.PasswordViolations.minimum_length)
  return _internal_minimum_length();
}
inline void PasswordViolations::_internal_set_minimum_length(bool value) {
  
  _impl_.minimum_length_ = value;
}
inline void PasswordViolations::set_minimum_length(bool value) {
  _internal_set_minimum_length(value);
  // @@protoc_insertion_point(field_set:clarifai.api.PasswordViolations.minimum_length)
}

// bool maximum_length = 2;
inline void PasswordViolations::clear_maximum_length() {
  _impl_.maximum_length_ = false;
}
inline bool PasswordViolations::_internal_maximum_length() const {
  return _impl_.maximum_length_;
}
inline bool PasswordViolations::maximum_length() const {
  // @@protoc_insertion_point(field_get:clarifai.api.PasswordViolations.maximum_length)
  return _internal_maximum_length();
}
inline void PasswordViolations::_internal_set_maximum_length(bool value) {
  
  _impl_.maximum_length_ = value;
}
inline void PasswordViolations::set_maximum_length(bool value) {
  _internal_set_maximum_length(value);
  // @@protoc_insertion_point(field_set:clarifai.api.PasswordViolations.maximum_length)
}

// bool upper_case_needed = 3;
inline void PasswordViolations::clear_upper_case_needed() {
  _impl_.upper_case_needed_ = false;
}
inline bool PasswordViolations::_internal_upper_case_needed() const {
  return _impl_.upper_case_needed_;
}
inline bool PasswordViolations::upper_case_needed() const {
  // @@protoc_insertion_point(field_get:clarifai.api.PasswordViolations.upper_case_needed)
  return _internal_upper_case_needed();
}
inline void PasswordViolations::_internal_set_upper_case_needed(bool value) {
  
  _impl_.upper_case_needed_ = value;
}
inline void PasswordViolations::set_upper_case_needed(bool value) {
  _internal_set_upper_case_needed(value);
  // @@protoc_insertion_point(field_set:clarifai.api.PasswordViolations.upper_case_needed)
}

// bool lower_case_needed = 4;
inline void PasswordViolations::clear_lower_case_needed() {
  _impl_.lower_case_needed_ = false;
}
inline bool PasswordViolations::_internal_lower_case_needed() const {
  return _impl_.lower_case_needed_;
}
inline bool PasswordViolations::lower_case_needed() const {
  // @@protoc_insertion_point(field_get:clarifai.api.PasswordViolations.lower_case_needed)
  return _internal_lower_case_needed();
}
inline void PasswordViolations::_internal_set_lower_case_needed(bool value) {
  
  _impl_.lower_case_needed_ = value;
}
inline void PasswordViolations::set_lower_case_needed(bool value) {
  _internal_set_lower_case_needed(value);
  // @@protoc_insertion_point(field_set:clarifai.api.PasswordViolations.lower_case_needed)
}

// bool numeric_needed = 5;
inline void PasswordViolations::clear_numeric_needed() {
  _impl_.numeric_needed_ = false;
}
inline bool PasswordViolations::_internal_numeric_needed() const {
  return _impl_.numeric_needed_;
}
inline bool PasswordViolations::numeric_needed() const {
  // @@protoc_insertion_point(field_get:clarifai.api.PasswordViolations.numeric_needed)
  return _internal_numeric_needed();
}
inline void PasswordViolations::_internal_set_numeric_needed(bool value) {
  
  _impl_.numeric_needed_ = value;
}
inline void PasswordViolations::set_numeric_needed(bool value) {
  _internal_set_numeric_needed(value);
  // @@protoc_insertion_point(field_set:clarifai.api.PasswordViolations.numeric_needed)
}

// bool non_alphanumeric_needed = 6;
inline void PasswordViolations::clear_non_alphanumeric_needed() {
  _impl_.non_alphanumeric_needed_ = false;
}
inline bool PasswordViolations::_internal_non_alphanumeric_needed() const {
  return _impl_.non_alphanumeric_needed_;
}
inline bool PasswordViolations::non_alphanumeric_needed() const {
  // @@protoc_insertion_point(field_get:clarifai.api.PasswordViolations.non_alphanumeric_needed)
  return _internal_non_alphanumeric_needed();
}
inline void PasswordViolations::_internal_set_non_alphanumeric_needed(bool value) {
  
  _impl_.non_alphanumeric_needed_ = value;
}
inline void PasswordViolations::set_non_alphanumeric_needed(bool value) {
  _internal_set_non_alphanumeric_needed(value);
  // @@protoc_insertion_point(field_set:clarifai.api.PasswordViolations.non_alphanumeric_needed)
}

// bool password_reuse = 7;
inline void PasswordViolations::clear_password_reuse() {
  _impl_.password_reuse_ = false;
}
inline bool PasswordViolations::_internal_password_reuse() const {
  return _impl_.password_reuse_;
}
inline bool PasswordViolations::password_reuse() const {
  // @@protoc_insertion_point(field_get:clarifai.api.PasswordViolations.password_reuse)
  return _internal_password_reuse();
}
inline void PasswordViolations::_internal_set_password_reuse(bool value) {
  
  _impl_.password_reuse_ = value;
}
inline void PasswordViolations::set_password_reuse(bool value) {
  _internal_set_password_reuse(value);
  // @@protoc_insertion_point(field_set:clarifai.api.PasswordViolations.password_reuse)
}

// bool exclude_names = 8;
inline void PasswordViolations::clear_exclude_names() {
  _impl_.exclude_names_ = false;
}
inline bool PasswordViolations::_internal_exclude_names() const {
  return _impl_.exclude_names_;
}
inline bool PasswordViolations::exclude_names() const {
  // @@protoc_insertion_point(field_get:clarifai.api.PasswordViolations.exclude_names)
  return _internal_exclude_names();
}
inline void PasswordViolations::_internal_set_exclude_names(bool value) {
  
  _impl_.exclude_names_ = value;
}
inline void PasswordViolations::set_exclude_names(bool value) {
  _internal_set_exclude_names(value);
  // @@protoc_insertion_point(field_set:clarifai.api.PasswordViolations.exclude_names)
}

// bool exclude_email = 9;
inline void PasswordViolations::clear_exclude_email() {
  _impl_.exclude_email_ = false;
}
inline bool PasswordViolations::_internal_exclude_email() const {
  return _impl_.exclude_email_;
}
inline bool PasswordViolations::exclude_email() const {
  // @@protoc_insertion_point(field_get:clarifai.api.PasswordViolations.exclude_email)
  return _internal_exclude_email();
}
inline void PasswordViolations::_internal_set_exclude_email(bool value) {
  
  _impl_.exclude_email_ = value;
}
inline void PasswordViolations::set_exclude_email(bool value) {
  _internal_set_exclude_email(value);
  // @@protoc_insertion_point(field_set:clarifai.api.PasswordViolations.exclude_email)
}

// bool no_confusing_letters = 10;
inline void PasswordViolations::clear_no_confusing_letters() {
  _impl_.no_confusing_letters_ = false;
}
inline bool PasswordViolations::_internal_no_confusing_letters() const {
  return _impl_.no_confusing_letters_;
}
inline bool PasswordViolations::no_confusing_letters() const {
  // @@protoc_insertion_point(field_get:clarifai.api.PasswordViolations.no_confusing_letters)
  return _internal_no_confusing_letters();
}
inline void PasswordViolations::_internal_set_no_confusing_letters(bool value) {
  
  _impl_.no_confusing_letters_ = value;
}
inline void PasswordViolations::set_no_confusing_letters(bool value) {
  _internal_set_no_confusing_letters(value);
  // @@protoc_insertion_point(field_set:clarifai.api.PasswordViolations.no_confusing_letters)
}

// bool no_simple_passwords = 11;
inline void PasswordViolations::clear_no_simple_passwords() {
  _impl_.no_simple_passwords_ = false;
}
inline bool PasswordViolations::_internal_no_simple_passwords() const {
  return _impl_.no_simple_passwords_;
}
inline bool PasswordViolations::no_simple_passwords() const {
  // @@protoc_insertion_point(field_get:clarifai.api.PasswordViolations.no_simple_passwords)
  return _internal_no_simple_passwords();
}
inline void PasswordViolations::_internal_set_no_simple_passwords(bool value) {
  
  _impl_.no_simple_passwords_ = value;
}
inline void PasswordViolations::set_no_simple_passwords(bool value) {
  _internal_set_no_simple_passwords(value);
  // @@protoc_insertion_point(field_set:clarifai.api.PasswordViolations.no_simple_passwords)
}

// bool no_common_vocabs = 12;
inline void PasswordViolations::clear_no_common_vocabs() {
  _impl_.no_common_vocabs_ = false;
}
inline bool PasswordViolations::_internal_no_common_vocabs() const {
  return _impl_.no_common_vocabs_;
}
inline bool PasswordViolations::no_common_vocabs() const {
  // @@protoc_insertion_point(field_get:clarifai.api.PasswordViolations.no_common_vocabs)
  return _internal_no_common_vocabs();
}
inline void PasswordViolations::_internal_set_no_common_vocabs(bool value) {
  
  _impl_.no_common_vocabs_ = value;
}
inline void PasswordViolations::set_no_common_vocabs(bool value) {
  _internal_set_no_common_vocabs(value);
  // @@protoc_insertion_point(field_set:clarifai.api.PasswordViolations.no_common_vocabs)
}

// bool no_overlap_with_old = 13;
inline void PasswordViolations::clear_no_overlap_with_old() {
  _impl_.no_overlap_with_old_ = false;
}
inline bool PasswordViolations::_internal_no_overlap_with_old() const {
  return _impl_.no_overlap_with_old_;
}
inline bool PasswordViolations::no_overlap_with_old() const {
  // @@protoc_insertion_point(field_get:clarifai.api.PasswordViolations.no_overlap_with_old)
  return _internal_no_overlap_with_old();
}
inline void PasswordViolations::_internal_set_no_overlap_with_old(bool value) {
  
  _impl_.no_overlap_with_old_ = value;
}
inline void PasswordViolations::set_no_overlap_with_old(bool value) {
  _internal_set_no_overlap_with_old(value);
  // @@protoc_insertion_point(field_set:clarifai.api.PasswordViolations.no_overlap_with_old)
}

// bool password_lifespan = 14;
inline void PasswordViolations::clear_password_lifespan() {
  _impl_.password_lifespan_ = false;
}
inline bool PasswordViolations::_internal_password_lifespan() const {
  return _impl_.password_lifespan_;
}
inline bool PasswordViolations::password_lifespan() const {
  // @@protoc_insertion_point(field_get:clarifai.api.PasswordViolations.password_lifespan)
  return _internal_password_lifespan();
}
inline void PasswordViolations::_internal_set_password_lifespan(bool value) {
  
  _impl_.password_lifespan_ = value;
}
inline void PasswordViolations::set_password_lifespan(bool value) {
  _internal_set_password_lifespan(value);
  // @@protoc_insertion_point(field_set:clarifai.api.PasswordViolations.password_lifespan)
}

// -------------------------------------------------------------------

// Video

// string url = 1;
inline void Video::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& Video::url() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Video.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Video::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Video.url)
}
inline std::string* Video::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Video.url)
  return _s;
}
inline const std::string& Video::_internal_url() const {
  return _impl_.url_.Get();
}
inline void Video::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* Video::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* Video::release_url() {
  // @@protoc_insertion_point(field_release:clarifai.api.Video.url)
  return _impl_.url_.Release();
}
inline void Video::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Video.url)
}

// bytes base64 = 2;
inline void Video::clear_base64() {
  _impl_.base64_.ClearToEmpty();
}
inline const std::string& Video::base64() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Video.base64)
  return _internal_base64();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Video::set_base64(ArgT0&& arg0, ArgT... args) {
 
 _impl_.base64_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Video.base64)
}
inline std::string* Video::mutable_base64() {
  std::string* _s = _internal_mutable_base64();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Video.base64)
  return _s;
}
inline const std::string& Video::_internal_base64() const {
  return _impl_.base64_.Get();
}
inline void Video::_internal_set_base64(const std::string& value) {
  
  _impl_.base64_.Set(value, GetArenaForAllocation());
}
inline std::string* Video::_internal_mutable_base64() {
  
  return _impl_.base64_.Mutable(GetArenaForAllocation());
}
inline std::string* Video::release_base64() {
  // @@protoc_insertion_point(field_release:clarifai.api.Video.base64)
  return _impl_.base64_.Release();
}
inline void Video::set_allocated_base64(std::string* base64) {
  if (base64 != nullptr) {
    
  } else {
    
  }
  _impl_.base64_.SetAllocated(base64, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.base64_.IsDefault()) {
    _impl_.base64_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Video.base64)
}

// bool allow_duplicate_url = 4;
inline void Video::clear_allow_duplicate_url() {
  _impl_.allow_duplicate_url_ = false;
}
inline bool Video::_internal_allow_duplicate_url() const {
  return _impl_.allow_duplicate_url_;
}
inline bool Video::allow_duplicate_url() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Video.allow_duplicate_url)
  return _internal_allow_duplicate_url();
}
inline void Video::_internal_set_allow_duplicate_url(bool value) {
  
  _impl_.allow_duplicate_url_ = value;
}
inline void Video::set_allow_duplicate_url(bool value) {
  _internal_set_allow_duplicate_url(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Video.allow_duplicate_url)
}

// string thumbnail_url = 5;
inline void Video::clear_thumbnail_url() {
  _impl_.thumbnail_url_.ClearToEmpty();
}
inline const std::string& Video::thumbnail_url() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Video.thumbnail_url)
  return _internal_thumbnail_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Video::set_thumbnail_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.thumbnail_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Video.thumbnail_url)
}
inline std::string* Video::mutable_thumbnail_url() {
  std::string* _s = _internal_mutable_thumbnail_url();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Video.thumbnail_url)
  return _s;
}
inline const std::string& Video::_internal_thumbnail_url() const {
  return _impl_.thumbnail_url_.Get();
}
inline void Video::_internal_set_thumbnail_url(const std::string& value) {
  
  _impl_.thumbnail_url_.Set(value, GetArenaForAllocation());
}
inline std::string* Video::_internal_mutable_thumbnail_url() {
  
  return _impl_.thumbnail_url_.Mutable(GetArenaForAllocation());
}
inline std::string* Video::release_thumbnail_url() {
  // @@protoc_insertion_point(field_release:clarifai.api.Video.thumbnail_url)
  return _impl_.thumbnail_url_.Release();
}
inline void Video::set_allocated_thumbnail_url(std::string* thumbnail_url) {
  if (thumbnail_url != nullptr) {
    
  } else {
    
  }
  _impl_.thumbnail_url_.SetAllocated(thumbnail_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnail_url_.IsDefault()) {
    _impl_.thumbnail_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Video.thumbnail_url)
}

// .clarifai.api.HostedURL hosted = 6;
inline bool Video::_internal_has_hosted() const {
  return this != internal_default_instance() && _impl_.hosted_ != nullptr;
}
inline bool Video::has_hosted() const {
  return _internal_has_hosted();
}
inline void Video::clear_hosted() {
  if (GetArenaForAllocation() == nullptr && _impl_.hosted_ != nullptr) {
    delete _impl_.hosted_;
  }
  _impl_.hosted_ = nullptr;
}
inline const ::clarifai::api::HostedURL& Video::_internal_hosted() const {
  const ::clarifai::api::HostedURL* p = _impl_.hosted_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::HostedURL&>(
      ::clarifai::api::_HostedURL_default_instance_);
}
inline const ::clarifai::api::HostedURL& Video::hosted() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Video.hosted)
  return _internal_hosted();
}
inline void Video::unsafe_arena_set_allocated_hosted(
    ::clarifai::api::HostedURL* hosted) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hosted_);
  }
  _impl_.hosted_ = hosted;
  if (hosted) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Video.hosted)
}
inline ::clarifai::api::HostedURL* Video::release_hosted() {
  
  ::clarifai::api::HostedURL* temp = _impl_.hosted_;
  _impl_.hosted_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::HostedURL* Video::unsafe_arena_release_hosted() {
  // @@protoc_insertion_point(field_release:clarifai.api.Video.hosted)
  
  ::clarifai::api::HostedURL* temp = _impl_.hosted_;
  _impl_.hosted_ = nullptr;
  return temp;
}
inline ::clarifai::api::HostedURL* Video::_internal_mutable_hosted() {
  
  if (_impl_.hosted_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::HostedURL>(GetArenaForAllocation());
    _impl_.hosted_ = p;
  }
  return _impl_.hosted_;
}
inline ::clarifai::api::HostedURL* Video::mutable_hosted() {
  ::clarifai::api::HostedURL* _msg = _internal_mutable_hosted();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Video.hosted)
  return _msg;
}
inline void Video::set_allocated_hosted(::clarifai::api::HostedURL* hosted) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hosted_;
  }
  if (hosted) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hosted);
    if (message_arena != submessage_arena) {
      hosted = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hosted, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.hosted_ = hosted;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Video.hosted)
}

// .clarifai.api.VideoInfo video_info = 7;
inline bool Video::_internal_has_video_info() const {
  return this != internal_default_instance() && _impl_.video_info_ != nullptr;
}
inline bool Video::has_video_info() const {
  return _internal_has_video_info();
}
inline void Video::clear_video_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.video_info_ != nullptr) {
    delete _impl_.video_info_;
  }
  _impl_.video_info_ = nullptr;
}
inline const ::clarifai::api::VideoInfo& Video::_internal_video_info() const {
  const ::clarifai::api::VideoInfo* p = _impl_.video_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::VideoInfo&>(
      ::clarifai::api::_VideoInfo_default_instance_);
}
inline const ::clarifai::api::VideoInfo& Video::video_info() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Video.video_info)
  return _internal_video_info();
}
inline void Video::unsafe_arena_set_allocated_video_info(
    ::clarifai::api::VideoInfo* video_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.video_info_);
  }
  _impl_.video_info_ = video_info;
  if (video_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Video.video_info)
}
inline ::clarifai::api::VideoInfo* Video::release_video_info() {
  
  ::clarifai::api::VideoInfo* temp = _impl_.video_info_;
  _impl_.video_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::VideoInfo* Video::unsafe_arena_release_video_info() {
  // @@protoc_insertion_point(field_release:clarifai.api.Video.video_info)
  
  ::clarifai::api::VideoInfo* temp = _impl_.video_info_;
  _impl_.video_info_ = nullptr;
  return temp;
}
inline ::clarifai::api::VideoInfo* Video::_internal_mutable_video_info() {
  
  if (_impl_.video_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::VideoInfo>(GetArenaForAllocation());
    _impl_.video_info_ = p;
  }
  return _impl_.video_info_;
}
inline ::clarifai::api::VideoInfo* Video::mutable_video_info() {
  ::clarifai::api::VideoInfo* _msg = _internal_mutable_video_info();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Video.video_info)
  return _msg;
}
inline void Video::set_allocated_video_info(::clarifai::api::VideoInfo* video_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.video_info_;
  }
  if (video_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(video_info);
    if (message_arena != submessage_arena) {
      video_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, video_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.video_info_ = video_info;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Video.video_info)
}

// -------------------------------------------------------------------

// VideoInfo

// int32 width = 1;
inline void VideoInfo::clear_width() {
  _impl_.width_ = 0;
}
inline int32_t VideoInfo::_internal_width() const {
  return _impl_.width_;
}
inline int32_t VideoInfo::width() const {
  // @@protoc_insertion_point(field_get:clarifai.api.VideoInfo.width)
  return _internal_width();
}
inline void VideoInfo::_internal_set_width(int32_t value) {
  
  _impl_.width_ = value;
}
inline void VideoInfo::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:clarifai.api.VideoInfo.width)
}

// int32 height = 2;
inline void VideoInfo::clear_height() {
  _impl_.height_ = 0;
}
inline int32_t VideoInfo::_internal_height() const {
  return _impl_.height_;
}
inline int32_t VideoInfo::height() const {
  // @@protoc_insertion_point(field_get:clarifai.api.VideoInfo.height)
  return _internal_height();
}
inline void VideoInfo::_internal_set_height(int32_t value) {
  
  _impl_.height_ = value;
}
inline void VideoInfo::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:clarifai.api.VideoInfo.height)
}

// float fps = 3;
inline void VideoInfo::clear_fps() {
  _impl_.fps_ = 0;
}
inline float VideoInfo::_internal_fps() const {
  return _impl_.fps_;
}
inline float VideoInfo::fps() const {
  // @@protoc_insertion_point(field_get:clarifai.api.VideoInfo.fps)
  return _internal_fps();
}
inline void VideoInfo::_internal_set_fps(float value) {
  
  _impl_.fps_ = value;
}
inline void VideoInfo::set_fps(float value) {
  _internal_set_fps(value);
  // @@protoc_insertion_point(field_set:clarifai.api.VideoInfo.fps)
}

// string video_format = 4;
inline void VideoInfo::clear_video_format() {
  _impl_.video_format_.ClearToEmpty();
}
inline const std::string& VideoInfo::video_format() const {
  // @@protoc_insertion_point(field_get:clarifai.api.VideoInfo.video_format)
  return _internal_video_format();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoInfo::set_video_format(ArgT0&& arg0, ArgT... args) {
 
 _impl_.video_format_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.VideoInfo.video_format)
}
inline std::string* VideoInfo::mutable_video_format() {
  std::string* _s = _internal_mutable_video_format();
  // @@protoc_insertion_point(field_mutable:clarifai.api.VideoInfo.video_format)
  return _s;
}
inline const std::string& VideoInfo::_internal_video_format() const {
  return _impl_.video_format_.Get();
}
inline void VideoInfo::_internal_set_video_format(const std::string& value) {
  
  _impl_.video_format_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoInfo::_internal_mutable_video_format() {
  
  return _impl_.video_format_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoInfo::release_video_format() {
  // @@protoc_insertion_point(field_release:clarifai.api.VideoInfo.video_format)
  return _impl_.video_format_.Release();
}
inline void VideoInfo::set_allocated_video_format(std::string* video_format) {
  if (video_format != nullptr) {
    
  } else {
    
  }
  _impl_.video_format_.SetAllocated(video_format, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.video_format_.IsDefault()) {
    _impl_.video_format_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.VideoInfo.video_format)
}

// int32 bit_rate = 5;
inline void VideoInfo::clear_bit_rate() {
  _impl_.bit_rate_ = 0;
}
inline int32_t VideoInfo::_internal_bit_rate() const {
  return _impl_.bit_rate_;
}
inline int32_t VideoInfo::bit_rate() const {
  // @@protoc_insertion_point(field_get:clarifai.api.VideoInfo.bit_rate)
  return _internal_bit_rate();
}
inline void VideoInfo::_internal_set_bit_rate(int32_t value) {
  
  _impl_.bit_rate_ = value;
}
inline void VideoInfo::set_bit_rate(int32_t value) {
  _internal_set_bit_rate(value);
  // @@protoc_insertion_point(field_set:clarifai.api.VideoInfo.bit_rate)
}

// int32 frame_count = 6;
inline void VideoInfo::clear_frame_count() {
  _impl_.frame_count_ = 0;
}
inline int32_t VideoInfo::_internal_frame_count() const {
  return _impl_.frame_count_;
}
inline int32_t VideoInfo::frame_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.VideoInfo.frame_count)
  return _internal_frame_count();
}
inline void VideoInfo::_internal_set_frame_count(int32_t value) {
  
  _impl_.frame_count_ = value;
}
inline void VideoInfo::set_frame_count(int32_t value) {
  _internal_set_frame_count(value);
  // @@protoc_insertion_point(field_set:clarifai.api.VideoInfo.frame_count)
}

// float duration_seconds = 7;
inline void VideoInfo::clear_duration_seconds() {
  _impl_.duration_seconds_ = 0;
}
inline float VideoInfo::_internal_duration_seconds() const {
  return _impl_.duration_seconds_;
}
inline float VideoInfo::duration_seconds() const {
  // @@protoc_insertion_point(field_get:clarifai.api.VideoInfo.duration_seconds)
  return _internal_duration_seconds();
}
inline void VideoInfo::_internal_set_duration_seconds(float value) {
  
  _impl_.duration_seconds_ = value;
}
inline void VideoInfo::set_duration_seconds(float value) {
  _internal_set_duration_seconds(value);
  // @@protoc_insertion_point(field_set:clarifai.api.VideoInfo.duration_seconds)
}

// -------------------------------------------------------------------

// Workflow

// string id = 1;
inline void Workflow::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Workflow::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Workflow.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Workflow::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Workflow.id)
}
inline std::string* Workflow::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Workflow.id)
  return _s;
}
inline const std::string& Workflow::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Workflow::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Workflow::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Workflow::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Workflow.id)
  return _impl_.id_.Release();
}
inline void Workflow::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Workflow.id)
}

// string app_id = 2;
inline void Workflow::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& Workflow::app_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Workflow.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Workflow::set_app_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.app_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Workflow.app_id)
}
inline std::string* Workflow::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Workflow.app_id)
  return _s;
}
inline const std::string& Workflow::_internal_app_id() const {
  return _impl_.app_id_.Get();
}
inline void Workflow::_internal_set_app_id(const std::string& value) {
  
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Workflow::_internal_mutable_app_id() {
  
  return _impl_.app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Workflow::release_app_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Workflow.app_id)
  return _impl_.app_id_.Release();
}
inline void Workflow::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    
  } else {
    
  }
  _impl_.app_id_.SetAllocated(app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Workflow.app_id)
}

// .google.protobuf.Timestamp created_at = 3;
inline bool Workflow::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool Workflow::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Workflow::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Workflow::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Workflow.created_at)
  return _internal_created_at();
}
inline void Workflow::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Workflow.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Workflow::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Workflow::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.Workflow.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Workflow::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Workflow::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Workflow.created_at)
  return _msg;
}
inline void Workflow::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Workflow.created_at)
}

// repeated .clarifai.api.WorkflowNode nodes = 4;
inline int Workflow::_internal_nodes_size() const {
  return _impl_.nodes_.size();
}
inline int Workflow::nodes_size() const {
  return _internal_nodes_size();
}
inline void Workflow::clear_nodes() {
  _impl_.nodes_.Clear();
}
inline ::clarifai::api::WorkflowNode* Workflow::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Workflow.nodes)
  return _impl_.nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::WorkflowNode >*
Workflow::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Workflow.nodes)
  return &_impl_.nodes_;
}
inline const ::clarifai::api::WorkflowNode& Workflow::_internal_nodes(int index) const {
  return _impl_.nodes_.Get(index);
}
inline const ::clarifai::api::WorkflowNode& Workflow::nodes(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Workflow.nodes)
  return _internal_nodes(index);
}
inline ::clarifai::api::WorkflowNode* Workflow::_internal_add_nodes() {
  return _impl_.nodes_.Add();
}
inline ::clarifai::api::WorkflowNode* Workflow::add_nodes() {
  ::clarifai::api::WorkflowNode* _add = _internal_add_nodes();
  // @@protoc_insertion_point(field_add:clarifai.api.Workflow.nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::WorkflowNode >&
Workflow::nodes() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Workflow.nodes)
  return _impl_.nodes_;
}

// .google.protobuf.Struct metadata = 5;
inline bool Workflow::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool Workflow::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Workflow::_internal_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Workflow::metadata() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Workflow.metadata)
  return _internal_metadata();
}
inline void Workflow::unsafe_arena_set_allocated_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Workflow.metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Workflow::release_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Workflow::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:clarifai.api.Workflow.metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Workflow::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Workflow::mutable_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Workflow.metadata)
  return _msg;
}
inline void Workflow::set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Workflow.metadata)
}

// .clarifai.api.Visibility visibility = 6;
inline bool Workflow::_internal_has_visibility() const {
  return this != internal_default_instance() && _impl_.visibility_ != nullptr;
}
inline bool Workflow::has_visibility() const {
  return _internal_has_visibility();
}
inline void Workflow::clear_visibility() {
  if (GetArenaForAllocation() == nullptr && _impl_.visibility_ != nullptr) {
    delete _impl_.visibility_;
  }
  _impl_.visibility_ = nullptr;
}
inline const ::clarifai::api::Visibility& Workflow::_internal_visibility() const {
  const ::clarifai::api::Visibility* p = _impl_.visibility_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Visibility&>(
      ::clarifai::api::_Visibility_default_instance_);
}
inline const ::clarifai::api::Visibility& Workflow::visibility() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Workflow.visibility)
  return _internal_visibility();
}
inline void Workflow::unsafe_arena_set_allocated_visibility(
    ::clarifai::api::Visibility* visibility) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visibility_);
  }
  _impl_.visibility_ = visibility;
  if (visibility) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Workflow.visibility)
}
inline ::clarifai::api::Visibility* Workflow::release_visibility() {
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Visibility* Workflow::unsafe_arena_release_visibility() {
  // @@protoc_insertion_point(field_release:clarifai.api.Workflow.visibility)
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
  return temp;
}
inline ::clarifai::api::Visibility* Workflow::_internal_mutable_visibility() {
  
  if (_impl_.visibility_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Visibility>(GetArenaForAllocation());
    _impl_.visibility_ = p;
  }
  return _impl_.visibility_;
}
inline ::clarifai::api::Visibility* Workflow::mutable_visibility() {
  ::clarifai::api::Visibility* _msg = _internal_mutable_visibility();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Workflow.visibility)
  return _msg;
}
inline void Workflow::set_allocated_visibility(::clarifai::api::Visibility* visibility) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.visibility_;
  }
  if (visibility) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(visibility);
    if (message_arena != submessage_arena) {
      visibility = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visibility, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.visibility_ = visibility;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Workflow.visibility)
}

// string user_id = 7;
inline void Workflow::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& Workflow::user_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Workflow.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Workflow::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Workflow.user_id)
}
inline std::string* Workflow::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Workflow.user_id)
  return _s;
}
inline const std::string& Workflow::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void Workflow::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Workflow::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Workflow::release_user_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Workflow.user_id)
  return _impl_.user_id_.Release();
}
inline void Workflow::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Workflow.user_id)
}

// .google.protobuf.Timestamp modified_at = 8;
inline bool Workflow::_internal_has_modified_at() const {
  return this != internal_default_instance() && _impl_.modified_at_ != nullptr;
}
inline bool Workflow::has_modified_at() const {
  return _internal_has_modified_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Workflow::_internal_modified_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.modified_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Workflow::modified_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Workflow.modified_at)
  return _internal_modified_at();
}
inline void Workflow::unsafe_arena_set_allocated_modified_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  _impl_.modified_at_ = modified_at;
  if (modified_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Workflow.modified_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Workflow::release_modified_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Workflow::unsafe_arena_release_modified_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.Workflow.modified_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Workflow::_internal_mutable_modified_at() {
  
  if (_impl_.modified_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.modified_at_ = p;
  }
  return _impl_.modified_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Workflow::mutable_modified_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_modified_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Workflow.modified_at)
  return _msg;
}
inline void Workflow::set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  if (modified_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(modified_at));
    if (message_arena != submessage_arena) {
      modified_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modified_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.modified_at_ = modified_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Workflow.modified_at)
}

// .clarifai.api.WorkflowVersion version = 9;
inline bool Workflow::_internal_has_version() const {
  return this != internal_default_instance() && _impl_.version_ != nullptr;
}
inline bool Workflow::has_version() const {
  return _internal_has_version();
}
inline void Workflow::clear_version() {
  if (GetArenaForAllocation() == nullptr && _impl_.version_ != nullptr) {
    delete _impl_.version_;
  }
  _impl_.version_ = nullptr;
}
inline const ::clarifai::api::WorkflowVersion& Workflow::_internal_version() const {
  const ::clarifai::api::WorkflowVersion* p = _impl_.version_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::WorkflowVersion&>(
      ::clarifai::api::_WorkflowVersion_default_instance_);
}
inline const ::clarifai::api::WorkflowVersion& Workflow::version() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Workflow.version)
  return _internal_version();
}
inline void Workflow::unsafe_arena_set_allocated_version(
    ::clarifai::api::WorkflowVersion* version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.version_);
  }
  _impl_.version_ = version;
  if (version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Workflow.version)
}
inline ::clarifai::api::WorkflowVersion* Workflow::release_version() {
  
  ::clarifai::api::WorkflowVersion* temp = _impl_.version_;
  _impl_.version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::WorkflowVersion* Workflow::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_release:clarifai.api.Workflow.version)
  
  ::clarifai::api::WorkflowVersion* temp = _impl_.version_;
  _impl_.version_ = nullptr;
  return temp;
}
inline ::clarifai::api::WorkflowVersion* Workflow::_internal_mutable_version() {
  
  if (_impl_.version_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::WorkflowVersion>(GetArenaForAllocation());
    _impl_.version_ = p;
  }
  return _impl_.version_;
}
inline ::clarifai::api::WorkflowVersion* Workflow::mutable_version() {
  ::clarifai::api::WorkflowVersion* _msg = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Workflow.version)
  return _msg;
}
inline void Workflow::set_allocated_version(::clarifai::api::WorkflowVersion* version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.version_;
  }
  if (version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(version);
    if (message_arena != submessage_arena) {
      version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.version_ = version;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Workflow.version)
}

// bool is_starred = 10;
inline void Workflow::clear_is_starred() {
  _impl_.is_starred_ = false;
}
inline bool Workflow::_internal_is_starred() const {
  return _impl_.is_starred_;
}
inline bool Workflow::is_starred() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Workflow.is_starred)
  return _internal_is_starred();
}
inline void Workflow::_internal_set_is_starred(bool value) {
  
  _impl_.is_starred_ = value;
}
inline void Workflow::set_is_starred(bool value) {
  _internal_set_is_starred(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Workflow.is_starred)
}

// int32 star_count = 11;
inline void Workflow::clear_star_count() {
  _impl_.star_count_ = 0;
}
inline int32_t Workflow::_internal_star_count() const {
  return _impl_.star_count_;
}
inline int32_t Workflow::star_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Workflow.star_count)
  return _internal_star_count();
}
inline void Workflow::_internal_set_star_count(int32_t value) {
  
  _impl_.star_count_ = value;
}
inline void Workflow::set_star_count(int32_t value) {
  _internal_set_star_count(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Workflow.star_count)
}

// string description = 12;
inline void Workflow::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Workflow::description() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Workflow.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Workflow::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Workflow.description)
}
inline std::string* Workflow::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Workflow.description)
  return _s;
}
inline const std::string& Workflow::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Workflow::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Workflow::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Workflow::release_description() {
  // @@protoc_insertion_point(field_release:clarifai.api.Workflow.description)
  return _impl_.description_.Release();
}
inline void Workflow::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Workflow.description)
}

// string notes = 13;
inline void Workflow::clear_notes() {
  _impl_.notes_.ClearToEmpty();
}
inline const std::string& Workflow::notes() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Workflow.notes)
  return _internal_notes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Workflow::set_notes(ArgT0&& arg0, ArgT... args) {
 
 _impl_.notes_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Workflow.notes)
}
inline std::string* Workflow::mutable_notes() {
  std::string* _s = _internal_mutable_notes();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Workflow.notes)
  return _s;
}
inline const std::string& Workflow::_internal_notes() const {
  return _impl_.notes_.Get();
}
inline void Workflow::_internal_set_notes(const std::string& value) {
  
  _impl_.notes_.Set(value, GetArenaForAllocation());
}
inline std::string* Workflow::_internal_mutable_notes() {
  
  return _impl_.notes_.Mutable(GetArenaForAllocation());
}
inline std::string* Workflow::release_notes() {
  // @@protoc_insertion_point(field_release:clarifai.api.Workflow.notes)
  return _impl_.notes_.Release();
}
inline void Workflow::set_allocated_notes(std::string* notes) {
  if (notes != nullptr) {
    
  } else {
    
  }
  _impl_.notes_.SetAllocated(notes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.notes_.IsDefault()) {
    _impl_.notes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Workflow.notes)
}

// repeated string use_cases = 14 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline int Workflow::_internal_use_cases_size() const {
  return _impl_.use_cases_.size();
}
inline int Workflow::use_cases_size() const {
  return _internal_use_cases_size();
}
inline void Workflow::clear_use_cases() {
  _impl_.use_cases_.Clear();
}
inline std::string* Workflow::add_use_cases() {
  std::string* _s = _internal_add_use_cases();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.Workflow.use_cases)
  return _s;
}
inline const std::string& Workflow::_internal_use_cases(int index) const {
  return _impl_.use_cases_.Get(index);
}
inline const std::string& Workflow::use_cases(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Workflow.use_cases)
  return _internal_use_cases(index);
}
inline std::string* Workflow::mutable_use_cases(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Workflow.use_cases)
  return _impl_.use_cases_.Mutable(index);
}
inline void Workflow::set_use_cases(int index, const std::string& value) {
  _impl_.use_cases_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Workflow.use_cases)
}
inline void Workflow::set_use_cases(int index, std::string&& value) {
  _impl_.use_cases_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.Workflow.use_cases)
}
inline void Workflow::set_use_cases(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.use_cases_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.Workflow.use_cases)
}
inline void Workflow::set_use_cases(int index, const char* value, size_t size) {
  _impl_.use_cases_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.Workflow.use_cases)
}
inline std::string* Workflow::_internal_add_use_cases() {
  return _impl_.use_cases_.Add();
}
inline void Workflow::add_use_cases(const std::string& value) {
  _impl_.use_cases_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.Workflow.use_cases)
}
inline void Workflow::add_use_cases(std::string&& value) {
  _impl_.use_cases_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.Workflow.use_cases)
}
inline void Workflow::add_use_cases(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.use_cases_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.Workflow.use_cases)
}
inline void Workflow::add_use_cases(const char* value, size_t size) {
  _impl_.use_cases_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.Workflow.use_cases)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Workflow::use_cases() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Workflow.use_cases)
  return _impl_.use_cases_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Workflow::mutable_use_cases() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Workflow.use_cases)
  return &_impl_.use_cases_;
}

// repeated string check_consents = 15 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline int Workflow::_internal_check_consents_size() const {
  return _impl_.check_consents_.size();
}
inline int Workflow::check_consents_size() const {
  return _internal_check_consents_size();
}
inline void Workflow::clear_check_consents() {
  _impl_.check_consents_.Clear();
}
inline std::string* Workflow::add_check_consents() {
  std::string* _s = _internal_add_check_consents();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.Workflow.check_consents)
  return _s;
}
inline const std::string& Workflow::_internal_check_consents(int index) const {
  return _impl_.check_consents_.Get(index);
}
inline const std::string& Workflow::check_consents(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Workflow.check_consents)
  return _internal_check_consents(index);
}
inline std::string* Workflow::mutable_check_consents(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Workflow.check_consents)
  return _impl_.check_consents_.Mutable(index);
}
inline void Workflow::set_check_consents(int index, const std::string& value) {
  _impl_.check_consents_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Workflow.check_consents)
}
inline void Workflow::set_check_consents(int index, std::string&& value) {
  _impl_.check_consents_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.Workflow.check_consents)
}
inline void Workflow::set_check_consents(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.check_consents_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.Workflow.check_consents)
}
inline void Workflow::set_check_consents(int index, const char* value, size_t size) {
  _impl_.check_consents_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.Workflow.check_consents)
}
inline std::string* Workflow::_internal_add_check_consents() {
  return _impl_.check_consents_.Add();
}
inline void Workflow::add_check_consents(const std::string& value) {
  _impl_.check_consents_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.Workflow.check_consents)
}
inline void Workflow::add_check_consents(std::string&& value) {
  _impl_.check_consents_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.Workflow.check_consents)
}
inline void Workflow::add_check_consents(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.check_consents_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.Workflow.check_consents)
}
inline void Workflow::add_check_consents(const char* value, size_t size) {
  _impl_.check_consents_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.Workflow.check_consents)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Workflow::check_consents() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Workflow.check_consents)
  return _impl_.check_consents_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Workflow::mutable_check_consents() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Workflow.check_consents)
  return &_impl_.check_consents_;
}

// -------------------------------------------------------------------

// WorkflowVersion

// string id = 1;
inline void WorkflowVersion::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& WorkflowVersion::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.WorkflowVersion.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowVersion::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.WorkflowVersion.id)
}
inline std::string* WorkflowVersion::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.WorkflowVersion.id)
  return _s;
}
inline const std::string& WorkflowVersion::_internal_id() const {
  return _impl_.id_.Get();
}
inline void WorkflowVersion::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowVersion::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowVersion::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.WorkflowVersion.id)
  return _impl_.id_.Release();
}
inline void WorkflowVersion::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.WorkflowVersion.id)
}

// string workflow_id = 2;
inline void WorkflowVersion::clear_workflow_id() {
  _impl_.workflow_id_.ClearToEmpty();
}
inline const std::string& WorkflowVersion::workflow_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.WorkflowVersion.workflow_id)
  return _internal_workflow_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowVersion::set_workflow_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.workflow_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.WorkflowVersion.workflow_id)
}
inline std::string* WorkflowVersion::mutable_workflow_id() {
  std::string* _s = _internal_mutable_workflow_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.WorkflowVersion.workflow_id)
  return _s;
}
inline const std::string& WorkflowVersion::_internal_workflow_id() const {
  return _impl_.workflow_id_.Get();
}
inline void WorkflowVersion::_internal_set_workflow_id(const std::string& value) {
  
  _impl_.workflow_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowVersion::_internal_mutable_workflow_id() {
  
  return _impl_.workflow_id_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowVersion::release_workflow_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.WorkflowVersion.workflow_id)
  return _impl_.workflow_id_.Release();
}
inline void WorkflowVersion::set_allocated_workflow_id(std::string* workflow_id) {
  if (workflow_id != nullptr) {
    
  } else {
    
  }
  _impl_.workflow_id_.SetAllocated(workflow_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.workflow_id_.IsDefault()) {
    _impl_.workflow_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.WorkflowVersion.workflow_id)
}

// .google.protobuf.Timestamp created_at = 3;
inline bool WorkflowVersion::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool WorkflowVersion::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& WorkflowVersion::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& WorkflowVersion::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.WorkflowVersion.created_at)
  return _internal_created_at();
}
inline void WorkflowVersion::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.WorkflowVersion.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* WorkflowVersion::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* WorkflowVersion::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.WorkflowVersion.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* WorkflowVersion::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* WorkflowVersion::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.WorkflowVersion.created_at)
  return _msg;
}
inline void WorkflowVersion::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.WorkflowVersion.created_at)
}

// .google.protobuf.Timestamp modified_at = 4;
inline bool WorkflowVersion::_internal_has_modified_at() const {
  return this != internal_default_instance() && _impl_.modified_at_ != nullptr;
}
inline bool WorkflowVersion::has_modified_at() const {
  return _internal_has_modified_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& WorkflowVersion::_internal_modified_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.modified_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& WorkflowVersion::modified_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.WorkflowVersion.modified_at)
  return _internal_modified_at();
}
inline void WorkflowVersion::unsafe_arena_set_allocated_modified_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  _impl_.modified_at_ = modified_at;
  if (modified_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.WorkflowVersion.modified_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* WorkflowVersion::release_modified_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* WorkflowVersion::unsafe_arena_release_modified_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.WorkflowVersion.modified_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* WorkflowVersion::_internal_mutable_modified_at() {
  
  if (_impl_.modified_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.modified_at_ = p;
  }
  return _impl_.modified_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* WorkflowVersion::mutable_modified_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_modified_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.WorkflowVersion.modified_at)
  return _msg;
}
inline void WorkflowVersion::set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  if (modified_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(modified_at));
    if (message_arena != submessage_arena) {
      modified_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modified_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.modified_at_ = modified_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.WorkflowVersion.modified_at)
}

// .clarifai.api.Visibility visibility = 5;
inline bool WorkflowVersion::_internal_has_visibility() const {
  return this != internal_default_instance() && _impl_.visibility_ != nullptr;
}
inline bool WorkflowVersion::has_visibility() const {
  return _internal_has_visibility();
}
inline void WorkflowVersion::clear_visibility() {
  if (GetArenaForAllocation() == nullptr && _impl_.visibility_ != nullptr) {
    delete _impl_.visibility_;
  }
  _impl_.visibility_ = nullptr;
}
inline const ::clarifai::api::Visibility& WorkflowVersion::_internal_visibility() const {
  const ::clarifai::api::Visibility* p = _impl_.visibility_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Visibility&>(
      ::clarifai::api::_Visibility_default_instance_);
}
inline const ::clarifai::api::Visibility& WorkflowVersion::visibility() const {
  // @@protoc_insertion_point(field_get:clarifai.api.WorkflowVersion.visibility)
  return _internal_visibility();
}
inline void WorkflowVersion::unsafe_arena_set_allocated_visibility(
    ::clarifai::api::Visibility* visibility) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visibility_);
  }
  _impl_.visibility_ = visibility;
  if (visibility) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.WorkflowVersion.visibility)
}
inline ::clarifai::api::Visibility* WorkflowVersion::release_visibility() {
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Visibility* WorkflowVersion::unsafe_arena_release_visibility() {
  // @@protoc_insertion_point(field_release:clarifai.api.WorkflowVersion.visibility)
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
  return temp;
}
inline ::clarifai::api::Visibility* WorkflowVersion::_internal_mutable_visibility() {
  
  if (_impl_.visibility_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Visibility>(GetArenaForAllocation());
    _impl_.visibility_ = p;
  }
  return _impl_.visibility_;
}
inline ::clarifai::api::Visibility* WorkflowVersion::mutable_visibility() {
  ::clarifai::api::Visibility* _msg = _internal_mutable_visibility();
  // @@protoc_insertion_point(field_mutable:clarifai.api.WorkflowVersion.visibility)
  return _msg;
}
inline void WorkflowVersion::set_allocated_visibility(::clarifai::api::Visibility* visibility) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.visibility_;
  }
  if (visibility) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(visibility);
    if (message_arena != submessage_arena) {
      visibility = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visibility, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.visibility_ = visibility;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.WorkflowVersion.visibility)
}

// repeated .clarifai.api.WorkflowNode nodes = 6;
inline int WorkflowVersion::_internal_nodes_size() const {
  return _impl_.nodes_.size();
}
inline int WorkflowVersion::nodes_size() const {
  return _internal_nodes_size();
}
inline void WorkflowVersion::clear_nodes() {
  _impl_.nodes_.Clear();
}
inline ::clarifai::api::WorkflowNode* WorkflowVersion::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.WorkflowVersion.nodes)
  return _impl_.nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::WorkflowNode >*
WorkflowVersion::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.WorkflowVersion.nodes)
  return &_impl_.nodes_;
}
inline const ::clarifai::api::WorkflowNode& WorkflowVersion::_internal_nodes(int index) const {
  return _impl_.nodes_.Get(index);
}
inline const ::clarifai::api::WorkflowNode& WorkflowVersion::nodes(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.WorkflowVersion.nodes)
  return _internal_nodes(index);
}
inline ::clarifai::api::WorkflowNode* WorkflowVersion::_internal_add_nodes() {
  return _impl_.nodes_.Add();
}
inline ::clarifai::api::WorkflowNode* WorkflowVersion::add_nodes() {
  ::clarifai::api::WorkflowNode* _add = _internal_add_nodes();
  // @@protoc_insertion_point(field_add:clarifai.api.WorkflowVersion.nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::WorkflowNode >&
WorkflowVersion::nodes() const {
  // @@protoc_insertion_point(field_list:clarifai.api.WorkflowVersion.nodes)
  return _impl_.nodes_;
}

// .google.protobuf.Struct metadata = 7;
inline bool WorkflowVersion::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool WorkflowVersion::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& WorkflowVersion::_internal_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& WorkflowVersion::metadata() const {
  // @@protoc_insertion_point(field_get:clarifai.api.WorkflowVersion.metadata)
  return _internal_metadata();
}
inline void WorkflowVersion::unsafe_arena_set_allocated_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.WorkflowVersion.metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowVersion::release_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowVersion::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:clarifai.api.WorkflowVersion.metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowVersion::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowVersion::mutable_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:clarifai.api.WorkflowVersion.metadata)
  return _msg;
}
inline void WorkflowVersion::set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.WorkflowVersion.metadata)
}

// string app_id = 8;
inline void WorkflowVersion::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& WorkflowVersion::app_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.WorkflowVersion.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowVersion::set_app_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.app_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.WorkflowVersion.app_id)
}
inline std::string* WorkflowVersion::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.WorkflowVersion.app_id)
  return _s;
}
inline const std::string& WorkflowVersion::_internal_app_id() const {
  return _impl_.app_id_.Get();
}
inline void WorkflowVersion::_internal_set_app_id(const std::string& value) {
  
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowVersion::_internal_mutable_app_id() {
  
  return _impl_.app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowVersion::release_app_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.WorkflowVersion.app_id)
  return _impl_.app_id_.Release();
}
inline void WorkflowVersion::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    
  } else {
    
  }
  _impl_.app_id_.SetAllocated(app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.WorkflowVersion.app_id)
}

// string user_id = 9;
inline void WorkflowVersion::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& WorkflowVersion::user_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.WorkflowVersion.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowVersion::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.WorkflowVersion.user_id)
}
inline std::string* WorkflowVersion::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.WorkflowVersion.user_id)
  return _s;
}
inline const std::string& WorkflowVersion::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void WorkflowVersion::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowVersion::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowVersion::release_user_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.WorkflowVersion.user_id)
  return _impl_.user_id_.Release();
}
inline void WorkflowVersion::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.WorkflowVersion.user_id)
}

// string description = 10;
inline void WorkflowVersion::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& WorkflowVersion::description() const {
  // @@protoc_insertion_point(field_get:clarifai.api.WorkflowVersion.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowVersion::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.WorkflowVersion.description)
}
inline std::string* WorkflowVersion::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:clarifai.api.WorkflowVersion.description)
  return _s;
}
inline const std::string& WorkflowVersion::_internal_description() const {
  return _impl_.description_.Get();
}
inline void WorkflowVersion::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowVersion::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowVersion::release_description() {
  // @@protoc_insertion_point(field_release:clarifai.api.WorkflowVersion.description)
  return _impl_.description_.Release();
}
inline void WorkflowVersion::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.WorkflowVersion.description)
}

// string license = 11;
inline void WorkflowVersion::clear_license() {
  _impl_.license_.ClearToEmpty();
}
inline const std::string& WorkflowVersion::license() const {
  // @@protoc_insertion_point(field_get:clarifai.api.WorkflowVersion.license)
  return _internal_license();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowVersion::set_license(ArgT0&& arg0, ArgT... args) {
 
 _impl_.license_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.WorkflowVersion.license)
}
inline std::string* WorkflowVersion::mutable_license() {
  std::string* _s = _internal_mutable_license();
  // @@protoc_insertion_point(field_mutable:clarifai.api.WorkflowVersion.license)
  return _s;
}
inline const std::string& WorkflowVersion::_internal_license() const {
  return _impl_.license_.Get();
}
inline void WorkflowVersion::_internal_set_license(const std::string& value) {
  
  _impl_.license_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowVersion::_internal_mutable_license() {
  
  return _impl_.license_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowVersion::release_license() {
  // @@protoc_insertion_point(field_release:clarifai.api.WorkflowVersion.license)
  return _impl_.license_.Release();
}
inline void WorkflowVersion::set_allocated_license(std::string* license) {
  if (license != nullptr) {
    
  } else {
    
  }
  _impl_.license_.SetAllocated(license, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.license_.IsDefault()) {
    _impl_.license_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.WorkflowVersion.license)
}

// -------------------------------------------------------------------

// WorkflowNode

// string id = 1;
inline void WorkflowNode::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& WorkflowNode::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.WorkflowNode.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowNode::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.WorkflowNode.id)
}
inline std::string* WorkflowNode::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.WorkflowNode.id)
  return _s;
}
inline const std::string& WorkflowNode::_internal_id() const {
  return _impl_.id_.Get();
}
inline void WorkflowNode::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowNode::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowNode::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.WorkflowNode.id)
  return _impl_.id_.Release();
}
inline void WorkflowNode::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.WorkflowNode.id)
}

// .clarifai.api.Model model = 2;
inline bool WorkflowNode::_internal_has_model() const {
  return this != internal_default_instance() && _impl_.model_ != nullptr;
}
inline bool WorkflowNode::has_model() const {
  return _internal_has_model();
}
inline void WorkflowNode::clear_model() {
  if (GetArenaForAllocation() == nullptr && _impl_.model_ != nullptr) {
    delete _impl_.model_;
  }
  _impl_.model_ = nullptr;
}
inline const ::clarifai::api::Model& WorkflowNode::_internal_model() const {
  const ::clarifai::api::Model* p = _impl_.model_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Model&>(
      ::clarifai::api::_Model_default_instance_);
}
inline const ::clarifai::api::Model& WorkflowNode::model() const {
  // @@protoc_insertion_point(field_get:clarifai.api.WorkflowNode.model)
  return _internal_model();
}
inline void WorkflowNode::unsafe_arena_set_allocated_model(
    ::clarifai::api::Model* model) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.model_);
  }
  _impl_.model_ = model;
  if (model) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.WorkflowNode.model)
}
inline ::clarifai::api::Model* WorkflowNode::release_model() {
  
  ::clarifai::api::Model* temp = _impl_.model_;
  _impl_.model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Model* WorkflowNode::unsafe_arena_release_model() {
  // @@protoc_insertion_point(field_release:clarifai.api.WorkflowNode.model)
  
  ::clarifai::api::Model* temp = _impl_.model_;
  _impl_.model_ = nullptr;
  return temp;
}
inline ::clarifai::api::Model* WorkflowNode::_internal_mutable_model() {
  
  if (_impl_.model_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Model>(GetArenaForAllocation());
    _impl_.model_ = p;
  }
  return _impl_.model_;
}
inline ::clarifai::api::Model* WorkflowNode::mutable_model() {
  ::clarifai::api::Model* _msg = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:clarifai.api.WorkflowNode.model)
  return _msg;
}
inline void WorkflowNode::set_allocated_model(::clarifai::api::Model* model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.model_;
  }
  if (model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(model);
    if (message_arena != submessage_arena) {
      model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.model_ = model;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.WorkflowNode.model)
}

// repeated .clarifai.api.NodeInput node_inputs = 3;
inline int WorkflowNode::_internal_node_inputs_size() const {
  return _impl_.node_inputs_.size();
}
inline int WorkflowNode::node_inputs_size() const {
  return _internal_node_inputs_size();
}
inline void WorkflowNode::clear_node_inputs() {
  _impl_.node_inputs_.Clear();
}
inline ::clarifai::api::NodeInput* WorkflowNode::mutable_node_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.WorkflowNode.node_inputs)
  return _impl_.node_inputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::NodeInput >*
WorkflowNode::mutable_node_inputs() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.WorkflowNode.node_inputs)
  return &_impl_.node_inputs_;
}
inline const ::clarifai::api::NodeInput& WorkflowNode::_internal_node_inputs(int index) const {
  return _impl_.node_inputs_.Get(index);
}
inline const ::clarifai::api::NodeInput& WorkflowNode::node_inputs(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.WorkflowNode.node_inputs)
  return _internal_node_inputs(index);
}
inline ::clarifai::api::NodeInput* WorkflowNode::_internal_add_node_inputs() {
  return _impl_.node_inputs_.Add();
}
inline ::clarifai::api::NodeInput* WorkflowNode::add_node_inputs() {
  ::clarifai::api::NodeInput* _add = _internal_add_node_inputs();
  // @@protoc_insertion_point(field_add:clarifai.api.WorkflowNode.node_inputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::NodeInput >&
WorkflowNode::node_inputs() const {
  // @@protoc_insertion_point(field_list:clarifai.api.WorkflowNode.node_inputs)
  return _impl_.node_inputs_;
}

// bool suppress_output = 4;
inline void WorkflowNode::clear_suppress_output() {
  _impl_.suppress_output_ = false;
}
inline bool WorkflowNode::_internal_suppress_output() const {
  return _impl_.suppress_output_;
}
inline bool WorkflowNode::suppress_output() const {
  // @@protoc_insertion_point(field_get:clarifai.api.WorkflowNode.suppress_output)
  return _internal_suppress_output();
}
inline void WorkflowNode::_internal_set_suppress_output(bool value) {
  
  _impl_.suppress_output_ = value;
}
inline void WorkflowNode::set_suppress_output(bool value) {
  _internal_set_suppress_output(value);
  // @@protoc_insertion_point(field_set:clarifai.api.WorkflowNode.suppress_output)
}

// -------------------------------------------------------------------

// NodeInput

// string node_id = 1;
inline void NodeInput::clear_node_id() {
  _impl_.node_id_.ClearToEmpty();
}
inline const std::string& NodeInput::node_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.NodeInput.node_id)
  return _internal_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInput::set_node_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.node_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.NodeInput.node_id)
}
inline std::string* NodeInput::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.NodeInput.node_id)
  return _s;
}
inline const std::string& NodeInput::_internal_node_id() const {
  return _impl_.node_id_.Get();
}
inline void NodeInput::_internal_set_node_id(const std::string& value) {
  
  _impl_.node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeInput::_internal_mutable_node_id() {
  
  return _impl_.node_id_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeInput::release_node_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.NodeInput.node_id)
  return _impl_.node_id_.Release();
}
inline void NodeInput::set_allocated_node_id(std::string* node_id) {
  if (node_id != nullptr) {
    
  } else {
    
  }
  _impl_.node_id_.SetAllocated(node_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.node_id_.IsDefault()) {
    _impl_.node_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.NodeInput.node_id)
}

// -------------------------------------------------------------------

// WorkflowResult

// string id = 1;
inline void WorkflowResult::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& WorkflowResult::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.WorkflowResult.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowResult::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.WorkflowResult.id)
}
inline std::string* WorkflowResult::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.WorkflowResult.id)
  return _s;
}
inline const std::string& WorkflowResult::_internal_id() const {
  return _impl_.id_.Get();
}
inline void WorkflowResult::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowResult::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowResult::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.WorkflowResult.id)
  return _impl_.id_.Release();
}
inline void WorkflowResult::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.WorkflowResult.id)
}

// .clarifai.api.status.Status status = 2;
inline bool WorkflowResult::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool WorkflowResult::has_status() const {
  return _internal_has_status();
}
inline const ::clarifai::api::status::Status& WorkflowResult::_internal_status() const {
  const ::clarifai::api::status::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::status::Status&>(
      ::clarifai::api::status::_Status_default_instance_);
}
inline const ::clarifai::api::status::Status& WorkflowResult::status() const {
  // @@protoc_insertion_point(field_get:clarifai.api.WorkflowResult.status)
  return _internal_status();
}
inline void WorkflowResult::unsafe_arena_set_allocated_status(
    ::clarifai::api::status::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.WorkflowResult.status)
}
inline ::clarifai::api::status::Status* WorkflowResult::release_status() {
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::status::Status* WorkflowResult::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:clarifai.api.WorkflowResult.status)
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::clarifai::api::status::Status* WorkflowResult::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::status::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::clarifai::api::status::Status* WorkflowResult::mutable_status() {
  ::clarifai::api::status::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:clarifai.api.WorkflowResult.status)
  return _msg;
}
inline void WorkflowResult::set_allocated_status(::clarifai::api::status::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.WorkflowResult.status)
}

// .google.protobuf.Timestamp created_at = 3;
inline bool WorkflowResult::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool WorkflowResult::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& WorkflowResult::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& WorkflowResult::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.WorkflowResult.created_at)
  return _internal_created_at();
}
inline void WorkflowResult::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.WorkflowResult.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* WorkflowResult::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* WorkflowResult::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.WorkflowResult.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* WorkflowResult::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* WorkflowResult::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.WorkflowResult.created_at)
  return _msg;
}
inline void WorkflowResult::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.WorkflowResult.created_at)
}

// .clarifai.api.Model model = 4;
inline bool WorkflowResult::_internal_has_model() const {
  return this != internal_default_instance() && _impl_.model_ != nullptr;
}
inline bool WorkflowResult::has_model() const {
  return _internal_has_model();
}
inline void WorkflowResult::clear_model() {
  if (GetArenaForAllocation() == nullptr && _impl_.model_ != nullptr) {
    delete _impl_.model_;
  }
  _impl_.model_ = nullptr;
}
inline const ::clarifai::api::Model& WorkflowResult::_internal_model() const {
  const ::clarifai::api::Model* p = _impl_.model_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Model&>(
      ::clarifai::api::_Model_default_instance_);
}
inline const ::clarifai::api::Model& WorkflowResult::model() const {
  // @@protoc_insertion_point(field_get:clarifai.api.WorkflowResult.model)
  return _internal_model();
}
inline void WorkflowResult::unsafe_arena_set_allocated_model(
    ::clarifai::api::Model* model) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.model_);
  }
  _impl_.model_ = model;
  if (model) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.WorkflowResult.model)
}
inline ::clarifai::api::Model* WorkflowResult::release_model() {
  
  ::clarifai::api::Model* temp = _impl_.model_;
  _impl_.model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Model* WorkflowResult::unsafe_arena_release_model() {
  // @@protoc_insertion_point(field_release:clarifai.api.WorkflowResult.model)
  
  ::clarifai::api::Model* temp = _impl_.model_;
  _impl_.model_ = nullptr;
  return temp;
}
inline ::clarifai::api::Model* WorkflowResult::_internal_mutable_model() {
  
  if (_impl_.model_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Model>(GetArenaForAllocation());
    _impl_.model_ = p;
  }
  return _impl_.model_;
}
inline ::clarifai::api::Model* WorkflowResult::mutable_model() {
  ::clarifai::api::Model* _msg = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:clarifai.api.WorkflowResult.model)
  return _msg;
}
inline void WorkflowResult::set_allocated_model(::clarifai::api::Model* model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.model_;
  }
  if (model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(model);
    if (message_arena != submessage_arena) {
      model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.model_ = model;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.WorkflowResult.model)
}

// .clarifai.api.Input input = 5;
inline bool WorkflowResult::_internal_has_input() const {
  return this != internal_default_instance() && _impl_.input_ != nullptr;
}
inline bool WorkflowResult::has_input() const {
  return _internal_has_input();
}
inline void WorkflowResult::clear_input() {
  if (GetArenaForAllocation() == nullptr && _impl_.input_ != nullptr) {
    delete _impl_.input_;
  }
  _impl_.input_ = nullptr;
}
inline const ::clarifai::api::Input& WorkflowResult::_internal_input() const {
  const ::clarifai::api::Input* p = _impl_.input_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Input&>(
      ::clarifai::api::_Input_default_instance_);
}
inline const ::clarifai::api::Input& WorkflowResult::input() const {
  // @@protoc_insertion_point(field_get:clarifai.api.WorkflowResult.input)
  return _internal_input();
}
inline void WorkflowResult::unsafe_arena_set_allocated_input(
    ::clarifai::api::Input* input) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.input_);
  }
  _impl_.input_ = input;
  if (input) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.WorkflowResult.input)
}
inline ::clarifai::api::Input* WorkflowResult::release_input() {
  
  ::clarifai::api::Input* temp = _impl_.input_;
  _impl_.input_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Input* WorkflowResult::unsafe_arena_release_input() {
  // @@protoc_insertion_point(field_release:clarifai.api.WorkflowResult.input)
  
  ::clarifai::api::Input* temp = _impl_.input_;
  _impl_.input_ = nullptr;
  return temp;
}
inline ::clarifai::api::Input* WorkflowResult::_internal_mutable_input() {
  
  if (_impl_.input_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Input>(GetArenaForAllocation());
    _impl_.input_ = p;
  }
  return _impl_.input_;
}
inline ::clarifai::api::Input* WorkflowResult::mutable_input() {
  ::clarifai::api::Input* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:clarifai.api.WorkflowResult.input)
  return _msg;
}
inline void WorkflowResult::set_allocated_input(::clarifai::api::Input* input) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.input_;
  }
  if (input) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(input);
    if (message_arena != submessage_arena) {
      input = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.input_ = input;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.WorkflowResult.input)
}

// repeated .clarifai.api.Output outputs = 6;
inline int WorkflowResult::_internal_outputs_size() const {
  return _impl_.outputs_.size();
}
inline int WorkflowResult::outputs_size() const {
  return _internal_outputs_size();
}
inline void WorkflowResult::clear_outputs() {
  _impl_.outputs_.Clear();
}
inline ::clarifai::api::Output* WorkflowResult::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.WorkflowResult.outputs)
  return _impl_.outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Output >*
WorkflowResult::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.WorkflowResult.outputs)
  return &_impl_.outputs_;
}
inline const ::clarifai::api::Output& WorkflowResult::_internal_outputs(int index) const {
  return _impl_.outputs_.Get(index);
}
inline const ::clarifai::api::Output& WorkflowResult::outputs(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.WorkflowResult.outputs)
  return _internal_outputs(index);
}
inline ::clarifai::api::Output* WorkflowResult::_internal_add_outputs() {
  return _impl_.outputs_.Add();
}
inline ::clarifai::api::Output* WorkflowResult::add_outputs() {
  ::clarifai::api::Output* _add = _internal_add_outputs();
  // @@protoc_insertion_point(field_add:clarifai.api.WorkflowResult.outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Output >&
WorkflowResult::outputs() const {
  // @@protoc_insertion_point(field_list:clarifai.api.WorkflowResult.outputs)
  return _impl_.outputs_;
}

// bool suppress_output = 7;
inline void WorkflowResult::clear_suppress_output() {
  _impl_.suppress_output_ = false;
}
inline bool WorkflowResult::_internal_suppress_output() const {
  return _impl_.suppress_output_;
}
inline bool WorkflowResult::suppress_output() const {
  // @@protoc_insertion_point(field_get:clarifai.api.WorkflowResult.suppress_output)
  return _internal_suppress_output();
}
inline void WorkflowResult::_internal_set_suppress_output(bool value) {
  
  _impl_.suppress_output_ = value;
}
inline void WorkflowResult::set_suppress_output(bool value) {
  _internal_set_suppress_output(value);
  // @@protoc_insertion_point(field_set:clarifai.api.WorkflowResult.suppress_output)
}

// -------------------------------------------------------------------

// WorkflowState

// string id = 1;
inline void WorkflowState::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& WorkflowState::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.WorkflowState.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowState::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.WorkflowState.id)
}
inline std::string* WorkflowState::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.WorkflowState.id)
  return _s;
}
inline const std::string& WorkflowState::_internal_id() const {
  return _impl_.id_.Get();
}
inline void WorkflowState::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowState::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowState::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.WorkflowState.id)
  return _impl_.id_.Release();
}
inline void WorkflowState::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.WorkflowState.id)
}

// -------------------------------------------------------------------

// AppDuplication

// string id = 1;
inline void AppDuplication::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& AppDuplication::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AppDuplication.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppDuplication::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.AppDuplication.id)
}
inline std::string* AppDuplication::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.AppDuplication.id)
  return _s;
}
inline const std::string& AppDuplication::_internal_id() const {
  return _impl_.id_.Get();
}
inline void AppDuplication::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* AppDuplication::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* AppDuplication::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.AppDuplication.id)
  return _impl_.id_.Release();
}
inline void AppDuplication::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.AppDuplication.id)
}

// string new_app_id = 2;
inline void AppDuplication::clear_new_app_id() {
  _impl_.new_app_id_.ClearToEmpty();
}
inline const std::string& AppDuplication::new_app_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AppDuplication.new_app_id)
  return _internal_new_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppDuplication::set_new_app_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.new_app_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.AppDuplication.new_app_id)
}
inline std::string* AppDuplication::mutable_new_app_id() {
  std::string* _s = _internal_mutable_new_app_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.AppDuplication.new_app_id)
  return _s;
}
inline const std::string& AppDuplication::_internal_new_app_id() const {
  return _impl_.new_app_id_.Get();
}
inline void AppDuplication::_internal_set_new_app_id(const std::string& value) {
  
  _impl_.new_app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AppDuplication::_internal_mutable_new_app_id() {
  
  return _impl_.new_app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AppDuplication::release_new_app_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.AppDuplication.new_app_id)
  return _impl_.new_app_id_.Release();
}
inline void AppDuplication::set_allocated_new_app_id(std::string* new_app_id) {
  if (new_app_id != nullptr) {
    
  } else {
    
  }
  _impl_.new_app_id_.SetAllocated(new_app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_app_id_.IsDefault()) {
    _impl_.new_app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.AppDuplication.new_app_id)
}

// string new_app_name = 3;
inline void AppDuplication::clear_new_app_name() {
  _impl_.new_app_name_.ClearToEmpty();
}
inline const std::string& AppDuplication::new_app_name() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AppDuplication.new_app_name)
  return _internal_new_app_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppDuplication::set_new_app_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.new_app_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.AppDuplication.new_app_name)
}
inline std::string* AppDuplication::mutable_new_app_name() {
  std::string* _s = _internal_mutable_new_app_name();
  // @@protoc_insertion_point(field_mutable:clarifai.api.AppDuplication.new_app_name)
  return _s;
}
inline const std::string& AppDuplication::_internal_new_app_name() const {
  return _impl_.new_app_name_.Get();
}
inline void AppDuplication::_internal_set_new_app_name(const std::string& value) {
  
  _impl_.new_app_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AppDuplication::_internal_mutable_new_app_name() {
  
  return _impl_.new_app_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AppDuplication::release_new_app_name() {
  // @@protoc_insertion_point(field_release:clarifai.api.AppDuplication.new_app_name)
  return _impl_.new_app_name_.Release();
}
inline void AppDuplication::set_allocated_new_app_name(std::string* new_app_name) {
  if (new_app_name != nullptr) {
    
  } else {
    
  }
  _impl_.new_app_name_.SetAllocated(new_app_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_app_name_.IsDefault()) {
    _impl_.new_app_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.AppDuplication.new_app_name)
}

// .clarifai.api.status.Status status = 4;
inline bool AppDuplication::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool AppDuplication::has_status() const {
  return _internal_has_status();
}
inline const ::clarifai::api::status::Status& AppDuplication::_internal_status() const {
  const ::clarifai::api::status::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::status::Status&>(
      ::clarifai::api::status::_Status_default_instance_);
}
inline const ::clarifai::api::status::Status& AppDuplication::status() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AppDuplication.status)
  return _internal_status();
}
inline void AppDuplication::unsafe_arena_set_allocated_status(
    ::clarifai::api::status::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.AppDuplication.status)
}
inline ::clarifai::api::status::Status* AppDuplication::release_status() {
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::status::Status* AppDuplication::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:clarifai.api.AppDuplication.status)
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::clarifai::api::status::Status* AppDuplication::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::status::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::clarifai::api::status::Status* AppDuplication::mutable_status() {
  ::clarifai::api::status::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:clarifai.api.AppDuplication.status)
  return _msg;
}
inline void AppDuplication::set_allocated_status(::clarifai::api::status::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.AppDuplication.status)
}

// .google.protobuf.Timestamp created_at = 5;
inline bool AppDuplication::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool AppDuplication::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& AppDuplication::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& AppDuplication::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AppDuplication.created_at)
  return _internal_created_at();
}
inline void AppDuplication::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.AppDuplication.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AppDuplication::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AppDuplication::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.AppDuplication.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AppDuplication::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AppDuplication::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.AppDuplication.created_at)
  return _msg;
}
inline void AppDuplication::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.AppDuplication.created_at)
}

// .google.protobuf.Timestamp last_modified_at = 6;
inline bool AppDuplication::_internal_has_last_modified_at() const {
  return this != internal_default_instance() && _impl_.last_modified_at_ != nullptr;
}
inline bool AppDuplication::has_last_modified_at() const {
  return _internal_has_last_modified_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& AppDuplication::_internal_last_modified_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.last_modified_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& AppDuplication::last_modified_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AppDuplication.last_modified_at)
  return _internal_last_modified_at();
}
inline void AppDuplication::unsafe_arena_set_allocated_last_modified_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_modified_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_modified_at_);
  }
  _impl_.last_modified_at_ = last_modified_at;
  if (last_modified_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.AppDuplication.last_modified_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AppDuplication::release_last_modified_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_modified_at_;
  _impl_.last_modified_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AppDuplication::unsafe_arena_release_last_modified_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.AppDuplication.last_modified_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_modified_at_;
  _impl_.last_modified_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AppDuplication::_internal_mutable_last_modified_at() {
  
  if (_impl_.last_modified_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.last_modified_at_ = p;
  }
  return _impl_.last_modified_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AppDuplication::mutable_last_modified_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_modified_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.AppDuplication.last_modified_at)
  return _msg;
}
inline void AppDuplication::set_allocated_last_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* last_modified_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_modified_at_);
  }
  if (last_modified_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_modified_at));
    if (message_arena != submessage_arena) {
      last_modified_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_modified_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_modified_at_ = last_modified_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.AppDuplication.last_modified_at)
}

// .clarifai.api.AppDuplicationFilters filter = 7;
inline bool AppDuplication::_internal_has_filter() const {
  return this != internal_default_instance() && _impl_.filter_ != nullptr;
}
inline bool AppDuplication::has_filter() const {
  return _internal_has_filter();
}
inline void AppDuplication::clear_filter() {
  if (GetArenaForAllocation() == nullptr && _impl_.filter_ != nullptr) {
    delete _impl_.filter_;
  }
  _impl_.filter_ = nullptr;
}
inline const ::clarifai::api::AppDuplicationFilters& AppDuplication::_internal_filter() const {
  const ::clarifai::api::AppDuplicationFilters* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::AppDuplicationFilters&>(
      ::clarifai::api::_AppDuplicationFilters_default_instance_);
}
inline const ::clarifai::api::AppDuplicationFilters& AppDuplication::filter() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AppDuplication.filter)
  return _internal_filter();
}
inline void AppDuplication::unsafe_arena_set_allocated_filter(
    ::clarifai::api::AppDuplicationFilters* filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = filter;
  if (filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.AppDuplication.filter)
}
inline ::clarifai::api::AppDuplicationFilters* AppDuplication::release_filter() {
  
  ::clarifai::api::AppDuplicationFilters* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::AppDuplicationFilters* AppDuplication::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_release:clarifai.api.AppDuplication.filter)
  
  ::clarifai::api::AppDuplicationFilters* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::clarifai::api::AppDuplicationFilters* AppDuplication::_internal_mutable_filter() {
  
  if (_impl_.filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::AppDuplicationFilters>(GetArenaForAllocation());
    _impl_.filter_ = p;
  }
  return _impl_.filter_;
}
inline ::clarifai::api::AppDuplicationFilters* AppDuplication::mutable_filter() {
  ::clarifai::api::AppDuplicationFilters* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:clarifai.api.AppDuplication.filter)
  return _msg;
}
inline void AppDuplication::set_allocated_filter(::clarifai::api::AppDuplicationFilters* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.filter_;
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(filter);
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.AppDuplication.filter)
}

// string existing_app_id = 8;
inline void AppDuplication::clear_existing_app_id() {
  _impl_.existing_app_id_.ClearToEmpty();
}
inline const std::string& AppDuplication::existing_app_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AppDuplication.existing_app_id)
  return _internal_existing_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppDuplication::set_existing_app_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.existing_app_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.AppDuplication.existing_app_id)
}
inline std::string* AppDuplication::mutable_existing_app_id() {
  std::string* _s = _internal_mutable_existing_app_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.AppDuplication.existing_app_id)
  return _s;
}
inline const std::string& AppDuplication::_internal_existing_app_id() const {
  return _impl_.existing_app_id_.Get();
}
inline void AppDuplication::_internal_set_existing_app_id(const std::string& value) {
  
  _impl_.existing_app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AppDuplication::_internal_mutable_existing_app_id() {
  
  return _impl_.existing_app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AppDuplication::release_existing_app_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.AppDuplication.existing_app_id)
  return _impl_.existing_app_id_.Release();
}
inline void AppDuplication::set_allocated_existing_app_id(std::string* existing_app_id) {
  if (existing_app_id != nullptr) {
    
  } else {
    
  }
  _impl_.existing_app_id_.SetAllocated(existing_app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.existing_app_id_.IsDefault()) {
    _impl_.existing_app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.AppDuplication.existing_app_id)
}

// repeated .clarifai.api.AppCopyProgress progress = 9;
inline int AppDuplication::_internal_progress_size() const {
  return _impl_.progress_.size();
}
inline int AppDuplication::progress_size() const {
  return _internal_progress_size();
}
inline void AppDuplication::clear_progress() {
  _impl_.progress_.Clear();
}
inline ::clarifai::api::AppCopyProgress* AppDuplication::mutable_progress(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.AppDuplication.progress)
  return _impl_.progress_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::AppCopyProgress >*
AppDuplication::mutable_progress() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.AppDuplication.progress)
  return &_impl_.progress_;
}
inline const ::clarifai::api::AppCopyProgress& AppDuplication::_internal_progress(int index) const {
  return _impl_.progress_.Get(index);
}
inline const ::clarifai::api::AppCopyProgress& AppDuplication::progress(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.AppDuplication.progress)
  return _internal_progress(index);
}
inline ::clarifai::api::AppCopyProgress* AppDuplication::_internal_add_progress() {
  return _impl_.progress_.Add();
}
inline ::clarifai::api::AppCopyProgress* AppDuplication::add_progress() {
  ::clarifai::api::AppCopyProgress* _add = _internal_add_progress();
  // @@protoc_insertion_point(field_add:clarifai.api.AppDuplication.progress)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::AppCopyProgress >&
AppDuplication::progress() const {
  // @@protoc_insertion_point(field_list:clarifai.api.AppDuplication.progress)
  return _impl_.progress_;
}

// -------------------------------------------------------------------

// AppCopyProgress

// string field = 1;
inline void AppCopyProgress::clear_field() {
  _impl_.field_.ClearToEmpty();
}
inline const std::string& AppCopyProgress::field() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AppCopyProgress.field)
  return _internal_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppCopyProgress::set_field(ArgT0&& arg0, ArgT... args) {
 
 _impl_.field_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.AppCopyProgress.field)
}
inline std::string* AppCopyProgress::mutable_field() {
  std::string* _s = _internal_mutable_field();
  // @@protoc_insertion_point(field_mutable:clarifai.api.AppCopyProgress.field)
  return _s;
}
inline const std::string& AppCopyProgress::_internal_field() const {
  return _impl_.field_.Get();
}
inline void AppCopyProgress::_internal_set_field(const std::string& value) {
  
  _impl_.field_.Set(value, GetArenaForAllocation());
}
inline std::string* AppCopyProgress::_internal_mutable_field() {
  
  return _impl_.field_.Mutable(GetArenaForAllocation());
}
inline std::string* AppCopyProgress::release_field() {
  // @@protoc_insertion_point(field_release:clarifai.api.AppCopyProgress.field)
  return _impl_.field_.Release();
}
inline void AppCopyProgress::set_allocated_field(std::string* field) {
  if (field != nullptr) {
    
  } else {
    
  }
  _impl_.field_.SetAllocated(field, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field_.IsDefault()) {
    _impl_.field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.AppCopyProgress.field)
}

// int32 value = 2;
inline void AppCopyProgress::clear_value() {
  _impl_.value_ = 0;
}
inline int32_t AppCopyProgress::_internal_value() const {
  return _impl_.value_;
}
inline int32_t AppCopyProgress::value() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AppCopyProgress.value)
  return _internal_value();
}
inline void AppCopyProgress::_internal_set_value(int32_t value) {
  
  _impl_.value_ = value;
}
inline void AppCopyProgress::set_value(int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:clarifai.api.AppCopyProgress.value)
}

// -------------------------------------------------------------------

// AppDuplicationFilters

// bool copy_inputs = 1;
inline void AppDuplicationFilters::clear_copy_inputs() {
  _impl_.copy_inputs_ = false;
}
inline bool AppDuplicationFilters::_internal_copy_inputs() const {
  return _impl_.copy_inputs_;
}
inline bool AppDuplicationFilters::copy_inputs() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AppDuplicationFilters.copy_inputs)
  return _internal_copy_inputs();
}
inline void AppDuplicationFilters::_internal_set_copy_inputs(bool value) {
  
  _impl_.copy_inputs_ = value;
}
inline void AppDuplicationFilters::set_copy_inputs(bool value) {
  _internal_set_copy_inputs(value);
  // @@protoc_insertion_point(field_set:clarifai.api.AppDuplicationFilters.copy_inputs)
}

// bool copy_concepts = 2;
inline void AppDuplicationFilters::clear_copy_concepts() {
  _impl_.copy_concepts_ = false;
}
inline bool AppDuplicationFilters::_internal_copy_concepts() const {
  return _impl_.copy_concepts_;
}
inline bool AppDuplicationFilters::copy_concepts() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AppDuplicationFilters.copy_concepts)
  return _internal_copy_concepts();
}
inline void AppDuplicationFilters::_internal_set_copy_concepts(bool value) {
  
  _impl_.copy_concepts_ = value;
}
inline void AppDuplicationFilters::set_copy_concepts(bool value) {
  _internal_set_copy_concepts(value);
  // @@protoc_insertion_point(field_set:clarifai.api.AppDuplicationFilters.copy_concepts)
}

// bool copy_annotations = 3;
inline void AppDuplicationFilters::clear_copy_annotations() {
  _impl_.copy_annotations_ = false;
}
inline bool AppDuplicationFilters::_internal_copy_annotations() const {
  return _impl_.copy_annotations_;
}
inline bool AppDuplicationFilters::copy_annotations() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AppDuplicationFilters.copy_annotations)
  return _internal_copy_annotations();
}
inline void AppDuplicationFilters::_internal_set_copy_annotations(bool value) {
  
  _impl_.copy_annotations_ = value;
}
inline void AppDuplicationFilters::set_copy_annotations(bool value) {
  _internal_set_copy_annotations(value);
  // @@protoc_insertion_point(field_set:clarifai.api.AppDuplicationFilters.copy_annotations)
}

// bool copy_models = 4;
inline void AppDuplicationFilters::clear_copy_models() {
  _impl_.copy_models_ = false;
}
inline bool AppDuplicationFilters::_internal_copy_models() const {
  return _impl_.copy_models_;
}
inline bool AppDuplicationFilters::copy_models() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AppDuplicationFilters.copy_models)
  return _internal_copy_models();
}
inline void AppDuplicationFilters::_internal_set_copy_models(bool value) {
  
  _impl_.copy_models_ = value;
}
inline void AppDuplicationFilters::set_copy_models(bool value) {
  _internal_set_copy_models(value);
  // @@protoc_insertion_point(field_set:clarifai.api.AppDuplicationFilters.copy_models)
}

// bool copy_workflows = 5;
inline void AppDuplicationFilters::clear_copy_workflows() {
  _impl_.copy_workflows_ = false;
}
inline bool AppDuplicationFilters::_internal_copy_workflows() const {
  return _impl_.copy_workflows_;
}
inline bool AppDuplicationFilters::copy_workflows() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AppDuplicationFilters.copy_workflows)
  return _internal_copy_workflows();
}
inline void AppDuplicationFilters::_internal_set_copy_workflows(bool value) {
  
  _impl_.copy_workflows_ = value;
}
inline void AppDuplicationFilters::set_copy_workflows(bool value) {
  _internal_set_copy_workflows(value);
  // @@protoc_insertion_point(field_set:clarifai.api.AppDuplicationFilters.copy_workflows)
}

// -------------------------------------------------------------------

// LabelOrder

// string id = 1;
inline void LabelOrder::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& LabelOrder::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.LabelOrder.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LabelOrder::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.LabelOrder.id)
}
inline std::string* LabelOrder::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.LabelOrder.id)
  return _s;
}
inline const std::string& LabelOrder::_internal_id() const {
  return _impl_.id_.Get();
}
inline void LabelOrder::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* LabelOrder::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* LabelOrder::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.LabelOrder.id)
  return _impl_.id_.Release();
}
inline void LabelOrder::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.LabelOrder.id)
}

// string name = 2;
inline void LabelOrder::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& LabelOrder::name() const {
  // @@protoc_insertion_point(field_get:clarifai.api.LabelOrder.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LabelOrder::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.LabelOrder.name)
}
inline std::string* LabelOrder::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:clarifai.api.LabelOrder.name)
  return _s;
}
inline const std::string& LabelOrder::_internal_name() const {
  return _impl_.name_.Get();
}
inline void LabelOrder::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* LabelOrder::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* LabelOrder::release_name() {
  // @@protoc_insertion_point(field_release:clarifai.api.LabelOrder.name)
  return _impl_.name_.Release();
}
inline void LabelOrder::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.LabelOrder.name)
}

// .clarifai.api.status.Status status = 3;
inline bool LabelOrder::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool LabelOrder::has_status() const {
  return _internal_has_status();
}
inline const ::clarifai::api::status::Status& LabelOrder::_internal_status() const {
  const ::clarifai::api::status::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::status::Status&>(
      ::clarifai::api::status::_Status_default_instance_);
}
inline const ::clarifai::api::status::Status& LabelOrder::status() const {
  // @@protoc_insertion_point(field_get:clarifai.api.LabelOrder.status)
  return _internal_status();
}
inline void LabelOrder::unsafe_arena_set_allocated_status(
    ::clarifai::api::status::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.LabelOrder.status)
}
inline ::clarifai::api::status::Status* LabelOrder::release_status() {
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::status::Status* LabelOrder::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:clarifai.api.LabelOrder.status)
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::clarifai::api::status::Status* LabelOrder::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::status::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::clarifai::api::status::Status* LabelOrder::mutable_status() {
  ::clarifai::api::status::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:clarifai.api.LabelOrder.status)
  return _msg;
}
inline void LabelOrder::set_allocated_status(::clarifai::api::status::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.LabelOrder.status)
}

// bool auto_release = 4;
inline void LabelOrder::clear_auto_release() {
  _impl_.auto_release_ = false;
}
inline bool LabelOrder::_internal_auto_release() const {
  return _impl_.auto_release_;
}
inline bool LabelOrder::auto_release() const {
  // @@protoc_insertion_point(field_get:clarifai.api.LabelOrder.auto_release)
  return _internal_auto_release();
}
inline void LabelOrder::_internal_set_auto_release(bool value) {
  
  _impl_.auto_release_ = value;
}
inline void LabelOrder::set_auto_release(bool value) {
  _internal_set_auto_release(value);
  // @@protoc_insertion_point(field_set:clarifai.api.LabelOrder.auto_release)
}

// bool allow_empty_tag = 5;
inline void LabelOrder::clear_allow_empty_tag() {
  _impl_.allow_empty_tag_ = false;
}
inline bool LabelOrder::_internal_allow_empty_tag() const {
  return _impl_.allow_empty_tag_;
}
inline bool LabelOrder::allow_empty_tag() const {
  // @@protoc_insertion_point(field_get:clarifai.api.LabelOrder.allow_empty_tag)
  return _internal_allow_empty_tag();
}
inline void LabelOrder::_internal_set_allow_empty_tag(bool value) {
  
  _impl_.allow_empty_tag_ = value;
}
inline void LabelOrder::set_allow_empty_tag(bool value) {
  _internal_set_allow_empty_tag(value);
  // @@protoc_insertion_point(field_set:clarifai.api.LabelOrder.allow_empty_tag)
}

// .google.protobuf.Timestamp desired_fulfill_time = 6;
inline bool LabelOrder::_internal_has_desired_fulfill_time() const {
  return this != internal_default_instance() && _impl_.desired_fulfill_time_ != nullptr;
}
inline bool LabelOrder::has_desired_fulfill_time() const {
  return _internal_has_desired_fulfill_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LabelOrder::_internal_desired_fulfill_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.desired_fulfill_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LabelOrder::desired_fulfill_time() const {
  // @@protoc_insertion_point(field_get:clarifai.api.LabelOrder.desired_fulfill_time)
  return _internal_desired_fulfill_time();
}
inline void LabelOrder::unsafe_arena_set_allocated_desired_fulfill_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* desired_fulfill_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.desired_fulfill_time_);
  }
  _impl_.desired_fulfill_time_ = desired_fulfill_time;
  if (desired_fulfill_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.LabelOrder.desired_fulfill_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LabelOrder::release_desired_fulfill_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.desired_fulfill_time_;
  _impl_.desired_fulfill_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LabelOrder::unsafe_arena_release_desired_fulfill_time() {
  // @@protoc_insertion_point(field_release:clarifai.api.LabelOrder.desired_fulfill_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.desired_fulfill_time_;
  _impl_.desired_fulfill_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LabelOrder::_internal_mutable_desired_fulfill_time() {
  
  if (_impl_.desired_fulfill_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.desired_fulfill_time_ = p;
  }
  return _impl_.desired_fulfill_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LabelOrder::mutable_desired_fulfill_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_desired_fulfill_time();
  // @@protoc_insertion_point(field_mutable:clarifai.api.LabelOrder.desired_fulfill_time)
  return _msg;
}
inline void LabelOrder::set_allocated_desired_fulfill_time(::PROTOBUF_NAMESPACE_ID::Timestamp* desired_fulfill_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.desired_fulfill_time_);
  }
  if (desired_fulfill_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(desired_fulfill_time));
    if (message_arena != submessage_arena) {
      desired_fulfill_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, desired_fulfill_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.desired_fulfill_time_ = desired_fulfill_time;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.LabelOrder.desired_fulfill_time)
}

// .google.protobuf.Timestamp estimate_fulfill_time = 7;
inline bool LabelOrder::_internal_has_estimate_fulfill_time() const {
  return this != internal_default_instance() && _impl_.estimate_fulfill_time_ != nullptr;
}
inline bool LabelOrder::has_estimate_fulfill_time() const {
  return _internal_has_estimate_fulfill_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LabelOrder::_internal_estimate_fulfill_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.estimate_fulfill_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LabelOrder::estimate_fulfill_time() const {
  // @@protoc_insertion_point(field_get:clarifai.api.LabelOrder.estimate_fulfill_time)
  return _internal_estimate_fulfill_time();
}
inline void LabelOrder::unsafe_arena_set_allocated_estimate_fulfill_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* estimate_fulfill_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.estimate_fulfill_time_);
  }
  _impl_.estimate_fulfill_time_ = estimate_fulfill_time;
  if (estimate_fulfill_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.LabelOrder.estimate_fulfill_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LabelOrder::release_estimate_fulfill_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.estimate_fulfill_time_;
  _impl_.estimate_fulfill_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LabelOrder::unsafe_arena_release_estimate_fulfill_time() {
  // @@protoc_insertion_point(field_release:clarifai.api.LabelOrder.estimate_fulfill_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.estimate_fulfill_time_;
  _impl_.estimate_fulfill_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LabelOrder::_internal_mutable_estimate_fulfill_time() {
  
  if (_impl_.estimate_fulfill_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.estimate_fulfill_time_ = p;
  }
  return _impl_.estimate_fulfill_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LabelOrder::mutable_estimate_fulfill_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_estimate_fulfill_time();
  // @@protoc_insertion_point(field_mutable:clarifai.api.LabelOrder.estimate_fulfill_time)
  return _msg;
}
inline void LabelOrder::set_allocated_estimate_fulfill_time(::PROTOBUF_NAMESPACE_ID::Timestamp* estimate_fulfill_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.estimate_fulfill_time_);
  }
  if (estimate_fulfill_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(estimate_fulfill_time));
    if (message_arena != submessage_arena) {
      estimate_fulfill_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, estimate_fulfill_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.estimate_fulfill_time_ = estimate_fulfill_time;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.LabelOrder.estimate_fulfill_time)
}

// .clarifai.api.Task task = 8;
inline bool LabelOrder::_internal_has_task() const {
  return this != internal_default_instance() && _impl_.task_ != nullptr;
}
inline bool LabelOrder::has_task() const {
  return _internal_has_task();
}
inline void LabelOrder::clear_task() {
  if (GetArenaForAllocation() == nullptr && _impl_.task_ != nullptr) {
    delete _impl_.task_;
  }
  _impl_.task_ = nullptr;
}
inline const ::clarifai::api::Task& LabelOrder::_internal_task() const {
  const ::clarifai::api::Task* p = _impl_.task_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Task&>(
      ::clarifai::api::_Task_default_instance_);
}
inline const ::clarifai::api::Task& LabelOrder::task() const {
  // @@protoc_insertion_point(field_get:clarifai.api.LabelOrder.task)
  return _internal_task();
}
inline void LabelOrder::unsafe_arena_set_allocated_task(
    ::clarifai::api::Task* task) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.task_);
  }
  _impl_.task_ = task;
  if (task) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.LabelOrder.task)
}
inline ::clarifai::api::Task* LabelOrder::release_task() {
  
  ::clarifai::api::Task* temp = _impl_.task_;
  _impl_.task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Task* LabelOrder::unsafe_arena_release_task() {
  // @@protoc_insertion_point(field_release:clarifai.api.LabelOrder.task)
  
  ::clarifai::api::Task* temp = _impl_.task_;
  _impl_.task_ = nullptr;
  return temp;
}
inline ::clarifai::api::Task* LabelOrder::_internal_mutable_task() {
  
  if (_impl_.task_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Task>(GetArenaForAllocation());
    _impl_.task_ = p;
  }
  return _impl_.task_;
}
inline ::clarifai::api::Task* LabelOrder::mutable_task() {
  ::clarifai::api::Task* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:clarifai.api.LabelOrder.task)
  return _msg;
}
inline void LabelOrder::set_allocated_task(::clarifai::api::Task* task) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.task_;
  }
  if (task) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(task);
    if (message_arena != submessage_arena) {
      task = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.task_ = task;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.LabelOrder.task)
}

// .google.protobuf.Timestamp created_at = 9;
inline bool LabelOrder::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool LabelOrder::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LabelOrder::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LabelOrder::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.LabelOrder.created_at)
  return _internal_created_at();
}
inline void LabelOrder::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.LabelOrder.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LabelOrder::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LabelOrder::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.LabelOrder.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LabelOrder::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LabelOrder::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.LabelOrder.created_at)
  return _msg;
}
inline void LabelOrder::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.LabelOrder.created_at)
}

// .google.protobuf.Timestamp modified_at = 10;
inline bool LabelOrder::_internal_has_modified_at() const {
  return this != internal_default_instance() && _impl_.modified_at_ != nullptr;
}
inline bool LabelOrder::has_modified_at() const {
  return _internal_has_modified_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LabelOrder::_internal_modified_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.modified_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LabelOrder::modified_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.LabelOrder.modified_at)
  return _internal_modified_at();
}
inline void LabelOrder::unsafe_arena_set_allocated_modified_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  _impl_.modified_at_ = modified_at;
  if (modified_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.LabelOrder.modified_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LabelOrder::release_modified_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LabelOrder::unsafe_arena_release_modified_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.LabelOrder.modified_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LabelOrder::_internal_mutable_modified_at() {
  
  if (_impl_.modified_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.modified_at_ = p;
  }
  return _impl_.modified_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LabelOrder::mutable_modified_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_modified_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.LabelOrder.modified_at)
  return _msg;
}
inline void LabelOrder::set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  if (modified_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(modified_at));
    if (message_arena != submessage_arena) {
      modified_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modified_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.modified_at_ = modified_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.LabelOrder.modified_at)
}

// -------------------------------------------------------------------

// Task

// string id = 1;
inline void Task::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Task::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Task.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Task::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Task.id)
}
inline std::string* Task::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Task.id)
  return _s;
}
inline const std::string& Task::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Task::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Task::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Task::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Task.id)
  return _impl_.id_.Release();
}
inline void Task::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Task.id)
}

// .google.protobuf.Timestamp created_at = 2;
inline bool Task::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool Task::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Task::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Task::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Task.created_at)
  return _internal_created_at();
}
inline void Task::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Task.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Task::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Task::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.Task.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Task::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Task::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Task.created_at)
  return _msg;
}
inline void Task::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Task.created_at)
}

// .google.protobuf.Timestamp modified_at = 3;
inline bool Task::_internal_has_modified_at() const {
  return this != internal_default_instance() && _impl_.modified_at_ != nullptr;
}
inline bool Task::has_modified_at() const {
  return _internal_has_modified_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Task::_internal_modified_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.modified_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Task::modified_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Task.modified_at)
  return _internal_modified_at();
}
inline void Task::unsafe_arena_set_allocated_modified_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  _impl_.modified_at_ = modified_at;
  if (modified_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Task.modified_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Task::release_modified_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Task::unsafe_arena_release_modified_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.Task.modified_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Task::_internal_mutable_modified_at() {
  
  if (_impl_.modified_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.modified_at_ = p;
  }
  return _impl_.modified_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Task::mutable_modified_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_modified_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Task.modified_at)
  return _msg;
}
inline void Task::set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  if (modified_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(modified_at));
    if (message_arena != submessage_arena) {
      modified_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modified_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.modified_at_ = modified_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Task.modified_at)
}

// .clarifai.api.Task.TaskType type = 4;
inline void Task::clear_type() {
  _impl_.type_ = 0;
}
inline ::clarifai::api::Task_TaskType Task::_internal_type() const {
  return static_cast< ::clarifai::api::Task_TaskType >(_impl_.type_);
}
inline ::clarifai::api::Task_TaskType Task::type() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Task.type)
  return _internal_type();
}
inline void Task::_internal_set_type(::clarifai::api::Task_TaskType value) {
  
  _impl_.type_ = value;
}
inline void Task::set_type(::clarifai::api::Task_TaskType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Task.type)
}

// string description = 5;
inline void Task::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Task::description() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Task.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Task::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Task.description)
}
inline std::string* Task::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Task.description)
  return _s;
}
inline const std::string& Task::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Task::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Task::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Task::release_description() {
  // @@protoc_insertion_point(field_release:clarifai.api.Task.description)
  return _impl_.description_.Release();
}
inline void Task::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Task.description)
}

// .clarifai.api.TaskWorker worker = 6;
inline bool Task::_internal_has_worker() const {
  return this != internal_default_instance() && _impl_.worker_ != nullptr;
}
inline bool Task::has_worker() const {
  return _internal_has_worker();
}
inline void Task::clear_worker() {
  if (GetArenaForAllocation() == nullptr && _impl_.worker_ != nullptr) {
    delete _impl_.worker_;
  }
  _impl_.worker_ = nullptr;
}
inline const ::clarifai::api::TaskWorker& Task::_internal_worker() const {
  const ::clarifai::api::TaskWorker* p = _impl_.worker_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::TaskWorker&>(
      ::clarifai::api::_TaskWorker_default_instance_);
}
inline const ::clarifai::api::TaskWorker& Task::worker() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Task.worker)
  return _internal_worker();
}
inline void Task::unsafe_arena_set_allocated_worker(
    ::clarifai::api::TaskWorker* worker) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.worker_);
  }
  _impl_.worker_ = worker;
  if (worker) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Task.worker)
}
inline ::clarifai::api::TaskWorker* Task::release_worker() {
  
  ::clarifai::api::TaskWorker* temp = _impl_.worker_;
  _impl_.worker_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::TaskWorker* Task::unsafe_arena_release_worker() {
  // @@protoc_insertion_point(field_release:clarifai.api.Task.worker)
  
  ::clarifai::api::TaskWorker* temp = _impl_.worker_;
  _impl_.worker_ = nullptr;
  return temp;
}
inline ::clarifai::api::TaskWorker* Task::_internal_mutable_worker() {
  
  if (_impl_.worker_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::TaskWorker>(GetArenaForAllocation());
    _impl_.worker_ = p;
  }
  return _impl_.worker_;
}
inline ::clarifai::api::TaskWorker* Task::mutable_worker() {
  ::clarifai::api::TaskWorker* _msg = _internal_mutable_worker();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Task.worker)
  return _msg;
}
inline void Task::set_allocated_worker(::clarifai::api::TaskWorker* worker) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.worker_;
  }
  if (worker) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(worker);
    if (message_arena != submessage_arena) {
      worker = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, worker, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.worker_ = worker;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Task.worker)
}

// repeated string concept_ids = 7;
inline int Task::_internal_concept_ids_size() const {
  return _impl_.concept_ids_.size();
}
inline int Task::concept_ids_size() const {
  return _internal_concept_ids_size();
}
inline void Task::clear_concept_ids() {
  _impl_.concept_ids_.Clear();
}
inline std::string* Task::add_concept_ids() {
  std::string* _s = _internal_add_concept_ids();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.Task.concept_ids)
  return _s;
}
inline const std::string& Task::_internal_concept_ids(int index) const {
  return _impl_.concept_ids_.Get(index);
}
inline const std::string& Task::concept_ids(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.Task.concept_ids)
  return _internal_concept_ids(index);
}
inline std::string* Task::mutable_concept_ids(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.Task.concept_ids)
  return _impl_.concept_ids_.Mutable(index);
}
inline void Task::set_concept_ids(int index, const std::string& value) {
  _impl_.concept_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Task.concept_ids)
}
inline void Task::set_concept_ids(int index, std::string&& value) {
  _impl_.concept_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.Task.concept_ids)
}
inline void Task::set_concept_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.concept_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.Task.concept_ids)
}
inline void Task::set_concept_ids(int index, const char* value, size_t size) {
  _impl_.concept_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.Task.concept_ids)
}
inline std::string* Task::_internal_add_concept_ids() {
  return _impl_.concept_ids_.Add();
}
inline void Task::add_concept_ids(const std::string& value) {
  _impl_.concept_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.Task.concept_ids)
}
inline void Task::add_concept_ids(std::string&& value) {
  _impl_.concept_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.Task.concept_ids)
}
inline void Task::add_concept_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.concept_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.Task.concept_ids)
}
inline void Task::add_concept_ids(const char* value, size_t size) {
  _impl_.concept_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.Task.concept_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Task::concept_ids() const {
  // @@protoc_insertion_point(field_list:clarifai.api.Task.concept_ids)
  return _impl_.concept_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Task::mutable_concept_ids() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.Task.concept_ids)
  return &_impl_.concept_ids_;
}

// .clarifai.api.TaskInputSource input_source = 8;
inline bool Task::_internal_has_input_source() const {
  return this != internal_default_instance() && _impl_.input_source_ != nullptr;
}
inline bool Task::has_input_source() const {
  return _internal_has_input_source();
}
inline void Task::clear_input_source() {
  if (GetArenaForAllocation() == nullptr && _impl_.input_source_ != nullptr) {
    delete _impl_.input_source_;
  }
  _impl_.input_source_ = nullptr;
}
inline const ::clarifai::api::TaskInputSource& Task::_internal_input_source() const {
  const ::clarifai::api::TaskInputSource* p = _impl_.input_source_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::TaskInputSource&>(
      ::clarifai::api::_TaskInputSource_default_instance_);
}
inline const ::clarifai::api::TaskInputSource& Task::input_source() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Task.input_source)
  return _internal_input_source();
}
inline void Task::unsafe_arena_set_allocated_input_source(
    ::clarifai::api::TaskInputSource* input_source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.input_source_);
  }
  _impl_.input_source_ = input_source;
  if (input_source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Task.input_source)
}
inline ::clarifai::api::TaskInputSource* Task::release_input_source() {
  
  ::clarifai::api::TaskInputSource* temp = _impl_.input_source_;
  _impl_.input_source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::TaskInputSource* Task::unsafe_arena_release_input_source() {
  // @@protoc_insertion_point(field_release:clarifai.api.Task.input_source)
  
  ::clarifai::api::TaskInputSource* temp = _impl_.input_source_;
  _impl_.input_source_ = nullptr;
  return temp;
}
inline ::clarifai::api::TaskInputSource* Task::_internal_mutable_input_source() {
  
  if (_impl_.input_source_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::TaskInputSource>(GetArenaForAllocation());
    _impl_.input_source_ = p;
  }
  return _impl_.input_source_;
}
inline ::clarifai::api::TaskInputSource* Task::mutable_input_source() {
  ::clarifai::api::TaskInputSource* _msg = _internal_mutable_input_source();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Task.input_source)
  return _msg;
}
inline void Task::set_allocated_input_source(::clarifai::api::TaskInputSource* input_source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.input_source_;
  }
  if (input_source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(input_source);
    if (message_arena != submessage_arena) {
      input_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input_source, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.input_source_ = input_source;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Task.input_source)
}

// uint32 sample_ms = 9;
inline void Task::clear_sample_ms() {
  _impl_.sample_ms_ = 0u;
}
inline uint32_t Task::_internal_sample_ms() const {
  return _impl_.sample_ms_;
}
inline uint32_t Task::sample_ms() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Task.sample_ms)
  return _internal_sample_ms();
}
inline void Task::_internal_set_sample_ms(uint32_t value) {
  
  _impl_.sample_ms_ = value;
}
inline void Task::set_sample_ms(uint32_t value) {
  _internal_set_sample_ms(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Task.sample_ms)
}

// .clarifai.api.TaskAIAssistant ai_assistant = 10;
inline bool Task::_internal_has_ai_assistant() const {
  return this != internal_default_instance() && _impl_.ai_assistant_ != nullptr;
}
inline bool Task::has_ai_assistant() const {
  return _internal_has_ai_assistant();
}
inline void Task::clear_ai_assistant() {
  if (GetArenaForAllocation() == nullptr && _impl_.ai_assistant_ != nullptr) {
    delete _impl_.ai_assistant_;
  }
  _impl_.ai_assistant_ = nullptr;
}
inline const ::clarifai::api::TaskAIAssistant& Task::_internal_ai_assistant() const {
  const ::clarifai::api::TaskAIAssistant* p = _impl_.ai_assistant_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::TaskAIAssistant&>(
      ::clarifai::api::_TaskAIAssistant_default_instance_);
}
inline const ::clarifai::api::TaskAIAssistant& Task::ai_assistant() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Task.ai_assistant)
  return _internal_ai_assistant();
}
inline void Task::unsafe_arena_set_allocated_ai_assistant(
    ::clarifai::api::TaskAIAssistant* ai_assistant) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ai_assistant_);
  }
  _impl_.ai_assistant_ = ai_assistant;
  if (ai_assistant) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Task.ai_assistant)
}
inline ::clarifai::api::TaskAIAssistant* Task::release_ai_assistant() {
  
  ::clarifai::api::TaskAIAssistant* temp = _impl_.ai_assistant_;
  _impl_.ai_assistant_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::TaskAIAssistant* Task::unsafe_arena_release_ai_assistant() {
  // @@protoc_insertion_point(field_release:clarifai.api.Task.ai_assistant)
  
  ::clarifai::api::TaskAIAssistant* temp = _impl_.ai_assistant_;
  _impl_.ai_assistant_ = nullptr;
  return temp;
}
inline ::clarifai::api::TaskAIAssistant* Task::_internal_mutable_ai_assistant() {
  
  if (_impl_.ai_assistant_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::TaskAIAssistant>(GetArenaForAllocation());
    _impl_.ai_assistant_ = p;
  }
  return _impl_.ai_assistant_;
}
inline ::clarifai::api::TaskAIAssistant* Task::mutable_ai_assistant() {
  ::clarifai::api::TaskAIAssistant* _msg = _internal_mutable_ai_assistant();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Task.ai_assistant)
  return _msg;
}
inline void Task::set_allocated_ai_assistant(::clarifai::api::TaskAIAssistant* ai_assistant) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ai_assistant_;
  }
  if (ai_assistant) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ai_assistant);
    if (message_arena != submessage_arena) {
      ai_assistant = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ai_assistant, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ai_assistant_ = ai_assistant;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Task.ai_assistant)
}

// .clarifai.api.TaskReview review = 11;
inline bool Task::_internal_has_review() const {
  return this != internal_default_instance() && _impl_.review_ != nullptr;
}
inline bool Task::has_review() const {
  return _internal_has_review();
}
inline void Task::clear_review() {
  if (GetArenaForAllocation() == nullptr && _impl_.review_ != nullptr) {
    delete _impl_.review_;
  }
  _impl_.review_ = nullptr;
}
inline const ::clarifai::api::TaskReview& Task::_internal_review() const {
  const ::clarifai::api::TaskReview* p = _impl_.review_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::TaskReview&>(
      ::clarifai::api::_TaskReview_default_instance_);
}
inline const ::clarifai::api::TaskReview& Task::review() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Task.review)
  return _internal_review();
}
inline void Task::unsafe_arena_set_allocated_review(
    ::clarifai::api::TaskReview* review) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.review_);
  }
  _impl_.review_ = review;
  if (review) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Task.review)
}
inline ::clarifai::api::TaskReview* Task::release_review() {
  
  ::clarifai::api::TaskReview* temp = _impl_.review_;
  _impl_.review_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::TaskReview* Task::unsafe_arena_release_review() {
  // @@protoc_insertion_point(field_release:clarifai.api.Task.review)
  
  ::clarifai::api::TaskReview* temp = _impl_.review_;
  _impl_.review_ = nullptr;
  return temp;
}
inline ::clarifai::api::TaskReview* Task::_internal_mutable_review() {
  
  if (_impl_.review_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::TaskReview>(GetArenaForAllocation());
    _impl_.review_ = p;
  }
  return _impl_.review_;
}
inline ::clarifai::api::TaskReview* Task::mutable_review() {
  ::clarifai::api::TaskReview* _msg = _internal_mutable_review();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Task.review)
  return _msg;
}
inline void Task::set_allocated_review(::clarifai::api::TaskReview* review) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.review_;
  }
  if (review) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(review);
    if (message_arena != submessage_arena) {
      review = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, review, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.review_ = review;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Task.review)
}

// .clarifai.api.status.Status status = 12;
inline bool Task::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool Task::has_status() const {
  return _internal_has_status();
}
inline const ::clarifai::api::status::Status& Task::_internal_status() const {
  const ::clarifai::api::status::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::status::Status&>(
      ::clarifai::api::status::_Status_default_instance_);
}
inline const ::clarifai::api::status::Status& Task::status() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Task.status)
  return _internal_status();
}
inline void Task::unsafe_arena_set_allocated_status(
    ::clarifai::api::status::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Task.status)
}
inline ::clarifai::api::status::Status* Task::release_status() {
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::status::Status* Task::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:clarifai.api.Task.status)
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::clarifai::api::status::Status* Task::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::status::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::clarifai::api::status::Status* Task::mutable_status() {
  ::clarifai::api::status::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Task.status)
  return _msg;
}
inline void Task::set_allocated_status(::clarifai::api::status::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Task.status)
}

// string name = 13;
inline void Task::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Task::name() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Task.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Task::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Task.name)
}
inline std::string* Task::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Task.name)
  return _s;
}
inline const std::string& Task::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Task::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Task::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Task::release_name() {
  // @@protoc_insertion_point(field_release:clarifai.api.Task.name)
  return _impl_.name_.Release();
}
inline void Task::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Task.name)
}

// .clarifai.api.AiAssistParameters ai_assist_params = 14;
inline bool Task::_internal_has_ai_assist_params() const {
  return this != internal_default_instance() && _impl_.ai_assist_params_ != nullptr;
}
inline bool Task::has_ai_assist_params() const {
  return _internal_has_ai_assist_params();
}
inline void Task::clear_ai_assist_params() {
  if (GetArenaForAllocation() == nullptr && _impl_.ai_assist_params_ != nullptr) {
    delete _impl_.ai_assist_params_;
  }
  _impl_.ai_assist_params_ = nullptr;
}
inline const ::clarifai::api::AiAssistParameters& Task::_internal_ai_assist_params() const {
  const ::clarifai::api::AiAssistParameters* p = _impl_.ai_assist_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::AiAssistParameters&>(
      ::clarifai::api::_AiAssistParameters_default_instance_);
}
inline const ::clarifai::api::AiAssistParameters& Task::ai_assist_params() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Task.ai_assist_params)
  return _internal_ai_assist_params();
}
inline void Task::unsafe_arena_set_allocated_ai_assist_params(
    ::clarifai::api::AiAssistParameters* ai_assist_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ai_assist_params_);
  }
  _impl_.ai_assist_params_ = ai_assist_params;
  if (ai_assist_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Task.ai_assist_params)
}
inline ::clarifai::api::AiAssistParameters* Task::release_ai_assist_params() {
  
  ::clarifai::api::AiAssistParameters* temp = _impl_.ai_assist_params_;
  _impl_.ai_assist_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::AiAssistParameters* Task::unsafe_arena_release_ai_assist_params() {
  // @@protoc_insertion_point(field_release:clarifai.api.Task.ai_assist_params)
  
  ::clarifai::api::AiAssistParameters* temp = _impl_.ai_assist_params_;
  _impl_.ai_assist_params_ = nullptr;
  return temp;
}
inline ::clarifai::api::AiAssistParameters* Task::_internal_mutable_ai_assist_params() {
  
  if (_impl_.ai_assist_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::AiAssistParameters>(GetArenaForAllocation());
    _impl_.ai_assist_params_ = p;
  }
  return _impl_.ai_assist_params_;
}
inline ::clarifai::api::AiAssistParameters* Task::mutable_ai_assist_params() {
  ::clarifai::api::AiAssistParameters* _msg = _internal_mutable_ai_assist_params();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Task.ai_assist_params)
  return _msg;
}
inline void Task::set_allocated_ai_assist_params(::clarifai::api::AiAssistParameters* ai_assist_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ai_assist_params_;
  }
  if (ai_assist_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ai_assist_params);
    if (message_arena != submessage_arena) {
      ai_assist_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ai_assist_params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ai_assist_params_ = ai_assist_params;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Task.ai_assist_params)
}

// .clarifai.api.Visibility visibility = 15;
inline bool Task::_internal_has_visibility() const {
  return this != internal_default_instance() && _impl_.visibility_ != nullptr;
}
inline bool Task::has_visibility() const {
  return _internal_has_visibility();
}
inline void Task::clear_visibility() {
  if (GetArenaForAllocation() == nullptr && _impl_.visibility_ != nullptr) {
    delete _impl_.visibility_;
  }
  _impl_.visibility_ = nullptr;
}
inline const ::clarifai::api::Visibility& Task::_internal_visibility() const {
  const ::clarifai::api::Visibility* p = _impl_.visibility_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Visibility&>(
      ::clarifai::api::_Visibility_default_instance_);
}
inline const ::clarifai::api::Visibility& Task::visibility() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Task.visibility)
  return _internal_visibility();
}
inline void Task::unsafe_arena_set_allocated_visibility(
    ::clarifai::api::Visibility* visibility) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visibility_);
  }
  _impl_.visibility_ = visibility;
  if (visibility) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Task.visibility)
}
inline ::clarifai::api::Visibility* Task::release_visibility() {
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Visibility* Task::unsafe_arena_release_visibility() {
  // @@protoc_insertion_point(field_release:clarifai.api.Task.visibility)
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
  return temp;
}
inline ::clarifai::api::Visibility* Task::_internal_mutable_visibility() {
  
  if (_impl_.visibility_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Visibility>(GetArenaForAllocation());
    _impl_.visibility_ = p;
  }
  return _impl_.visibility_;
}
inline ::clarifai::api::Visibility* Task::mutable_visibility() {
  ::clarifai::api::Visibility* _msg = _internal_mutable_visibility();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Task.visibility)
  return _msg;
}
inline void Task::set_allocated_visibility(::clarifai::api::Visibility* visibility) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.visibility_;
  }
  if (visibility) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(visibility);
    if (message_arena != submessage_arena) {
      visibility = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visibility, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.visibility_ = visibility;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Task.visibility)
}

// string app_id = 16;
inline void Task::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& Task::app_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Task.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Task::set_app_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.app_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Task.app_id)
}
inline std::string* Task::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Task.app_id)
  return _s;
}
inline const std::string& Task::_internal_app_id() const {
  return _impl_.app_id_.Get();
}
inline void Task::_internal_set_app_id(const std::string& value) {
  
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Task::_internal_mutable_app_id() {
  
  return _impl_.app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Task::release_app_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Task.app_id)
  return _impl_.app_id_.Release();
}
inline void Task::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    
  } else {
    
  }
  _impl_.app_id_.SetAllocated(app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Task.app_id)
}

// string user_id = 17;
inline void Task::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& Task::user_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Task.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Task::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Task.user_id)
}
inline std::string* Task::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Task.user_id)
  return _s;
}
inline const std::string& Task::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void Task::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Task::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Task::release_user_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Task.user_id)
  return _impl_.user_id_.Release();
}
inline void Task::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Task.user_id)
}

// string label_order_id = 18;
inline void Task::clear_label_order_id() {
  _impl_.label_order_id_.ClearToEmpty();
}
inline const std::string& Task::label_order_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Task.label_order_id)
  return _internal_label_order_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Task::set_label_order_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.label_order_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Task.label_order_id)
}
inline std::string* Task::mutable_label_order_id() {
  std::string* _s = _internal_mutable_label_order_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Task.label_order_id)
  return _s;
}
inline const std::string& Task::_internal_label_order_id() const {
  return _impl_.label_order_id_.Get();
}
inline void Task::_internal_set_label_order_id(const std::string& value) {
  
  _impl_.label_order_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Task::_internal_mutable_label_order_id() {
  
  return _impl_.label_order_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Task::release_label_order_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Task.label_order_id)
  return _impl_.label_order_id_.Release();
}
inline void Task::set_allocated_label_order_id(std::string* label_order_id) {
  if (label_order_id != nullptr) {
    
  } else {
    
  }
  _impl_.label_order_id_.SetAllocated(label_order_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_order_id_.IsDefault()) {
    _impl_.label_order_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Task.label_order_id)
}

// -------------------------------------------------------------------

// AiAssistParameters

// float min_threshold = 1;
inline void AiAssistParameters::clear_min_threshold() {
  _impl_.min_threshold_ = 0;
}
inline float AiAssistParameters::_internal_min_threshold() const {
  return _impl_.min_threshold_;
}
inline float AiAssistParameters::min_threshold() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AiAssistParameters.min_threshold)
  return _internal_min_threshold();
}
inline void AiAssistParameters::_internal_set_min_threshold(float value) {
  
  _impl_.min_threshold_ = value;
}
inline void AiAssistParameters::set_min_threshold(float value) {
  _internal_set_min_threshold(value);
  // @@protoc_insertion_point(field_set:clarifai.api.AiAssistParameters.min_threshold)
}

// float max_threshold = 2;
inline void AiAssistParameters::clear_max_threshold() {
  _impl_.max_threshold_ = 0;
}
inline float AiAssistParameters::_internal_max_threshold() const {
  return _impl_.max_threshold_;
}
inline float AiAssistParameters::max_threshold() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AiAssistParameters.max_threshold)
  return _internal_max_threshold();
}
inline void AiAssistParameters::_internal_set_max_threshold(float value) {
  
  _impl_.max_threshold_ = value;
}
inline void AiAssistParameters::set_max_threshold(float value) {
  _internal_set_max_threshold(value);
  // @@protoc_insertion_point(field_set:clarifai.api.AiAssistParameters.max_threshold)
}

// repeated string concept_relation_ids = 3;
inline int AiAssistParameters::_internal_concept_relation_ids_size() const {
  return _impl_.concept_relation_ids_.size();
}
inline int AiAssistParameters::concept_relation_ids_size() const {
  return _internal_concept_relation_ids_size();
}
inline void AiAssistParameters::clear_concept_relation_ids() {
  _impl_.concept_relation_ids_.Clear();
}
inline std::string* AiAssistParameters::add_concept_relation_ids() {
  std::string* _s = _internal_add_concept_relation_ids();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.AiAssistParameters.concept_relation_ids)
  return _s;
}
inline const std::string& AiAssistParameters::_internal_concept_relation_ids(int index) const {
  return _impl_.concept_relation_ids_.Get(index);
}
inline const std::string& AiAssistParameters::concept_relation_ids(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.AiAssistParameters.concept_relation_ids)
  return _internal_concept_relation_ids(index);
}
inline std::string* AiAssistParameters::mutable_concept_relation_ids(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.AiAssistParameters.concept_relation_ids)
  return _impl_.concept_relation_ids_.Mutable(index);
}
inline void AiAssistParameters::set_concept_relation_ids(int index, const std::string& value) {
  _impl_.concept_relation_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.AiAssistParameters.concept_relation_ids)
}
inline void AiAssistParameters::set_concept_relation_ids(int index, std::string&& value) {
  _impl_.concept_relation_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.AiAssistParameters.concept_relation_ids)
}
inline void AiAssistParameters::set_concept_relation_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.concept_relation_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.AiAssistParameters.concept_relation_ids)
}
inline void AiAssistParameters::set_concept_relation_ids(int index, const char* value, size_t size) {
  _impl_.concept_relation_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.AiAssistParameters.concept_relation_ids)
}
inline std::string* AiAssistParameters::_internal_add_concept_relation_ids() {
  return _impl_.concept_relation_ids_.Add();
}
inline void AiAssistParameters::add_concept_relation_ids(const std::string& value) {
  _impl_.concept_relation_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.AiAssistParameters.concept_relation_ids)
}
inline void AiAssistParameters::add_concept_relation_ids(std::string&& value) {
  _impl_.concept_relation_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.AiAssistParameters.concept_relation_ids)
}
inline void AiAssistParameters::add_concept_relation_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.concept_relation_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.AiAssistParameters.concept_relation_ids)
}
inline void AiAssistParameters::add_concept_relation_ids(const char* value, size_t size) {
  _impl_.concept_relation_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.AiAssistParameters.concept_relation_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AiAssistParameters::concept_relation_ids() const {
  // @@protoc_insertion_point(field_list:clarifai.api.AiAssistParameters.concept_relation_ids)
  return _impl_.concept_relation_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AiAssistParameters::mutable_concept_relation_ids() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.AiAssistParameters.concept_relation_ids)
  return &_impl_.concept_relation_ids_;
}

// -------------------------------------------------------------------

// TaskWorker

// .clarifai.api.TaskWorker.TaskWorkerStrategy strategy = 1;
inline void TaskWorker::clear_strategy() {
  _impl_.strategy_ = 0;
}
inline ::clarifai::api::TaskWorker_TaskWorkerStrategy TaskWorker::_internal_strategy() const {
  return static_cast< ::clarifai::api::TaskWorker_TaskWorkerStrategy >(_impl_.strategy_);
}
inline ::clarifai::api::TaskWorker_TaskWorkerStrategy TaskWorker::strategy() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TaskWorker.strategy)
  return _internal_strategy();
}
inline void TaskWorker::_internal_set_strategy(::clarifai::api::TaskWorker_TaskWorkerStrategy value) {
  
  _impl_.strategy_ = value;
}
inline void TaskWorker::set_strategy(::clarifai::api::TaskWorker_TaskWorkerStrategy value) {
  _internal_set_strategy(value);
  // @@protoc_insertion_point(field_set:clarifai.api.TaskWorker.strategy)
}

// repeated string user_ids = 2 [deprecated = true];
inline int TaskWorker::_internal_user_ids_size() const {
  return _impl_.user_ids_.size();
}
inline int TaskWorker::user_ids_size() const {
  return _internal_user_ids_size();
}
inline void TaskWorker::clear_user_ids() {
  _impl_.user_ids_.Clear();
}
inline std::string* TaskWorker::add_user_ids() {
  std::string* _s = _internal_add_user_ids();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.TaskWorker.user_ids)
  return _s;
}
inline const std::string& TaskWorker::_internal_user_ids(int index) const {
  return _impl_.user_ids_.Get(index);
}
inline const std::string& TaskWorker::user_ids(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.TaskWorker.user_ids)
  return _internal_user_ids(index);
}
inline std::string* TaskWorker::mutable_user_ids(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.TaskWorker.user_ids)
  return _impl_.user_ids_.Mutable(index);
}
inline void TaskWorker::set_user_ids(int index, const std::string& value) {
  _impl_.user_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.TaskWorker.user_ids)
}
inline void TaskWorker::set_user_ids(int index, std::string&& value) {
  _impl_.user_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.TaskWorker.user_ids)
}
inline void TaskWorker::set_user_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.user_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.TaskWorker.user_ids)
}
inline void TaskWorker::set_user_ids(int index, const char* value, size_t size) {
  _impl_.user_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.TaskWorker.user_ids)
}
inline std::string* TaskWorker::_internal_add_user_ids() {
  return _impl_.user_ids_.Add();
}
inline void TaskWorker::add_user_ids(const std::string& value) {
  _impl_.user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.TaskWorker.user_ids)
}
inline void TaskWorker::add_user_ids(std::string&& value) {
  _impl_.user_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.TaskWorker.user_ids)
}
inline void TaskWorker::add_user_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.TaskWorker.user_ids)
}
inline void TaskWorker::add_user_ids(const char* value, size_t size) {
  _impl_.user_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.TaskWorker.user_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TaskWorker::user_ids() const {
  // @@protoc_insertion_point(field_list:clarifai.api.TaskWorker.user_ids)
  return _impl_.user_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TaskWorker::mutable_user_ids() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.TaskWorker.user_ids)
  return &_impl_.user_ids_;
}

// repeated .clarifai.api.User users = 4;
inline int TaskWorker::_internal_users_size() const {
  return _impl_.users_.size();
}
inline int TaskWorker::users_size() const {
  return _internal_users_size();
}
inline void TaskWorker::clear_users() {
  _impl_.users_.Clear();
}
inline ::clarifai::api::User* TaskWorker::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.TaskWorker.users)
  return _impl_.users_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::User >*
TaskWorker::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.TaskWorker.users)
  return &_impl_.users_;
}
inline const ::clarifai::api::User& TaskWorker::_internal_users(int index) const {
  return _impl_.users_.Get(index);
}
inline const ::clarifai::api::User& TaskWorker::users(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.TaskWorker.users)
  return _internal_users(index);
}
inline ::clarifai::api::User* TaskWorker::_internal_add_users() {
  return _impl_.users_.Add();
}
inline ::clarifai::api::User* TaskWorker::add_users() {
  ::clarifai::api::User* _add = _internal_add_users();
  // @@protoc_insertion_point(field_add:clarifai.api.TaskWorker.users)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::User >&
TaskWorker::users() const {
  // @@protoc_insertion_point(field_list:clarifai.api.TaskWorker.users)
  return _impl_.users_;
}

// .clarifai.api.TaskWorkerPartitionedStrategyInfo partitioned_strategy_info = 3;
inline bool TaskWorker::_internal_has_partitioned_strategy_info() const {
  return strategy_info_case() == kPartitionedStrategyInfo;
}
inline bool TaskWorker::has_partitioned_strategy_info() const {
  return _internal_has_partitioned_strategy_info();
}
inline void TaskWorker::set_has_partitioned_strategy_info() {
  _impl_._oneof_case_[0] = kPartitionedStrategyInfo;
}
inline void TaskWorker::clear_partitioned_strategy_info() {
  if (_internal_has_partitioned_strategy_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.strategy_info_.partitioned_strategy_info_;
    }
    clear_has_strategy_info();
  }
}
inline ::clarifai::api::TaskWorkerPartitionedStrategyInfo* TaskWorker::release_partitioned_strategy_info() {
  // @@protoc_insertion_point(field_release:clarifai.api.TaskWorker.partitioned_strategy_info)
  if (_internal_has_partitioned_strategy_info()) {
    clear_has_strategy_info();
    ::clarifai::api::TaskWorkerPartitionedStrategyInfo* temp = _impl_.strategy_info_.partitioned_strategy_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.strategy_info_.partitioned_strategy_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clarifai::api::TaskWorkerPartitionedStrategyInfo& TaskWorker::_internal_partitioned_strategy_info() const {
  return _internal_has_partitioned_strategy_info()
      ? *_impl_.strategy_info_.partitioned_strategy_info_
      : reinterpret_cast< ::clarifai::api::TaskWorkerPartitionedStrategyInfo&>(::clarifai::api::_TaskWorkerPartitionedStrategyInfo_default_instance_);
}
inline const ::clarifai::api::TaskWorkerPartitionedStrategyInfo& TaskWorker::partitioned_strategy_info() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TaskWorker.partitioned_strategy_info)
  return _internal_partitioned_strategy_info();
}
inline ::clarifai::api::TaskWorkerPartitionedStrategyInfo* TaskWorker::unsafe_arena_release_partitioned_strategy_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clarifai.api.TaskWorker.partitioned_strategy_info)
  if (_internal_has_partitioned_strategy_info()) {
    clear_has_strategy_info();
    ::clarifai::api::TaskWorkerPartitionedStrategyInfo* temp = _impl_.strategy_info_.partitioned_strategy_info_;
    _impl_.strategy_info_.partitioned_strategy_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TaskWorker::unsafe_arena_set_allocated_partitioned_strategy_info(::clarifai::api::TaskWorkerPartitionedStrategyInfo* partitioned_strategy_info) {
  clear_strategy_info();
  if (partitioned_strategy_info) {
    set_has_partitioned_strategy_info();
    _impl_.strategy_info_.partitioned_strategy_info_ = partitioned_strategy_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.TaskWorker.partitioned_strategy_info)
}
inline ::clarifai::api::TaskWorkerPartitionedStrategyInfo* TaskWorker::_internal_mutable_partitioned_strategy_info() {
  if (!_internal_has_partitioned_strategy_info()) {
    clear_strategy_info();
    set_has_partitioned_strategy_info();
    _impl_.strategy_info_.partitioned_strategy_info_ = CreateMaybeMessage< ::clarifai::api::TaskWorkerPartitionedStrategyInfo >(GetArenaForAllocation());
  }
  return _impl_.strategy_info_.partitioned_strategy_info_;
}
inline ::clarifai::api::TaskWorkerPartitionedStrategyInfo* TaskWorker::mutable_partitioned_strategy_info() {
  ::clarifai::api::TaskWorkerPartitionedStrategyInfo* _msg = _internal_mutable_partitioned_strategy_info();
  // @@protoc_insertion_point(field_mutable:clarifai.api.TaskWorker.partitioned_strategy_info)
  return _msg;
}

inline bool TaskWorker::has_strategy_info() const {
  return strategy_info_case() != STRATEGY_INFO_NOT_SET;
}
inline void TaskWorker::clear_has_strategy_info() {
  _impl_._oneof_case_[0] = STRATEGY_INFO_NOT_SET;
}
inline TaskWorker::StrategyInfoCase TaskWorker::strategy_info_case() const {
  return TaskWorker::StrategyInfoCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TaskWorkerPartitionedStrategyInfo

// .clarifai.api.TaskWorkerPartitionedStrategyInfo.TaskWorkerPartitionedStrategy type = 1;
inline void TaskWorkerPartitionedStrategyInfo::clear_type() {
  _impl_.type_ = 0;
}
inline ::clarifai::api::TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy TaskWorkerPartitionedStrategyInfo::_internal_type() const {
  return static_cast< ::clarifai::api::TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy >(_impl_.type_);
}
inline ::clarifai::api::TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy TaskWorkerPartitionedStrategyInfo::type() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TaskWorkerPartitionedStrategyInfo.type)
  return _internal_type();
}
inline void TaskWorkerPartitionedStrategyInfo::_internal_set_type(::clarifai::api::TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy value) {
  
  _impl_.type_ = value;
}
inline void TaskWorkerPartitionedStrategyInfo::set_type(::clarifai::api::TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:clarifai.api.TaskWorkerPartitionedStrategyInfo.type)
}

// int32 workers_per_input = 2;
inline void TaskWorkerPartitionedStrategyInfo::clear_workers_per_input() {
  _impl_.workers_per_input_ = 0;
}
inline int32_t TaskWorkerPartitionedStrategyInfo::_internal_workers_per_input() const {
  return _impl_.workers_per_input_;
}
inline int32_t TaskWorkerPartitionedStrategyInfo::workers_per_input() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TaskWorkerPartitionedStrategyInfo.workers_per_input)
  return _internal_workers_per_input();
}
inline void TaskWorkerPartitionedStrategyInfo::_internal_set_workers_per_input(int32_t value) {
  
  _impl_.workers_per_input_ = value;
}
inline void TaskWorkerPartitionedStrategyInfo::set_workers_per_input(int32_t value) {
  _internal_set_workers_per_input(value);
  // @@protoc_insertion_point(field_set:clarifai.api.TaskWorkerPartitionedStrategyInfo.workers_per_input)
}

// .google.protobuf.Struct weights = 3;
inline bool TaskWorkerPartitionedStrategyInfo::_internal_has_weights() const {
  return this != internal_default_instance() && _impl_.weights_ != nullptr;
}
inline bool TaskWorkerPartitionedStrategyInfo::has_weights() const {
  return _internal_has_weights();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& TaskWorkerPartitionedStrategyInfo::_internal_weights() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.weights_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& TaskWorkerPartitionedStrategyInfo::weights() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TaskWorkerPartitionedStrategyInfo.weights)
  return _internal_weights();
}
inline void TaskWorkerPartitionedStrategyInfo::unsafe_arena_set_allocated_weights(
    ::PROTOBUF_NAMESPACE_ID::Struct* weights) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.weights_);
  }
  _impl_.weights_ = weights;
  if (weights) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.TaskWorkerPartitionedStrategyInfo.weights)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* TaskWorkerPartitionedStrategyInfo::release_weights() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.weights_;
  _impl_.weights_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* TaskWorkerPartitionedStrategyInfo::unsafe_arena_release_weights() {
  // @@protoc_insertion_point(field_release:clarifai.api.TaskWorkerPartitionedStrategyInfo.weights)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.weights_;
  _impl_.weights_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* TaskWorkerPartitionedStrategyInfo::_internal_mutable_weights() {
  
  if (_impl_.weights_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.weights_ = p;
  }
  return _impl_.weights_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* TaskWorkerPartitionedStrategyInfo::mutable_weights() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_weights();
  // @@protoc_insertion_point(field_mutable:clarifai.api.TaskWorkerPartitionedStrategyInfo.weights)
  return _msg;
}
inline void TaskWorkerPartitionedStrategyInfo::set_allocated_weights(::PROTOBUF_NAMESPACE_ID::Struct* weights) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.weights_);
  }
  if (weights) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(weights));
    if (message_arena != submessage_arena) {
      weights = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, weights, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.weights_ = weights;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.TaskWorkerPartitionedStrategyInfo.weights)
}

// -------------------------------------------------------------------

// TaskInputSource

// .clarifai.api.TaskInputSource.TaskInputSourceType type = 1;
inline void TaskInputSource::clear_type() {
  _impl_.type_ = 0;
}
inline ::clarifai::api::TaskInputSource_TaskInputSourceType TaskInputSource::_internal_type() const {
  return static_cast< ::clarifai::api::TaskInputSource_TaskInputSourceType >(_impl_.type_);
}
inline ::clarifai::api::TaskInputSource_TaskInputSourceType TaskInputSource::type() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TaskInputSource.type)
  return _internal_type();
}
inline void TaskInputSource::_internal_set_type(::clarifai::api::TaskInputSource_TaskInputSourceType value) {
  
  _impl_.type_ = value;
}
inline void TaskInputSource::set_type(::clarifai::api::TaskInputSource_TaskInputSourceType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:clarifai.api.TaskInputSource.type)
}

// string id = 2;
inline void TaskInputSource::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& TaskInputSource::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TaskInputSource.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskInputSource::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.TaskInputSource.id)
}
inline std::string* TaskInputSource::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.TaskInputSource.id)
  return _s;
}
inline const std::string& TaskInputSource::_internal_id() const {
  return _impl_.id_.Get();
}
inline void TaskInputSource::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* TaskInputSource::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* TaskInputSource::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.TaskInputSource.id)
  return _impl_.id_.Release();
}
inline void TaskInputSource::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.TaskInputSource.id)
}

// -------------------------------------------------------------------

// TaskReview

// .clarifai.api.TaskReview.TaskReviewStrategy strategy = 1;
inline void TaskReview::clear_strategy() {
  _impl_.strategy_ = 0;
}
inline ::clarifai::api::TaskReview_TaskReviewStrategy TaskReview::_internal_strategy() const {
  return static_cast< ::clarifai::api::TaskReview_TaskReviewStrategy >(_impl_.strategy_);
}
inline ::clarifai::api::TaskReview_TaskReviewStrategy TaskReview::strategy() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TaskReview.strategy)
  return _internal_strategy();
}
inline void TaskReview::_internal_set_strategy(::clarifai::api::TaskReview_TaskReviewStrategy value) {
  
  _impl_.strategy_ = value;
}
inline void TaskReview::set_strategy(::clarifai::api::TaskReview_TaskReviewStrategy value) {
  _internal_set_strategy(value);
  // @@protoc_insertion_point(field_set:clarifai.api.TaskReview.strategy)
}

// repeated string user_ids = 2 [deprecated = true];
inline int TaskReview::_internal_user_ids_size() const {
  return _impl_.user_ids_.size();
}
inline int TaskReview::user_ids_size() const {
  return _internal_user_ids_size();
}
inline void TaskReview::clear_user_ids() {
  _impl_.user_ids_.Clear();
}
inline std::string* TaskReview::add_user_ids() {
  std::string* _s = _internal_add_user_ids();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.TaskReview.user_ids)
  return _s;
}
inline const std::string& TaskReview::_internal_user_ids(int index) const {
  return _impl_.user_ids_.Get(index);
}
inline const std::string& TaskReview::user_ids(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.TaskReview.user_ids)
  return _internal_user_ids(index);
}
inline std::string* TaskReview::mutable_user_ids(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.TaskReview.user_ids)
  return _impl_.user_ids_.Mutable(index);
}
inline void TaskReview::set_user_ids(int index, const std::string& value) {
  _impl_.user_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.TaskReview.user_ids)
}
inline void TaskReview::set_user_ids(int index, std::string&& value) {
  _impl_.user_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.TaskReview.user_ids)
}
inline void TaskReview::set_user_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.user_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.TaskReview.user_ids)
}
inline void TaskReview::set_user_ids(int index, const char* value, size_t size) {
  _impl_.user_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.TaskReview.user_ids)
}
inline std::string* TaskReview::_internal_add_user_ids() {
  return _impl_.user_ids_.Add();
}
inline void TaskReview::add_user_ids(const std::string& value) {
  _impl_.user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.TaskReview.user_ids)
}
inline void TaskReview::add_user_ids(std::string&& value) {
  _impl_.user_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.TaskReview.user_ids)
}
inline void TaskReview::add_user_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.TaskReview.user_ids)
}
inline void TaskReview::add_user_ids(const char* value, size_t size) {
  _impl_.user_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.TaskReview.user_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TaskReview::user_ids() const {
  // @@protoc_insertion_point(field_list:clarifai.api.TaskReview.user_ids)
  return _impl_.user_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TaskReview::mutable_user_ids() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.TaskReview.user_ids)
  return &_impl_.user_ids_;
}

// repeated .clarifai.api.User users = 5;
inline int TaskReview::_internal_users_size() const {
  return _impl_.users_.size();
}
inline int TaskReview::users_size() const {
  return _internal_users_size();
}
inline void TaskReview::clear_users() {
  _impl_.users_.Clear();
}
inline ::clarifai::api::User* TaskReview::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.TaskReview.users)
  return _impl_.users_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::User >*
TaskReview::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.TaskReview.users)
  return &_impl_.users_;
}
inline const ::clarifai::api::User& TaskReview::_internal_users(int index) const {
  return _impl_.users_.Get(index);
}
inline const ::clarifai::api::User& TaskReview::users(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.TaskReview.users)
  return _internal_users(index);
}
inline ::clarifai::api::User* TaskReview::_internal_add_users() {
  return _impl_.users_.Add();
}
inline ::clarifai::api::User* TaskReview::add_users() {
  ::clarifai::api::User* _add = _internal_add_users();
  // @@protoc_insertion_point(field_add:clarifai.api.TaskReview.users)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::User >&
TaskReview::users() const {
  // @@protoc_insertion_point(field_list:clarifai.api.TaskReview.users)
  return _impl_.users_;
}

// .clarifai.api.TaskReviewManualStrategyInfo manual_strategy_info = 3;
inline bool TaskReview::_internal_has_manual_strategy_info() const {
  return strategy_info_case() == kManualStrategyInfo;
}
inline bool TaskReview::has_manual_strategy_info() const {
  return _internal_has_manual_strategy_info();
}
inline void TaskReview::set_has_manual_strategy_info() {
  _impl_._oneof_case_[0] = kManualStrategyInfo;
}
inline void TaskReview::clear_manual_strategy_info() {
  if (_internal_has_manual_strategy_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.strategy_info_.manual_strategy_info_;
    }
    clear_has_strategy_info();
  }
}
inline ::clarifai::api::TaskReviewManualStrategyInfo* TaskReview::release_manual_strategy_info() {
  // @@protoc_insertion_point(field_release:clarifai.api.TaskReview.manual_strategy_info)
  if (_internal_has_manual_strategy_info()) {
    clear_has_strategy_info();
    ::clarifai::api::TaskReviewManualStrategyInfo* temp = _impl_.strategy_info_.manual_strategy_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.strategy_info_.manual_strategy_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clarifai::api::TaskReviewManualStrategyInfo& TaskReview::_internal_manual_strategy_info() const {
  return _internal_has_manual_strategy_info()
      ? *_impl_.strategy_info_.manual_strategy_info_
      : reinterpret_cast< ::clarifai::api::TaskReviewManualStrategyInfo&>(::clarifai::api::_TaskReviewManualStrategyInfo_default_instance_);
}
inline const ::clarifai::api::TaskReviewManualStrategyInfo& TaskReview::manual_strategy_info() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TaskReview.manual_strategy_info)
  return _internal_manual_strategy_info();
}
inline ::clarifai::api::TaskReviewManualStrategyInfo* TaskReview::unsafe_arena_release_manual_strategy_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clarifai.api.TaskReview.manual_strategy_info)
  if (_internal_has_manual_strategy_info()) {
    clear_has_strategy_info();
    ::clarifai::api::TaskReviewManualStrategyInfo* temp = _impl_.strategy_info_.manual_strategy_info_;
    _impl_.strategy_info_.manual_strategy_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TaskReview::unsafe_arena_set_allocated_manual_strategy_info(::clarifai::api::TaskReviewManualStrategyInfo* manual_strategy_info) {
  clear_strategy_info();
  if (manual_strategy_info) {
    set_has_manual_strategy_info();
    _impl_.strategy_info_.manual_strategy_info_ = manual_strategy_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.TaskReview.manual_strategy_info)
}
inline ::clarifai::api::TaskReviewManualStrategyInfo* TaskReview::_internal_mutable_manual_strategy_info() {
  if (!_internal_has_manual_strategy_info()) {
    clear_strategy_info();
    set_has_manual_strategy_info();
    _impl_.strategy_info_.manual_strategy_info_ = CreateMaybeMessage< ::clarifai::api::TaskReviewManualStrategyInfo >(GetArenaForAllocation());
  }
  return _impl_.strategy_info_.manual_strategy_info_;
}
inline ::clarifai::api::TaskReviewManualStrategyInfo* TaskReview::mutable_manual_strategy_info() {
  ::clarifai::api::TaskReviewManualStrategyInfo* _msg = _internal_mutable_manual_strategy_info();
  // @@protoc_insertion_point(field_mutable:clarifai.api.TaskReview.manual_strategy_info)
  return _msg;
}

// .clarifai.api.TaskReviewConsensusStrategyInfo consensus_strategy_info = 4;
inline bool TaskReview::_internal_has_consensus_strategy_info() const {
  return strategy_info_case() == kConsensusStrategyInfo;
}
inline bool TaskReview::has_consensus_strategy_info() const {
  return _internal_has_consensus_strategy_info();
}
inline void TaskReview::set_has_consensus_strategy_info() {
  _impl_._oneof_case_[0] = kConsensusStrategyInfo;
}
inline void TaskReview::clear_consensus_strategy_info() {
  if (_internal_has_consensus_strategy_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.strategy_info_.consensus_strategy_info_;
    }
    clear_has_strategy_info();
  }
}
inline ::clarifai::api::TaskReviewConsensusStrategyInfo* TaskReview::release_consensus_strategy_info() {
  // @@protoc_insertion_point(field_release:clarifai.api.TaskReview.consensus_strategy_info)
  if (_internal_has_consensus_strategy_info()) {
    clear_has_strategy_info();
    ::clarifai::api::TaskReviewConsensusStrategyInfo* temp = _impl_.strategy_info_.consensus_strategy_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.strategy_info_.consensus_strategy_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clarifai::api::TaskReviewConsensusStrategyInfo& TaskReview::_internal_consensus_strategy_info() const {
  return _internal_has_consensus_strategy_info()
      ? *_impl_.strategy_info_.consensus_strategy_info_
      : reinterpret_cast< ::clarifai::api::TaskReviewConsensusStrategyInfo&>(::clarifai::api::_TaskReviewConsensusStrategyInfo_default_instance_);
}
inline const ::clarifai::api::TaskReviewConsensusStrategyInfo& TaskReview::consensus_strategy_info() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TaskReview.consensus_strategy_info)
  return _internal_consensus_strategy_info();
}
inline ::clarifai::api::TaskReviewConsensusStrategyInfo* TaskReview::unsafe_arena_release_consensus_strategy_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clarifai.api.TaskReview.consensus_strategy_info)
  if (_internal_has_consensus_strategy_info()) {
    clear_has_strategy_info();
    ::clarifai::api::TaskReviewConsensusStrategyInfo* temp = _impl_.strategy_info_.consensus_strategy_info_;
    _impl_.strategy_info_.consensus_strategy_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TaskReview::unsafe_arena_set_allocated_consensus_strategy_info(::clarifai::api::TaskReviewConsensusStrategyInfo* consensus_strategy_info) {
  clear_strategy_info();
  if (consensus_strategy_info) {
    set_has_consensus_strategy_info();
    _impl_.strategy_info_.consensus_strategy_info_ = consensus_strategy_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.TaskReview.consensus_strategy_info)
}
inline ::clarifai::api::TaskReviewConsensusStrategyInfo* TaskReview::_internal_mutable_consensus_strategy_info() {
  if (!_internal_has_consensus_strategy_info()) {
    clear_strategy_info();
    set_has_consensus_strategy_info();
    _impl_.strategy_info_.consensus_strategy_info_ = CreateMaybeMessage< ::clarifai::api::TaskReviewConsensusStrategyInfo >(GetArenaForAllocation());
  }
  return _impl_.strategy_info_.consensus_strategy_info_;
}
inline ::clarifai::api::TaskReviewConsensusStrategyInfo* TaskReview::mutable_consensus_strategy_info() {
  ::clarifai::api::TaskReviewConsensusStrategyInfo* _msg = _internal_mutable_consensus_strategy_info();
  // @@protoc_insertion_point(field_mutable:clarifai.api.TaskReview.consensus_strategy_info)
  return _msg;
}

inline bool TaskReview::has_strategy_info() const {
  return strategy_info_case() != STRATEGY_INFO_NOT_SET;
}
inline void TaskReview::clear_has_strategy_info() {
  _impl_._oneof_case_[0] = STRATEGY_INFO_NOT_SET;
}
inline TaskReview::StrategyInfoCase TaskReview::strategy_info_case() const {
  return TaskReview::StrategyInfoCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TaskReviewManualStrategyInfo

// float sample_percentage = 1;
inline void TaskReviewManualStrategyInfo::clear_sample_percentage() {
  _impl_.sample_percentage_ = 0;
}
inline float TaskReviewManualStrategyInfo::_internal_sample_percentage() const {
  return _impl_.sample_percentage_;
}
inline float TaskReviewManualStrategyInfo::sample_percentage() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TaskReviewManualStrategyInfo.sample_percentage)
  return _internal_sample_percentage();
}
inline void TaskReviewManualStrategyInfo::_internal_set_sample_percentage(float value) {
  
  _impl_.sample_percentage_ = value;
}
inline void TaskReviewManualStrategyInfo::set_sample_percentage(float value) {
  _internal_set_sample_percentage(value);
  // @@protoc_insertion_point(field_set:clarifai.api.TaskReviewManualStrategyInfo.sample_percentage)
}

// -------------------------------------------------------------------

// TaskReviewConsensusStrategyInfo

// uint32 approval_threshold = 2;
inline void TaskReviewConsensusStrategyInfo::clear_approval_threshold() {
  _impl_.approval_threshold_ = 0u;
}
inline uint32_t TaskReviewConsensusStrategyInfo::_internal_approval_threshold() const {
  return _impl_.approval_threshold_;
}
inline uint32_t TaskReviewConsensusStrategyInfo::approval_threshold() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TaskReviewConsensusStrategyInfo.approval_threshold)
  return _internal_approval_threshold();
}
inline void TaskReviewConsensusStrategyInfo::_internal_set_approval_threshold(uint32_t value) {
  
  _impl_.approval_threshold_ = value;
}
inline void TaskReviewConsensusStrategyInfo::set_approval_threshold(uint32_t value) {
  _internal_set_approval_threshold(value);
  // @@protoc_insertion_point(field_set:clarifai.api.TaskReviewConsensusStrategyInfo.approval_threshold)
}

// -------------------------------------------------------------------

// TaskAIAssistant

// string workflow_id = 1;
inline void TaskAIAssistant::clear_workflow_id() {
  _impl_.workflow_id_.ClearToEmpty();
}
inline const std::string& TaskAIAssistant::workflow_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TaskAIAssistant.workflow_id)
  return _internal_workflow_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskAIAssistant::set_workflow_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.workflow_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.TaskAIAssistant.workflow_id)
}
inline std::string* TaskAIAssistant::mutable_workflow_id() {
  std::string* _s = _internal_mutable_workflow_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.TaskAIAssistant.workflow_id)
  return _s;
}
inline const std::string& TaskAIAssistant::_internal_workflow_id() const {
  return _impl_.workflow_id_.Get();
}
inline void TaskAIAssistant::_internal_set_workflow_id(const std::string& value) {
  
  _impl_.workflow_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TaskAIAssistant::_internal_mutable_workflow_id() {
  
  return _impl_.workflow_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TaskAIAssistant::release_workflow_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.TaskAIAssistant.workflow_id)
  return _impl_.workflow_id_.Release();
}
inline void TaskAIAssistant::set_allocated_workflow_id(std::string* workflow_id) {
  if (workflow_id != nullptr) {
    
  } else {
    
  }
  _impl_.workflow_id_.SetAllocated(workflow_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.workflow_id_.IsDefault()) {
    _impl_.workflow_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.TaskAIAssistant.workflow_id)
}

// -------------------------------------------------------------------

// TaskStatusCountPerUser

// string user_id = 1;
inline void TaskStatusCountPerUser::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& TaskStatusCountPerUser::user_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TaskStatusCountPerUser.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskStatusCountPerUser::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.TaskStatusCountPerUser.user_id)
}
inline std::string* TaskStatusCountPerUser::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.TaskStatusCountPerUser.user_id)
  return _s;
}
inline const std::string& TaskStatusCountPerUser::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void TaskStatusCountPerUser::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TaskStatusCountPerUser::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TaskStatusCountPerUser::release_user_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.TaskStatusCountPerUser.user_id)
  return _impl_.user_id_.Release();
}
inline void TaskStatusCountPerUser::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.TaskStatusCountPerUser.user_id)
}

// uint32 pending = 2 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void TaskStatusCountPerUser::clear_pending() {
  _impl_.pending_ = 0u;
}
inline uint32_t TaskStatusCountPerUser::_internal_pending() const {
  return _impl_.pending_;
}
inline uint32_t TaskStatusCountPerUser::pending() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TaskStatusCountPerUser.pending)
  return _internal_pending();
}
inline void TaskStatusCountPerUser::_internal_set_pending(uint32_t value) {
  
  _impl_.pending_ = value;
}
inline void TaskStatusCountPerUser::set_pending(uint32_t value) {
  _internal_set_pending(value);
  // @@protoc_insertion_point(field_set:clarifai.api.TaskStatusCountPerUser.pending)
}

// uint32 awaiting_review = 3 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void TaskStatusCountPerUser::clear_awaiting_review() {
  _impl_.awaiting_review_ = 0u;
}
inline uint32_t TaskStatusCountPerUser::_internal_awaiting_review() const {
  return _impl_.awaiting_review_;
}
inline uint32_t TaskStatusCountPerUser::awaiting_review() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TaskStatusCountPerUser.awaiting_review)
  return _internal_awaiting_review();
}
inline void TaskStatusCountPerUser::_internal_set_awaiting_review(uint32_t value) {
  
  _impl_.awaiting_review_ = value;
}
inline void TaskStatusCountPerUser::set_awaiting_review(uint32_t value) {
  _internal_set_awaiting_review(value);
  // @@protoc_insertion_point(field_set:clarifai.api.TaskStatusCountPerUser.awaiting_review)
}

// uint32 success = 4 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void TaskStatusCountPerUser::clear_success() {
  _impl_.success_ = 0u;
}
inline uint32_t TaskStatusCountPerUser::_internal_success() const {
  return _impl_.success_;
}
inline uint32_t TaskStatusCountPerUser::success() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TaskStatusCountPerUser.success)
  return _internal_success();
}
inline void TaskStatusCountPerUser::_internal_set_success(uint32_t value) {
  
  _impl_.success_ = value;
}
inline void TaskStatusCountPerUser::set_success(uint32_t value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:clarifai.api.TaskStatusCountPerUser.success)
}

// uint32 review_denied = 5 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void TaskStatusCountPerUser::clear_review_denied() {
  _impl_.review_denied_ = 0u;
}
inline uint32_t TaskStatusCountPerUser::_internal_review_denied() const {
  return _impl_.review_denied_;
}
inline uint32_t TaskStatusCountPerUser::review_denied() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TaskStatusCountPerUser.review_denied)
  return _internal_review_denied();
}
inline void TaskStatusCountPerUser::_internal_set_review_denied(uint32_t value) {
  
  _impl_.review_denied_ = value;
}
inline void TaskStatusCountPerUser::set_review_denied(uint32_t value) {
  _internal_set_review_denied(value);
  // @@protoc_insertion_point(field_set:clarifai.api.TaskStatusCountPerUser.review_denied)
}

// uint32 awaiting_consensus_review = 6 [(.clarifai.api.utils.cl_show_if_empty) = true];
inline void TaskStatusCountPerUser::clear_awaiting_consensus_review() {
  _impl_.awaiting_consensus_review_ = 0u;
}
inline uint32_t TaskStatusCountPerUser::_internal_awaiting_consensus_review() const {
  return _impl_.awaiting_consensus_review_;
}
inline uint32_t TaskStatusCountPerUser::awaiting_consensus_review() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TaskStatusCountPerUser.awaiting_consensus_review)
  return _internal_awaiting_consensus_review();
}
inline void TaskStatusCountPerUser::_internal_set_awaiting_consensus_review(uint32_t value) {
  
  _impl_.awaiting_consensus_review_ = value;
}
inline void TaskStatusCountPerUser::set_awaiting_consensus_review(uint32_t value) {
  _internal_set_awaiting_consensus_review(value);
  // @@protoc_insertion_point(field_set:clarifai.api.TaskStatusCountPerUser.awaiting_consensus_review)
}

// -------------------------------------------------------------------

// Collector

// string id = 1;
inline void Collector::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Collector::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Collector.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Collector::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Collector.id)
}
inline std::string* Collector::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Collector.id)
  return _s;
}
inline const std::string& Collector::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Collector::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Collector::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Collector::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Collector.id)
  return _impl_.id_.Release();
}
inline void Collector::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Collector.id)
}

// string description = 2;
inline void Collector::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Collector::description() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Collector.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Collector::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Collector.description)
}
inline std::string* Collector::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Collector.description)
  return _s;
}
inline const std::string& Collector::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Collector::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Collector::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Collector::release_description() {
  // @@protoc_insertion_point(field_release:clarifai.api.Collector.description)
  return _impl_.description_.Release();
}
inline void Collector::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Collector.description)
}

// .google.protobuf.Timestamp created_at = 3;
inline bool Collector::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool Collector::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Collector::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Collector::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Collector.created_at)
  return _internal_created_at();
}
inline void Collector::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Collector.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Collector::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Collector::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.Collector.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Collector::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Collector::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Collector.created_at)
  return _msg;
}
inline void Collector::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Collector.created_at)
}

// string pre_queue_workflow_id = 4;
inline void Collector::clear_pre_queue_workflow_id() {
  _impl_.pre_queue_workflow_id_.ClearToEmpty();
}
inline const std::string& Collector::pre_queue_workflow_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Collector.pre_queue_workflow_id)
  return _internal_pre_queue_workflow_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Collector::set_pre_queue_workflow_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pre_queue_workflow_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Collector.pre_queue_workflow_id)
}
inline std::string* Collector::mutable_pre_queue_workflow_id() {
  std::string* _s = _internal_mutable_pre_queue_workflow_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Collector.pre_queue_workflow_id)
  return _s;
}
inline const std::string& Collector::_internal_pre_queue_workflow_id() const {
  return _impl_.pre_queue_workflow_id_.Get();
}
inline void Collector::_internal_set_pre_queue_workflow_id(const std::string& value) {
  
  _impl_.pre_queue_workflow_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Collector::_internal_mutable_pre_queue_workflow_id() {
  
  return _impl_.pre_queue_workflow_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Collector::release_pre_queue_workflow_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Collector.pre_queue_workflow_id)
  return _impl_.pre_queue_workflow_id_.Release();
}
inline void Collector::set_allocated_pre_queue_workflow_id(std::string* pre_queue_workflow_id) {
  if (pre_queue_workflow_id != nullptr) {
    
  } else {
    
  }
  _impl_.pre_queue_workflow_id_.SetAllocated(pre_queue_workflow_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pre_queue_workflow_id_.IsDefault()) {
    _impl_.pre_queue_workflow_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Collector.pre_queue_workflow_id)
}

// string post_queue_workflow_id = 5;
inline void Collector::clear_post_queue_workflow_id() {
  _impl_.post_queue_workflow_id_.ClearToEmpty();
}
inline const std::string& Collector::post_queue_workflow_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Collector.post_queue_workflow_id)
  return _internal_post_queue_workflow_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Collector::set_post_queue_workflow_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.post_queue_workflow_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Collector.post_queue_workflow_id)
}
inline std::string* Collector::mutable_post_queue_workflow_id() {
  std::string* _s = _internal_mutable_post_queue_workflow_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Collector.post_queue_workflow_id)
  return _s;
}
inline const std::string& Collector::_internal_post_queue_workflow_id() const {
  return _impl_.post_queue_workflow_id_.Get();
}
inline void Collector::_internal_set_post_queue_workflow_id(const std::string& value) {
  
  _impl_.post_queue_workflow_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Collector::_internal_mutable_post_queue_workflow_id() {
  
  return _impl_.post_queue_workflow_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Collector::release_post_queue_workflow_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Collector.post_queue_workflow_id)
  return _impl_.post_queue_workflow_id_.Release();
}
inline void Collector::set_allocated_post_queue_workflow_id(std::string* post_queue_workflow_id) {
  if (post_queue_workflow_id != nullptr) {
    
  } else {
    
  }
  _impl_.post_queue_workflow_id_.SetAllocated(post_queue_workflow_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.post_queue_workflow_id_.IsDefault()) {
    _impl_.post_queue_workflow_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Collector.post_queue_workflow_id)
}

// .clarifai.api.CollectorSource collector_source = 6;
inline bool Collector::_internal_has_collector_source() const {
  return this != internal_default_instance() && _impl_.collector_source_ != nullptr;
}
inline bool Collector::has_collector_source() const {
  return _internal_has_collector_source();
}
inline void Collector::clear_collector_source() {
  if (GetArenaForAllocation() == nullptr && _impl_.collector_source_ != nullptr) {
    delete _impl_.collector_source_;
  }
  _impl_.collector_source_ = nullptr;
}
inline const ::clarifai::api::CollectorSource& Collector::_internal_collector_source() const {
  const ::clarifai::api::CollectorSource* p = _impl_.collector_source_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::CollectorSource&>(
      ::clarifai::api::_CollectorSource_default_instance_);
}
inline const ::clarifai::api::CollectorSource& Collector::collector_source() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Collector.collector_source)
  return _internal_collector_source();
}
inline void Collector::unsafe_arena_set_allocated_collector_source(
    ::clarifai::api::CollectorSource* collector_source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.collector_source_);
  }
  _impl_.collector_source_ = collector_source;
  if (collector_source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Collector.collector_source)
}
inline ::clarifai::api::CollectorSource* Collector::release_collector_source() {
  
  ::clarifai::api::CollectorSource* temp = _impl_.collector_source_;
  _impl_.collector_source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::CollectorSource* Collector::unsafe_arena_release_collector_source() {
  // @@protoc_insertion_point(field_release:clarifai.api.Collector.collector_source)
  
  ::clarifai::api::CollectorSource* temp = _impl_.collector_source_;
  _impl_.collector_source_ = nullptr;
  return temp;
}
inline ::clarifai::api::CollectorSource* Collector::_internal_mutable_collector_source() {
  
  if (_impl_.collector_source_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::CollectorSource>(GetArenaForAllocation());
    _impl_.collector_source_ = p;
  }
  return _impl_.collector_source_;
}
inline ::clarifai::api::CollectorSource* Collector::mutable_collector_source() {
  ::clarifai::api::CollectorSource* _msg = _internal_mutable_collector_source();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Collector.collector_source)
  return _msg;
}
inline void Collector::set_allocated_collector_source(::clarifai::api::CollectorSource* collector_source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.collector_source_;
  }
  if (collector_source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(collector_source);
    if (message_arena != submessage_arena) {
      collector_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, collector_source, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.collector_source_ = collector_source;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Collector.collector_source)
}

// .clarifai.api.status.Status status = 7;
inline bool Collector::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool Collector::has_status() const {
  return _internal_has_status();
}
inline const ::clarifai::api::status::Status& Collector::_internal_status() const {
  const ::clarifai::api::status::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::status::Status&>(
      ::clarifai::api::status::_Status_default_instance_);
}
inline const ::clarifai::api::status::Status& Collector::status() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Collector.status)
  return _internal_status();
}
inline void Collector::unsafe_arena_set_allocated_status(
    ::clarifai::api::status::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Collector.status)
}
inline ::clarifai::api::status::Status* Collector::release_status() {
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::status::Status* Collector::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:clarifai.api.Collector.status)
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::clarifai::api::status::Status* Collector::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::status::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::clarifai::api::status::Status* Collector::mutable_status() {
  ::clarifai::api::status::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Collector.status)
  return _msg;
}
inline void Collector::set_allocated_status(::clarifai::api::status::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Collector.status)
}

// -------------------------------------------------------------------

// CollectorSource

// .clarifai.api.APIPostModelOutputsCollectorSource api_post_model_outputs_collector_source = 2;
inline bool CollectorSource::_internal_has_api_post_model_outputs_collector_source() const {
  return this != internal_default_instance() && _impl_.api_post_model_outputs_collector_source_ != nullptr;
}
inline bool CollectorSource::has_api_post_model_outputs_collector_source() const {
  return _internal_has_api_post_model_outputs_collector_source();
}
inline void CollectorSource::clear_api_post_model_outputs_collector_source() {
  if (GetArenaForAllocation() == nullptr && _impl_.api_post_model_outputs_collector_source_ != nullptr) {
    delete _impl_.api_post_model_outputs_collector_source_;
  }
  _impl_.api_post_model_outputs_collector_source_ = nullptr;
}
inline const ::clarifai::api::APIPostModelOutputsCollectorSource& CollectorSource::_internal_api_post_model_outputs_collector_source() const {
  const ::clarifai::api::APIPostModelOutputsCollectorSource* p = _impl_.api_post_model_outputs_collector_source_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::APIPostModelOutputsCollectorSource&>(
      ::clarifai::api::_APIPostModelOutputsCollectorSource_default_instance_);
}
inline const ::clarifai::api::APIPostModelOutputsCollectorSource& CollectorSource::api_post_model_outputs_collector_source() const {
  // @@protoc_insertion_point(field_get:clarifai.api.CollectorSource.api_post_model_outputs_collector_source)
  return _internal_api_post_model_outputs_collector_source();
}
inline void CollectorSource::unsafe_arena_set_allocated_api_post_model_outputs_collector_source(
    ::clarifai::api::APIPostModelOutputsCollectorSource* api_post_model_outputs_collector_source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.api_post_model_outputs_collector_source_);
  }
  _impl_.api_post_model_outputs_collector_source_ = api_post_model_outputs_collector_source;
  if (api_post_model_outputs_collector_source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.CollectorSource.api_post_model_outputs_collector_source)
}
inline ::clarifai::api::APIPostModelOutputsCollectorSource* CollectorSource::release_api_post_model_outputs_collector_source() {
  
  ::clarifai::api::APIPostModelOutputsCollectorSource* temp = _impl_.api_post_model_outputs_collector_source_;
  _impl_.api_post_model_outputs_collector_source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::APIPostModelOutputsCollectorSource* CollectorSource::unsafe_arena_release_api_post_model_outputs_collector_source() {
  // @@protoc_insertion_point(field_release:clarifai.api.CollectorSource.api_post_model_outputs_collector_source)
  
  ::clarifai::api::APIPostModelOutputsCollectorSource* temp = _impl_.api_post_model_outputs_collector_source_;
  _impl_.api_post_model_outputs_collector_source_ = nullptr;
  return temp;
}
inline ::clarifai::api::APIPostModelOutputsCollectorSource* CollectorSource::_internal_mutable_api_post_model_outputs_collector_source() {
  
  if (_impl_.api_post_model_outputs_collector_source_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::APIPostModelOutputsCollectorSource>(GetArenaForAllocation());
    _impl_.api_post_model_outputs_collector_source_ = p;
  }
  return _impl_.api_post_model_outputs_collector_source_;
}
inline ::clarifai::api::APIPostModelOutputsCollectorSource* CollectorSource::mutable_api_post_model_outputs_collector_source() {
  ::clarifai::api::APIPostModelOutputsCollectorSource* _msg = _internal_mutable_api_post_model_outputs_collector_source();
  // @@protoc_insertion_point(field_mutable:clarifai.api.CollectorSource.api_post_model_outputs_collector_source)
  return _msg;
}
inline void CollectorSource::set_allocated_api_post_model_outputs_collector_source(::clarifai::api::APIPostModelOutputsCollectorSource* api_post_model_outputs_collector_source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.api_post_model_outputs_collector_source_;
  }
  if (api_post_model_outputs_collector_source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(api_post_model_outputs_collector_source);
    if (message_arena != submessage_arena) {
      api_post_model_outputs_collector_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, api_post_model_outputs_collector_source, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.api_post_model_outputs_collector_source_ = api_post_model_outputs_collector_source;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.CollectorSource.api_post_model_outputs_collector_source)
}

// -------------------------------------------------------------------

// APIPostModelOutputsCollectorSource

// string model_user_id = 1;
inline void APIPostModelOutputsCollectorSource::clear_model_user_id() {
  _impl_.model_user_id_.ClearToEmpty();
}
inline const std::string& APIPostModelOutputsCollectorSource::model_user_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.APIPostModelOutputsCollectorSource.model_user_id)
  return _internal_model_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void APIPostModelOutputsCollectorSource::set_model_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.APIPostModelOutputsCollectorSource.model_user_id)
}
inline std::string* APIPostModelOutputsCollectorSource::mutable_model_user_id() {
  std::string* _s = _internal_mutable_model_user_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.APIPostModelOutputsCollectorSource.model_user_id)
  return _s;
}
inline const std::string& APIPostModelOutputsCollectorSource::_internal_model_user_id() const {
  return _impl_.model_user_id_.Get();
}
inline void APIPostModelOutputsCollectorSource::_internal_set_model_user_id(const std::string& value) {
  
  _impl_.model_user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* APIPostModelOutputsCollectorSource::_internal_mutable_model_user_id() {
  
  return _impl_.model_user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* APIPostModelOutputsCollectorSource::release_model_user_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.APIPostModelOutputsCollectorSource.model_user_id)
  return _impl_.model_user_id_.Release();
}
inline void APIPostModelOutputsCollectorSource::set_allocated_model_user_id(std::string* model_user_id) {
  if (model_user_id != nullptr) {
    
  } else {
    
  }
  _impl_.model_user_id_.SetAllocated(model_user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_user_id_.IsDefault()) {
    _impl_.model_user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.APIPostModelOutputsCollectorSource.model_user_id)
}

// string model_app_id = 2;
inline void APIPostModelOutputsCollectorSource::clear_model_app_id() {
  _impl_.model_app_id_.ClearToEmpty();
}
inline const std::string& APIPostModelOutputsCollectorSource::model_app_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.APIPostModelOutputsCollectorSource.model_app_id)
  return _internal_model_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void APIPostModelOutputsCollectorSource::set_model_app_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_app_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.APIPostModelOutputsCollectorSource.model_app_id)
}
inline std::string* APIPostModelOutputsCollectorSource::mutable_model_app_id() {
  std::string* _s = _internal_mutable_model_app_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.APIPostModelOutputsCollectorSource.model_app_id)
  return _s;
}
inline const std::string& APIPostModelOutputsCollectorSource::_internal_model_app_id() const {
  return _impl_.model_app_id_.Get();
}
inline void APIPostModelOutputsCollectorSource::_internal_set_model_app_id(const std::string& value) {
  
  _impl_.model_app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* APIPostModelOutputsCollectorSource::_internal_mutable_model_app_id() {
  
  return _impl_.model_app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* APIPostModelOutputsCollectorSource::release_model_app_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.APIPostModelOutputsCollectorSource.model_app_id)
  return _impl_.model_app_id_.Release();
}
inline void APIPostModelOutputsCollectorSource::set_allocated_model_app_id(std::string* model_app_id) {
  if (model_app_id != nullptr) {
    
  } else {
    
  }
  _impl_.model_app_id_.SetAllocated(model_app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_app_id_.IsDefault()) {
    _impl_.model_app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.APIPostModelOutputsCollectorSource.model_app_id)
}

// string model_id = 3;
inline void APIPostModelOutputsCollectorSource::clear_model_id() {
  _impl_.model_id_.ClearToEmpty();
}
inline const std::string& APIPostModelOutputsCollectorSource::model_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.APIPostModelOutputsCollectorSource.model_id)
  return _internal_model_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void APIPostModelOutputsCollectorSource::set_model_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.APIPostModelOutputsCollectorSource.model_id)
}
inline std::string* APIPostModelOutputsCollectorSource::mutable_model_id() {
  std::string* _s = _internal_mutable_model_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.APIPostModelOutputsCollectorSource.model_id)
  return _s;
}
inline const std::string& APIPostModelOutputsCollectorSource::_internal_model_id() const {
  return _impl_.model_id_.Get();
}
inline void APIPostModelOutputsCollectorSource::_internal_set_model_id(const std::string& value) {
  
  _impl_.model_id_.Set(value, GetArenaForAllocation());
}
inline std::string* APIPostModelOutputsCollectorSource::_internal_mutable_model_id() {
  
  return _impl_.model_id_.Mutable(GetArenaForAllocation());
}
inline std::string* APIPostModelOutputsCollectorSource::release_model_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.APIPostModelOutputsCollectorSource.model_id)
  return _impl_.model_id_.Release();
}
inline void APIPostModelOutputsCollectorSource::set_allocated_model_id(std::string* model_id) {
  if (model_id != nullptr) {
    
  } else {
    
  }
  _impl_.model_id_.SetAllocated(model_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_id_.IsDefault()) {
    _impl_.model_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.APIPostModelOutputsCollectorSource.model_id)
}

// string model_version_id = 4;
inline void APIPostModelOutputsCollectorSource::clear_model_version_id() {
  _impl_.model_version_id_.ClearToEmpty();
}
inline const std::string& APIPostModelOutputsCollectorSource::model_version_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.APIPostModelOutputsCollectorSource.model_version_id)
  return _internal_model_version_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void APIPostModelOutputsCollectorSource::set_model_version_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_version_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.APIPostModelOutputsCollectorSource.model_version_id)
}
inline std::string* APIPostModelOutputsCollectorSource::mutable_model_version_id() {
  std::string* _s = _internal_mutable_model_version_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.APIPostModelOutputsCollectorSource.model_version_id)
  return _s;
}
inline const std::string& APIPostModelOutputsCollectorSource::_internal_model_version_id() const {
  return _impl_.model_version_id_.Get();
}
inline void APIPostModelOutputsCollectorSource::_internal_set_model_version_id(const std::string& value) {
  
  _impl_.model_version_id_.Set(value, GetArenaForAllocation());
}
inline std::string* APIPostModelOutputsCollectorSource::_internal_mutable_model_version_id() {
  
  return _impl_.model_version_id_.Mutable(GetArenaForAllocation());
}
inline std::string* APIPostModelOutputsCollectorSource::release_model_version_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.APIPostModelOutputsCollectorSource.model_version_id)
  return _impl_.model_version_id_.Release();
}
inline void APIPostModelOutputsCollectorSource::set_allocated_model_version_id(std::string* model_version_id) {
  if (model_version_id != nullptr) {
    
  } else {
    
  }
  _impl_.model_version_id_.SetAllocated(model_version_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_version_id_.IsDefault()) {
    _impl_.model_version_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.APIPostModelOutputsCollectorSource.model_version_id)
}

// string post_inputs_key_id = 5;
inline void APIPostModelOutputsCollectorSource::clear_post_inputs_key_id() {
  _impl_.post_inputs_key_id_.ClearToEmpty();
}
inline const std::string& APIPostModelOutputsCollectorSource::post_inputs_key_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.APIPostModelOutputsCollectorSource.post_inputs_key_id)
  return _internal_post_inputs_key_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void APIPostModelOutputsCollectorSource::set_post_inputs_key_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.post_inputs_key_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.APIPostModelOutputsCollectorSource.post_inputs_key_id)
}
inline std::string* APIPostModelOutputsCollectorSource::mutable_post_inputs_key_id() {
  std::string* _s = _internal_mutable_post_inputs_key_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.APIPostModelOutputsCollectorSource.post_inputs_key_id)
  return _s;
}
inline const std::string& APIPostModelOutputsCollectorSource::_internal_post_inputs_key_id() const {
  return _impl_.post_inputs_key_id_.Get();
}
inline void APIPostModelOutputsCollectorSource::_internal_set_post_inputs_key_id(const std::string& value) {
  
  _impl_.post_inputs_key_id_.Set(value, GetArenaForAllocation());
}
inline std::string* APIPostModelOutputsCollectorSource::_internal_mutable_post_inputs_key_id() {
  
  return _impl_.post_inputs_key_id_.Mutable(GetArenaForAllocation());
}
inline std::string* APIPostModelOutputsCollectorSource::release_post_inputs_key_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.APIPostModelOutputsCollectorSource.post_inputs_key_id)
  return _impl_.post_inputs_key_id_.Release();
}
inline void APIPostModelOutputsCollectorSource::set_allocated_post_inputs_key_id(std::string* post_inputs_key_id) {
  if (post_inputs_key_id != nullptr) {
    
  } else {
    
  }
  _impl_.post_inputs_key_id_.SetAllocated(post_inputs_key_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.post_inputs_key_id_.IsDefault()) {
    _impl_.post_inputs_key_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.APIPostModelOutputsCollectorSource.post_inputs_key_id)
}

// -------------------------------------------------------------------

// StatValue

// .google.protobuf.Timestamp time = 1;
inline bool StatValue::_internal_has_time() const {
  return this != internal_default_instance() && _impl_.time_ != nullptr;
}
inline bool StatValue::has_time() const {
  return _internal_has_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& StatValue::_internal_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& StatValue::time() const {
  // @@protoc_insertion_point(field_get:clarifai.api.StatValue.time)
  return _internal_time();
}
inline void StatValue::unsafe_arena_set_allocated_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = time;
  if (time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.StatValue.time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StatValue::release_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StatValue::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:clarifai.api.StatValue.time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StatValue::_internal_mutable_time() {
  
  if (_impl_.time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.time_ = p;
  }
  return _impl_.time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StatValue::mutable_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:clarifai.api.StatValue.time)
  return _msg;
}
inline void StatValue::set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time));
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.time_ = time;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.StatValue.time)
}

// float value = 2;
inline void StatValue::clear_value() {
  _impl_.value_ = 0;
}
inline float StatValue::_internal_value() const {
  return _impl_.value_;
}
inline float StatValue::value() const {
  // @@protoc_insertion_point(field_get:clarifai.api.StatValue.value)
  return _internal_value();
}
inline void StatValue::_internal_set_value(float value) {
  
  _impl_.value_ = value;
}
inline void StatValue::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:clarifai.api.StatValue.value)
}

// repeated string tags = 3;
inline int StatValue::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int StatValue::tags_size() const {
  return _internal_tags_size();
}
inline void StatValue::clear_tags() {
  _impl_.tags_.Clear();
}
inline std::string* StatValue::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.StatValue.tags)
  return _s;
}
inline const std::string& StatValue::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline const std::string& StatValue::tags(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.StatValue.tags)
  return _internal_tags(index);
}
inline std::string* StatValue::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.StatValue.tags)
  return _impl_.tags_.Mutable(index);
}
inline void StatValue::set_tags(int index, const std::string& value) {
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.StatValue.tags)
}
inline void StatValue::set_tags(int index, std::string&& value) {
  _impl_.tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.StatValue.tags)
}
inline void StatValue::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.StatValue.tags)
}
inline void StatValue::set_tags(int index, const char* value, size_t size) {
  _impl_.tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.StatValue.tags)
}
inline std::string* StatValue::_internal_add_tags() {
  return _impl_.tags_.Add();
}
inline void StatValue::add_tags(const std::string& value) {
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.StatValue.tags)
}
inline void StatValue::add_tags(std::string&& value) {
  _impl_.tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.StatValue.tags)
}
inline void StatValue::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.StatValue.tags)
}
inline void StatValue::add_tags(const char* value, size_t size) {
  _impl_.tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.StatValue.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StatValue::tags() const {
  // @@protoc_insertion_point(field_list:clarifai.api.StatValue.tags)
  return _impl_.tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StatValue::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.StatValue.tags)
  return &_impl_.tags_;
}

// -------------------------------------------------------------------

// StatValueAggregateResult

// repeated .clarifai.api.StatValueAggregate stat_value_aggregates = 1;
inline int StatValueAggregateResult::_internal_stat_value_aggregates_size() const {
  return _impl_.stat_value_aggregates_.size();
}
inline int StatValueAggregateResult::stat_value_aggregates_size() const {
  return _internal_stat_value_aggregates_size();
}
inline void StatValueAggregateResult::clear_stat_value_aggregates() {
  _impl_.stat_value_aggregates_.Clear();
}
inline ::clarifai::api::StatValueAggregate* StatValueAggregateResult::mutable_stat_value_aggregates(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.StatValueAggregateResult.stat_value_aggregates)
  return _impl_.stat_value_aggregates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::StatValueAggregate >*
StatValueAggregateResult::mutable_stat_value_aggregates() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.StatValueAggregateResult.stat_value_aggregates)
  return &_impl_.stat_value_aggregates_;
}
inline const ::clarifai::api::StatValueAggregate& StatValueAggregateResult::_internal_stat_value_aggregates(int index) const {
  return _impl_.stat_value_aggregates_.Get(index);
}
inline const ::clarifai::api::StatValueAggregate& StatValueAggregateResult::stat_value_aggregates(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.StatValueAggregateResult.stat_value_aggregates)
  return _internal_stat_value_aggregates(index);
}
inline ::clarifai::api::StatValueAggregate* StatValueAggregateResult::_internal_add_stat_value_aggregates() {
  return _impl_.stat_value_aggregates_.Add();
}
inline ::clarifai::api::StatValueAggregate* StatValueAggregateResult::add_stat_value_aggregates() {
  ::clarifai::api::StatValueAggregate* _add = _internal_add_stat_value_aggregates();
  // @@protoc_insertion_point(field_add:clarifai.api.StatValueAggregateResult.stat_value_aggregates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::StatValueAggregate >&
StatValueAggregateResult::stat_value_aggregates() const {
  // @@protoc_insertion_point(field_list:clarifai.api.StatValueAggregateResult.stat_value_aggregates)
  return _impl_.stat_value_aggregates_;
}

// .clarifai.api.StatValueAggregateQuery stat_value_aggregate_query = 2;
inline bool StatValueAggregateResult::_internal_has_stat_value_aggregate_query() const {
  return this != internal_default_instance() && _impl_.stat_value_aggregate_query_ != nullptr;
}
inline bool StatValueAggregateResult::has_stat_value_aggregate_query() const {
  return _internal_has_stat_value_aggregate_query();
}
inline void StatValueAggregateResult::clear_stat_value_aggregate_query() {
  if (GetArenaForAllocation() == nullptr && _impl_.stat_value_aggregate_query_ != nullptr) {
    delete _impl_.stat_value_aggregate_query_;
  }
  _impl_.stat_value_aggregate_query_ = nullptr;
}
inline const ::clarifai::api::StatValueAggregateQuery& StatValueAggregateResult::_internal_stat_value_aggregate_query() const {
  const ::clarifai::api::StatValueAggregateQuery* p = _impl_.stat_value_aggregate_query_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::StatValueAggregateQuery&>(
      ::clarifai::api::_StatValueAggregateQuery_default_instance_);
}
inline const ::clarifai::api::StatValueAggregateQuery& StatValueAggregateResult::stat_value_aggregate_query() const {
  // @@protoc_insertion_point(field_get:clarifai.api.StatValueAggregateResult.stat_value_aggregate_query)
  return _internal_stat_value_aggregate_query();
}
inline void StatValueAggregateResult::unsafe_arena_set_allocated_stat_value_aggregate_query(
    ::clarifai::api::StatValueAggregateQuery* stat_value_aggregate_query) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stat_value_aggregate_query_);
  }
  _impl_.stat_value_aggregate_query_ = stat_value_aggregate_query;
  if (stat_value_aggregate_query) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.StatValueAggregateResult.stat_value_aggregate_query)
}
inline ::clarifai::api::StatValueAggregateQuery* StatValueAggregateResult::release_stat_value_aggregate_query() {
  
  ::clarifai::api::StatValueAggregateQuery* temp = _impl_.stat_value_aggregate_query_;
  _impl_.stat_value_aggregate_query_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::StatValueAggregateQuery* StatValueAggregateResult::unsafe_arena_release_stat_value_aggregate_query() {
  // @@protoc_insertion_point(field_release:clarifai.api.StatValueAggregateResult.stat_value_aggregate_query)
  
  ::clarifai::api::StatValueAggregateQuery* temp = _impl_.stat_value_aggregate_query_;
  _impl_.stat_value_aggregate_query_ = nullptr;
  return temp;
}
inline ::clarifai::api::StatValueAggregateQuery* StatValueAggregateResult::_internal_mutable_stat_value_aggregate_query() {
  
  if (_impl_.stat_value_aggregate_query_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::StatValueAggregateQuery>(GetArenaForAllocation());
    _impl_.stat_value_aggregate_query_ = p;
  }
  return _impl_.stat_value_aggregate_query_;
}
inline ::clarifai::api::StatValueAggregateQuery* StatValueAggregateResult::mutable_stat_value_aggregate_query() {
  ::clarifai::api::StatValueAggregateQuery* _msg = _internal_mutable_stat_value_aggregate_query();
  // @@protoc_insertion_point(field_mutable:clarifai.api.StatValueAggregateResult.stat_value_aggregate_query)
  return _msg;
}
inline void StatValueAggregateResult::set_allocated_stat_value_aggregate_query(::clarifai::api::StatValueAggregateQuery* stat_value_aggregate_query) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stat_value_aggregate_query_;
  }
  if (stat_value_aggregate_query) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stat_value_aggregate_query);
    if (message_arena != submessage_arena) {
      stat_value_aggregate_query = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stat_value_aggregate_query, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stat_value_aggregate_query_ = stat_value_aggregate_query;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.StatValueAggregateResult.stat_value_aggregate_query)
}

// -------------------------------------------------------------------

// StatValueAggregate

// .google.protobuf.Timestamp time = 1;
inline bool StatValueAggregate::_internal_has_time() const {
  return this != internal_default_instance() && _impl_.time_ != nullptr;
}
inline bool StatValueAggregate::has_time() const {
  return _internal_has_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& StatValueAggregate::_internal_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& StatValueAggregate::time() const {
  // @@protoc_insertion_point(field_get:clarifai.api.StatValueAggregate.time)
  return _internal_time();
}
inline void StatValueAggregate::unsafe_arena_set_allocated_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = time;
  if (time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.StatValueAggregate.time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StatValueAggregate::release_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StatValueAggregate::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:clarifai.api.StatValueAggregate.time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StatValueAggregate::_internal_mutable_time() {
  
  if (_impl_.time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.time_ = p;
  }
  return _impl_.time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StatValueAggregate::mutable_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:clarifai.api.StatValueAggregate.time)
  return _msg;
}
inline void StatValueAggregate::set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time));
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.time_ = time;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.StatValueAggregate.time)
}

// float aggregate_value = 2;
inline void StatValueAggregate::clear_aggregate_value() {
  _impl_.aggregate_value_ = 0;
}
inline float StatValueAggregate::_internal_aggregate_value() const {
  return _impl_.aggregate_value_;
}
inline float StatValueAggregate::aggregate_value() const {
  // @@protoc_insertion_point(field_get:clarifai.api.StatValueAggregate.aggregate_value)
  return _internal_aggregate_value();
}
inline void StatValueAggregate::_internal_set_aggregate_value(float value) {
  
  _impl_.aggregate_value_ = value;
}
inline void StatValueAggregate::set_aggregate_value(float value) {
  _internal_set_aggregate_value(value);
  // @@protoc_insertion_point(field_set:clarifai.api.StatValueAggregate.aggregate_value)
}

// uint64 count = 3;
inline void StatValueAggregate::clear_count() {
  _impl_.count_ = uint64_t{0u};
}
inline uint64_t StatValueAggregate::_internal_count() const {
  return _impl_.count_;
}
inline uint64_t StatValueAggregate::count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.StatValueAggregate.count)
  return _internal_count();
}
inline void StatValueAggregate::_internal_set_count(uint64_t value) {
  
  _impl_.count_ = value;
}
inline void StatValueAggregate::set_count(uint64_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:clarifai.api.StatValueAggregate.count)
}

// repeated string tags = 4;
inline int StatValueAggregate::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int StatValueAggregate::tags_size() const {
  return _internal_tags_size();
}
inline void StatValueAggregate::clear_tags() {
  _impl_.tags_.Clear();
}
inline std::string* StatValueAggregate::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.StatValueAggregate.tags)
  return _s;
}
inline const std::string& StatValueAggregate::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline const std::string& StatValueAggregate::tags(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.StatValueAggregate.tags)
  return _internal_tags(index);
}
inline std::string* StatValueAggregate::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.StatValueAggregate.tags)
  return _impl_.tags_.Mutable(index);
}
inline void StatValueAggregate::set_tags(int index, const std::string& value) {
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.StatValueAggregate.tags)
}
inline void StatValueAggregate::set_tags(int index, std::string&& value) {
  _impl_.tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.StatValueAggregate.tags)
}
inline void StatValueAggregate::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.StatValueAggregate.tags)
}
inline void StatValueAggregate::set_tags(int index, const char* value, size_t size) {
  _impl_.tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.StatValueAggregate.tags)
}
inline std::string* StatValueAggregate::_internal_add_tags() {
  return _impl_.tags_.Add();
}
inline void StatValueAggregate::add_tags(const std::string& value) {
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.StatValueAggregate.tags)
}
inline void StatValueAggregate::add_tags(std::string&& value) {
  _impl_.tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.StatValueAggregate.tags)
}
inline void StatValueAggregate::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.StatValueAggregate.tags)
}
inline void StatValueAggregate::add_tags(const char* value, size_t size) {
  _impl_.tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.StatValueAggregate.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StatValueAggregate::tags() const {
  // @@protoc_insertion_point(field_list:clarifai.api.StatValueAggregate.tags)
  return _impl_.tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StatValueAggregate::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.StatValueAggregate.tags)
  return &_impl_.tags_;
}

// -------------------------------------------------------------------

// StatValueAggregateQuery

// repeated string tags = 1;
inline int StatValueAggregateQuery::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int StatValueAggregateQuery::tags_size() const {
  return _internal_tags_size();
}
inline void StatValueAggregateQuery::clear_tags() {
  _impl_.tags_.Clear();
}
inline std::string* StatValueAggregateQuery::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.StatValueAggregateQuery.tags)
  return _s;
}
inline const std::string& StatValueAggregateQuery::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline const std::string& StatValueAggregateQuery::tags(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.StatValueAggregateQuery.tags)
  return _internal_tags(index);
}
inline std::string* StatValueAggregateQuery::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.StatValueAggregateQuery.tags)
  return _impl_.tags_.Mutable(index);
}
inline void StatValueAggregateQuery::set_tags(int index, const std::string& value) {
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.StatValueAggregateQuery.tags)
}
inline void StatValueAggregateQuery::set_tags(int index, std::string&& value) {
  _impl_.tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.StatValueAggregateQuery.tags)
}
inline void StatValueAggregateQuery::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.StatValueAggregateQuery.tags)
}
inline void StatValueAggregateQuery::set_tags(int index, const char* value, size_t size) {
  _impl_.tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.StatValueAggregateQuery.tags)
}
inline std::string* StatValueAggregateQuery::_internal_add_tags() {
  return _impl_.tags_.Add();
}
inline void StatValueAggregateQuery::add_tags(const std::string& value) {
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.StatValueAggregateQuery.tags)
}
inline void StatValueAggregateQuery::add_tags(std::string&& value) {
  _impl_.tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.StatValueAggregateQuery.tags)
}
inline void StatValueAggregateQuery::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.StatValueAggregateQuery.tags)
}
inline void StatValueAggregateQuery::add_tags(const char* value, size_t size) {
  _impl_.tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.StatValueAggregateQuery.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StatValueAggregateQuery::tags() const {
  // @@protoc_insertion_point(field_list:clarifai.api.StatValueAggregateQuery.tags)
  return _impl_.tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StatValueAggregateQuery::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.StatValueAggregateQuery.tags)
  return &_impl_.tags_;
}

// repeated string tag_groups = 2;
inline int StatValueAggregateQuery::_internal_tag_groups_size() const {
  return _impl_.tag_groups_.size();
}
inline int StatValueAggregateQuery::tag_groups_size() const {
  return _internal_tag_groups_size();
}
inline void StatValueAggregateQuery::clear_tag_groups() {
  _impl_.tag_groups_.Clear();
}
inline std::string* StatValueAggregateQuery::add_tag_groups() {
  std::string* _s = _internal_add_tag_groups();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.StatValueAggregateQuery.tag_groups)
  return _s;
}
inline const std::string& StatValueAggregateQuery::_internal_tag_groups(int index) const {
  return _impl_.tag_groups_.Get(index);
}
inline const std::string& StatValueAggregateQuery::tag_groups(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.StatValueAggregateQuery.tag_groups)
  return _internal_tag_groups(index);
}
inline std::string* StatValueAggregateQuery::mutable_tag_groups(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.StatValueAggregateQuery.tag_groups)
  return _impl_.tag_groups_.Mutable(index);
}
inline void StatValueAggregateQuery::set_tag_groups(int index, const std::string& value) {
  _impl_.tag_groups_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.StatValueAggregateQuery.tag_groups)
}
inline void StatValueAggregateQuery::set_tag_groups(int index, std::string&& value) {
  _impl_.tag_groups_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.StatValueAggregateQuery.tag_groups)
}
inline void StatValueAggregateQuery::set_tag_groups(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tag_groups_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.StatValueAggregateQuery.tag_groups)
}
inline void StatValueAggregateQuery::set_tag_groups(int index, const char* value, size_t size) {
  _impl_.tag_groups_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.StatValueAggregateQuery.tag_groups)
}
inline std::string* StatValueAggregateQuery::_internal_add_tag_groups() {
  return _impl_.tag_groups_.Add();
}
inline void StatValueAggregateQuery::add_tag_groups(const std::string& value) {
  _impl_.tag_groups_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.StatValueAggregateQuery.tag_groups)
}
inline void StatValueAggregateQuery::add_tag_groups(std::string&& value) {
  _impl_.tag_groups_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.StatValueAggregateQuery.tag_groups)
}
inline void StatValueAggregateQuery::add_tag_groups(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tag_groups_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.StatValueAggregateQuery.tag_groups)
}
inline void StatValueAggregateQuery::add_tag_groups(const char* value, size_t size) {
  _impl_.tag_groups_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.StatValueAggregateQuery.tag_groups)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StatValueAggregateQuery::tag_groups() const {
  // @@protoc_insertion_point(field_list:clarifai.api.StatValueAggregateQuery.tag_groups)
  return _impl_.tag_groups_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StatValueAggregateQuery::mutable_tag_groups() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.StatValueAggregateQuery.tag_groups)
  return &_impl_.tag_groups_;
}

// .clarifai.api.StatValueAggType stat_value_agg_type = 3;
inline void StatValueAggregateQuery::clear_stat_value_agg_type() {
  _impl_.stat_value_agg_type_ = 0;
}
inline ::clarifai::api::StatValueAggType StatValueAggregateQuery::_internal_stat_value_agg_type() const {
  return static_cast< ::clarifai::api::StatValueAggType >(_impl_.stat_value_agg_type_);
}
inline ::clarifai::api::StatValueAggType StatValueAggregateQuery::stat_value_agg_type() const {
  // @@protoc_insertion_point(field_get:clarifai.api.StatValueAggregateQuery.stat_value_agg_type)
  return _internal_stat_value_agg_type();
}
inline void StatValueAggregateQuery::_internal_set_stat_value_agg_type(::clarifai::api::StatValueAggType value) {
  
  _impl_.stat_value_agg_type_ = value;
}
inline void StatValueAggregateQuery::set_stat_value_agg_type(::clarifai::api::StatValueAggType value) {
  _internal_set_stat_value_agg_type(value);
  // @@protoc_insertion_point(field_set:clarifai.api.StatValueAggregateQuery.stat_value_agg_type)
}

// .clarifai.api.StatTimeAggType stat_time_agg_type = 4;
inline void StatValueAggregateQuery::clear_stat_time_agg_type() {
  _impl_.stat_time_agg_type_ = 0;
}
inline ::clarifai::api::StatTimeAggType StatValueAggregateQuery::_internal_stat_time_agg_type() const {
  return static_cast< ::clarifai::api::StatTimeAggType >(_impl_.stat_time_agg_type_);
}
inline ::clarifai::api::StatTimeAggType StatValueAggregateQuery::stat_time_agg_type() const {
  // @@protoc_insertion_point(field_get:clarifai.api.StatValueAggregateQuery.stat_time_agg_type)
  return _internal_stat_time_agg_type();
}
inline void StatValueAggregateQuery::_internal_set_stat_time_agg_type(::clarifai::api::StatTimeAggType value) {
  
  _impl_.stat_time_agg_type_ = value;
}
inline void StatValueAggregateQuery::set_stat_time_agg_type(::clarifai::api::StatTimeAggType value) {
  _internal_set_stat_time_agg_type(value);
  // @@protoc_insertion_point(field_set:clarifai.api.StatValueAggregateQuery.stat_time_agg_type)
}

// .google.protobuf.Timestamp start_time = 5;
inline bool StatValueAggregateQuery::_internal_has_start_time() const {
  return this != internal_default_instance() && _impl_.start_time_ != nullptr;
}
inline bool StatValueAggregateQuery::has_start_time() const {
  return _internal_has_start_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& StatValueAggregateQuery::_internal_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& StatValueAggregateQuery::start_time() const {
  // @@protoc_insertion_point(field_get:clarifai.api.StatValueAggregateQuery.start_time)
  return _internal_start_time();
}
inline void StatValueAggregateQuery::unsafe_arena_set_allocated_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.StatValueAggregateQuery.start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StatValueAggregateQuery::release_start_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StatValueAggregateQuery::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:clarifai.api.StatValueAggregateQuery.start_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StatValueAggregateQuery::_internal_mutable_start_time() {
  
  if (_impl_.start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.start_time_ = p;
  }
  return _impl_.start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StatValueAggregateQuery::mutable_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:clarifai.api.StatValueAggregateQuery.start_time)
  return _msg;
}
inline void StatValueAggregateQuery::set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time));
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.StatValueAggregateQuery.start_time)
}

// .google.protobuf.Timestamp end_time = 6;
inline bool StatValueAggregateQuery::_internal_has_end_time() const {
  return this != internal_default_instance() && _impl_.end_time_ != nullptr;
}
inline bool StatValueAggregateQuery::has_end_time() const {
  return _internal_has_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& StatValueAggregateQuery::_internal_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& StatValueAggregateQuery::end_time() const {
  // @@protoc_insertion_point(field_get:clarifai.api.StatValueAggregateQuery.end_time)
  return _internal_end_time();
}
inline void StatValueAggregateQuery::unsafe_arena_set_allocated_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  _impl_.end_time_ = end_time;
  if (end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.StatValueAggregateQuery.end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StatValueAggregateQuery::release_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StatValueAggregateQuery::unsafe_arena_release_end_time() {
  // @@protoc_insertion_point(field_release:clarifai.api.StatValueAggregateQuery.end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StatValueAggregateQuery::_internal_mutable_end_time() {
  
  if (_impl_.end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.end_time_ = p;
  }
  return _impl_.end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StatValueAggregateQuery::mutable_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:clarifai.api.StatValueAggregateQuery.end_time)
  return _msg;
}
inline void StatValueAggregateQuery::set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  if (end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time));
    if (message_arena != submessage_arena) {
      end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.StatValueAggregateQuery.end_time)
}

// -------------------------------------------------------------------

// DatasetInputsSearchAddJob

// string id = 1;
inline void DatasetInputsSearchAddJob::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& DatasetInputsSearchAddJob::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetInputsSearchAddJob.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DatasetInputsSearchAddJob::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.DatasetInputsSearchAddJob.id)
}
inline std::string* DatasetInputsSearchAddJob::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetInputsSearchAddJob.id)
  return _s;
}
inline const std::string& DatasetInputsSearchAddJob::_internal_id() const {
  return _impl_.id_.Get();
}
inline void DatasetInputsSearchAddJob::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* DatasetInputsSearchAddJob::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* DatasetInputsSearchAddJob::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetInputsSearchAddJob.id)
  return _impl_.id_.Release();
}
inline void DatasetInputsSearchAddJob::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetInputsSearchAddJob.id)
}

// .google.protobuf.Timestamp created_at = 2;
inline bool DatasetInputsSearchAddJob::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool DatasetInputsSearchAddJob::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DatasetInputsSearchAddJob::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DatasetInputsSearchAddJob::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetInputsSearchAddJob.created_at)
  return _internal_created_at();
}
inline void DatasetInputsSearchAddJob::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetInputsSearchAddJob.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DatasetInputsSearchAddJob::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DatasetInputsSearchAddJob::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetInputsSearchAddJob.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DatasetInputsSearchAddJob::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DatasetInputsSearchAddJob::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetInputsSearchAddJob.created_at)
  return _msg;
}
inline void DatasetInputsSearchAddJob::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetInputsSearchAddJob.created_at)
}

// .google.protobuf.Timestamp modified_at = 3;
inline bool DatasetInputsSearchAddJob::_internal_has_modified_at() const {
  return this != internal_default_instance() && _impl_.modified_at_ != nullptr;
}
inline bool DatasetInputsSearchAddJob::has_modified_at() const {
  return _internal_has_modified_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DatasetInputsSearchAddJob::_internal_modified_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.modified_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DatasetInputsSearchAddJob::modified_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetInputsSearchAddJob.modified_at)
  return _internal_modified_at();
}
inline void DatasetInputsSearchAddJob::unsafe_arena_set_allocated_modified_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  _impl_.modified_at_ = modified_at;
  if (modified_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetInputsSearchAddJob.modified_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DatasetInputsSearchAddJob::release_modified_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DatasetInputsSearchAddJob::unsafe_arena_release_modified_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetInputsSearchAddJob.modified_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DatasetInputsSearchAddJob::_internal_mutable_modified_at() {
  
  if (_impl_.modified_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.modified_at_ = p;
  }
  return _impl_.modified_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DatasetInputsSearchAddJob::mutable_modified_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_modified_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetInputsSearchAddJob.modified_at)
  return _msg;
}
inline void DatasetInputsSearchAddJob::set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  if (modified_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(modified_at));
    if (message_arena != submessage_arena) {
      modified_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modified_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.modified_at_ = modified_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetInputsSearchAddJob.modified_at)
}

// .clarifai.api.status.Status status = 4;
inline bool DatasetInputsSearchAddJob::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool DatasetInputsSearchAddJob::has_status() const {
  return _internal_has_status();
}
inline const ::clarifai::api::status::Status& DatasetInputsSearchAddJob::_internal_status() const {
  const ::clarifai::api::status::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::status::Status&>(
      ::clarifai::api::status::_Status_default_instance_);
}
inline const ::clarifai::api::status::Status& DatasetInputsSearchAddJob::status() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetInputsSearchAddJob.status)
  return _internal_status();
}
inline void DatasetInputsSearchAddJob::unsafe_arena_set_allocated_status(
    ::clarifai::api::status::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetInputsSearchAddJob.status)
}
inline ::clarifai::api::status::Status* DatasetInputsSearchAddJob::release_status() {
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::status::Status* DatasetInputsSearchAddJob::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetInputsSearchAddJob.status)
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::clarifai::api::status::Status* DatasetInputsSearchAddJob::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::status::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::clarifai::api::status::Status* DatasetInputsSearchAddJob::mutable_status() {
  ::clarifai::api::status::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetInputsSearchAddJob.status)
  return _msg;
}
inline void DatasetInputsSearchAddJob::set_allocated_status(::clarifai::api::status::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetInputsSearchAddJob.status)
}

// string dataset_id = 5;
inline void DatasetInputsSearchAddJob::clear_dataset_id() {
  _impl_.dataset_id_.ClearToEmpty();
}
inline const std::string& DatasetInputsSearchAddJob::dataset_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetInputsSearchAddJob.dataset_id)
  return _internal_dataset_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DatasetInputsSearchAddJob::set_dataset_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dataset_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.DatasetInputsSearchAddJob.dataset_id)
}
inline std::string* DatasetInputsSearchAddJob::mutable_dataset_id() {
  std::string* _s = _internal_mutable_dataset_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetInputsSearchAddJob.dataset_id)
  return _s;
}
inline const std::string& DatasetInputsSearchAddJob::_internal_dataset_id() const {
  return _impl_.dataset_id_.Get();
}
inline void DatasetInputsSearchAddJob::_internal_set_dataset_id(const std::string& value) {
  
  _impl_.dataset_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DatasetInputsSearchAddJob::_internal_mutable_dataset_id() {
  
  return _impl_.dataset_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DatasetInputsSearchAddJob::release_dataset_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetInputsSearchAddJob.dataset_id)
  return _impl_.dataset_id_.Release();
}
inline void DatasetInputsSearchAddJob::set_allocated_dataset_id(std::string* dataset_id) {
  if (dataset_id != nullptr) {
    
  } else {
    
  }
  _impl_.dataset_id_.SetAllocated(dataset_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dataset_id_.IsDefault()) {
    _impl_.dataset_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetInputsSearchAddJob.dataset_id)
}

// .clarifai.api.Search search = 6;
inline bool DatasetInputsSearchAddJob::_internal_has_search() const {
  return this != internal_default_instance() && _impl_.search_ != nullptr;
}
inline bool DatasetInputsSearchAddJob::has_search() const {
  return _internal_has_search();
}
inline void DatasetInputsSearchAddJob::clear_search() {
  if (GetArenaForAllocation() == nullptr && _impl_.search_ != nullptr) {
    delete _impl_.search_;
  }
  _impl_.search_ = nullptr;
}
inline const ::clarifai::api::Search& DatasetInputsSearchAddJob::_internal_search() const {
  const ::clarifai::api::Search* p = _impl_.search_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Search&>(
      ::clarifai::api::_Search_default_instance_);
}
inline const ::clarifai::api::Search& DatasetInputsSearchAddJob::search() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DatasetInputsSearchAddJob.search)
  return _internal_search();
}
inline void DatasetInputsSearchAddJob::unsafe_arena_set_allocated_search(
    ::clarifai::api::Search* search) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.search_);
  }
  _impl_.search_ = search;
  if (search) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DatasetInputsSearchAddJob.search)
}
inline ::clarifai::api::Search* DatasetInputsSearchAddJob::release_search() {
  
  ::clarifai::api::Search* temp = _impl_.search_;
  _impl_.search_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Search* DatasetInputsSearchAddJob::unsafe_arena_release_search() {
  // @@protoc_insertion_point(field_release:clarifai.api.DatasetInputsSearchAddJob.search)
  
  ::clarifai::api::Search* temp = _impl_.search_;
  _impl_.search_ = nullptr;
  return temp;
}
inline ::clarifai::api::Search* DatasetInputsSearchAddJob::_internal_mutable_search() {
  
  if (_impl_.search_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Search>(GetArenaForAllocation());
    _impl_.search_ = p;
  }
  return _impl_.search_;
}
inline ::clarifai::api::Search* DatasetInputsSearchAddJob::mutable_search() {
  ::clarifai::api::Search* _msg = _internal_mutable_search();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DatasetInputsSearchAddJob.search)
  return _msg;
}
inline void DatasetInputsSearchAddJob::set_allocated_search(::clarifai::api::Search* search) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.search_;
  }
  if (search) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(search);
    if (message_arena != submessage_arena) {
      search = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, search, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.search_ = search;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DatasetInputsSearchAddJob.search)
}

// -------------------------------------------------------------------

// Visibility

// .clarifai.api.Visibility.Gettable gettable = 1;
inline void Visibility::clear_gettable() {
  _impl_.gettable_ = 0;
}
inline ::clarifai::api::Visibility_Gettable Visibility::_internal_gettable() const {
  return static_cast< ::clarifai::api::Visibility_Gettable >(_impl_.gettable_);
}
inline ::clarifai::api::Visibility_Gettable Visibility::gettable() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Visibility.gettable)
  return _internal_gettable();
}
inline void Visibility::_internal_set_gettable(::clarifai::api::Visibility_Gettable value) {
  
  _impl_.gettable_ = value;
}
inline void Visibility::set_gettable(::clarifai::api::Visibility_Gettable value) {
  _internal_set_gettable(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Visibility.gettable)
}

// -------------------------------------------------------------------

// TrendingMetric

// string user_id = 1;
inline void TrendingMetric::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& TrendingMetric::user_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TrendingMetric.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrendingMetric::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.TrendingMetric.user_id)
}
inline std::string* TrendingMetric::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.TrendingMetric.user_id)
  return _s;
}
inline const std::string& TrendingMetric::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void TrendingMetric::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TrendingMetric::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TrendingMetric::release_user_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.TrendingMetric.user_id)
  return _impl_.user_id_.Release();
}
inline void TrendingMetric::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.TrendingMetric.user_id)
}

// string app_id = 2;
inline void TrendingMetric::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& TrendingMetric::app_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TrendingMetric.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrendingMetric::set_app_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.app_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.TrendingMetric.app_id)
}
inline std::string* TrendingMetric::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.TrendingMetric.app_id)
  return _s;
}
inline const std::string& TrendingMetric::_internal_app_id() const {
  return _impl_.app_id_.Get();
}
inline void TrendingMetric::_internal_set_app_id(const std::string& value) {
  
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TrendingMetric::_internal_mutable_app_id() {
  
  return _impl_.app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TrendingMetric::release_app_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.TrendingMetric.app_id)
  return _impl_.app_id_.Release();
}
inline void TrendingMetric::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    
  } else {
    
  }
  _impl_.app_id_.SetAllocated(app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.TrendingMetric.app_id)
}

// string object_id = 3;
inline void TrendingMetric::clear_object_id() {
  _impl_.object_id_.ClearToEmpty();
}
inline const std::string& TrendingMetric::object_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TrendingMetric.object_id)
  return _internal_object_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrendingMetric::set_object_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.object_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.TrendingMetric.object_id)
}
inline std::string* TrendingMetric::mutable_object_id() {
  std::string* _s = _internal_mutable_object_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.TrendingMetric.object_id)
  return _s;
}
inline const std::string& TrendingMetric::_internal_object_id() const {
  return _impl_.object_id_.Get();
}
inline void TrendingMetric::_internal_set_object_id(const std::string& value) {
  
  _impl_.object_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TrendingMetric::_internal_mutable_object_id() {
  
  return _impl_.object_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TrendingMetric::release_object_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.TrendingMetric.object_id)
  return _impl_.object_id_.Release();
}
inline void TrendingMetric::set_allocated_object_id(std::string* object_id) {
  if (object_id != nullptr) {
    
  } else {
    
  }
  _impl_.object_id_.SetAllocated(object_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.object_id_.IsDefault()) {
    _impl_.object_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.TrendingMetric.object_id)
}

// uint64 view_count = 4;
inline void TrendingMetric::clear_view_count() {
  _impl_.view_count_ = uint64_t{0u};
}
inline uint64_t TrendingMetric::_internal_view_count() const {
  return _impl_.view_count_;
}
inline uint64_t TrendingMetric::view_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TrendingMetric.view_count)
  return _internal_view_count();
}
inline void TrendingMetric::_internal_set_view_count(uint64_t value) {
  
  _impl_.view_count_ = value;
}
inline void TrendingMetric::set_view_count(uint64_t value) {
  _internal_set_view_count(value);
  // @@protoc_insertion_point(field_set:clarifai.api.TrendingMetric.view_count)
}

// -------------------------------------------------------------------

// FullTag

// string name = 1;
inline void FullTag::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& FullTag::name() const {
  // @@protoc_insertion_point(field_get:clarifai.api.FullTag.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FullTag::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.FullTag.name)
}
inline std::string* FullTag::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:clarifai.api.FullTag.name)
  return _s;
}
inline const std::string& FullTag::_internal_name() const {
  return _impl_.name_.Get();
}
inline void FullTag::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* FullTag::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* FullTag::release_name() {
  // @@protoc_insertion_point(field_release:clarifai.api.FullTag.name)
  return _impl_.name_.Release();
}
inline void FullTag::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.FullTag.name)
}

// string id = 2;
inline void FullTag::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& FullTag::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.FullTag.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FullTag::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.FullTag.id)
}
inline std::string* FullTag::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.FullTag.id)
  return _s;
}
inline const std::string& FullTag::_internal_id() const {
  return _impl_.id_.Get();
}
inline void FullTag::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* FullTag::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* FullTag::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.FullTag.id)
  return _impl_.id_.Release();
}
inline void FullTag::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.FullTag.id)
}

// -------------------------------------------------------------------

// TimeSegment

// string id = 1;
inline void TimeSegment::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& TimeSegment::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TimeSegment.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TimeSegment::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.TimeSegment.id)
}
inline std::string* TimeSegment::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.TimeSegment.id)
  return _s;
}
inline const std::string& TimeSegment::_internal_id() const {
  return _impl_.id_.Get();
}
inline void TimeSegment::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* TimeSegment::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* TimeSegment::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.TimeSegment.id)
  return _impl_.id_.Release();
}
inline void TimeSegment::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.TimeSegment.id)
}

// .clarifai.api.Data data = 2;
inline bool TimeSegment::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool TimeSegment::has_data() const {
  return _internal_has_data();
}
inline void TimeSegment::clear_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.data_ != nullptr) {
    delete _impl_.data_;
  }
  _impl_.data_ = nullptr;
}
inline const ::clarifai::api::Data& TimeSegment::_internal_data() const {
  const ::clarifai::api::Data* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Data&>(
      ::clarifai::api::_Data_default_instance_);
}
inline const ::clarifai::api::Data& TimeSegment::data() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TimeSegment.data)
  return _internal_data();
}
inline void TimeSegment::unsafe_arena_set_allocated_data(
    ::clarifai::api::Data* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.TimeSegment.data)
}
inline ::clarifai::api::Data* TimeSegment::release_data() {
  
  ::clarifai::api::Data* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Data* TimeSegment::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:clarifai.api.TimeSegment.data)
  
  ::clarifai::api::Data* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::clarifai::api::Data* TimeSegment::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Data>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::clarifai::api::Data* TimeSegment::mutable_data() {
  ::clarifai::api::Data* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:clarifai.api.TimeSegment.data)
  return _msg;
}
inline void TimeSegment::set_allocated_data(::clarifai::api::Data* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.TimeSegment.data)
}

// .clarifai.api.TimeInfo time_info = 3;
inline bool TimeSegment::_internal_has_time_info() const {
  return this != internal_default_instance() && _impl_.time_info_ != nullptr;
}
inline bool TimeSegment::has_time_info() const {
  return _internal_has_time_info();
}
inline void TimeSegment::clear_time_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.time_info_ != nullptr) {
    delete _impl_.time_info_;
  }
  _impl_.time_info_ = nullptr;
}
inline const ::clarifai::api::TimeInfo& TimeSegment::_internal_time_info() const {
  const ::clarifai::api::TimeInfo* p = _impl_.time_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::TimeInfo&>(
      ::clarifai::api::_TimeInfo_default_instance_);
}
inline const ::clarifai::api::TimeInfo& TimeSegment::time_info() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TimeSegment.time_info)
  return _internal_time_info();
}
inline void TimeSegment::unsafe_arena_set_allocated_time_info(
    ::clarifai::api::TimeInfo* time_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_info_);
  }
  _impl_.time_info_ = time_info;
  if (time_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.TimeSegment.time_info)
}
inline ::clarifai::api::TimeInfo* TimeSegment::release_time_info() {
  
  ::clarifai::api::TimeInfo* temp = _impl_.time_info_;
  _impl_.time_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::TimeInfo* TimeSegment::unsafe_arena_release_time_info() {
  // @@protoc_insertion_point(field_release:clarifai.api.TimeSegment.time_info)
  
  ::clarifai::api::TimeInfo* temp = _impl_.time_info_;
  _impl_.time_info_ = nullptr;
  return temp;
}
inline ::clarifai::api::TimeInfo* TimeSegment::_internal_mutable_time_info() {
  
  if (_impl_.time_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::TimeInfo>(GetArenaForAllocation());
    _impl_.time_info_ = p;
  }
  return _impl_.time_info_;
}
inline ::clarifai::api::TimeInfo* TimeSegment::mutable_time_info() {
  ::clarifai::api::TimeInfo* _msg = _internal_mutable_time_info();
  // @@protoc_insertion_point(field_mutable:clarifai.api.TimeSegment.time_info)
  return _msg;
}
inline void TimeSegment::set_allocated_time_info(::clarifai::api::TimeInfo* time_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.time_info_;
  }
  if (time_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(time_info);
    if (message_arena != submessage_arena) {
      time_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.time_info_ = time_info;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.TimeSegment.time_info)
}

// -------------------------------------------------------------------

// TimeInfo

// uint32 num_frames = 1;
inline void TimeInfo::clear_num_frames() {
  _impl_.num_frames_ = 0u;
}
inline uint32_t TimeInfo::_internal_num_frames() const {
  return _impl_.num_frames_;
}
inline uint32_t TimeInfo::num_frames() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TimeInfo.num_frames)
  return _internal_num_frames();
}
inline void TimeInfo::_internal_set_num_frames(uint32_t value) {
  
  _impl_.num_frames_ = value;
}
inline void TimeInfo::set_num_frames(uint32_t value) {
  _internal_set_num_frames(value);
  // @@protoc_insertion_point(field_set:clarifai.api.TimeInfo.num_frames)
}

// uint32 begin_time = 2;
inline void TimeInfo::clear_begin_time() {
  _impl_.begin_time_ = 0u;
}
inline uint32_t TimeInfo::_internal_begin_time() const {
  return _impl_.begin_time_;
}
inline uint32_t TimeInfo::begin_time() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TimeInfo.begin_time)
  return _internal_begin_time();
}
inline void TimeInfo::_internal_set_begin_time(uint32_t value) {
  
  _impl_.begin_time_ = value;
}
inline void TimeInfo::set_begin_time(uint32_t value) {
  _internal_set_begin_time(value);
  // @@protoc_insertion_point(field_set:clarifai.api.TimeInfo.begin_time)
}

// uint32 end_time = 3;
inline void TimeInfo::clear_end_time() {
  _impl_.end_time_ = 0u;
}
inline uint32_t TimeInfo::_internal_end_time() const {
  return _impl_.end_time_;
}
inline uint32_t TimeInfo::end_time() const {
  // @@protoc_insertion_point(field_get:clarifai.api.TimeInfo.end_time)
  return _internal_end_time();
}
inline void TimeInfo::_internal_set_end_time(uint32_t value) {
  
  _impl_.end_time_ = value;
}
inline void TimeInfo::set_end_time(uint32_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:clarifai.api.TimeInfo.end_time)
}

// -------------------------------------------------------------------

// Module

// string id = 1;
inline void Module::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Module::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Module.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Module::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Module.id)
}
inline std::string* Module::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Module.id)
  return _s;
}
inline const std::string& Module::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Module::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Module::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Module::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Module.id)
  return _impl_.id_.Release();
}
inline void Module::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Module.id)
}

// string description = 3;
inline void Module::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Module::description() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Module.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Module::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Module.description)
}
inline std::string* Module::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Module.description)
  return _s;
}
inline const std::string& Module::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Module::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Module::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Module::release_description() {
  // @@protoc_insertion_point(field_release:clarifai.api.Module.description)
  return _impl_.description_.Release();
}
inline void Module::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Module.description)
}

// .google.protobuf.Timestamp created_at = 4;
inline bool Module::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool Module::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Module::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Module::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Module.created_at)
  return _internal_created_at();
}
inline void Module::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Module.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Module::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Module::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.Module.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Module::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Module::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Module.created_at)
  return _msg;
}
inline void Module::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Module.created_at)
}

// .google.protobuf.Timestamp modified_at = 5;
inline bool Module::_internal_has_modified_at() const {
  return this != internal_default_instance() && _impl_.modified_at_ != nullptr;
}
inline bool Module::has_modified_at() const {
  return _internal_has_modified_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Module::_internal_modified_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.modified_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Module::modified_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Module.modified_at)
  return _internal_modified_at();
}
inline void Module::unsafe_arena_set_allocated_modified_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  _impl_.modified_at_ = modified_at;
  if (modified_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Module.modified_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Module::release_modified_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Module::unsafe_arena_release_modified_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.Module.modified_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Module::_internal_mutable_modified_at() {
  
  if (_impl_.modified_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.modified_at_ = p;
  }
  return _impl_.modified_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Module::mutable_modified_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_modified_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Module.modified_at)
  return _msg;
}
inline void Module::set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  if (modified_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(modified_at));
    if (message_arena != submessage_arena) {
      modified_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modified_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.modified_at_ = modified_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Module.modified_at)
}

// .clarifai.api.Visibility visibility = 7;
inline bool Module::_internal_has_visibility() const {
  return this != internal_default_instance() && _impl_.visibility_ != nullptr;
}
inline bool Module::has_visibility() const {
  return _internal_has_visibility();
}
inline void Module::clear_visibility() {
  if (GetArenaForAllocation() == nullptr && _impl_.visibility_ != nullptr) {
    delete _impl_.visibility_;
  }
  _impl_.visibility_ = nullptr;
}
inline const ::clarifai::api::Visibility& Module::_internal_visibility() const {
  const ::clarifai::api::Visibility* p = _impl_.visibility_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Visibility&>(
      ::clarifai::api::_Visibility_default_instance_);
}
inline const ::clarifai::api::Visibility& Module::visibility() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Module.visibility)
  return _internal_visibility();
}
inline void Module::unsafe_arena_set_allocated_visibility(
    ::clarifai::api::Visibility* visibility) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visibility_);
  }
  _impl_.visibility_ = visibility;
  if (visibility) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Module.visibility)
}
inline ::clarifai::api::Visibility* Module::release_visibility() {
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Visibility* Module::unsafe_arena_release_visibility() {
  // @@protoc_insertion_point(field_release:clarifai.api.Module.visibility)
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
  return temp;
}
inline ::clarifai::api::Visibility* Module::_internal_mutable_visibility() {
  
  if (_impl_.visibility_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Visibility>(GetArenaForAllocation());
    _impl_.visibility_ = p;
  }
  return _impl_.visibility_;
}
inline ::clarifai::api::Visibility* Module::mutable_visibility() {
  ::clarifai::api::Visibility* _msg = _internal_mutable_visibility();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Module.visibility)
  return _msg;
}
inline void Module::set_allocated_visibility(::clarifai::api::Visibility* visibility) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.visibility_;
  }
  if (visibility) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(visibility);
    if (message_arena != submessage_arena) {
      visibility = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visibility, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.visibility_ = visibility;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Module.visibility)
}

// .google.protobuf.Struct metadata = 8;
inline bool Module::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool Module::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Module::_internal_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Module::metadata() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Module.metadata)
  return _internal_metadata();
}
inline void Module::unsafe_arena_set_allocated_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Module.metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Module::release_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Module::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:clarifai.api.Module.metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Module::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Module::mutable_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Module.metadata)
  return _msg;
}
inline void Module::set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Module.metadata)
}

// string user_id = 9;
inline void Module::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& Module::user_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Module.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Module::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Module.user_id)
}
inline std::string* Module::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Module.user_id)
  return _s;
}
inline const std::string& Module::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void Module::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Module::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Module::release_user_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Module.user_id)
  return _impl_.user_id_.Release();
}
inline void Module::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Module.user_id)
}

// string app_id = 10;
inline void Module::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& Module::app_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Module.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Module::set_app_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.app_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Module.app_id)
}
inline std::string* Module::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Module.app_id)
  return _s;
}
inline const std::string& Module::_internal_app_id() const {
  return _impl_.app_id_.Get();
}
inline void Module::_internal_set_app_id(const std::string& value) {
  
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Module::_internal_mutable_app_id() {
  
  return _impl_.app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Module::release_app_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Module.app_id)
  return _impl_.app_id_.Release();
}
inline void Module::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    
  } else {
    
  }
  _impl_.app_id_.SetAllocated(app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Module.app_id)
}

// .clarifai.api.ModuleVersion module_version = 11;
inline bool Module::_internal_has_module_version() const {
  return this != internal_default_instance() && _impl_.module_version_ != nullptr;
}
inline bool Module::has_module_version() const {
  return _internal_has_module_version();
}
inline void Module::clear_module_version() {
  if (GetArenaForAllocation() == nullptr && _impl_.module_version_ != nullptr) {
    delete _impl_.module_version_;
  }
  _impl_.module_version_ = nullptr;
}
inline const ::clarifai::api::ModuleVersion& Module::_internal_module_version() const {
  const ::clarifai::api::ModuleVersion* p = _impl_.module_version_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::ModuleVersion&>(
      ::clarifai::api::_ModuleVersion_default_instance_);
}
inline const ::clarifai::api::ModuleVersion& Module::module_version() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Module.module_version)
  return _internal_module_version();
}
inline void Module::unsafe_arena_set_allocated_module_version(
    ::clarifai::api::ModuleVersion* module_version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.module_version_);
  }
  _impl_.module_version_ = module_version;
  if (module_version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Module.module_version)
}
inline ::clarifai::api::ModuleVersion* Module::release_module_version() {
  
  ::clarifai::api::ModuleVersion* temp = _impl_.module_version_;
  _impl_.module_version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::ModuleVersion* Module::unsafe_arena_release_module_version() {
  // @@protoc_insertion_point(field_release:clarifai.api.Module.module_version)
  
  ::clarifai::api::ModuleVersion* temp = _impl_.module_version_;
  _impl_.module_version_ = nullptr;
  return temp;
}
inline ::clarifai::api::ModuleVersion* Module::_internal_mutable_module_version() {
  
  if (_impl_.module_version_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::ModuleVersion>(GetArenaForAllocation());
    _impl_.module_version_ = p;
  }
  return _impl_.module_version_;
}
inline ::clarifai::api::ModuleVersion* Module::mutable_module_version() {
  ::clarifai::api::ModuleVersion* _msg = _internal_mutable_module_version();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Module.module_version)
  return _msg;
}
inline void Module::set_allocated_module_version(::clarifai::api::ModuleVersion* module_version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.module_version_;
  }
  if (module_version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(module_version);
    if (message_arena != submessage_arena) {
      module_version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, module_version, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.module_version_ = module_version;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Module.module_version)
}

// -------------------------------------------------------------------

// ModuleVersion_ModuleSubNav

// string title = 1;
inline void ModuleVersion_ModuleSubNav::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& ModuleVersion_ModuleSubNav::title() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModuleVersion.ModuleSubNav.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleVersion_ModuleSubNav::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModuleVersion.ModuleSubNav.title)
}
inline std::string* ModuleVersion_ModuleSubNav::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModuleVersion.ModuleSubNav.title)
  return _s;
}
inline const std::string& ModuleVersion_ModuleSubNav::_internal_title() const {
  return _impl_.title_.Get();
}
inline void ModuleVersion_ModuleSubNav::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleVersion_ModuleSubNav::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleVersion_ModuleSubNav::release_title() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModuleVersion.ModuleSubNav.title)
  return _impl_.title_.Release();
}
inline void ModuleVersion_ModuleSubNav::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModuleVersion.ModuleSubNav.title)
}

// string query_key = 2;
inline void ModuleVersion_ModuleSubNav::clear_query_key() {
  _impl_.query_key_.ClearToEmpty();
}
inline const std::string& ModuleVersion_ModuleSubNav::query_key() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModuleVersion.ModuleSubNav.query_key)
  return _internal_query_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleVersion_ModuleSubNav::set_query_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.query_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModuleVersion.ModuleSubNav.query_key)
}
inline std::string* ModuleVersion_ModuleSubNav::mutable_query_key() {
  std::string* _s = _internal_mutable_query_key();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModuleVersion.ModuleSubNav.query_key)
  return _s;
}
inline const std::string& ModuleVersion_ModuleSubNav::_internal_query_key() const {
  return _impl_.query_key_.Get();
}
inline void ModuleVersion_ModuleSubNav::_internal_set_query_key(const std::string& value) {
  
  _impl_.query_key_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleVersion_ModuleSubNav::_internal_mutable_query_key() {
  
  return _impl_.query_key_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleVersion_ModuleSubNav::release_query_key() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModuleVersion.ModuleSubNav.query_key)
  return _impl_.query_key_.Release();
}
inline void ModuleVersion_ModuleSubNav::set_allocated_query_key(std::string* query_key) {
  if (query_key != nullptr) {
    
  } else {
    
  }
  _impl_.query_key_.SetAllocated(query_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.query_key_.IsDefault()) {
    _impl_.query_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModuleVersion.ModuleSubNav.query_key)
}

// string query_value = 3;
inline void ModuleVersion_ModuleSubNav::clear_query_value() {
  _impl_.query_value_.ClearToEmpty();
}
inline const std::string& ModuleVersion_ModuleSubNav::query_value() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModuleVersion.ModuleSubNav.query_value)
  return _internal_query_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleVersion_ModuleSubNav::set_query_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.query_value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModuleVersion.ModuleSubNav.query_value)
}
inline std::string* ModuleVersion_ModuleSubNav::mutable_query_value() {
  std::string* _s = _internal_mutable_query_value();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModuleVersion.ModuleSubNav.query_value)
  return _s;
}
inline const std::string& ModuleVersion_ModuleSubNav::_internal_query_value() const {
  return _impl_.query_value_.Get();
}
inline void ModuleVersion_ModuleSubNav::_internal_set_query_value(const std::string& value) {
  
  _impl_.query_value_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleVersion_ModuleSubNav::_internal_mutable_query_value() {
  
  return _impl_.query_value_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleVersion_ModuleSubNav::release_query_value() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModuleVersion.ModuleSubNav.query_value)
  return _impl_.query_value_.Release();
}
inline void ModuleVersion_ModuleSubNav::set_allocated_query_value(std::string* query_value) {
  if (query_value != nullptr) {
    
  } else {
    
  }
  _impl_.query_value_.SetAllocated(query_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.query_value_.IsDefault()) {
    _impl_.query_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModuleVersion.ModuleSubNav.query_value)
}

// -------------------------------------------------------------------

// ModuleVersion_ModuleNav

// string title = 1;
inline void ModuleVersion_ModuleNav::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& ModuleVersion_ModuleNav::title() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModuleVersion.ModuleNav.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleVersion_ModuleNav::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModuleVersion.ModuleNav.title)
}
inline std::string* ModuleVersion_ModuleNav::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModuleVersion.ModuleNav.title)
  return _s;
}
inline const std::string& ModuleVersion_ModuleNav::_internal_title() const {
  return _impl_.title_.Get();
}
inline void ModuleVersion_ModuleNav::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleVersion_ModuleNav::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleVersion_ModuleNav::release_title() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModuleVersion.ModuleNav.title)
  return _impl_.title_.Release();
}
inline void ModuleVersion_ModuleNav::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModuleVersion.ModuleNav.title)
}

// repeated .clarifai.api.ModuleVersion.ModuleSubNav module_sub_navs = 2;
inline int ModuleVersion_ModuleNav::_internal_module_sub_navs_size() const {
  return _impl_.module_sub_navs_.size();
}
inline int ModuleVersion_ModuleNav::module_sub_navs_size() const {
  return _internal_module_sub_navs_size();
}
inline void ModuleVersion_ModuleNav::clear_module_sub_navs() {
  _impl_.module_sub_navs_.Clear();
}
inline ::clarifai::api::ModuleVersion_ModuleSubNav* ModuleVersion_ModuleNav::mutable_module_sub_navs(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModuleVersion.ModuleNav.module_sub_navs)
  return _impl_.module_sub_navs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModuleVersion_ModuleSubNav >*
ModuleVersion_ModuleNav::mutable_module_sub_navs() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.ModuleVersion.ModuleNav.module_sub_navs)
  return &_impl_.module_sub_navs_;
}
inline const ::clarifai::api::ModuleVersion_ModuleSubNav& ModuleVersion_ModuleNav::_internal_module_sub_navs(int index) const {
  return _impl_.module_sub_navs_.Get(index);
}
inline const ::clarifai::api::ModuleVersion_ModuleSubNav& ModuleVersion_ModuleNav::module_sub_navs(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModuleVersion.ModuleNav.module_sub_navs)
  return _internal_module_sub_navs(index);
}
inline ::clarifai::api::ModuleVersion_ModuleSubNav* ModuleVersion_ModuleNav::_internal_add_module_sub_navs() {
  return _impl_.module_sub_navs_.Add();
}
inline ::clarifai::api::ModuleVersion_ModuleSubNav* ModuleVersion_ModuleNav::add_module_sub_navs() {
  ::clarifai::api::ModuleVersion_ModuleSubNav* _add = _internal_add_module_sub_navs();
  // @@protoc_insertion_point(field_add:clarifai.api.ModuleVersion.ModuleNav.module_sub_navs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::ModuleVersion_ModuleSubNav >&
ModuleVersion_ModuleNav::module_sub_navs() const {
  // @@protoc_insertion_point(field_list:clarifai.api.ModuleVersion.ModuleNav.module_sub_navs)
  return _impl_.module_sub_navs_;
}

// -------------------------------------------------------------------

// ModuleVersion

// string id = 1;
inline void ModuleVersion::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ModuleVersion::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModuleVersion.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleVersion::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModuleVersion.id)
}
inline std::string* ModuleVersion::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModuleVersion.id)
  return _s;
}
inline const std::string& ModuleVersion::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ModuleVersion::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleVersion::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleVersion::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModuleVersion.id)
  return _impl_.id_.Release();
}
inline void ModuleVersion::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModuleVersion.id)
}

// string module_id = 2;
inline void ModuleVersion::clear_module_id() {
  _impl_.module_id_.ClearToEmpty();
}
inline const std::string& ModuleVersion::module_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModuleVersion.module_id)
  return _internal_module_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleVersion::set_module_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.module_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModuleVersion.module_id)
}
inline std::string* ModuleVersion::mutable_module_id() {
  std::string* _s = _internal_mutable_module_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModuleVersion.module_id)
  return _s;
}
inline const std::string& ModuleVersion::_internal_module_id() const {
  return _impl_.module_id_.Get();
}
inline void ModuleVersion::_internal_set_module_id(const std::string& value) {
  
  _impl_.module_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleVersion::_internal_mutable_module_id() {
  
  return _impl_.module_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleVersion::release_module_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModuleVersion.module_id)
  return _impl_.module_id_.Release();
}
inline void ModuleVersion::set_allocated_module_id(std::string* module_id) {
  if (module_id != nullptr) {
    
  } else {
    
  }
  _impl_.module_id_.SetAllocated(module_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.module_id_.IsDefault()) {
    _impl_.module_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModuleVersion.module_id)
}

// string app_id = 3;
inline void ModuleVersion::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& ModuleVersion::app_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModuleVersion.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleVersion::set_app_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.app_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModuleVersion.app_id)
}
inline std::string* ModuleVersion::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModuleVersion.app_id)
  return _s;
}
inline const std::string& ModuleVersion::_internal_app_id() const {
  return _impl_.app_id_.Get();
}
inline void ModuleVersion::_internal_set_app_id(const std::string& value) {
  
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleVersion::_internal_mutable_app_id() {
  
  return _impl_.app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleVersion::release_app_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModuleVersion.app_id)
  return _impl_.app_id_.Release();
}
inline void ModuleVersion::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    
  } else {
    
  }
  _impl_.app_id_.SetAllocated(app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModuleVersion.app_id)
}

// string user_id = 4;
inline void ModuleVersion::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& ModuleVersion::user_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModuleVersion.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleVersion::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModuleVersion.user_id)
}
inline std::string* ModuleVersion::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModuleVersion.user_id)
  return _s;
}
inline const std::string& ModuleVersion::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void ModuleVersion::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleVersion::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleVersion::release_user_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModuleVersion.user_id)
  return _impl_.user_id_.Release();
}
inline void ModuleVersion::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModuleVersion.user_id)
}

// string description = 6;
inline void ModuleVersion::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ModuleVersion::description() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModuleVersion.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleVersion::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModuleVersion.description)
}
inline std::string* ModuleVersion::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModuleVersion.description)
  return _s;
}
inline const std::string& ModuleVersion::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ModuleVersion::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleVersion::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleVersion::release_description() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModuleVersion.description)
  return _impl_.description_.Release();
}
inline void ModuleVersion::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModuleVersion.description)
}

// string notes = 7;
inline void ModuleVersion::clear_notes() {
  _impl_.notes_.ClearToEmpty();
}
inline const std::string& ModuleVersion::notes() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModuleVersion.notes)
  return _internal_notes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleVersion::set_notes(ArgT0&& arg0, ArgT... args) {
 
 _impl_.notes_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModuleVersion.notes)
}
inline std::string* ModuleVersion::mutable_notes() {
  std::string* _s = _internal_mutable_notes();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModuleVersion.notes)
  return _s;
}
inline const std::string& ModuleVersion::_internal_notes() const {
  return _impl_.notes_.Get();
}
inline void ModuleVersion::_internal_set_notes(const std::string& value) {
  
  _impl_.notes_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleVersion::_internal_mutable_notes() {
  
  return _impl_.notes_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleVersion::release_notes() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModuleVersion.notes)
  return _impl_.notes_.Release();
}
inline void ModuleVersion::set_allocated_notes(std::string* notes) {
  if (notes != nullptr) {
    
  } else {
    
  }
  _impl_.notes_.SetAllocated(notes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.notes_.IsDefault()) {
    _impl_.notes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModuleVersion.notes)
}

// .google.protobuf.Timestamp created_at = 8;
inline bool ModuleVersion::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool ModuleVersion::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ModuleVersion::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ModuleVersion::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModuleVersion.created_at)
  return _internal_created_at();
}
inline void ModuleVersion::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.ModuleVersion.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ModuleVersion::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ModuleVersion::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModuleVersion.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ModuleVersion::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ModuleVersion::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModuleVersion.created_at)
  return _msg;
}
inline void ModuleVersion::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModuleVersion.created_at)
}

// .google.protobuf.Timestamp modified_at = 9;
inline bool ModuleVersion::_internal_has_modified_at() const {
  return this != internal_default_instance() && _impl_.modified_at_ != nullptr;
}
inline bool ModuleVersion::has_modified_at() const {
  return _internal_has_modified_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ModuleVersion::_internal_modified_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.modified_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ModuleVersion::modified_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModuleVersion.modified_at)
  return _internal_modified_at();
}
inline void ModuleVersion::unsafe_arena_set_allocated_modified_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  _impl_.modified_at_ = modified_at;
  if (modified_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.ModuleVersion.modified_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ModuleVersion::release_modified_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ModuleVersion::unsafe_arena_release_modified_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModuleVersion.modified_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ModuleVersion::_internal_mutable_modified_at() {
  
  if (_impl_.modified_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.modified_at_ = p;
  }
  return _impl_.modified_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ModuleVersion::mutable_modified_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_modified_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModuleVersion.modified_at)
  return _msg;
}
inline void ModuleVersion::set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  if (modified_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(modified_at));
    if (message_arena != submessage_arena) {
      modified_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modified_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.modified_at_ = modified_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModuleVersion.modified_at)
}

// string git_commit_url = 10;
inline void ModuleVersion::clear_git_commit_url() {
  _impl_.git_commit_url_.ClearToEmpty();
}
inline const std::string& ModuleVersion::git_commit_url() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModuleVersion.git_commit_url)
  return _internal_git_commit_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleVersion::set_git_commit_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.git_commit_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.ModuleVersion.git_commit_url)
}
inline std::string* ModuleVersion::mutable_git_commit_url() {
  std::string* _s = _internal_mutable_git_commit_url();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModuleVersion.git_commit_url)
  return _s;
}
inline const std::string& ModuleVersion::_internal_git_commit_url() const {
  return _impl_.git_commit_url_.Get();
}
inline void ModuleVersion::_internal_set_git_commit_url(const std::string& value) {
  
  _impl_.git_commit_url_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleVersion::_internal_mutable_git_commit_url() {
  
  return _impl_.git_commit_url_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleVersion::release_git_commit_url() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModuleVersion.git_commit_url)
  return _impl_.git_commit_url_.Release();
}
inline void ModuleVersion::set_allocated_git_commit_url(std::string* git_commit_url) {
  if (git_commit_url != nullptr) {
    
  } else {
    
  }
  _impl_.git_commit_url_.SetAllocated(git_commit_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.git_commit_url_.IsDefault()) {
    _impl_.git_commit_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModuleVersion.git_commit_url)
}

// .clarifai.api.ModuleVersion.ModuleNav module_nav = 11;
inline bool ModuleVersion::_internal_has_module_nav() const {
  return this != internal_default_instance() && _impl_.module_nav_ != nullptr;
}
inline bool ModuleVersion::has_module_nav() const {
  return _internal_has_module_nav();
}
inline void ModuleVersion::clear_module_nav() {
  if (GetArenaForAllocation() == nullptr && _impl_.module_nav_ != nullptr) {
    delete _impl_.module_nav_;
  }
  _impl_.module_nav_ = nullptr;
}
inline const ::clarifai::api::ModuleVersion_ModuleNav& ModuleVersion::_internal_module_nav() const {
  const ::clarifai::api::ModuleVersion_ModuleNav* p = _impl_.module_nav_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::ModuleVersion_ModuleNav&>(
      ::clarifai::api::_ModuleVersion_ModuleNav_default_instance_);
}
inline const ::clarifai::api::ModuleVersion_ModuleNav& ModuleVersion::module_nav() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModuleVersion.module_nav)
  return _internal_module_nav();
}
inline void ModuleVersion::unsafe_arena_set_allocated_module_nav(
    ::clarifai::api::ModuleVersion_ModuleNav* module_nav) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.module_nav_);
  }
  _impl_.module_nav_ = module_nav;
  if (module_nav) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.ModuleVersion.module_nav)
}
inline ::clarifai::api::ModuleVersion_ModuleNav* ModuleVersion::release_module_nav() {
  
  ::clarifai::api::ModuleVersion_ModuleNav* temp = _impl_.module_nav_;
  _impl_.module_nav_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::ModuleVersion_ModuleNav* ModuleVersion::unsafe_arena_release_module_nav() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModuleVersion.module_nav)
  
  ::clarifai::api::ModuleVersion_ModuleNav* temp = _impl_.module_nav_;
  _impl_.module_nav_ = nullptr;
  return temp;
}
inline ::clarifai::api::ModuleVersion_ModuleNav* ModuleVersion::_internal_mutable_module_nav() {
  
  if (_impl_.module_nav_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::ModuleVersion_ModuleNav>(GetArenaForAllocation());
    _impl_.module_nav_ = p;
  }
  return _impl_.module_nav_;
}
inline ::clarifai::api::ModuleVersion_ModuleNav* ModuleVersion::mutable_module_nav() {
  ::clarifai::api::ModuleVersion_ModuleNav* _msg = _internal_mutable_module_nav();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModuleVersion.module_nav)
  return _msg;
}
inline void ModuleVersion::set_allocated_module_nav(::clarifai::api::ModuleVersion_ModuleNav* module_nav) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.module_nav_;
  }
  if (module_nav) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(module_nav);
    if (message_arena != submessage_arena) {
      module_nav = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, module_nav, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.module_nav_ = module_nav;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModuleVersion.module_nav)
}

// bool approved = 12;
inline void ModuleVersion::clear_approved() {
  _impl_.approved_ = false;
}
inline bool ModuleVersion::_internal_approved() const {
  return _impl_.approved_;
}
inline bool ModuleVersion::approved() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModuleVersion.approved)
  return _internal_approved();
}
inline void ModuleVersion::_internal_set_approved(bool value) {
  
  _impl_.approved_ = value;
}
inline void ModuleVersion::set_approved(bool value) {
  _internal_set_approved(value);
  // @@protoc_insertion_point(field_set:clarifai.api.ModuleVersion.approved)
}

// .clarifai.api.Visibility visibility = 13;
inline bool ModuleVersion::_internal_has_visibility() const {
  return this != internal_default_instance() && _impl_.visibility_ != nullptr;
}
inline bool ModuleVersion::has_visibility() const {
  return _internal_has_visibility();
}
inline void ModuleVersion::clear_visibility() {
  if (GetArenaForAllocation() == nullptr && _impl_.visibility_ != nullptr) {
    delete _impl_.visibility_;
  }
  _impl_.visibility_ = nullptr;
}
inline const ::clarifai::api::Visibility& ModuleVersion::_internal_visibility() const {
  const ::clarifai::api::Visibility* p = _impl_.visibility_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Visibility&>(
      ::clarifai::api::_Visibility_default_instance_);
}
inline const ::clarifai::api::Visibility& ModuleVersion::visibility() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModuleVersion.visibility)
  return _internal_visibility();
}
inline void ModuleVersion::unsafe_arena_set_allocated_visibility(
    ::clarifai::api::Visibility* visibility) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visibility_);
  }
  _impl_.visibility_ = visibility;
  if (visibility) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.ModuleVersion.visibility)
}
inline ::clarifai::api::Visibility* ModuleVersion::release_visibility() {
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Visibility* ModuleVersion::unsafe_arena_release_visibility() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModuleVersion.visibility)
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
  return temp;
}
inline ::clarifai::api::Visibility* ModuleVersion::_internal_mutable_visibility() {
  
  if (_impl_.visibility_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Visibility>(GetArenaForAllocation());
    _impl_.visibility_ = p;
  }
  return _impl_.visibility_;
}
inline ::clarifai::api::Visibility* ModuleVersion::mutable_visibility() {
  ::clarifai::api::Visibility* _msg = _internal_mutable_visibility();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModuleVersion.visibility)
  return _msg;
}
inline void ModuleVersion::set_allocated_visibility(::clarifai::api::Visibility* visibility) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.visibility_;
  }
  if (visibility) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(visibility);
    if (message_arena != submessage_arena) {
      visibility = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visibility, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.visibility_ = visibility;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModuleVersion.visibility)
}

// .google.protobuf.Struct metadata = 14;
inline bool ModuleVersion::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool ModuleVersion::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ModuleVersion::_internal_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ModuleVersion::metadata() const {
  // @@protoc_insertion_point(field_get:clarifai.api.ModuleVersion.metadata)
  return _internal_metadata();
}
inline void ModuleVersion::unsafe_arena_set_allocated_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.ModuleVersion.metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ModuleVersion::release_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ModuleVersion::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:clarifai.api.ModuleVersion.metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ModuleVersion::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ModuleVersion::mutable_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:clarifai.api.ModuleVersion.metadata)
  return _msg;
}
inline void ModuleVersion::set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.ModuleVersion.metadata)
}

// -------------------------------------------------------------------

// InstalledModuleVersion

// string id = 1;
inline void InstalledModuleVersion::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& InstalledModuleVersion::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InstalledModuleVersion.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstalledModuleVersion::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.InstalledModuleVersion.id)
}
inline std::string* InstalledModuleVersion::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.InstalledModuleVersion.id)
  return _s;
}
inline const std::string& InstalledModuleVersion::_internal_id() const {
  return _impl_.id_.Get();
}
inline void InstalledModuleVersion::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* InstalledModuleVersion::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* InstalledModuleVersion::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.InstalledModuleVersion.id)
  return _impl_.id_.Release();
}
inline void InstalledModuleVersion::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.InstalledModuleVersion.id)
}

// .clarifai.api.ModuleVersion module_version = 2;
inline bool InstalledModuleVersion::_internal_has_module_version() const {
  return this != internal_default_instance() && _impl_.module_version_ != nullptr;
}
inline bool InstalledModuleVersion::has_module_version() const {
  return _internal_has_module_version();
}
inline void InstalledModuleVersion::clear_module_version() {
  if (GetArenaForAllocation() == nullptr && _impl_.module_version_ != nullptr) {
    delete _impl_.module_version_;
  }
  _impl_.module_version_ = nullptr;
}
inline const ::clarifai::api::ModuleVersion& InstalledModuleVersion::_internal_module_version() const {
  const ::clarifai::api::ModuleVersion* p = _impl_.module_version_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::ModuleVersion&>(
      ::clarifai::api::_ModuleVersion_default_instance_);
}
inline const ::clarifai::api::ModuleVersion& InstalledModuleVersion::module_version() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InstalledModuleVersion.module_version)
  return _internal_module_version();
}
inline void InstalledModuleVersion::unsafe_arena_set_allocated_module_version(
    ::clarifai::api::ModuleVersion* module_version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.module_version_);
  }
  _impl_.module_version_ = module_version;
  if (module_version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.InstalledModuleVersion.module_version)
}
inline ::clarifai::api::ModuleVersion* InstalledModuleVersion::release_module_version() {
  
  ::clarifai::api::ModuleVersion* temp = _impl_.module_version_;
  _impl_.module_version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::ModuleVersion* InstalledModuleVersion::unsafe_arena_release_module_version() {
  // @@protoc_insertion_point(field_release:clarifai.api.InstalledModuleVersion.module_version)
  
  ::clarifai::api::ModuleVersion* temp = _impl_.module_version_;
  _impl_.module_version_ = nullptr;
  return temp;
}
inline ::clarifai::api::ModuleVersion* InstalledModuleVersion::_internal_mutable_module_version() {
  
  if (_impl_.module_version_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::ModuleVersion>(GetArenaForAllocation());
    _impl_.module_version_ = p;
  }
  return _impl_.module_version_;
}
inline ::clarifai::api::ModuleVersion* InstalledModuleVersion::mutable_module_version() {
  ::clarifai::api::ModuleVersion* _msg = _internal_mutable_module_version();
  // @@protoc_insertion_point(field_mutable:clarifai.api.InstalledModuleVersion.module_version)
  return _msg;
}
inline void InstalledModuleVersion::set_allocated_module_version(::clarifai::api::ModuleVersion* module_version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.module_version_;
  }
  if (module_version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(module_version);
    if (message_arena != submessage_arena) {
      module_version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, module_version, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.module_version_ = module_version;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.InstalledModuleVersion.module_version)
}

// string app_id = 3;
inline void InstalledModuleVersion::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& InstalledModuleVersion::app_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InstalledModuleVersion.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstalledModuleVersion::set_app_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.app_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.InstalledModuleVersion.app_id)
}
inline std::string* InstalledModuleVersion::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.InstalledModuleVersion.app_id)
  return _s;
}
inline const std::string& InstalledModuleVersion::_internal_app_id() const {
  return _impl_.app_id_.Get();
}
inline void InstalledModuleVersion::_internal_set_app_id(const std::string& value) {
  
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* InstalledModuleVersion::_internal_mutable_app_id() {
  
  return _impl_.app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* InstalledModuleVersion::release_app_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.InstalledModuleVersion.app_id)
  return _impl_.app_id_.Release();
}
inline void InstalledModuleVersion::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    
  } else {
    
  }
  _impl_.app_id_.SetAllocated(app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.InstalledModuleVersion.app_id)
}

// string user_id = 4;
inline void InstalledModuleVersion::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& InstalledModuleVersion::user_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InstalledModuleVersion.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstalledModuleVersion::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.InstalledModuleVersion.user_id)
}
inline std::string* InstalledModuleVersion::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.InstalledModuleVersion.user_id)
  return _s;
}
inline const std::string& InstalledModuleVersion::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void InstalledModuleVersion::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* InstalledModuleVersion::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* InstalledModuleVersion::release_user_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.InstalledModuleVersion.user_id)
  return _impl_.user_id_.Release();
}
inline void InstalledModuleVersion::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.InstalledModuleVersion.user_id)
}

// .google.protobuf.Timestamp created_at = 5;
inline bool InstalledModuleVersion::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool InstalledModuleVersion::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& InstalledModuleVersion::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& InstalledModuleVersion::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InstalledModuleVersion.created_at)
  return _internal_created_at();
}
inline void InstalledModuleVersion::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.InstalledModuleVersion.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InstalledModuleVersion::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InstalledModuleVersion::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.InstalledModuleVersion.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InstalledModuleVersion::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InstalledModuleVersion::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.InstalledModuleVersion.created_at)
  return _msg;
}
inline void InstalledModuleVersion::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.InstalledModuleVersion.created_at)
}

// .google.protobuf.Timestamp modified_at = 6;
inline bool InstalledModuleVersion::_internal_has_modified_at() const {
  return this != internal_default_instance() && _impl_.modified_at_ != nullptr;
}
inline bool InstalledModuleVersion::has_modified_at() const {
  return _internal_has_modified_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& InstalledModuleVersion::_internal_modified_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.modified_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& InstalledModuleVersion::modified_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InstalledModuleVersion.modified_at)
  return _internal_modified_at();
}
inline void InstalledModuleVersion::unsafe_arena_set_allocated_modified_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  _impl_.modified_at_ = modified_at;
  if (modified_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.InstalledModuleVersion.modified_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InstalledModuleVersion::release_modified_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InstalledModuleVersion::unsafe_arena_release_modified_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.InstalledModuleVersion.modified_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InstalledModuleVersion::_internal_mutable_modified_at() {
  
  if (_impl_.modified_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.modified_at_ = p;
  }
  return _impl_.modified_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InstalledModuleVersion::mutable_modified_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_modified_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.InstalledModuleVersion.modified_at)
  return _msg;
}
inline void InstalledModuleVersion::set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  if (modified_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(modified_at));
    if (message_arena != submessage_arena) {
      modified_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modified_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.modified_at_ = modified_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.InstalledModuleVersion.modified_at)
}

// string deploy_url = 7;
inline void InstalledModuleVersion::clear_deploy_url() {
  _impl_.deploy_url_.ClearToEmpty();
}
inline const std::string& InstalledModuleVersion::deploy_url() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InstalledModuleVersion.deploy_url)
  return _internal_deploy_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstalledModuleVersion::set_deploy_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.deploy_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.InstalledModuleVersion.deploy_url)
}
inline std::string* InstalledModuleVersion::mutable_deploy_url() {
  std::string* _s = _internal_mutable_deploy_url();
  // @@protoc_insertion_point(field_mutable:clarifai.api.InstalledModuleVersion.deploy_url)
  return _s;
}
inline const std::string& InstalledModuleVersion::_internal_deploy_url() const {
  return _impl_.deploy_url_.Get();
}
inline void InstalledModuleVersion::_internal_set_deploy_url(const std::string& value) {
  
  _impl_.deploy_url_.Set(value, GetArenaForAllocation());
}
inline std::string* InstalledModuleVersion::_internal_mutable_deploy_url() {
  
  return _impl_.deploy_url_.Mutable(GetArenaForAllocation());
}
inline std::string* InstalledModuleVersion::release_deploy_url() {
  // @@protoc_insertion_point(field_release:clarifai.api.InstalledModuleVersion.deploy_url)
  return _impl_.deploy_url_.Release();
}
inline void InstalledModuleVersion::set_allocated_deploy_url(std::string* deploy_url) {
  if (deploy_url != nullptr) {
    
  } else {
    
  }
  _impl_.deploy_url_.SetAllocated(deploy_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deploy_url_.IsDefault()) {
    _impl_.deploy_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.InstalledModuleVersion.deploy_url)
}

// .clarifai.api.Visibility visibility = 8;
inline bool InstalledModuleVersion::_internal_has_visibility() const {
  return this != internal_default_instance() && _impl_.visibility_ != nullptr;
}
inline bool InstalledModuleVersion::has_visibility() const {
  return _internal_has_visibility();
}
inline void InstalledModuleVersion::clear_visibility() {
  if (GetArenaForAllocation() == nullptr && _impl_.visibility_ != nullptr) {
    delete _impl_.visibility_;
  }
  _impl_.visibility_ = nullptr;
}
inline const ::clarifai::api::Visibility& InstalledModuleVersion::_internal_visibility() const {
  const ::clarifai::api::Visibility* p = _impl_.visibility_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Visibility&>(
      ::clarifai::api::_Visibility_default_instance_);
}
inline const ::clarifai::api::Visibility& InstalledModuleVersion::visibility() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InstalledModuleVersion.visibility)
  return _internal_visibility();
}
inline void InstalledModuleVersion::unsafe_arena_set_allocated_visibility(
    ::clarifai::api::Visibility* visibility) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visibility_);
  }
  _impl_.visibility_ = visibility;
  if (visibility) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.InstalledModuleVersion.visibility)
}
inline ::clarifai::api::Visibility* InstalledModuleVersion::release_visibility() {
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Visibility* InstalledModuleVersion::unsafe_arena_release_visibility() {
  // @@protoc_insertion_point(field_release:clarifai.api.InstalledModuleVersion.visibility)
  
  ::clarifai::api::Visibility* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
  return temp;
}
inline ::clarifai::api::Visibility* InstalledModuleVersion::_internal_mutable_visibility() {
  
  if (_impl_.visibility_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Visibility>(GetArenaForAllocation());
    _impl_.visibility_ = p;
  }
  return _impl_.visibility_;
}
inline ::clarifai::api::Visibility* InstalledModuleVersion::mutable_visibility() {
  ::clarifai::api::Visibility* _msg = _internal_mutable_visibility();
  // @@protoc_insertion_point(field_mutable:clarifai.api.InstalledModuleVersion.visibility)
  return _msg;
}
inline void InstalledModuleVersion::set_allocated_visibility(::clarifai::api::Visibility* visibility) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.visibility_;
  }
  if (visibility) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(visibility);
    if (message_arena != submessage_arena) {
      visibility = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visibility, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.visibility_ = visibility;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.InstalledModuleVersion.visibility)
}

// string key_id = 9;
inline void InstalledModuleVersion::clear_key_id() {
  _impl_.key_id_.ClearToEmpty();
}
inline const std::string& InstalledModuleVersion::key_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InstalledModuleVersion.key_id)
  return _internal_key_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstalledModuleVersion::set_key_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.InstalledModuleVersion.key_id)
}
inline std::string* InstalledModuleVersion::mutable_key_id() {
  std::string* _s = _internal_mutable_key_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.InstalledModuleVersion.key_id)
  return _s;
}
inline const std::string& InstalledModuleVersion::_internal_key_id() const {
  return _impl_.key_id_.Get();
}
inline void InstalledModuleVersion::_internal_set_key_id(const std::string& value) {
  
  _impl_.key_id_.Set(value, GetArenaForAllocation());
}
inline std::string* InstalledModuleVersion::_internal_mutable_key_id() {
  
  return _impl_.key_id_.Mutable(GetArenaForAllocation());
}
inline std::string* InstalledModuleVersion::release_key_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.InstalledModuleVersion.key_id)
  return _impl_.key_id_.Release();
}
inline void InstalledModuleVersion::set_allocated_key_id(std::string* key_id) {
  if (key_id != nullptr) {
    
  } else {
    
  }
  _impl_.key_id_.SetAllocated(key_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_id_.IsDefault()) {
    _impl_.key_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.InstalledModuleVersion.key_id)
}

// -------------------------------------------------------------------

// BulkOperation

// string id = 1;
inline void BulkOperation::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& BulkOperation::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.BulkOperation.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BulkOperation::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.BulkOperation.id)
}
inline std::string* BulkOperation::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.BulkOperation.id)
  return _s;
}
inline const std::string& BulkOperation::_internal_id() const {
  return _impl_.id_.Get();
}
inline void BulkOperation::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* BulkOperation::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* BulkOperation::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.BulkOperation.id)
  return _impl_.id_.Release();
}
inline void BulkOperation::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.BulkOperation.id)
}

// .clarifai.api.InputIDs input_ids = 2;
inline bool BulkOperation::_internal_has_input_ids() const {
  return input_source_case() == kInputIds;
}
inline bool BulkOperation::has_input_ids() const {
  return _internal_has_input_ids();
}
inline void BulkOperation::set_has_input_ids() {
  _impl_._oneof_case_[0] = kInputIds;
}
inline void BulkOperation::clear_input_ids() {
  if (_internal_has_input_ids()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.input_source_.input_ids_;
    }
    clear_has_input_source();
  }
}
inline ::clarifai::api::InputIDs* BulkOperation::release_input_ids() {
  // @@protoc_insertion_point(field_release:clarifai.api.BulkOperation.input_ids)
  if (_internal_has_input_ids()) {
    clear_has_input_source();
    ::clarifai::api::InputIDs* temp = _impl_.input_source_.input_ids_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.input_source_.input_ids_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clarifai::api::InputIDs& BulkOperation::_internal_input_ids() const {
  return _internal_has_input_ids()
      ? *_impl_.input_source_.input_ids_
      : reinterpret_cast< ::clarifai::api::InputIDs&>(::clarifai::api::_InputIDs_default_instance_);
}
inline const ::clarifai::api::InputIDs& BulkOperation::input_ids() const {
  // @@protoc_insertion_point(field_get:clarifai.api.BulkOperation.input_ids)
  return _internal_input_ids();
}
inline ::clarifai::api::InputIDs* BulkOperation::unsafe_arena_release_input_ids() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clarifai.api.BulkOperation.input_ids)
  if (_internal_has_input_ids()) {
    clear_has_input_source();
    ::clarifai::api::InputIDs* temp = _impl_.input_source_.input_ids_;
    _impl_.input_source_.input_ids_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BulkOperation::unsafe_arena_set_allocated_input_ids(::clarifai::api::InputIDs* input_ids) {
  clear_input_source();
  if (input_ids) {
    set_has_input_ids();
    _impl_.input_source_.input_ids_ = input_ids;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.BulkOperation.input_ids)
}
inline ::clarifai::api::InputIDs* BulkOperation::_internal_mutable_input_ids() {
  if (!_internal_has_input_ids()) {
    clear_input_source();
    set_has_input_ids();
    _impl_.input_source_.input_ids_ = CreateMaybeMessage< ::clarifai::api::InputIDs >(GetArenaForAllocation());
  }
  return _impl_.input_source_.input_ids_;
}
inline ::clarifai::api::InputIDs* BulkOperation::mutable_input_ids() {
  ::clarifai::api::InputIDs* _msg = _internal_mutable_input_ids();
  // @@protoc_insertion_point(field_mutable:clarifai.api.BulkOperation.input_ids)
  return _msg;
}

// .clarifai.api.Search search = 10;
inline bool BulkOperation::_internal_has_search() const {
  return input_source_case() == kSearch;
}
inline bool BulkOperation::has_search() const {
  return _internal_has_search();
}
inline void BulkOperation::set_has_search() {
  _impl_._oneof_case_[0] = kSearch;
}
inline void BulkOperation::clear_search() {
  if (_internal_has_search()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.input_source_.search_;
    }
    clear_has_input_source();
  }
}
inline ::clarifai::api::Search* BulkOperation::release_search() {
  // @@protoc_insertion_point(field_release:clarifai.api.BulkOperation.search)
  if (_internal_has_search()) {
    clear_has_input_source();
    ::clarifai::api::Search* temp = _impl_.input_source_.search_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.input_source_.search_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clarifai::api::Search& BulkOperation::_internal_search() const {
  return _internal_has_search()
      ? *_impl_.input_source_.search_
      : reinterpret_cast< ::clarifai::api::Search&>(::clarifai::api::_Search_default_instance_);
}
inline const ::clarifai::api::Search& BulkOperation::search() const {
  // @@protoc_insertion_point(field_get:clarifai.api.BulkOperation.search)
  return _internal_search();
}
inline ::clarifai::api::Search* BulkOperation::unsafe_arena_release_search() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clarifai.api.BulkOperation.search)
  if (_internal_has_search()) {
    clear_has_input_source();
    ::clarifai::api::Search* temp = _impl_.input_source_.search_;
    _impl_.input_source_.search_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BulkOperation::unsafe_arena_set_allocated_search(::clarifai::api::Search* search) {
  clear_input_source();
  if (search) {
    set_has_search();
    _impl_.input_source_.search_ = search;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.BulkOperation.search)
}
inline ::clarifai::api::Search* BulkOperation::_internal_mutable_search() {
  if (!_internal_has_search()) {
    clear_input_source();
    set_has_search();
    _impl_.input_source_.search_ = CreateMaybeMessage< ::clarifai::api::Search >(GetArenaForAllocation());
  }
  return _impl_.input_source_.search_;
}
inline ::clarifai::api::Search* BulkOperation::mutable_search() {
  ::clarifai::api::Search* _msg = _internal_mutable_search();
  // @@protoc_insertion_point(field_mutable:clarifai.api.BulkOperation.search)
  return _msg;
}

// .clarifai.api.Operation operation = 3;
inline bool BulkOperation::_internal_has_operation() const {
  return this != internal_default_instance() && _impl_.operation_ != nullptr;
}
inline bool BulkOperation::has_operation() const {
  return _internal_has_operation();
}
inline void BulkOperation::clear_operation() {
  if (GetArenaForAllocation() == nullptr && _impl_.operation_ != nullptr) {
    delete _impl_.operation_;
  }
  _impl_.operation_ = nullptr;
}
inline const ::clarifai::api::Operation& BulkOperation::_internal_operation() const {
  const ::clarifai::api::Operation* p = _impl_.operation_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Operation&>(
      ::clarifai::api::_Operation_default_instance_);
}
inline const ::clarifai::api::Operation& BulkOperation::operation() const {
  // @@protoc_insertion_point(field_get:clarifai.api.BulkOperation.operation)
  return _internal_operation();
}
inline void BulkOperation::unsafe_arena_set_allocated_operation(
    ::clarifai::api::Operation* operation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.operation_);
  }
  _impl_.operation_ = operation;
  if (operation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.BulkOperation.operation)
}
inline ::clarifai::api::Operation* BulkOperation::release_operation() {
  
  ::clarifai::api::Operation* temp = _impl_.operation_;
  _impl_.operation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Operation* BulkOperation::unsafe_arena_release_operation() {
  // @@protoc_insertion_point(field_release:clarifai.api.BulkOperation.operation)
  
  ::clarifai::api::Operation* temp = _impl_.operation_;
  _impl_.operation_ = nullptr;
  return temp;
}
inline ::clarifai::api::Operation* BulkOperation::_internal_mutable_operation() {
  
  if (_impl_.operation_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Operation>(GetArenaForAllocation());
    _impl_.operation_ = p;
  }
  return _impl_.operation_;
}
inline ::clarifai::api::Operation* BulkOperation::mutable_operation() {
  ::clarifai::api::Operation* _msg = _internal_mutable_operation();
  // @@protoc_insertion_point(field_mutable:clarifai.api.BulkOperation.operation)
  return _msg;
}
inline void BulkOperation::set_allocated_operation(::clarifai::api::Operation* operation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.operation_;
  }
  if (operation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(operation);
    if (message_arena != submessage_arena) {
      operation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, operation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.operation_ = operation;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.BulkOperation.operation)
}

// string app_id = 4;
inline void BulkOperation::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& BulkOperation::app_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.BulkOperation.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BulkOperation::set_app_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.app_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.BulkOperation.app_id)
}
inline std::string* BulkOperation::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.BulkOperation.app_id)
  return _s;
}
inline const std::string& BulkOperation::_internal_app_id() const {
  return _impl_.app_id_.Get();
}
inline void BulkOperation::_internal_set_app_id(const std::string& value) {
  
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BulkOperation::_internal_mutable_app_id() {
  
  return _impl_.app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BulkOperation::release_app_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.BulkOperation.app_id)
  return _impl_.app_id_.Release();
}
inline void BulkOperation::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    
  } else {
    
  }
  _impl_.app_id_.SetAllocated(app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.BulkOperation.app_id)
}

// .clarifai.api.status.Status status = 5;
inline bool BulkOperation::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool BulkOperation::has_status() const {
  return _internal_has_status();
}
inline const ::clarifai::api::status::Status& BulkOperation::_internal_status() const {
  const ::clarifai::api::status::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::status::Status&>(
      ::clarifai::api::status::_Status_default_instance_);
}
inline const ::clarifai::api::status::Status& BulkOperation::status() const {
  // @@protoc_insertion_point(field_get:clarifai.api.BulkOperation.status)
  return _internal_status();
}
inline void BulkOperation::unsafe_arena_set_allocated_status(
    ::clarifai::api::status::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.BulkOperation.status)
}
inline ::clarifai::api::status::Status* BulkOperation::release_status() {
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::status::Status* BulkOperation::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:clarifai.api.BulkOperation.status)
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::clarifai::api::status::Status* BulkOperation::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::status::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::clarifai::api::status::Status* BulkOperation::mutable_status() {
  ::clarifai::api::status::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:clarifai.api.BulkOperation.status)
  return _msg;
}
inline void BulkOperation::set_allocated_status(::clarifai::api::status::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.BulkOperation.status)
}

// .clarifai.api.Progress progress = 6;
inline bool BulkOperation::_internal_has_progress() const {
  return this != internal_default_instance() && _impl_.progress_ != nullptr;
}
inline bool BulkOperation::has_progress() const {
  return _internal_has_progress();
}
inline void BulkOperation::clear_progress() {
  if (GetArenaForAllocation() == nullptr && _impl_.progress_ != nullptr) {
    delete _impl_.progress_;
  }
  _impl_.progress_ = nullptr;
}
inline const ::clarifai::api::Progress& BulkOperation::_internal_progress() const {
  const ::clarifai::api::Progress* p = _impl_.progress_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Progress&>(
      ::clarifai::api::_Progress_default_instance_);
}
inline const ::clarifai::api::Progress& BulkOperation::progress() const {
  // @@protoc_insertion_point(field_get:clarifai.api.BulkOperation.progress)
  return _internal_progress();
}
inline void BulkOperation::unsafe_arena_set_allocated_progress(
    ::clarifai::api::Progress* progress) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.progress_);
  }
  _impl_.progress_ = progress;
  if (progress) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.BulkOperation.progress)
}
inline ::clarifai::api::Progress* BulkOperation::release_progress() {
  
  ::clarifai::api::Progress* temp = _impl_.progress_;
  _impl_.progress_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Progress* BulkOperation::unsafe_arena_release_progress() {
  // @@protoc_insertion_point(field_release:clarifai.api.BulkOperation.progress)
  
  ::clarifai::api::Progress* temp = _impl_.progress_;
  _impl_.progress_ = nullptr;
  return temp;
}
inline ::clarifai::api::Progress* BulkOperation::_internal_mutable_progress() {
  
  if (_impl_.progress_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Progress>(GetArenaForAllocation());
    _impl_.progress_ = p;
  }
  return _impl_.progress_;
}
inline ::clarifai::api::Progress* BulkOperation::mutable_progress() {
  ::clarifai::api::Progress* _msg = _internal_mutable_progress();
  // @@protoc_insertion_point(field_mutable:clarifai.api.BulkOperation.progress)
  return _msg;
}
inline void BulkOperation::set_allocated_progress(::clarifai::api::Progress* progress) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.progress_;
  }
  if (progress) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(progress);
    if (message_arena != submessage_arena) {
      progress = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, progress, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.progress_ = progress;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.BulkOperation.progress)
}

// string created_by = 7;
inline void BulkOperation::clear_created_by() {
  _impl_.created_by_.ClearToEmpty();
}
inline const std::string& BulkOperation::created_by() const {
  // @@protoc_insertion_point(field_get:clarifai.api.BulkOperation.created_by)
  return _internal_created_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BulkOperation::set_created_by(ArgT0&& arg0, ArgT... args) {
 
 _impl_.created_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.BulkOperation.created_by)
}
inline std::string* BulkOperation::mutable_created_by() {
  std::string* _s = _internal_mutable_created_by();
  // @@protoc_insertion_point(field_mutable:clarifai.api.BulkOperation.created_by)
  return _s;
}
inline const std::string& BulkOperation::_internal_created_by() const {
  return _impl_.created_by_.Get();
}
inline void BulkOperation::_internal_set_created_by(const std::string& value) {
  
  _impl_.created_by_.Set(value, GetArenaForAllocation());
}
inline std::string* BulkOperation::_internal_mutable_created_by() {
  
  return _impl_.created_by_.Mutable(GetArenaForAllocation());
}
inline std::string* BulkOperation::release_created_by() {
  // @@protoc_insertion_point(field_release:clarifai.api.BulkOperation.created_by)
  return _impl_.created_by_.Release();
}
inline void BulkOperation::set_allocated_created_by(std::string* created_by) {
  if (created_by != nullptr) {
    
  } else {
    
  }
  _impl_.created_by_.SetAllocated(created_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.created_by_.IsDefault()) {
    _impl_.created_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.BulkOperation.created_by)
}

// .google.protobuf.Timestamp created_at = 8;
inline bool BulkOperation::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool BulkOperation::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& BulkOperation::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& BulkOperation::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.BulkOperation.created_at)
  return _internal_created_at();
}
inline void BulkOperation::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.BulkOperation.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BulkOperation::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BulkOperation::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.BulkOperation.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BulkOperation::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BulkOperation::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.BulkOperation.created_at)
  return _msg;
}
inline void BulkOperation::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.BulkOperation.created_at)
}

// .google.protobuf.Timestamp last_modified_at = 9;
inline bool BulkOperation::_internal_has_last_modified_at() const {
  return this != internal_default_instance() && _impl_.last_modified_at_ != nullptr;
}
inline bool BulkOperation::has_last_modified_at() const {
  return _internal_has_last_modified_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& BulkOperation::_internal_last_modified_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.last_modified_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& BulkOperation::last_modified_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.BulkOperation.last_modified_at)
  return _internal_last_modified_at();
}
inline void BulkOperation::unsafe_arena_set_allocated_last_modified_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_modified_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_modified_at_);
  }
  _impl_.last_modified_at_ = last_modified_at;
  if (last_modified_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.BulkOperation.last_modified_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BulkOperation::release_last_modified_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_modified_at_;
  _impl_.last_modified_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BulkOperation::unsafe_arena_release_last_modified_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.BulkOperation.last_modified_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_modified_at_;
  _impl_.last_modified_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BulkOperation::_internal_mutable_last_modified_at() {
  
  if (_impl_.last_modified_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.last_modified_at_ = p;
  }
  return _impl_.last_modified_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BulkOperation::mutable_last_modified_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_modified_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.BulkOperation.last_modified_at)
  return _msg;
}
inline void BulkOperation::set_allocated_last_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* last_modified_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_modified_at_);
  }
  if (last_modified_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_modified_at));
    if (message_arena != submessage_arena) {
      last_modified_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_modified_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_modified_at_ = last_modified_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.BulkOperation.last_modified_at)
}

inline bool BulkOperation::has_input_source() const {
  return input_source_case() != INPUT_SOURCE_NOT_SET;
}
inline void BulkOperation::clear_has_input_source() {
  _impl_._oneof_case_[0] = INPUT_SOURCE_NOT_SET;
}
inline BulkOperation::InputSourceCase BulkOperation::input_source_case() const {
  return BulkOperation::InputSourceCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// InputIDs

// repeated string input_ids = 1;
inline int InputIDs::_internal_input_ids_size() const {
  return _impl_.input_ids_.size();
}
inline int InputIDs::input_ids_size() const {
  return _internal_input_ids_size();
}
inline void InputIDs::clear_input_ids() {
  _impl_.input_ids_.Clear();
}
inline std::string* InputIDs::add_input_ids() {
  std::string* _s = _internal_add_input_ids();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.InputIDs.input_ids)
  return _s;
}
inline const std::string& InputIDs::_internal_input_ids(int index) const {
  return _impl_.input_ids_.Get(index);
}
inline const std::string& InputIDs::input_ids(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputIDs.input_ids)
  return _internal_input_ids(index);
}
inline std::string* InputIDs::mutable_input_ids(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.InputIDs.input_ids)
  return _impl_.input_ids_.Mutable(index);
}
inline void InputIDs::set_input_ids(int index, const std::string& value) {
  _impl_.input_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.InputIDs.input_ids)
}
inline void InputIDs::set_input_ids(int index, std::string&& value) {
  _impl_.input_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.InputIDs.input_ids)
}
inline void InputIDs::set_input_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.input_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.InputIDs.input_ids)
}
inline void InputIDs::set_input_ids(int index, const char* value, size_t size) {
  _impl_.input_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.InputIDs.input_ids)
}
inline std::string* InputIDs::_internal_add_input_ids() {
  return _impl_.input_ids_.Add();
}
inline void InputIDs::add_input_ids(const std::string& value) {
  _impl_.input_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.InputIDs.input_ids)
}
inline void InputIDs::add_input_ids(std::string&& value) {
  _impl_.input_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.InputIDs.input_ids)
}
inline void InputIDs::add_input_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.input_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.InputIDs.input_ids)
}
inline void InputIDs::add_input_ids(const char* value, size_t size) {
  _impl_.input_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.InputIDs.input_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
InputIDs::input_ids() const {
  // @@protoc_insertion_point(field_list:clarifai.api.InputIDs.input_ids)
  return _impl_.input_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
InputIDs::mutable_input_ids() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.InputIDs.input_ids)
  return &_impl_.input_ids_;
}

// -------------------------------------------------------------------

// Progress

// uint32 processed = 1;
inline void Progress::clear_processed() {
  _impl_.processed_ = 0u;
}
inline uint32_t Progress::_internal_processed() const {
  return _impl_.processed_;
}
inline uint32_t Progress::processed() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Progress.processed)
  return _internal_processed();
}
inline void Progress::_internal_set_processed(uint32_t value) {
  
  _impl_.processed_ = value;
}
inline void Progress::set_processed(uint32_t value) {
  _internal_set_processed(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Progress.processed)
}

// string last_processed_id = 2;
inline void Progress::clear_last_processed_id() {
  _impl_.last_processed_id_.ClearToEmpty();
}
inline const std::string& Progress::last_processed_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Progress.last_processed_id)
  return _internal_last_processed_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Progress::set_last_processed_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.last_processed_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Progress.last_processed_id)
}
inline std::string* Progress::mutable_last_processed_id() {
  std::string* _s = _internal_mutable_last_processed_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Progress.last_processed_id)
  return _s;
}
inline const std::string& Progress::_internal_last_processed_id() const {
  return _impl_.last_processed_id_.Get();
}
inline void Progress::_internal_set_last_processed_id(const std::string& value) {
  
  _impl_.last_processed_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Progress::_internal_mutable_last_processed_id() {
  
  return _impl_.last_processed_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Progress::release_last_processed_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Progress.last_processed_id)
  return _impl_.last_processed_id_.Release();
}
inline void Progress::set_allocated_last_processed_id(std::string* last_processed_id) {
  if (last_processed_id != nullptr) {
    
  } else {
    
  }
  _impl_.last_processed_id_.SetAllocated(last_processed_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.last_processed_id_.IsDefault()) {
    _impl_.last_processed_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Progress.last_processed_id)
}

// -------------------------------------------------------------------

// Operation

// .clarifai.api.AddConcepts add_concepts = 1;
inline bool Operation::_internal_has_add_concepts() const {
  return operation_case() == kAddConcepts;
}
inline bool Operation::has_add_concepts() const {
  return _internal_has_add_concepts();
}
inline void Operation::set_has_add_concepts() {
  _impl_._oneof_case_[0] = kAddConcepts;
}
inline void Operation::clear_add_concepts() {
  if (_internal_has_add_concepts()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.operation_.add_concepts_;
    }
    clear_has_operation();
  }
}
inline ::clarifai::api::AddConcepts* Operation::release_add_concepts() {
  // @@protoc_insertion_point(field_release:clarifai.api.Operation.add_concepts)
  if (_internal_has_add_concepts()) {
    clear_has_operation();
    ::clarifai::api::AddConcepts* temp = _impl_.operation_.add_concepts_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.add_concepts_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clarifai::api::AddConcepts& Operation::_internal_add_concepts() const {
  return _internal_has_add_concepts()
      ? *_impl_.operation_.add_concepts_
      : reinterpret_cast< ::clarifai::api::AddConcepts&>(::clarifai::api::_AddConcepts_default_instance_);
}
inline const ::clarifai::api::AddConcepts& Operation::add_concepts() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Operation.add_concepts)
  return _internal_add_concepts();
}
inline ::clarifai::api::AddConcepts* Operation::unsafe_arena_release_add_concepts() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clarifai.api.Operation.add_concepts)
  if (_internal_has_add_concepts()) {
    clear_has_operation();
    ::clarifai::api::AddConcepts* temp = _impl_.operation_.add_concepts_;
    _impl_.operation_.add_concepts_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Operation::unsafe_arena_set_allocated_add_concepts(::clarifai::api::AddConcepts* add_concepts) {
  clear_operation();
  if (add_concepts) {
    set_has_add_concepts();
    _impl_.operation_.add_concepts_ = add_concepts;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Operation.add_concepts)
}
inline ::clarifai::api::AddConcepts* Operation::_internal_mutable_add_concepts() {
  if (!_internal_has_add_concepts()) {
    clear_operation();
    set_has_add_concepts();
    _impl_.operation_.add_concepts_ = CreateMaybeMessage< ::clarifai::api::AddConcepts >(GetArenaForAllocation());
  }
  return _impl_.operation_.add_concepts_;
}
inline ::clarifai::api::AddConcepts* Operation::mutable_add_concepts() {
  ::clarifai::api::AddConcepts* _msg = _internal_mutable_add_concepts();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Operation.add_concepts)
  return _msg;
}

// .clarifai.api.DeleteConcepts delete_concepts = 2;
inline bool Operation::_internal_has_delete_concepts() const {
  return operation_case() == kDeleteConcepts;
}
inline bool Operation::has_delete_concepts() const {
  return _internal_has_delete_concepts();
}
inline void Operation::set_has_delete_concepts() {
  _impl_._oneof_case_[0] = kDeleteConcepts;
}
inline void Operation::clear_delete_concepts() {
  if (_internal_has_delete_concepts()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.operation_.delete_concepts_;
    }
    clear_has_operation();
  }
}
inline ::clarifai::api::DeleteConcepts* Operation::release_delete_concepts() {
  // @@protoc_insertion_point(field_release:clarifai.api.Operation.delete_concepts)
  if (_internal_has_delete_concepts()) {
    clear_has_operation();
    ::clarifai::api::DeleteConcepts* temp = _impl_.operation_.delete_concepts_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.delete_concepts_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clarifai::api::DeleteConcepts& Operation::_internal_delete_concepts() const {
  return _internal_has_delete_concepts()
      ? *_impl_.operation_.delete_concepts_
      : reinterpret_cast< ::clarifai::api::DeleteConcepts&>(::clarifai::api::_DeleteConcepts_default_instance_);
}
inline const ::clarifai::api::DeleteConcepts& Operation::delete_concepts() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Operation.delete_concepts)
  return _internal_delete_concepts();
}
inline ::clarifai::api::DeleteConcepts* Operation::unsafe_arena_release_delete_concepts() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clarifai.api.Operation.delete_concepts)
  if (_internal_has_delete_concepts()) {
    clear_has_operation();
    ::clarifai::api::DeleteConcepts* temp = _impl_.operation_.delete_concepts_;
    _impl_.operation_.delete_concepts_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Operation::unsafe_arena_set_allocated_delete_concepts(::clarifai::api::DeleteConcepts* delete_concepts) {
  clear_operation();
  if (delete_concepts) {
    set_has_delete_concepts();
    _impl_.operation_.delete_concepts_ = delete_concepts;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Operation.delete_concepts)
}
inline ::clarifai::api::DeleteConcepts* Operation::_internal_mutable_delete_concepts() {
  if (!_internal_has_delete_concepts()) {
    clear_operation();
    set_has_delete_concepts();
    _impl_.operation_.delete_concepts_ = CreateMaybeMessage< ::clarifai::api::DeleteConcepts >(GetArenaForAllocation());
  }
  return _impl_.operation_.delete_concepts_;
}
inline ::clarifai::api::DeleteConcepts* Operation::mutable_delete_concepts() {
  ::clarifai::api::DeleteConcepts* _msg = _internal_mutable_delete_concepts();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Operation.delete_concepts)
  return _msg;
}

// .clarifai.api.AddMetadata add_metadata = 3;
inline bool Operation::_internal_has_add_metadata() const {
  return operation_case() == kAddMetadata;
}
inline bool Operation::has_add_metadata() const {
  return _internal_has_add_metadata();
}
inline void Operation::set_has_add_metadata() {
  _impl_._oneof_case_[0] = kAddMetadata;
}
inline void Operation::clear_add_metadata() {
  if (_internal_has_add_metadata()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.operation_.add_metadata_;
    }
    clear_has_operation();
  }
}
inline ::clarifai::api::AddMetadata* Operation::release_add_metadata() {
  // @@protoc_insertion_point(field_release:clarifai.api.Operation.add_metadata)
  if (_internal_has_add_metadata()) {
    clear_has_operation();
    ::clarifai::api::AddMetadata* temp = _impl_.operation_.add_metadata_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.add_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clarifai::api::AddMetadata& Operation::_internal_add_metadata() const {
  return _internal_has_add_metadata()
      ? *_impl_.operation_.add_metadata_
      : reinterpret_cast< ::clarifai::api::AddMetadata&>(::clarifai::api::_AddMetadata_default_instance_);
}
inline const ::clarifai::api::AddMetadata& Operation::add_metadata() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Operation.add_metadata)
  return _internal_add_metadata();
}
inline ::clarifai::api::AddMetadata* Operation::unsafe_arena_release_add_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clarifai.api.Operation.add_metadata)
  if (_internal_has_add_metadata()) {
    clear_has_operation();
    ::clarifai::api::AddMetadata* temp = _impl_.operation_.add_metadata_;
    _impl_.operation_.add_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Operation::unsafe_arena_set_allocated_add_metadata(::clarifai::api::AddMetadata* add_metadata) {
  clear_operation();
  if (add_metadata) {
    set_has_add_metadata();
    _impl_.operation_.add_metadata_ = add_metadata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Operation.add_metadata)
}
inline ::clarifai::api::AddMetadata* Operation::_internal_mutable_add_metadata() {
  if (!_internal_has_add_metadata()) {
    clear_operation();
    set_has_add_metadata();
    _impl_.operation_.add_metadata_ = CreateMaybeMessage< ::clarifai::api::AddMetadata >(GetArenaForAllocation());
  }
  return _impl_.operation_.add_metadata_;
}
inline ::clarifai::api::AddMetadata* Operation::mutable_add_metadata() {
  ::clarifai::api::AddMetadata* _msg = _internal_mutable_add_metadata();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Operation.add_metadata)
  return _msg;
}

// .clarifai.api.DeleteMetadata delete_metadata = 4;
inline bool Operation::_internal_has_delete_metadata() const {
  return operation_case() == kDeleteMetadata;
}
inline bool Operation::has_delete_metadata() const {
  return _internal_has_delete_metadata();
}
inline void Operation::set_has_delete_metadata() {
  _impl_._oneof_case_[0] = kDeleteMetadata;
}
inline void Operation::clear_delete_metadata() {
  if (_internal_has_delete_metadata()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.operation_.delete_metadata_;
    }
    clear_has_operation();
  }
}
inline ::clarifai::api::DeleteMetadata* Operation::release_delete_metadata() {
  // @@protoc_insertion_point(field_release:clarifai.api.Operation.delete_metadata)
  if (_internal_has_delete_metadata()) {
    clear_has_operation();
    ::clarifai::api::DeleteMetadata* temp = _impl_.operation_.delete_metadata_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.delete_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clarifai::api::DeleteMetadata& Operation::_internal_delete_metadata() const {
  return _internal_has_delete_metadata()
      ? *_impl_.operation_.delete_metadata_
      : reinterpret_cast< ::clarifai::api::DeleteMetadata&>(::clarifai::api::_DeleteMetadata_default_instance_);
}
inline const ::clarifai::api::DeleteMetadata& Operation::delete_metadata() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Operation.delete_metadata)
  return _internal_delete_metadata();
}
inline ::clarifai::api::DeleteMetadata* Operation::unsafe_arena_release_delete_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clarifai.api.Operation.delete_metadata)
  if (_internal_has_delete_metadata()) {
    clear_has_operation();
    ::clarifai::api::DeleteMetadata* temp = _impl_.operation_.delete_metadata_;
    _impl_.operation_.delete_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Operation::unsafe_arena_set_allocated_delete_metadata(::clarifai::api::DeleteMetadata* delete_metadata) {
  clear_operation();
  if (delete_metadata) {
    set_has_delete_metadata();
    _impl_.operation_.delete_metadata_ = delete_metadata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Operation.delete_metadata)
}
inline ::clarifai::api::DeleteMetadata* Operation::_internal_mutable_delete_metadata() {
  if (!_internal_has_delete_metadata()) {
    clear_operation();
    set_has_delete_metadata();
    _impl_.operation_.delete_metadata_ = CreateMaybeMessage< ::clarifai::api::DeleteMetadata >(GetArenaForAllocation());
  }
  return _impl_.operation_.delete_metadata_;
}
inline ::clarifai::api::DeleteMetadata* Operation::mutable_delete_metadata() {
  ::clarifai::api::DeleteMetadata* _msg = _internal_mutable_delete_metadata();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Operation.delete_metadata)
  return _msg;
}

// .clarifai.api.OverwriteGeo overwrite_geo = 5;
inline bool Operation::_internal_has_overwrite_geo() const {
  return operation_case() == kOverwriteGeo;
}
inline bool Operation::has_overwrite_geo() const {
  return _internal_has_overwrite_geo();
}
inline void Operation::set_has_overwrite_geo() {
  _impl_._oneof_case_[0] = kOverwriteGeo;
}
inline void Operation::clear_overwrite_geo() {
  if (_internal_has_overwrite_geo()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.operation_.overwrite_geo_;
    }
    clear_has_operation();
  }
}
inline ::clarifai::api::OverwriteGeo* Operation::release_overwrite_geo() {
  // @@protoc_insertion_point(field_release:clarifai.api.Operation.overwrite_geo)
  if (_internal_has_overwrite_geo()) {
    clear_has_operation();
    ::clarifai::api::OverwriteGeo* temp = _impl_.operation_.overwrite_geo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.overwrite_geo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clarifai::api::OverwriteGeo& Operation::_internal_overwrite_geo() const {
  return _internal_has_overwrite_geo()
      ? *_impl_.operation_.overwrite_geo_
      : reinterpret_cast< ::clarifai::api::OverwriteGeo&>(::clarifai::api::_OverwriteGeo_default_instance_);
}
inline const ::clarifai::api::OverwriteGeo& Operation::overwrite_geo() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Operation.overwrite_geo)
  return _internal_overwrite_geo();
}
inline ::clarifai::api::OverwriteGeo* Operation::unsafe_arena_release_overwrite_geo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clarifai.api.Operation.overwrite_geo)
  if (_internal_has_overwrite_geo()) {
    clear_has_operation();
    ::clarifai::api::OverwriteGeo* temp = _impl_.operation_.overwrite_geo_;
    _impl_.operation_.overwrite_geo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Operation::unsafe_arena_set_allocated_overwrite_geo(::clarifai::api::OverwriteGeo* overwrite_geo) {
  clear_operation();
  if (overwrite_geo) {
    set_has_overwrite_geo();
    _impl_.operation_.overwrite_geo_ = overwrite_geo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Operation.overwrite_geo)
}
inline ::clarifai::api::OverwriteGeo* Operation::_internal_mutable_overwrite_geo() {
  if (!_internal_has_overwrite_geo()) {
    clear_operation();
    set_has_overwrite_geo();
    _impl_.operation_.overwrite_geo_ = CreateMaybeMessage< ::clarifai::api::OverwriteGeo >(GetArenaForAllocation());
  }
  return _impl_.operation_.overwrite_geo_;
}
inline ::clarifai::api::OverwriteGeo* Operation::mutable_overwrite_geo() {
  ::clarifai::api::OverwriteGeo* _msg = _internal_mutable_overwrite_geo();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Operation.overwrite_geo)
  return _msg;
}

// .clarifai.api.DeleteGeo delete_geo = 6;
inline bool Operation::_internal_has_delete_geo() const {
  return operation_case() == kDeleteGeo;
}
inline bool Operation::has_delete_geo() const {
  return _internal_has_delete_geo();
}
inline void Operation::set_has_delete_geo() {
  _impl_._oneof_case_[0] = kDeleteGeo;
}
inline void Operation::clear_delete_geo() {
  if (_internal_has_delete_geo()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.operation_.delete_geo_;
    }
    clear_has_operation();
  }
}
inline ::clarifai::api::DeleteGeo* Operation::release_delete_geo() {
  // @@protoc_insertion_point(field_release:clarifai.api.Operation.delete_geo)
  if (_internal_has_delete_geo()) {
    clear_has_operation();
    ::clarifai::api::DeleteGeo* temp = _impl_.operation_.delete_geo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.delete_geo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clarifai::api::DeleteGeo& Operation::_internal_delete_geo() const {
  return _internal_has_delete_geo()
      ? *_impl_.operation_.delete_geo_
      : reinterpret_cast< ::clarifai::api::DeleteGeo&>(::clarifai::api::_DeleteGeo_default_instance_);
}
inline const ::clarifai::api::DeleteGeo& Operation::delete_geo() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Operation.delete_geo)
  return _internal_delete_geo();
}
inline ::clarifai::api::DeleteGeo* Operation::unsafe_arena_release_delete_geo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clarifai.api.Operation.delete_geo)
  if (_internal_has_delete_geo()) {
    clear_has_operation();
    ::clarifai::api::DeleteGeo* temp = _impl_.operation_.delete_geo_;
    _impl_.operation_.delete_geo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Operation::unsafe_arena_set_allocated_delete_geo(::clarifai::api::DeleteGeo* delete_geo) {
  clear_operation();
  if (delete_geo) {
    set_has_delete_geo();
    _impl_.operation_.delete_geo_ = delete_geo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Operation.delete_geo)
}
inline ::clarifai::api::DeleteGeo* Operation::_internal_mutable_delete_geo() {
  if (!_internal_has_delete_geo()) {
    clear_operation();
    set_has_delete_geo();
    _impl_.operation_.delete_geo_ = CreateMaybeMessage< ::clarifai::api::DeleteGeo >(GetArenaForAllocation());
  }
  return _impl_.operation_.delete_geo_;
}
inline ::clarifai::api::DeleteGeo* Operation::mutable_delete_geo() {
  ::clarifai::api::DeleteGeo* _msg = _internal_mutable_delete_geo();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Operation.delete_geo)
  return _msg;
}

inline bool Operation::has_operation() const {
  return operation_case() != OPERATION_NOT_SET;
}
inline void Operation::clear_has_operation() {
  _impl_._oneof_case_[0] = OPERATION_NOT_SET;
}
inline Operation::OperationCase Operation::operation_case() const {
  return Operation::OperationCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AddConcepts

// repeated .clarifai.api.Concept concepts = 1;
inline int AddConcepts::_internal_concepts_size() const {
  return _impl_.concepts_.size();
}
inline int AddConcepts::concepts_size() const {
  return _internal_concepts_size();
}
inline void AddConcepts::clear_concepts() {
  _impl_.concepts_.Clear();
}
inline ::clarifai::api::Concept* AddConcepts::mutable_concepts(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.AddConcepts.concepts)
  return _impl_.concepts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept >*
AddConcepts::mutable_concepts() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.AddConcepts.concepts)
  return &_impl_.concepts_;
}
inline const ::clarifai::api::Concept& AddConcepts::_internal_concepts(int index) const {
  return _impl_.concepts_.Get(index);
}
inline const ::clarifai::api::Concept& AddConcepts::concepts(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.AddConcepts.concepts)
  return _internal_concepts(index);
}
inline ::clarifai::api::Concept* AddConcepts::_internal_add_concepts() {
  return _impl_.concepts_.Add();
}
inline ::clarifai::api::Concept* AddConcepts::add_concepts() {
  ::clarifai::api::Concept* _add = _internal_add_concepts();
  // @@protoc_insertion_point(field_add:clarifai.api.AddConcepts.concepts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept >&
AddConcepts::concepts() const {
  // @@protoc_insertion_point(field_list:clarifai.api.AddConcepts.concepts)
  return _impl_.concepts_;
}

// -------------------------------------------------------------------

// DeleteConcepts

// repeated .clarifai.api.Concept concepts = 1;
inline int DeleteConcepts::_internal_concepts_size() const {
  return _impl_.concepts_.size();
}
inline int DeleteConcepts::concepts_size() const {
  return _internal_concepts_size();
}
inline void DeleteConcepts::clear_concepts() {
  _impl_.concepts_.Clear();
}
inline ::clarifai::api::Concept* DeleteConcepts::mutable_concepts(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.DeleteConcepts.concepts)
  return _impl_.concepts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept >*
DeleteConcepts::mutable_concepts() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.DeleteConcepts.concepts)
  return &_impl_.concepts_;
}
inline const ::clarifai::api::Concept& DeleteConcepts::_internal_concepts(int index) const {
  return _impl_.concepts_.Get(index);
}
inline const ::clarifai::api::Concept& DeleteConcepts::concepts(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.DeleteConcepts.concepts)
  return _internal_concepts(index);
}
inline ::clarifai::api::Concept* DeleteConcepts::_internal_add_concepts() {
  return _impl_.concepts_.Add();
}
inline ::clarifai::api::Concept* DeleteConcepts::add_concepts() {
  ::clarifai::api::Concept* _add = _internal_add_concepts();
  // @@protoc_insertion_point(field_add:clarifai.api.DeleteConcepts.concepts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::Concept >&
DeleteConcepts::concepts() const {
  // @@protoc_insertion_point(field_list:clarifai.api.DeleteConcepts.concepts)
  return _impl_.concepts_;
}

// repeated string user_ids = 2;
inline int DeleteConcepts::_internal_user_ids_size() const {
  return _impl_.user_ids_.size();
}
inline int DeleteConcepts::user_ids_size() const {
  return _internal_user_ids_size();
}
inline void DeleteConcepts::clear_user_ids() {
  _impl_.user_ids_.Clear();
}
inline std::string* DeleteConcepts::add_user_ids() {
  std::string* _s = _internal_add_user_ids();
  // @@protoc_insertion_point(field_add_mutable:clarifai.api.DeleteConcepts.user_ids)
  return _s;
}
inline const std::string& DeleteConcepts::_internal_user_ids(int index) const {
  return _impl_.user_ids_.Get(index);
}
inline const std::string& DeleteConcepts::user_ids(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.DeleteConcepts.user_ids)
  return _internal_user_ids(index);
}
inline std::string* DeleteConcepts::mutable_user_ids(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.DeleteConcepts.user_ids)
  return _impl_.user_ids_.Mutable(index);
}
inline void DeleteConcepts::set_user_ids(int index, const std::string& value) {
  _impl_.user_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clarifai.api.DeleteConcepts.user_ids)
}
inline void DeleteConcepts::set_user_ids(int index, std::string&& value) {
  _impl_.user_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clarifai.api.DeleteConcepts.user_ids)
}
inline void DeleteConcepts::set_user_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.user_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clarifai.api.DeleteConcepts.user_ids)
}
inline void DeleteConcepts::set_user_ids(int index, const char* value, size_t size) {
  _impl_.user_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clarifai.api.DeleteConcepts.user_ids)
}
inline std::string* DeleteConcepts::_internal_add_user_ids() {
  return _impl_.user_ids_.Add();
}
inline void DeleteConcepts::add_user_ids(const std::string& value) {
  _impl_.user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clarifai.api.DeleteConcepts.user_ids)
}
inline void DeleteConcepts::add_user_ids(std::string&& value) {
  _impl_.user_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clarifai.api.DeleteConcepts.user_ids)
}
inline void DeleteConcepts::add_user_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clarifai.api.DeleteConcepts.user_ids)
}
inline void DeleteConcepts::add_user_ids(const char* value, size_t size) {
  _impl_.user_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clarifai.api.DeleteConcepts.user_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DeleteConcepts::user_ids() const {
  // @@protoc_insertion_point(field_list:clarifai.api.DeleteConcepts.user_ids)
  return _impl_.user_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DeleteConcepts::mutable_user_ids() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.DeleteConcepts.user_ids)
  return &_impl_.user_ids_;
}

// -------------------------------------------------------------------

// AddMetadata

// .google.protobuf.Struct metadata = 1;
inline bool AddMetadata::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool AddMetadata::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AddMetadata::_internal_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AddMetadata::metadata() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AddMetadata.metadata)
  return _internal_metadata();
}
inline void AddMetadata::unsafe_arena_set_allocated_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.AddMetadata.metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AddMetadata::release_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AddMetadata::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:clarifai.api.AddMetadata.metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AddMetadata::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AddMetadata::mutable_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:clarifai.api.AddMetadata.metadata)
  return _msg;
}
inline void AddMetadata::set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.AddMetadata.metadata)
}

// -------------------------------------------------------------------

// DeleteMetadata

// .google.protobuf.Struct metadata = 1;
inline bool DeleteMetadata::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool DeleteMetadata::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& DeleteMetadata::_internal_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& DeleteMetadata::metadata() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DeleteMetadata.metadata)
  return _internal_metadata();
}
inline void DeleteMetadata::unsafe_arena_set_allocated_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DeleteMetadata.metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* DeleteMetadata::release_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* DeleteMetadata::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:clarifai.api.DeleteMetadata.metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* DeleteMetadata::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* DeleteMetadata::mutable_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DeleteMetadata.metadata)
  return _msg;
}
inline void DeleteMetadata::set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DeleteMetadata.metadata)
}

// -------------------------------------------------------------------

// OverwriteGeo

// .clarifai.api.Geo geo = 1;
inline bool OverwriteGeo::_internal_has_geo() const {
  return this != internal_default_instance() && _impl_.geo_ != nullptr;
}
inline bool OverwriteGeo::has_geo() const {
  return _internal_has_geo();
}
inline void OverwriteGeo::clear_geo() {
  if (GetArenaForAllocation() == nullptr && _impl_.geo_ != nullptr) {
    delete _impl_.geo_;
  }
  _impl_.geo_ = nullptr;
}
inline const ::clarifai::api::Geo& OverwriteGeo::_internal_geo() const {
  const ::clarifai::api::Geo* p = _impl_.geo_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::Geo&>(
      ::clarifai::api::_Geo_default_instance_);
}
inline const ::clarifai::api::Geo& OverwriteGeo::geo() const {
  // @@protoc_insertion_point(field_get:clarifai.api.OverwriteGeo.geo)
  return _internal_geo();
}
inline void OverwriteGeo::unsafe_arena_set_allocated_geo(
    ::clarifai::api::Geo* geo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.geo_);
  }
  _impl_.geo_ = geo;
  if (geo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.OverwriteGeo.geo)
}
inline ::clarifai::api::Geo* OverwriteGeo::release_geo() {
  
  ::clarifai::api::Geo* temp = _impl_.geo_;
  _impl_.geo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::Geo* OverwriteGeo::unsafe_arena_release_geo() {
  // @@protoc_insertion_point(field_release:clarifai.api.OverwriteGeo.geo)
  
  ::clarifai::api::Geo* temp = _impl_.geo_;
  _impl_.geo_ = nullptr;
  return temp;
}
inline ::clarifai::api::Geo* OverwriteGeo::_internal_mutable_geo() {
  
  if (_impl_.geo_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::Geo>(GetArenaForAllocation());
    _impl_.geo_ = p;
  }
  return _impl_.geo_;
}
inline ::clarifai::api::Geo* OverwriteGeo::mutable_geo() {
  ::clarifai::api::Geo* _msg = _internal_mutable_geo();
  // @@protoc_insertion_point(field_mutable:clarifai.api.OverwriteGeo.geo)
  return _msg;
}
inline void OverwriteGeo::set_allocated_geo(::clarifai::api::Geo* geo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.geo_;
  }
  if (geo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(geo);
    if (message_arena != submessage_arena) {
      geo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.geo_ = geo;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.OverwriteGeo.geo)
}

// -------------------------------------------------------------------

// DeleteGeo

// -------------------------------------------------------------------

// InputsAddJob

// string id = 1;
inline void InputsAddJob::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& InputsAddJob::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputsAddJob.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InputsAddJob::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.InputsAddJob.id)
}
inline std::string* InputsAddJob::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.InputsAddJob.id)
  return _s;
}
inline const std::string& InputsAddJob::_internal_id() const {
  return _impl_.id_.Get();
}
inline void InputsAddJob::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* InputsAddJob::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* InputsAddJob::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.InputsAddJob.id)
  return _impl_.id_.Release();
}
inline void InputsAddJob::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.InputsAddJob.id)
}

// string cloud_storage_url = 2;
inline void InputsAddJob::clear_cloud_storage_url() {
  _impl_.cloud_storage_url_.ClearToEmpty();
}
inline const std::string& InputsAddJob::cloud_storage_url() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputsAddJob.cloud_storage_url)
  return _internal_cloud_storage_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InputsAddJob::set_cloud_storage_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cloud_storage_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.InputsAddJob.cloud_storage_url)
}
inline std::string* InputsAddJob::mutable_cloud_storage_url() {
  std::string* _s = _internal_mutable_cloud_storage_url();
  // @@protoc_insertion_point(field_mutable:clarifai.api.InputsAddJob.cloud_storage_url)
  return _s;
}
inline const std::string& InputsAddJob::_internal_cloud_storage_url() const {
  return _impl_.cloud_storage_url_.Get();
}
inline void InputsAddJob::_internal_set_cloud_storage_url(const std::string& value) {
  
  _impl_.cloud_storage_url_.Set(value, GetArenaForAllocation());
}
inline std::string* InputsAddJob::_internal_mutable_cloud_storage_url() {
  
  return _impl_.cloud_storage_url_.Mutable(GetArenaForAllocation());
}
inline std::string* InputsAddJob::release_cloud_storage_url() {
  // @@protoc_insertion_point(field_release:clarifai.api.InputsAddJob.cloud_storage_url)
  return _impl_.cloud_storage_url_.Release();
}
inline void InputsAddJob::set_allocated_cloud_storage_url(std::string* cloud_storage_url) {
  if (cloud_storage_url != nullptr) {
    
  } else {
    
  }
  _impl_.cloud_storage_url_.SetAllocated(cloud_storage_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cloud_storage_url_.IsDefault()) {
    _impl_.cloud_storage_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.InputsAddJob.cloud_storage_url)
}

// string call_back_url = 3;
inline void InputsAddJob::clear_call_back_url() {
  _impl_.call_back_url_.ClearToEmpty();
}
inline const std::string& InputsAddJob::call_back_url() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputsAddJob.call_back_url)
  return _internal_call_back_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InputsAddJob::set_call_back_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.call_back_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.InputsAddJob.call_back_url)
}
inline std::string* InputsAddJob::mutable_call_back_url() {
  std::string* _s = _internal_mutable_call_back_url();
  // @@protoc_insertion_point(field_mutable:clarifai.api.InputsAddJob.call_back_url)
  return _s;
}
inline const std::string& InputsAddJob::_internal_call_back_url() const {
  return _impl_.call_back_url_.Get();
}
inline void InputsAddJob::_internal_set_call_back_url(const std::string& value) {
  
  _impl_.call_back_url_.Set(value, GetArenaForAllocation());
}
inline std::string* InputsAddJob::_internal_mutable_call_back_url() {
  
  return _impl_.call_back_url_.Mutable(GetArenaForAllocation());
}
inline std::string* InputsAddJob::release_call_back_url() {
  // @@protoc_insertion_point(field_release:clarifai.api.InputsAddJob.call_back_url)
  return _impl_.call_back_url_.Release();
}
inline void InputsAddJob::set_allocated_call_back_url(std::string* call_back_url) {
  if (call_back_url != nullptr) {
    
  } else {
    
  }
  _impl_.call_back_url_.SetAllocated(call_back_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.call_back_url_.IsDefault()) {
    _impl_.call_back_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.InputsAddJob.call_back_url)
}

// string app_pat = 4;
inline void InputsAddJob::clear_app_pat() {
  _impl_.app_pat_.ClearToEmpty();
}
inline const std::string& InputsAddJob::app_pat() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputsAddJob.app_pat)
  return _internal_app_pat();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InputsAddJob::set_app_pat(ArgT0&& arg0, ArgT... args) {
 
 _impl_.app_pat_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.InputsAddJob.app_pat)
}
inline std::string* InputsAddJob::mutable_app_pat() {
  std::string* _s = _internal_mutable_app_pat();
  // @@protoc_insertion_point(field_mutable:clarifai.api.InputsAddJob.app_pat)
  return _s;
}
inline const std::string& InputsAddJob::_internal_app_pat() const {
  return _impl_.app_pat_.Get();
}
inline void InputsAddJob::_internal_set_app_pat(const std::string& value) {
  
  _impl_.app_pat_.Set(value, GetArenaForAllocation());
}
inline std::string* InputsAddJob::_internal_mutable_app_pat() {
  
  return _impl_.app_pat_.Mutable(GetArenaForAllocation());
}
inline std::string* InputsAddJob::release_app_pat() {
  // @@protoc_insertion_point(field_release:clarifai.api.InputsAddJob.app_pat)
  return _impl_.app_pat_.Release();
}
inline void InputsAddJob::set_allocated_app_pat(std::string* app_pat) {
  if (app_pat != nullptr) {
    
  } else {
    
  }
  _impl_.app_pat_.SetAllocated(app_pat, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_pat_.IsDefault()) {
    _impl_.app_pat_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.InputsAddJob.app_pat)
}

// .clarifai.api.InputsAddJobProgress progress = 7;
inline bool InputsAddJob::_internal_has_progress() const {
  return this != internal_default_instance() && _impl_.progress_ != nullptr;
}
inline bool InputsAddJob::has_progress() const {
  return _internal_has_progress();
}
inline void InputsAddJob::clear_progress() {
  if (GetArenaForAllocation() == nullptr && _impl_.progress_ != nullptr) {
    delete _impl_.progress_;
  }
  _impl_.progress_ = nullptr;
}
inline const ::clarifai::api::InputsAddJobProgress& InputsAddJob::_internal_progress() const {
  const ::clarifai::api::InputsAddJobProgress* p = _impl_.progress_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::InputsAddJobProgress&>(
      ::clarifai::api::_InputsAddJobProgress_default_instance_);
}
inline const ::clarifai::api::InputsAddJobProgress& InputsAddJob::progress() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputsAddJob.progress)
  return _internal_progress();
}
inline void InputsAddJob::unsafe_arena_set_allocated_progress(
    ::clarifai::api::InputsAddJobProgress* progress) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.progress_);
  }
  _impl_.progress_ = progress;
  if (progress) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.InputsAddJob.progress)
}
inline ::clarifai::api::InputsAddJobProgress* InputsAddJob::release_progress() {
  
  ::clarifai::api::InputsAddJobProgress* temp = _impl_.progress_;
  _impl_.progress_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::InputsAddJobProgress* InputsAddJob::unsafe_arena_release_progress() {
  // @@protoc_insertion_point(field_release:clarifai.api.InputsAddJob.progress)
  
  ::clarifai::api::InputsAddJobProgress* temp = _impl_.progress_;
  _impl_.progress_ = nullptr;
  return temp;
}
inline ::clarifai::api::InputsAddJobProgress* InputsAddJob::_internal_mutable_progress() {
  
  if (_impl_.progress_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::InputsAddJobProgress>(GetArenaForAllocation());
    _impl_.progress_ = p;
  }
  return _impl_.progress_;
}
inline ::clarifai::api::InputsAddJobProgress* InputsAddJob::mutable_progress() {
  ::clarifai::api::InputsAddJobProgress* _msg = _internal_mutable_progress();
  // @@protoc_insertion_point(field_mutable:clarifai.api.InputsAddJob.progress)
  return _msg;
}
inline void InputsAddJob::set_allocated_progress(::clarifai::api::InputsAddJobProgress* progress) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.progress_;
  }
  if (progress) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(progress);
    if (message_arena != submessage_arena) {
      progress = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, progress, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.progress_ = progress;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.InputsAddJob.progress)
}

// .google.protobuf.Timestamp created_at = 8;
inline bool InputsAddJob::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool InputsAddJob::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& InputsAddJob::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& InputsAddJob::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputsAddJob.created_at)
  return _internal_created_at();
}
inline void InputsAddJob::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.InputsAddJob.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InputsAddJob::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InputsAddJob::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.InputsAddJob.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InputsAddJob::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InputsAddJob::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.InputsAddJob.created_at)
  return _msg;
}
inline void InputsAddJob::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.InputsAddJob.created_at)
}

// .google.protobuf.Timestamp modified_at = 9;
inline bool InputsAddJob::_internal_has_modified_at() const {
  return this != internal_default_instance() && _impl_.modified_at_ != nullptr;
}
inline bool InputsAddJob::has_modified_at() const {
  return _internal_has_modified_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& InputsAddJob::_internal_modified_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.modified_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& InputsAddJob::modified_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputsAddJob.modified_at)
  return _internal_modified_at();
}
inline void InputsAddJob::unsafe_arena_set_allocated_modified_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  _impl_.modified_at_ = modified_at;
  if (modified_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.InputsAddJob.modified_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InputsAddJob::release_modified_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InputsAddJob::unsafe_arena_release_modified_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.InputsAddJob.modified_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InputsAddJob::_internal_mutable_modified_at() {
  
  if (_impl_.modified_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.modified_at_ = p;
  }
  return _impl_.modified_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InputsAddJob::mutable_modified_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_modified_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.InputsAddJob.modified_at)
  return _msg;
}
inline void InputsAddJob::set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  if (modified_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(modified_at));
    if (message_arena != submessage_arena) {
      modified_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modified_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.modified_at_ = modified_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.InputsAddJob.modified_at)
}

// repeated .clarifai.api.InputsExtractionJob extraction_jobs = 10;
inline int InputsAddJob::_internal_extraction_jobs_size() const {
  return _impl_.extraction_jobs_.size();
}
inline int InputsAddJob::extraction_jobs_size() const {
  return _internal_extraction_jobs_size();
}
inline void InputsAddJob::clear_extraction_jobs() {
  _impl_.extraction_jobs_.Clear();
}
inline ::clarifai::api::InputsExtractionJob* InputsAddJob::mutable_extraction_jobs(int index) {
  // @@protoc_insertion_point(field_mutable:clarifai.api.InputsAddJob.extraction_jobs)
  return _impl_.extraction_jobs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::InputsExtractionJob >*
InputsAddJob::mutable_extraction_jobs() {
  // @@protoc_insertion_point(field_mutable_list:clarifai.api.InputsAddJob.extraction_jobs)
  return &_impl_.extraction_jobs_;
}
inline const ::clarifai::api::InputsExtractionJob& InputsAddJob::_internal_extraction_jobs(int index) const {
  return _impl_.extraction_jobs_.Get(index);
}
inline const ::clarifai::api::InputsExtractionJob& InputsAddJob::extraction_jobs(int index) const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputsAddJob.extraction_jobs)
  return _internal_extraction_jobs(index);
}
inline ::clarifai::api::InputsExtractionJob* InputsAddJob::_internal_add_extraction_jobs() {
  return _impl_.extraction_jobs_.Add();
}
inline ::clarifai::api::InputsExtractionJob* InputsAddJob::add_extraction_jobs() {
  ::clarifai::api::InputsExtractionJob* _add = _internal_add_extraction_jobs();
  // @@protoc_insertion_point(field_add:clarifai.api.InputsAddJob.extraction_jobs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clarifai::api::InputsExtractionJob >&
InputsAddJob::extraction_jobs() const {
  // @@protoc_insertion_point(field_list:clarifai.api.InputsAddJob.extraction_jobs)
  return _impl_.extraction_jobs_;
}

// -------------------------------------------------------------------

// InputsAddJobProgress

// uint64 pending_count = 1;
inline void InputsAddJobProgress::clear_pending_count() {
  _impl_.pending_count_ = uint64_t{0u};
}
inline uint64_t InputsAddJobProgress::_internal_pending_count() const {
  return _impl_.pending_count_;
}
inline uint64_t InputsAddJobProgress::pending_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputsAddJobProgress.pending_count)
  return _internal_pending_count();
}
inline void InputsAddJobProgress::_internal_set_pending_count(uint64_t value) {
  
  _impl_.pending_count_ = value;
}
inline void InputsAddJobProgress::set_pending_count(uint64_t value) {
  _internal_set_pending_count(value);
  // @@protoc_insertion_point(field_set:clarifai.api.InputsAddJobProgress.pending_count)
}

// uint64 in_progress_count = 2;
inline void InputsAddJobProgress::clear_in_progress_count() {
  _impl_.in_progress_count_ = uint64_t{0u};
}
inline uint64_t InputsAddJobProgress::_internal_in_progress_count() const {
  return _impl_.in_progress_count_;
}
inline uint64_t InputsAddJobProgress::in_progress_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputsAddJobProgress.in_progress_count)
  return _internal_in_progress_count();
}
inline void InputsAddJobProgress::_internal_set_in_progress_count(uint64_t value) {
  
  _impl_.in_progress_count_ = value;
}
inline void InputsAddJobProgress::set_in_progress_count(uint64_t value) {
  _internal_set_in_progress_count(value);
  // @@protoc_insertion_point(field_set:clarifai.api.InputsAddJobProgress.in_progress_count)
}

// uint64 success_count = 3;
inline void InputsAddJobProgress::clear_success_count() {
  _impl_.success_count_ = uint64_t{0u};
}
inline uint64_t InputsAddJobProgress::_internal_success_count() const {
  return _impl_.success_count_;
}
inline uint64_t InputsAddJobProgress::success_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputsAddJobProgress.success_count)
  return _internal_success_count();
}
inline void InputsAddJobProgress::_internal_set_success_count(uint64_t value) {
  
  _impl_.success_count_ = value;
}
inline void InputsAddJobProgress::set_success_count(uint64_t value) {
  _internal_set_success_count(value);
  // @@protoc_insertion_point(field_set:clarifai.api.InputsAddJobProgress.success_count)
}

// uint64 failed_count = 4;
inline void InputsAddJobProgress::clear_failed_count() {
  _impl_.failed_count_ = uint64_t{0u};
}
inline uint64_t InputsAddJobProgress::_internal_failed_count() const {
  return _impl_.failed_count_;
}
inline uint64_t InputsAddJobProgress::failed_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputsAddJobProgress.failed_count)
  return _internal_failed_count();
}
inline void InputsAddJobProgress::_internal_set_failed_count(uint64_t value) {
  
  _impl_.failed_count_ = value;
}
inline void InputsAddJobProgress::set_failed_count(uint64_t value) {
  _internal_set_failed_count(value);
  // @@protoc_insertion_point(field_set:clarifai.api.InputsAddJobProgress.failed_count)
}

// -------------------------------------------------------------------

// Upload

// string id = 1;
inline void Upload::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Upload::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Upload.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Upload::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Upload.id)
}
inline std::string* Upload::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Upload.id)
  return _s;
}
inline const std::string& Upload::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Upload::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Upload::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Upload::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.Upload.id)
  return _impl_.id_.Release();
}
inline void Upload::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Upload.id)
}

// .google.protobuf.Timestamp created_at = 2;
inline bool Upload::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool Upload::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Upload::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Upload::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Upload.created_at)
  return _internal_created_at();
}
inline void Upload::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Upload.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Upload::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Upload::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.Upload.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Upload::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Upload::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Upload.created_at)
  return _msg;
}
inline void Upload::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Upload.created_at)
}

// .google.protobuf.Timestamp modified_at = 3;
inline bool Upload::_internal_has_modified_at() const {
  return this != internal_default_instance() && _impl_.modified_at_ != nullptr;
}
inline bool Upload::has_modified_at() const {
  return _internal_has_modified_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Upload::_internal_modified_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.modified_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Upload::modified_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Upload.modified_at)
  return _internal_modified_at();
}
inline void Upload::unsafe_arena_set_allocated_modified_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  _impl_.modified_at_ = modified_at;
  if (modified_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Upload.modified_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Upload::release_modified_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Upload::unsafe_arena_release_modified_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.Upload.modified_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Upload::_internal_mutable_modified_at() {
  
  if (_impl_.modified_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.modified_at_ = p;
  }
  return _impl_.modified_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Upload::mutable_modified_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_modified_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Upload.modified_at)
  return _msg;
}
inline void Upload::set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  if (modified_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(modified_at));
    if (message_arena != submessage_arena) {
      modified_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modified_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.modified_at_ = modified_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Upload.modified_at)
}

// .google.protobuf.Timestamp expires_at = 4;
inline bool Upload::_internal_has_expires_at() const {
  return this != internal_default_instance() && _impl_.expires_at_ != nullptr;
}
inline bool Upload::has_expires_at() const {
  return _internal_has_expires_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Upload::_internal_expires_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.expires_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Upload::expires_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Upload.expires_at)
  return _internal_expires_at();
}
inline void Upload::unsafe_arena_set_allocated_expires_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expires_at_);
  }
  _impl_.expires_at_ = expires_at;
  if (expires_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Upload.expires_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Upload::release_expires_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.expires_at_;
  _impl_.expires_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Upload::unsafe_arena_release_expires_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.Upload.expires_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.expires_at_;
  _impl_.expires_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Upload::_internal_mutable_expires_at() {
  
  if (_impl_.expires_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.expires_at_ = p;
  }
  return _impl_.expires_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Upload::mutable_expires_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_expires_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Upload.expires_at)
  return _msg;
}
inline void Upload::set_allocated_expires_at(::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expires_at_);
  }
  if (expires_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expires_at));
    if (message_arena != submessage_arena) {
      expires_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expires_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.expires_at_ = expires_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Upload.expires_at)
}

// .clarifai.api.status.Status status = 5;
inline bool Upload::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool Upload::has_status() const {
  return _internal_has_status();
}
inline const ::clarifai::api::status::Status& Upload::_internal_status() const {
  const ::clarifai::api::status::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::status::Status&>(
      ::clarifai::api::status::_Status_default_instance_);
}
inline const ::clarifai::api::status::Status& Upload::status() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Upload.status)
  return _internal_status();
}
inline void Upload::unsafe_arena_set_allocated_status(
    ::clarifai::api::status::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.Upload.status)
}
inline ::clarifai::api::status::Status* Upload::release_status() {
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::status::Status* Upload::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:clarifai.api.Upload.status)
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::clarifai::api::status::Status* Upload::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::status::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::clarifai::api::status::Status* Upload::mutable_status() {
  ::clarifai::api::status::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Upload.status)
  return _msg;
}
inline void Upload::set_allocated_status(::clarifai::api::status::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Upload.status)
}

// string content_name = 8;
inline void Upload::clear_content_name() {
  _impl_.content_name_.ClearToEmpty();
}
inline const std::string& Upload::content_name() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Upload.content_name)
  return _internal_content_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Upload::set_content_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Upload.content_name)
}
inline std::string* Upload::mutable_content_name() {
  std::string* _s = _internal_mutable_content_name();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Upload.content_name)
  return _s;
}
inline const std::string& Upload::_internal_content_name() const {
  return _impl_.content_name_.Get();
}
inline void Upload::_internal_set_content_name(const std::string& value) {
  
  _impl_.content_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Upload::_internal_mutable_content_name() {
  
  return _impl_.content_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Upload::release_content_name() {
  // @@protoc_insertion_point(field_release:clarifai.api.Upload.content_name)
  return _impl_.content_name_.Release();
}
inline void Upload::set_allocated_content_name(std::string* content_name) {
  if (content_name != nullptr) {
    
  } else {
    
  }
  _impl_.content_name_.SetAllocated(content_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_name_.IsDefault()) {
    _impl_.content_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Upload.content_name)
}

// uint64 content_length = 6;
inline void Upload::clear_content_length() {
  _impl_.content_length_ = uint64_t{0u};
}
inline uint64_t Upload::_internal_content_length() const {
  return _impl_.content_length_;
}
inline uint64_t Upload::content_length() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Upload.content_length)
  return _internal_content_length();
}
inline void Upload::_internal_set_content_length(uint64_t value) {
  
  _impl_.content_length_ = value;
}
inline void Upload::set_content_length(uint64_t value) {
  _internal_set_content_length(value);
  // @@protoc_insertion_point(field_set:clarifai.api.Upload.content_length)
}

// string content_url = 7;
inline void Upload::clear_content_url() {
  _impl_.content_url_.ClearToEmpty();
}
inline const std::string& Upload::content_url() const {
  // @@protoc_insertion_point(field_get:clarifai.api.Upload.content_url)
  return _internal_content_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Upload::set_content_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.Upload.content_url)
}
inline std::string* Upload::mutable_content_url() {
  std::string* _s = _internal_mutable_content_url();
  // @@protoc_insertion_point(field_mutable:clarifai.api.Upload.content_url)
  return _s;
}
inline const std::string& Upload::_internal_content_url() const {
  return _impl_.content_url_.Get();
}
inline void Upload::_internal_set_content_url(const std::string& value) {
  
  _impl_.content_url_.Set(value, GetArenaForAllocation());
}
inline std::string* Upload::_internal_mutable_content_url() {
  
  return _impl_.content_url_.Mutable(GetArenaForAllocation());
}
inline std::string* Upload::release_content_url() {
  // @@protoc_insertion_point(field_release:clarifai.api.Upload.content_url)
  return _impl_.content_url_.Release();
}
inline void Upload::set_allocated_content_url(std::string* content_url) {
  if (content_url != nullptr) {
    
  } else {
    
  }
  _impl_.content_url_.SetAllocated(content_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_url_.IsDefault()) {
    _impl_.content_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.Upload.content_url)
}

// -------------------------------------------------------------------

// UploadContentPart

// uint64 range_start = 1;
inline void UploadContentPart::clear_range_start() {
  _impl_.range_start_ = uint64_t{0u};
}
inline uint64_t UploadContentPart::_internal_range_start() const {
  return _impl_.range_start_;
}
inline uint64_t UploadContentPart::range_start() const {
  // @@protoc_insertion_point(field_get:clarifai.api.UploadContentPart.range_start)
  return _internal_range_start();
}
inline void UploadContentPart::_internal_set_range_start(uint64_t value) {
  
  _impl_.range_start_ = value;
}
inline void UploadContentPart::set_range_start(uint64_t value) {
  _internal_set_range_start(value);
  // @@protoc_insertion_point(field_set:clarifai.api.UploadContentPart.range_start)
}

// int64 part_number = 2;
inline void UploadContentPart::clear_part_number() {
  _impl_.part_number_ = int64_t{0};
}
inline int64_t UploadContentPart::_internal_part_number() const {
  return _impl_.part_number_;
}
inline int64_t UploadContentPart::part_number() const {
  // @@protoc_insertion_point(field_get:clarifai.api.UploadContentPart.part_number)
  return _internal_part_number();
}
inline void UploadContentPart::_internal_set_part_number(int64_t value) {
  
  _impl_.part_number_ = value;
}
inline void UploadContentPart::set_part_number(int64_t value) {
  _internal_set_part_number(value);
  // @@protoc_insertion_point(field_set:clarifai.api.UploadContentPart.part_number)
}

// bytes data = 3;
inline void UploadContentPart::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& UploadContentPart::data() const {
  // @@protoc_insertion_point(field_get:clarifai.api.UploadContentPart.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadContentPart::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.UploadContentPart.data)
}
inline std::string* UploadContentPart::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:clarifai.api.UploadContentPart.data)
  return _s;
}
inline const std::string& UploadContentPart::_internal_data() const {
  return _impl_.data_.Get();
}
inline void UploadContentPart::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadContentPart::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadContentPart::release_data() {
  // @@protoc_insertion_point(field_release:clarifai.api.UploadContentPart.data)
  return _impl_.data_.Release();
}
inline void UploadContentPart::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.UploadContentPart.data)
}

// -------------------------------------------------------------------

// InputsExtractionJob

// .clarifai.api.status.Status status = 1;
inline bool InputsExtractionJob::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool InputsExtractionJob::has_status() const {
  return _internal_has_status();
}
inline const ::clarifai::api::status::Status& InputsExtractionJob::_internal_status() const {
  const ::clarifai::api::status::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::status::Status&>(
      ::clarifai::api::status::_Status_default_instance_);
}
inline const ::clarifai::api::status::Status& InputsExtractionJob::status() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputsExtractionJob.status)
  return _internal_status();
}
inline void InputsExtractionJob::unsafe_arena_set_allocated_status(
    ::clarifai::api::status::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.InputsExtractionJob.status)
}
inline ::clarifai::api::status::Status* InputsExtractionJob::release_status() {
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::status::Status* InputsExtractionJob::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:clarifai.api.InputsExtractionJob.status)
  
  ::clarifai::api::status::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::clarifai::api::status::Status* InputsExtractionJob::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::status::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::clarifai::api::status::Status* InputsExtractionJob::mutable_status() {
  ::clarifai::api::status::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:clarifai.api.InputsExtractionJob.status)
  return _msg;
}
inline void InputsExtractionJob::set_allocated_status(::clarifai::api::status::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.InputsExtractionJob.status)
}

// string id = 2;
inline void InputsExtractionJob::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& InputsExtractionJob::id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputsExtractionJob.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InputsExtractionJob::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.InputsExtractionJob.id)
}
inline std::string* InputsExtractionJob::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.InputsExtractionJob.id)
  return _s;
}
inline const std::string& InputsExtractionJob::_internal_id() const {
  return _impl_.id_.Get();
}
inline void InputsExtractionJob::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* InputsExtractionJob::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* InputsExtractionJob::release_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.InputsExtractionJob.id)
  return _impl_.id_.Release();
}
inline void InputsExtractionJob::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.InputsExtractionJob.id)
}

// string url = 3;
inline void InputsExtractionJob::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& InputsExtractionJob::url() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputsExtractionJob.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InputsExtractionJob::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.InputsExtractionJob.url)
}
inline std::string* InputsExtractionJob::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:clarifai.api.InputsExtractionJob.url)
  return _s;
}
inline const std::string& InputsExtractionJob::_internal_url() const {
  return _impl_.url_.Get();
}
inline void InputsExtractionJob::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* InputsExtractionJob::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* InputsExtractionJob::release_url() {
  // @@protoc_insertion_point(field_release:clarifai.api.InputsExtractionJob.url)
  return _impl_.url_.Release();
}
inline void InputsExtractionJob::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.InputsExtractionJob.url)
}

// .clarifai.api.InputsExtractionJobProgress progress = 4;
inline bool InputsExtractionJob::_internal_has_progress() const {
  return this != internal_default_instance() && _impl_.progress_ != nullptr;
}
inline bool InputsExtractionJob::has_progress() const {
  return _internal_has_progress();
}
inline void InputsExtractionJob::clear_progress() {
  if (GetArenaForAllocation() == nullptr && _impl_.progress_ != nullptr) {
    delete _impl_.progress_;
  }
  _impl_.progress_ = nullptr;
}
inline const ::clarifai::api::InputsExtractionJobProgress& InputsExtractionJob::_internal_progress() const {
  const ::clarifai::api::InputsExtractionJobProgress* p = _impl_.progress_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::InputsExtractionJobProgress&>(
      ::clarifai::api::_InputsExtractionJobProgress_default_instance_);
}
inline const ::clarifai::api::InputsExtractionJobProgress& InputsExtractionJob::progress() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputsExtractionJob.progress)
  return _internal_progress();
}
inline void InputsExtractionJob::unsafe_arena_set_allocated_progress(
    ::clarifai::api::InputsExtractionJobProgress* progress) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.progress_);
  }
  _impl_.progress_ = progress;
  if (progress) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.InputsExtractionJob.progress)
}
inline ::clarifai::api::InputsExtractionJobProgress* InputsExtractionJob::release_progress() {
  
  ::clarifai::api::InputsExtractionJobProgress* temp = _impl_.progress_;
  _impl_.progress_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::InputsExtractionJobProgress* InputsExtractionJob::unsafe_arena_release_progress() {
  // @@protoc_insertion_point(field_release:clarifai.api.InputsExtractionJob.progress)
  
  ::clarifai::api::InputsExtractionJobProgress* temp = _impl_.progress_;
  _impl_.progress_ = nullptr;
  return temp;
}
inline ::clarifai::api::InputsExtractionJobProgress* InputsExtractionJob::_internal_mutable_progress() {
  
  if (_impl_.progress_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::InputsExtractionJobProgress>(GetArenaForAllocation());
    _impl_.progress_ = p;
  }
  return _impl_.progress_;
}
inline ::clarifai::api::InputsExtractionJobProgress* InputsExtractionJob::mutable_progress() {
  ::clarifai::api::InputsExtractionJobProgress* _msg = _internal_mutable_progress();
  // @@protoc_insertion_point(field_mutable:clarifai.api.InputsExtractionJob.progress)
  return _msg;
}
inline void InputsExtractionJob::set_allocated_progress(::clarifai::api::InputsExtractionJobProgress* progress) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.progress_;
  }
  if (progress) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(progress);
    if (message_arena != submessage_arena) {
      progress = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, progress, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.progress_ = progress;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.InputsExtractionJob.progress)
}

// .google.protobuf.Timestamp created_at = 5;
inline bool InputsExtractionJob::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool InputsExtractionJob::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& InputsExtractionJob::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& InputsExtractionJob::created_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputsExtractionJob.created_at)
  return _internal_created_at();
}
inline void InputsExtractionJob::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.InputsExtractionJob.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InputsExtractionJob::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InputsExtractionJob::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.InputsExtractionJob.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InputsExtractionJob::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InputsExtractionJob::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.InputsExtractionJob.created_at)
  return _msg;
}
inline void InputsExtractionJob::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.InputsExtractionJob.created_at)
}

// .google.protobuf.Timestamp modified_at = 6;
inline bool InputsExtractionJob::_internal_has_modified_at() const {
  return this != internal_default_instance() && _impl_.modified_at_ != nullptr;
}
inline bool InputsExtractionJob::has_modified_at() const {
  return _internal_has_modified_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& InputsExtractionJob::_internal_modified_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.modified_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& InputsExtractionJob::modified_at() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputsExtractionJob.modified_at)
  return _internal_modified_at();
}
inline void InputsExtractionJob::unsafe_arena_set_allocated_modified_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  _impl_.modified_at_ = modified_at;
  if (modified_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.InputsExtractionJob.modified_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InputsExtractionJob::release_modified_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InputsExtractionJob::unsafe_arena_release_modified_at() {
  // @@protoc_insertion_point(field_release:clarifai.api.InputsExtractionJob.modified_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.modified_at_;
  _impl_.modified_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InputsExtractionJob::_internal_mutable_modified_at() {
  
  if (_impl_.modified_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.modified_at_ = p;
  }
  return _impl_.modified_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InputsExtractionJob::mutable_modified_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_modified_at();
  // @@protoc_insertion_point(field_mutable:clarifai.api.InputsExtractionJob.modified_at)
  return _msg;
}
inline void InputsExtractionJob::set_allocated_modified_at(::PROTOBUF_NAMESPACE_ID::Timestamp* modified_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modified_at_);
  }
  if (modified_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(modified_at));
    if (message_arena != submessage_arena) {
      modified_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modified_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.modified_at_ = modified_at;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.InputsExtractionJob.modified_at)
}

// -------------------------------------------------------------------

// InputsExtractionJobProgress

// uint64 read_objects_count = 1;
inline void InputsExtractionJobProgress::clear_read_objects_count() {
  _impl_.read_objects_count_ = uint64_t{0u};
}
inline uint64_t InputsExtractionJobProgress::_internal_read_objects_count() const {
  return _impl_.read_objects_count_;
}
inline uint64_t InputsExtractionJobProgress::read_objects_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputsExtractionJobProgress.read_objects_count)
  return _internal_read_objects_count();
}
inline void InputsExtractionJobProgress::_internal_set_read_objects_count(uint64_t value) {
  
  _impl_.read_objects_count_ = value;
}
inline void InputsExtractionJobProgress::set_read_objects_count(uint64_t value) {
  _internal_set_read_objects_count(value);
  // @@protoc_insertion_point(field_set:clarifai.api.InputsExtractionJobProgress.read_objects_count)
}

// uint64 audio_inputs_count = 2;
inline void InputsExtractionJobProgress::clear_audio_inputs_count() {
  _impl_.audio_inputs_count_ = uint64_t{0u};
}
inline uint64_t InputsExtractionJobProgress::_internal_audio_inputs_count() const {
  return _impl_.audio_inputs_count_;
}
inline uint64_t InputsExtractionJobProgress::audio_inputs_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputsExtractionJobProgress.audio_inputs_count)
  return _internal_audio_inputs_count();
}
inline void InputsExtractionJobProgress::_internal_set_audio_inputs_count(uint64_t value) {
  
  _impl_.audio_inputs_count_ = value;
}
inline void InputsExtractionJobProgress::set_audio_inputs_count(uint64_t value) {
  _internal_set_audio_inputs_count(value);
  // @@protoc_insertion_point(field_set:clarifai.api.InputsExtractionJobProgress.audio_inputs_count)
}

// uint64 image_inputs_count = 3;
inline void InputsExtractionJobProgress::clear_image_inputs_count() {
  _impl_.image_inputs_count_ = uint64_t{0u};
}
inline uint64_t InputsExtractionJobProgress::_internal_image_inputs_count() const {
  return _impl_.image_inputs_count_;
}
inline uint64_t InputsExtractionJobProgress::image_inputs_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputsExtractionJobProgress.image_inputs_count)
  return _internal_image_inputs_count();
}
inline void InputsExtractionJobProgress::_internal_set_image_inputs_count(uint64_t value) {
  
  _impl_.image_inputs_count_ = value;
}
inline void InputsExtractionJobProgress::set_image_inputs_count(uint64_t value) {
  _internal_set_image_inputs_count(value);
  // @@protoc_insertion_point(field_set:clarifai.api.InputsExtractionJobProgress.image_inputs_count)
}

// uint64 video_inputs_count = 4;
inline void InputsExtractionJobProgress::clear_video_inputs_count() {
  _impl_.video_inputs_count_ = uint64_t{0u};
}
inline uint64_t InputsExtractionJobProgress::_internal_video_inputs_count() const {
  return _impl_.video_inputs_count_;
}
inline uint64_t InputsExtractionJobProgress::video_inputs_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputsExtractionJobProgress.video_inputs_count)
  return _internal_video_inputs_count();
}
inline void InputsExtractionJobProgress::_internal_set_video_inputs_count(uint64_t value) {
  
  _impl_.video_inputs_count_ = value;
}
inline void InputsExtractionJobProgress::set_video_inputs_count(uint64_t value) {
  _internal_set_video_inputs_count(value);
  // @@protoc_insertion_point(field_set:clarifai.api.InputsExtractionJobProgress.video_inputs_count)
}

// uint64 text_inputs_count = 5;
inline void InputsExtractionJobProgress::clear_text_inputs_count() {
  _impl_.text_inputs_count_ = uint64_t{0u};
}
inline uint64_t InputsExtractionJobProgress::_internal_text_inputs_count() const {
  return _impl_.text_inputs_count_;
}
inline uint64_t InputsExtractionJobProgress::text_inputs_count() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputsExtractionJobProgress.text_inputs_count)
  return _internal_text_inputs_count();
}
inline void InputsExtractionJobProgress::_internal_set_text_inputs_count(uint64_t value) {
  
  _impl_.text_inputs_count_ = value;
}
inline void InputsExtractionJobProgress::set_text_inputs_count(uint64_t value) {
  _internal_set_text_inputs_count(value);
  // @@protoc_insertion_point(field_set:clarifai.api.InputsExtractionJobProgress.text_inputs_count)
}

// -------------------------------------------------------------------

// InputsDataSource

// string inputs_add_job_id = 1;
inline void InputsDataSource::clear_inputs_add_job_id() {
  _impl_.inputs_add_job_id_.ClearToEmpty();
}
inline const std::string& InputsDataSource::inputs_add_job_id() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputsDataSource.inputs_add_job_id)
  return _internal_inputs_add_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InputsDataSource::set_inputs_add_job_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.inputs_add_job_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.InputsDataSource.inputs_add_job_id)
}
inline std::string* InputsDataSource::mutable_inputs_add_job_id() {
  std::string* _s = _internal_mutable_inputs_add_job_id();
  // @@protoc_insertion_point(field_mutable:clarifai.api.InputsDataSource.inputs_add_job_id)
  return _s;
}
inline const std::string& InputsDataSource::_internal_inputs_add_job_id() const {
  return _impl_.inputs_add_job_id_.Get();
}
inline void InputsDataSource::_internal_set_inputs_add_job_id(const std::string& value) {
  
  _impl_.inputs_add_job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* InputsDataSource::_internal_mutable_inputs_add_job_id() {
  
  return _impl_.inputs_add_job_id_.Mutable(GetArenaForAllocation());
}
inline std::string* InputsDataSource::release_inputs_add_job_id() {
  // @@protoc_insertion_point(field_release:clarifai.api.InputsDataSource.inputs_add_job_id)
  return _impl_.inputs_add_job_id_.Release();
}
inline void InputsDataSource::set_allocated_inputs_add_job_id(std::string* inputs_add_job_id) {
  if (inputs_add_job_id != nullptr) {
    
  } else {
    
  }
  _impl_.inputs_add_job_id_.SetAllocated(inputs_add_job_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.inputs_add_job_id_.IsDefault()) {
    _impl_.inputs_add_job_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.InputsDataSource.inputs_add_job_id)
}

// .clarifai.api.DataSourceURL url = 2;
inline bool InputsDataSource::_internal_has_url() const {
  return this != internal_default_instance() && _impl_.url_ != nullptr;
}
inline bool InputsDataSource::has_url() const {
  return _internal_has_url();
}
inline void InputsDataSource::clear_url() {
  if (GetArenaForAllocation() == nullptr && _impl_.url_ != nullptr) {
    delete _impl_.url_;
  }
  _impl_.url_ = nullptr;
}
inline const ::clarifai::api::DataSourceURL& InputsDataSource::_internal_url() const {
  const ::clarifai::api::DataSourceURL* p = _impl_.url_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::DataSourceURL&>(
      ::clarifai::api::_DataSourceURL_default_instance_);
}
inline const ::clarifai::api::DataSourceURL& InputsDataSource::url() const {
  // @@protoc_insertion_point(field_get:clarifai.api.InputsDataSource.url)
  return _internal_url();
}
inline void InputsDataSource::unsafe_arena_set_allocated_url(
    ::clarifai::api::DataSourceURL* url) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.url_);
  }
  _impl_.url_ = url;
  if (url) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.InputsDataSource.url)
}
inline ::clarifai::api::DataSourceURL* InputsDataSource::release_url() {
  
  ::clarifai::api::DataSourceURL* temp = _impl_.url_;
  _impl_.url_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::DataSourceURL* InputsDataSource::unsafe_arena_release_url() {
  // @@protoc_insertion_point(field_release:clarifai.api.InputsDataSource.url)
  
  ::clarifai::api::DataSourceURL* temp = _impl_.url_;
  _impl_.url_ = nullptr;
  return temp;
}
inline ::clarifai::api::DataSourceURL* InputsDataSource::_internal_mutable_url() {
  
  if (_impl_.url_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::DataSourceURL>(GetArenaForAllocation());
    _impl_.url_ = p;
  }
  return _impl_.url_;
}
inline ::clarifai::api::DataSourceURL* InputsDataSource::mutable_url() {
  ::clarifai::api::DataSourceURL* _msg = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:clarifai.api.InputsDataSource.url)
  return _msg;
}
inline void InputsDataSource::set_allocated_url(::clarifai::api::DataSourceURL* url) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.url_;
  }
  if (url) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(url);
    if (message_arena != submessage_arena) {
      url = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, url, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.url_ = url;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.InputsDataSource.url)
}

// -------------------------------------------------------------------

// DataSourceURL

// string url = 1;
inline void DataSourceURL::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& DataSourceURL::url() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DataSourceURL.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataSourceURL::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.DataSourceURL.url)
}
inline std::string* DataSourceURL::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DataSourceURL.url)
  return _s;
}
inline const std::string& DataSourceURL::_internal_url() const {
  return _impl_.url_.Get();
}
inline void DataSourceURL::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* DataSourceURL::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* DataSourceURL::release_url() {
  // @@protoc_insertion_point(field_release:clarifai.api.DataSourceURL.url)
  return _impl_.url_.Release();
}
inline void DataSourceURL::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DataSourceURL.url)
}

// .clarifai.api.DataSourceCredentials credentials = 2;
inline bool DataSourceURL::_internal_has_credentials() const {
  return this != internal_default_instance() && _impl_.credentials_ != nullptr;
}
inline bool DataSourceURL::has_credentials() const {
  return _internal_has_credentials();
}
inline void DataSourceURL::clear_credentials() {
  if (GetArenaForAllocation() == nullptr && _impl_.credentials_ != nullptr) {
    delete _impl_.credentials_;
  }
  _impl_.credentials_ = nullptr;
}
inline const ::clarifai::api::DataSourceCredentials& DataSourceURL::_internal_credentials() const {
  const ::clarifai::api::DataSourceCredentials* p = _impl_.credentials_;
  return p != nullptr ? *p : reinterpret_cast<const ::clarifai::api::DataSourceCredentials&>(
      ::clarifai::api::_DataSourceCredentials_default_instance_);
}
inline const ::clarifai::api::DataSourceCredentials& DataSourceURL::credentials() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DataSourceURL.credentials)
  return _internal_credentials();
}
inline void DataSourceURL::unsafe_arena_set_allocated_credentials(
    ::clarifai::api::DataSourceCredentials* credentials) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.credentials_);
  }
  _impl_.credentials_ = credentials;
  if (credentials) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DataSourceURL.credentials)
}
inline ::clarifai::api::DataSourceCredentials* DataSourceURL::release_credentials() {
  
  ::clarifai::api::DataSourceCredentials* temp = _impl_.credentials_;
  _impl_.credentials_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clarifai::api::DataSourceCredentials* DataSourceURL::unsafe_arena_release_credentials() {
  // @@protoc_insertion_point(field_release:clarifai.api.DataSourceURL.credentials)
  
  ::clarifai::api::DataSourceCredentials* temp = _impl_.credentials_;
  _impl_.credentials_ = nullptr;
  return temp;
}
inline ::clarifai::api::DataSourceCredentials* DataSourceURL::_internal_mutable_credentials() {
  
  if (_impl_.credentials_ == nullptr) {
    auto* p = CreateMaybeMessage<::clarifai::api::DataSourceCredentials>(GetArenaForAllocation());
    _impl_.credentials_ = p;
  }
  return _impl_.credentials_;
}
inline ::clarifai::api::DataSourceCredentials* DataSourceURL::mutable_credentials() {
  ::clarifai::api::DataSourceCredentials* _msg = _internal_mutable_credentials();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DataSourceURL.credentials)
  return _msg;
}
inline void DataSourceURL::set_allocated_credentials(::clarifai::api::DataSourceCredentials* credentials) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.credentials_;
  }
  if (credentials) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(credentials);
    if (message_arena != submessage_arena) {
      credentials = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, credentials, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.credentials_ = credentials;
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DataSourceURL.credentials)
}

// -------------------------------------------------------------------

// DataSourceCredentials

// .clarifai.api.AWSCreds s3_creds = 1;
inline bool DataSourceCredentials::_internal_has_s3_creds() const {
  return credentials_case() == kS3Creds;
}
inline bool DataSourceCredentials::has_s3_creds() const {
  return _internal_has_s3_creds();
}
inline void DataSourceCredentials::set_has_s3_creds() {
  _impl_._oneof_case_[0] = kS3Creds;
}
inline void DataSourceCredentials::clear_s3_creds() {
  if (_internal_has_s3_creds()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.credentials_.s3_creds_;
    }
    clear_has_credentials();
  }
}
inline ::clarifai::api::AWSCreds* DataSourceCredentials::release_s3_creds() {
  // @@protoc_insertion_point(field_release:clarifai.api.DataSourceCredentials.s3_creds)
  if (_internal_has_s3_creds()) {
    clear_has_credentials();
    ::clarifai::api::AWSCreds* temp = _impl_.credentials_.s3_creds_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.credentials_.s3_creds_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clarifai::api::AWSCreds& DataSourceCredentials::_internal_s3_creds() const {
  return _internal_has_s3_creds()
      ? *_impl_.credentials_.s3_creds_
      : reinterpret_cast< ::clarifai::api::AWSCreds&>(::clarifai::api::_AWSCreds_default_instance_);
}
inline const ::clarifai::api::AWSCreds& DataSourceCredentials::s3_creds() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DataSourceCredentials.s3_creds)
  return _internal_s3_creds();
}
inline ::clarifai::api::AWSCreds* DataSourceCredentials::unsafe_arena_release_s3_creds() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clarifai.api.DataSourceCredentials.s3_creds)
  if (_internal_has_s3_creds()) {
    clear_has_credentials();
    ::clarifai::api::AWSCreds* temp = _impl_.credentials_.s3_creds_;
    _impl_.credentials_.s3_creds_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataSourceCredentials::unsafe_arena_set_allocated_s3_creds(::clarifai::api::AWSCreds* s3_creds) {
  clear_credentials();
  if (s3_creds) {
    set_has_s3_creds();
    _impl_.credentials_.s3_creds_ = s3_creds;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clarifai.api.DataSourceCredentials.s3_creds)
}
inline ::clarifai::api::AWSCreds* DataSourceCredentials::_internal_mutable_s3_creds() {
  if (!_internal_has_s3_creds()) {
    clear_credentials();
    set_has_s3_creds();
    _impl_.credentials_.s3_creds_ = CreateMaybeMessage< ::clarifai::api::AWSCreds >(GetArenaForAllocation());
  }
  return _impl_.credentials_.s3_creds_;
}
inline ::clarifai::api::AWSCreds* DataSourceCredentials::mutable_s3_creds() {
  ::clarifai::api::AWSCreds* _msg = _internal_mutable_s3_creds();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DataSourceCredentials.s3_creds)
  return _msg;
}

// bytes gcp_creds = 2;
inline bool DataSourceCredentials::_internal_has_gcp_creds() const {
  return credentials_case() == kGcpCreds;
}
inline bool DataSourceCredentials::has_gcp_creds() const {
  return _internal_has_gcp_creds();
}
inline void DataSourceCredentials::set_has_gcp_creds() {
  _impl_._oneof_case_[0] = kGcpCreds;
}
inline void DataSourceCredentials::clear_gcp_creds() {
  if (_internal_has_gcp_creds()) {
    _impl_.credentials_.gcp_creds_.Destroy();
    clear_has_credentials();
  }
}
inline const std::string& DataSourceCredentials::gcp_creds() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DataSourceCredentials.gcp_creds)
  return _internal_gcp_creds();
}
template <typename ArgT0, typename... ArgT>
inline void DataSourceCredentials::set_gcp_creds(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_gcp_creds()) {
    clear_credentials();
    set_has_gcp_creds();
    _impl_.credentials_.gcp_creds_.InitDefault();
  }
  _impl_.credentials_.gcp_creds_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.DataSourceCredentials.gcp_creds)
}
inline std::string* DataSourceCredentials::mutable_gcp_creds() {
  std::string* _s = _internal_mutable_gcp_creds();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DataSourceCredentials.gcp_creds)
  return _s;
}
inline const std::string& DataSourceCredentials::_internal_gcp_creds() const {
  if (_internal_has_gcp_creds()) {
    return _impl_.credentials_.gcp_creds_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DataSourceCredentials::_internal_set_gcp_creds(const std::string& value) {
  if (!_internal_has_gcp_creds()) {
    clear_credentials();
    set_has_gcp_creds();
    _impl_.credentials_.gcp_creds_.InitDefault();
  }
  _impl_.credentials_.gcp_creds_.Set(value, GetArenaForAllocation());
}
inline std::string* DataSourceCredentials::_internal_mutable_gcp_creds() {
  if (!_internal_has_gcp_creds()) {
    clear_credentials();
    set_has_gcp_creds();
    _impl_.credentials_.gcp_creds_.InitDefault();
  }
  return _impl_.credentials_.gcp_creds_.Mutable(      GetArenaForAllocation());
}
inline std::string* DataSourceCredentials::release_gcp_creds() {
  // @@protoc_insertion_point(field_release:clarifai.api.DataSourceCredentials.gcp_creds)
  if (_internal_has_gcp_creds()) {
    clear_has_credentials();
    return _impl_.credentials_.gcp_creds_.Release();
  } else {
    return nullptr;
  }
}
inline void DataSourceCredentials::set_allocated_gcp_creds(std::string* gcp_creds) {
  if (has_credentials()) {
    clear_credentials();
  }
  if (gcp_creds != nullptr) {
    set_has_gcp_creds();
    _impl_.credentials_.gcp_creds_.InitAllocated(gcp_creds, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DataSourceCredentials.gcp_creds)
}

// string azure_blob_creds = 3;
inline bool DataSourceCredentials::_internal_has_azure_blob_creds() const {
  return credentials_case() == kAzureBlobCreds;
}
inline bool DataSourceCredentials::has_azure_blob_creds() const {
  return _internal_has_azure_blob_creds();
}
inline void DataSourceCredentials::set_has_azure_blob_creds() {
  _impl_._oneof_case_[0] = kAzureBlobCreds;
}
inline void DataSourceCredentials::clear_azure_blob_creds() {
  if (_internal_has_azure_blob_creds()) {
    _impl_.credentials_.azure_blob_creds_.Destroy();
    clear_has_credentials();
  }
}
inline const std::string& DataSourceCredentials::azure_blob_creds() const {
  // @@protoc_insertion_point(field_get:clarifai.api.DataSourceCredentials.azure_blob_creds)
  return _internal_azure_blob_creds();
}
template <typename ArgT0, typename... ArgT>
inline void DataSourceCredentials::set_azure_blob_creds(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_azure_blob_creds()) {
    clear_credentials();
    set_has_azure_blob_creds();
    _impl_.credentials_.azure_blob_creds_.InitDefault();
  }
  _impl_.credentials_.azure_blob_creds_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.DataSourceCredentials.azure_blob_creds)
}
inline std::string* DataSourceCredentials::mutable_azure_blob_creds() {
  std::string* _s = _internal_mutable_azure_blob_creds();
  // @@protoc_insertion_point(field_mutable:clarifai.api.DataSourceCredentials.azure_blob_creds)
  return _s;
}
inline const std::string& DataSourceCredentials::_internal_azure_blob_creds() const {
  if (_internal_has_azure_blob_creds()) {
    return _impl_.credentials_.azure_blob_creds_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DataSourceCredentials::_internal_set_azure_blob_creds(const std::string& value) {
  if (!_internal_has_azure_blob_creds()) {
    clear_credentials();
    set_has_azure_blob_creds();
    _impl_.credentials_.azure_blob_creds_.InitDefault();
  }
  _impl_.credentials_.azure_blob_creds_.Set(value, GetArenaForAllocation());
}
inline std::string* DataSourceCredentials::_internal_mutable_azure_blob_creds() {
  if (!_internal_has_azure_blob_creds()) {
    clear_credentials();
    set_has_azure_blob_creds();
    _impl_.credentials_.azure_blob_creds_.InitDefault();
  }
  return _impl_.credentials_.azure_blob_creds_.Mutable(      GetArenaForAllocation());
}
inline std::string* DataSourceCredentials::release_azure_blob_creds() {
  // @@protoc_insertion_point(field_release:clarifai.api.DataSourceCredentials.azure_blob_creds)
  if (_internal_has_azure_blob_creds()) {
    clear_has_credentials();
    return _impl_.credentials_.azure_blob_creds_.Release();
  } else {
    return nullptr;
  }
}
inline void DataSourceCredentials::set_allocated_azure_blob_creds(std::string* azure_blob_creds) {
  if (has_credentials()) {
    clear_credentials();
  }
  if (azure_blob_creds != nullptr) {
    set_has_azure_blob_creds();
    _impl_.credentials_.azure_blob_creds_.InitAllocated(azure_blob_creds, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.DataSourceCredentials.azure_blob_creds)
}

inline bool DataSourceCredentials::has_credentials() const {
  return credentials_case() != CREDENTIALS_NOT_SET;
}
inline void DataSourceCredentials::clear_has_credentials() {
  _impl_._oneof_case_[0] = CREDENTIALS_NOT_SET;
}
inline DataSourceCredentials::CredentialsCase DataSourceCredentials::credentials_case() const {
  return DataSourceCredentials::CredentialsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AWSCreds

// string creds = 1;
inline void AWSCreds::clear_creds() {
  _impl_.creds_.ClearToEmpty();
}
inline const std::string& AWSCreds::creds() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AWSCreds.creds)
  return _internal_creds();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AWSCreds::set_creds(ArgT0&& arg0, ArgT... args) {
 
 _impl_.creds_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.AWSCreds.creds)
}
inline std::string* AWSCreds::mutable_creds() {
  std::string* _s = _internal_mutable_creds();
  // @@protoc_insertion_point(field_mutable:clarifai.api.AWSCreds.creds)
  return _s;
}
inline const std::string& AWSCreds::_internal_creds() const {
  return _impl_.creds_.Get();
}
inline void AWSCreds::_internal_set_creds(const std::string& value) {
  
  _impl_.creds_.Set(value, GetArenaForAllocation());
}
inline std::string* AWSCreds::_internal_mutable_creds() {
  
  return _impl_.creds_.Mutable(GetArenaForAllocation());
}
inline std::string* AWSCreds::release_creds() {
  // @@protoc_insertion_point(field_release:clarifai.api.AWSCreds.creds)
  return _impl_.creds_.Release();
}
inline void AWSCreds::set_allocated_creds(std::string* creds) {
  if (creds != nullptr) {
    
  } else {
    
  }
  _impl_.creds_.SetAllocated(creds, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.creds_.IsDefault()) {
    _impl_.creds_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.AWSCreds.creds)
}

// string region = 2;
inline void AWSCreds::clear_region() {
  _impl_.region_.ClearToEmpty();
}
inline const std::string& AWSCreds::region() const {
  // @@protoc_insertion_point(field_get:clarifai.api.AWSCreds.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AWSCreds::set_region(ArgT0&& arg0, ArgT... args) {
 
 _impl_.region_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clarifai.api.AWSCreds.region)
}
inline std::string* AWSCreds::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:clarifai.api.AWSCreds.region)
  return _s;
}
inline const std::string& AWSCreds::_internal_region() const {
  return _impl_.region_.Get();
}
inline void AWSCreds::_internal_set_region(const std::string& value) {
  
  _impl_.region_.Set(value, GetArenaForAllocation());
}
inline std::string* AWSCreds::_internal_mutable_region() {
  
  return _impl_.region_.Mutable(GetArenaForAllocation());
}
inline std::string* AWSCreds::release_region() {
  // @@protoc_insertion_point(field_release:clarifai.api.AWSCreds.region)
  return _impl_.region_.Release();
}
inline void AWSCreds::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    
  } else {
    
  }
  _impl_.region_.SetAllocated(region, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.region_.IsDefault()) {
    _impl_.region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clarifai.api.AWSCreds.region)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace clarifai

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::clarifai::api::Point_Visibility> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::clarifai::api::Point_Visibility>() {
  return ::clarifai::api::Point_Visibility_descriptor();
}
template <> struct is_proto_enum< ::clarifai::api::ModelTypeField_ModelTypeFieldType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::clarifai::api::ModelTypeField_ModelTypeFieldType>() {
  return ::clarifai::api::ModelTypeField_ModelTypeFieldType_descriptor();
}
template <> struct is_proto_enum< ::clarifai::api::Task_TaskType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::clarifai::api::Task_TaskType>() {
  return ::clarifai::api::Task_TaskType_descriptor();
}
template <> struct is_proto_enum< ::clarifai::api::TaskWorker_TaskWorkerStrategy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::clarifai::api::TaskWorker_TaskWorkerStrategy>() {
  return ::clarifai::api::TaskWorker_TaskWorkerStrategy_descriptor();
}
template <> struct is_proto_enum< ::clarifai::api::TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::clarifai::api::TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy>() {
  return ::clarifai::api::TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy_descriptor();
}
template <> struct is_proto_enum< ::clarifai::api::TaskInputSource_TaskInputSourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::clarifai::api::TaskInputSource_TaskInputSourceType>() {
  return ::clarifai::api::TaskInputSource_TaskInputSourceType_descriptor();
}
template <> struct is_proto_enum< ::clarifai::api::TaskReview_TaskReviewStrategy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::clarifai::api::TaskReview_TaskReviewStrategy>() {
  return ::clarifai::api::TaskReview_TaskReviewStrategy_descriptor();
}
template <> struct is_proto_enum< ::clarifai::api::Visibility_Gettable> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::clarifai::api::Visibility_Gettable>() {
  return ::clarifai::api::Visibility_Gettable_descriptor();
}
template <> struct is_proto_enum< ::clarifai::api::DatasetVersionMetricsGroupType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::clarifai::api::DatasetVersionMetricsGroupType>() {
  return ::clarifai::api::DatasetVersionMetricsGroupType_descriptor();
}
template <> struct is_proto_enum< ::clarifai::api::DatasetVersionExportFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::clarifai::api::DatasetVersionExportFormat>() {
  return ::clarifai::api::DatasetVersionExportFormat_descriptor();
}
template <> struct is_proto_enum< ::clarifai::api::ExpirationAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::clarifai::api::ExpirationAction>() {
  return ::clarifai::api::ExpirationAction_descriptor();
}
template <> struct is_proto_enum< ::clarifai::api::LicenseScope> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::clarifai::api::LicenseScope>() {
  return ::clarifai::api::LicenseScope_descriptor();
}
template <> struct is_proto_enum< ::clarifai::api::DataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::clarifai::api::DataType>() {
  return ::clarifai::api::DataType_descriptor();
}
template <> struct is_proto_enum< ::clarifai::api::ValueComparator> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::clarifai::api::ValueComparator>() {
  return ::clarifai::api::ValueComparator_descriptor();
}
template <> struct is_proto_enum< ::clarifai::api::EvaluationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::clarifai::api::EvaluationType>() {
  return ::clarifai::api::EvaluationType_descriptor();
}
template <> struct is_proto_enum< ::clarifai::api::APIEventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::clarifai::api::APIEventType>() {
  return ::clarifai::api::APIEventType_descriptor();
}
template <> struct is_proto_enum< ::clarifai::api::UsageIntervalType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::clarifai::api::UsageIntervalType>() {
  return ::clarifai::api::UsageIntervalType_descriptor();
}
template <> struct is_proto_enum< ::clarifai::api::RoleType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::clarifai::api::RoleType>() {
  return ::clarifai::api::RoleType_descriptor();
}
template <> struct is_proto_enum< ::clarifai::api::StatValueAggType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::clarifai::api::StatValueAggType>() {
  return ::clarifai::api::StatValueAggType_descriptor();
}
template <> struct is_proto_enum< ::clarifai::api::StatTimeAggType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::clarifai::api::StatTimeAggType>() {
  return ::clarifai::api::StatTimeAggType_descriptor();
}
template <> struct is_proto_enum< ::clarifai::api::ValidationErrorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::clarifai::api::ValidationErrorType>() {
  return ::clarifai::api::ValidationErrorType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_proto_2fclarifai_2fapi_2fresources_2eproto
